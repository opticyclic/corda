<?xml version="1.0" ?>
<SmellBaseline>
  <Blacklist></Blacklist>
  <Whitelist>
    <ID>ChainWrapping:</ID>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$FINALISING_TX : Step</ID>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$GENERATING_ID : Step</ID>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$GENERATING_TX : Step</ID>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$SIGNING_TX : Step</ID>
    <ID>ClassNaming:BlobWriter.kt$_Li_</ID>
    <ID>ClassNaming:BlobWriter.kt$_Mis_</ID>
    <ID>ClassNaming:BlobWriter.kt$_i_</ID>
    <ID>ClassNaming:BlobWriter.kt$_i_is__</ID>
    <ID>ClassNaming:BlobWriter.kt$_is_</ID>
    <ID>ClassNaming:BuyerFlow.kt$BuyerFlow$STARTING_BUY : Step</ID>
    <ID>ClassNaming:CustomVaultQuery.kt$TopupIssuerFlow.TopupIssuer.Companion$AWAITING_REQUEST : Step</ID>
    <ID>ClassNaming:CustomVaultQuery.kt$TopupIssuerFlow.TopupIssuer.Companion$SENDING_TOP_UP_ISSUE_REQUEST : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$EXTRACTING_VAULT_STATES : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$ID_OTHER_NODES : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$OTHER_TX_COMPONENTS : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$SENDING_AND_RECEIVING_DATA : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$SIGS_GATHERING : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$TX_BUILDING : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$TX_SIGNING : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$TX_VERIFICATION : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$VERIFYING_SIGS : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$ResponderFlow.Companion$RECEIVING_AND_SENDING_DATA : Step</ID>
    <ID>ClassNaming:FlowRetryTest.kt$AsyncRetryFlow.Companion$FIRST_STEP : Step</ID>
    <ID>ClassNaming:FlowRetryTest.kt$InitiatedFlow.Companion$FIRST_STEP : Step</ID>
    <ID>ClassNaming:FlowRetryTest.kt$InitiatorFlow.Companion$FIRST_STEP : Step</ID>
    <ID>ClassNaming:FlowRetryTest.kt$RetryFlow.Companion$FIRST_STEP : Step</ID>
    <ID>ClassNaming:FlowRetryTest.kt$ThrowingFlow.Companion$FIRST_STEP : Step</ID>
    <ID>ClassNaming:IdentitySyncFlow.kt$IdentitySyncFlow.Receive.Companion$RECEIVING_CERTIFICATES : Step</ID>
    <ID>ClassNaming:IdentitySyncFlow.kt$IdentitySyncFlow.Receive.Companion$RECEIVING_IDENTITIES : Step</ID>
    <ID>ClassNaming:IdentitySyncFlow.kt$IdentitySyncFlow.Send.Companion$SYNCING_IDENTITIES : Step</ID>
    <ID>ClassNaming:NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.kt$NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS</ID>
    <ID>ClassNaming:NodeStatePersistenceTests.kt$SendMessageFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>ClassNaming:NodeStatePersistenceTests.kt$SendMessageFlow.Companion$GENERATING_TRANSACTION : Step</ID>
    <ID>ClassNaming:NodeStatePersistenceTests.kt$SendMessageFlow.Companion$SIGNING_TRANSACTION : Step</ID>
    <ID>ClassNaming:NodeStatePersistenceTests.kt$SendMessageFlow.Companion$VERIFYING_TRANSACTION : Step</ID>
    <ID>ClassNaming:SellerFlow.kt$SellerFlow.Companion$SELF_ISSUING : Step</ID>
    <ID>ClassNaming:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion$AWAITING_IDENTITY : Step</ID>
    <ID>ClassNaming:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion$GENERATING_IDENTITY : Step</ID>
    <ID>ClassNaming:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion$SIGNING_IDENTITY : Step</ID>
    <ID>ClassNaming:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion$VERIFYING_IDENTITY : Step</ID>
    <ID>ClassNaming:TestCommsFlow.kt$TestCommsFlowInitiator$RECIEVED_ALL : Step</ID>
    <ID>ClassNaming:TwoPartyDealFlow.kt$TwoPartyDealFlow.Primary.Companion$GENERATING_ID : Step</ID>
    <ID>ClassNaming:TwoPartyDealFlow.kt$TwoPartyDealFlow.Primary.Companion$SENDING_PROPOSAL : Step</ID>
    <ID>ClassNaming:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary.Companion$COLLECTING_SIGNATURES : Step</ID>
    <ID>ClassNaming:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$COLLECTING_SIGNATURES : Step</ID>
    <ID>ClassNaming:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller.Companion$AWAITING_PROPOSAL : Step</ID>
    <ID>ClassNaming:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller.Companion$VERIFYING_AND_SIGNING : Step</ID>
    <ID>CommentSpacing:</ID>
    <ID>ComplexCondition:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser$c.isWhitespace() || c.isJavaIdentifierPart() || c.isJavaIdentifierStart() || c == '.' || c == ',' || c == '?' || c == '*'</ID>
    <ID>ComplexCondition:Address.kt$Address.Companion$parts.size != 2 || parts[0].isBlank() || parts[1].isBlank() || parts[1].toIntOrNull() == null</ID>
    <ID>ComplexCondition:CheckpointAgent.kt$CheckpointHook$!that.javaClass.name.endsWith("ObjectField") || arrayValue != null || that.field.type == java.lang.String::class.java || value == null</ID>
    <ID>ComplexCondition:CheckpointAgent.kt$CheckpointHook$(checkpointId != null) || ((clazz.name == instrumentClassname) &amp;&amp; (input.total() &gt;= minimumSize) &amp;&amp; (input.total() &lt;= maximumSize))</ID>
    <ID>ComplexCondition:CheckpointAgent.kt$CheckpointHook$(checkpointId != null) || ((obj.javaClass.name == instrumentClassname) &amp;&amp; (output.total() &gt;= minimumSize) &amp;&amp; (output.total() &lt;= maximumSize))</ID>
    <ID>ComplexCondition:ConfigUtilities.kt$value is Temporal || value is NetworkHostAndPort || value is CordaX500Name || value is Path || value is URL || value is UUID || value is X500Principal</ID>
    <ID>ComplexCondition:CordaClassResolver.kt$CordaClassResolver$type.isPrimitive || type == Any::class.java || type == String::class.java || (!type.isEnum &amp;&amp; isAbstract(type.modifiers))</ID>
    <ID>ComplexCondition:DeserializationInput.kt$DeserializationInput$type != TypeIdentifier.UnknownType.getLocalType() &amp;&amp; serializer.type != type &amp;&amp; with(serializer.type) { !isSubClassOf(type) &amp;&amp; !materiallyEquivalentTo(type) }</ID>
    <ID>ComplexCondition:FlowMessaging.kt$FlowMessagingImpl$(exception is KryoException || exception is NotSerializableException) &amp;&amp; message is ExistingSessionMessage &amp;&amp; message.payload is ErrorSessionMessage</ID>
    <ID>ComplexCondition:FlowStackSnapshot.kt$FlowStackSnapshotFactoryImpl$it != null &amp;&amp; (it is FlowLogic&lt;*&gt; || it is FlowStateMachine&lt;*&gt; || it is Fiber&lt;*&gt; || it is SerializeAsToken)</ID>
    <ID>ComplexCondition:InternalUtils.kt$it.type == this &amp;&amp; it.isPublic &amp;&amp; it.isStatic &amp;&amp; it.isFinal</ID>
    <ID>ComplexCondition:Main.kt$Main$(hostname != null) &amp;&amp; (port != null) &amp;&amp; (username != null) &amp;&amp; (password != null)</ID>
    <ID>ComplexCondition:Schema.kt$obj == null || obj is DescribedType || obj is Binary || forGenericType(type).run { isPrimitive(this) || this == TopType }</ID>
    <ID>ComplexCondition:TopLevelTransition.kt$TopLevelTransition$currentState.isTransactionTracked &amp;&amp; checkpoint.flowState is FlowState.Started &amp;&amp; checkpoint.flowState.flowIORequest is FlowIORequest.WaitForLedgerCommit &amp;&amp; checkpoint.flowState.flowIORequest.hash == event.transaction.id</ID>
    <ID>ComplexCondition:WireTransaction.kt$WireTransaction$notary != null &amp;&amp; (inputs.isNotEmpty() || references.isNotEmpty() || timeWindow != null)</ID>
    <ID>ComplexMethod:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$private fun clientArtemisMessageHandler(artemisMessage: ClientMessage)</ID>
    <ID>ComplexMethod:AMQPBridgeTest.kt$AMQPBridgeTest$@Test fun `test acked and nacked messages`()</ID>
    <ID>ComplexMethod:AMQPChannelHandler.kt$AMQPChannelHandler$override fun userEventTriggered(ctx: ChannelHandlerContext, evt: Any)</ID>
    <ID>ComplexMethod:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser$// Make sure our inputs aren't designed to blow things up. private fun validate(typeString: String)</ID>
    <ID>ComplexMethod:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser.ParseState.ParsingRawType$override fun accept(c: Char)</ID>
    <ID>ComplexMethod:AMQPTypeIdentifiers.kt$AMQPTypeIdentifiers$fun nameForType(typeIdentifier: TypeIdentifier): String</ID>
    <ID>ComplexMethod:ANSIProgressRenderer.kt$ANSIProgressRenderer$// Returns number of lines rendered. private fun renderLevel(ansi: Ansi, error: Boolean): Int</ID>
    <ID>ComplexMethod:ANSIProgressRenderer.kt$ANSIProgressRenderer$@Synchronized protected fun draw(moveUp: Boolean, error: Throwable? = null)</ID>
    <ID>ComplexMethod:AbstractNode.kt$AbstractNode$private fun installCordaServices()</ID>
    <ID>ComplexMethod:ActionExecutorImpl.kt$ActionExecutorImpl$@Suspendable override fun executeAction(fiber: FlowFiber, action: Action)</ID>
    <ID>ComplexMethod:AggregatedListTest.kt$AggregatedListTest$@Test fun removeWorks()</ID>
    <ID>ComplexMethod:Amount.kt$AmountTransfer$ fun apply(balances: List&lt;SourceAndAmount&lt;T, P&gt;&gt;, newRef: Any? = null): List&lt;SourceAndAmount&lt;T, P&gt;&gt;</ID>
    <ID>ComplexMethod:Amount.kt$AmountTransfer$ override fun equals(other: Any?): Boolean</ID>
    <ID>ComplexMethod:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$private fun set(key: K, value: V, logWarning: Boolean, store: (K, V) -&gt; V?): Boolean</ID>
    <ID>ComplexMethod:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.TestThread$private fun doActivity()</ID>
    <ID>ComplexMethod:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$override fun execute(database: Database?)</ID>
    <ID>ComplexMethod:AttachmentsClassLoader.kt$AttachmentsClassLoader$private fun checkAttachments(attachments: List&lt;Attachment&gt;)</ID>
    <ID>ComplexMethod:BridgeControlListener.kt$BridgeControlListener$private fun processControlMessage(msg: ClientMessage)</ID>
    <ID>ComplexMethod:CashSelectionH2Impl.kt$CashSelectionH2Impl$// We are using an H2 specific means of selecting a minimum set of rows that match a request amount of coins: // 1) There is no standard SQL mechanism of calculating a cumulative total on a field and restricting row selection on the // running total of such an accumulator // 2) H2 uses session variables to perform this accumulator function: // http://www.h2database.com/html/functions.html#set // 3) H2 does not support JOIN's in FOR UPDATE (hence we are forced to execute 2 queries) override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>ComplexMethod:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$// This is using PostgreSQL window functions for selecting a minimum set of rows that match a request amount of coins: // 1) This may also be possible with user-defined functions (e.g. using PL/pgSQL) // 2) The window function accumulated column (`total`) does not include the current row (starts from 0) and cannot // appear in the WHERE clause, hence restricting row selection and adjusting the returned total in the outer query. // 3) Currently (version 9.6), FOR UPDATE cannot be specified with window functions override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>ComplexMethod:CheckpointAgent.kt$CheckpointAgent.Companion$fun parseArguments(argumentsString: String?)</ID>
    <ID>ComplexMethod:CheckpointAgent.kt$CheckpointHook$private fun &lt;T&gt; getArrayValue(clazz: Class&lt;T&gt;, value: Any?): String?</ID>
    <ID>ComplexMethod:CheckpointAgent.kt$CheckpointHook$private fun instrumentClass(clazz: CtClass): CtClass?</ID>
    <ID>ComplexMethod:CheckpointAgent.kt$CheckpointHook$private fun prettyStatsTree(indent: Int, statsInfo: StatsInfo, identityInfo: IdentityInfo, builder: StringBuilder)</ID>
    <ID>ComplexMethod:CheckpointAgent.kt$fun readTrees(events: List&lt;StatsEvent&gt;, index: Int, idMap: IdentityHashMap&lt;Any, IdentityInfo&gt;): Pair&lt;Int, List&lt;Pair&lt;StatsInfo, IdentityInfo&gt;&gt;&gt;</ID>
    <ID>ComplexMethod:CheckpointDumper.kt$CheckpointDumper$fun dump()</ID>
    <ID>ComplexMethod:CheckpointDumper.kt$CheckpointDumper$private fun FlowIORequest&lt;*&gt;.toSuspendedOn(suspendedTimestamp: Instant, now: Instant): SuspendedOn</ID>
    <ID>ComplexMethod:ClassCarpenter.kt$ClassCarpenterImpl$ private fun validateSchema(schema: Schema)</ID>
    <ID>ComplexMethod:CollectSignaturesFlow.kt$CollectSignaturesFlow$@Suspendable override fun call(): SignedTransaction</ID>
    <ID>ComplexMethod:CompatibleTransactionTests.kt$CompatibleTransactionTests$@Test fun `Command visibility tests`()</ID>
    <ID>ComplexMethod:ConcatenatedList.kt$ConcatenatedList$// This is where we create a listener for a *nested* list. Note that 'indexMap' doesn't need to be adjusted on any // of these changes as the indices of nested lists don't change, just their contents. private fun createListener(wrapped: WrappedObservableList&lt;A&gt;): ListChangeListener&lt;A&gt;</ID>
    <ID>ComplexMethod:ConcatenatedList.kt$ConcatenatedList$// This is where we handle changes to the *source* list. override fun sourceChanged(change: ListChangeListener.Change&lt;out ObservableList&lt;A&gt;&gt;)</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$// For Iterables figure out the type parameter and apply the same logic as above on the individual elements. private fun Iterable&lt;*&gt;.toConfigIterable(field: Field): Iterable&lt;Any?&gt;</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$// TODO Move this to KeyStoreConfigHelpers. fun MutualSslConfiguration.configureDevKeyAndTrustStores(myLegalName: CordaX500Name, signingCertificateStore: FileBasedCertificateStoreSupplier, certificatesDirectory: Path, cryptoService: CryptoService? = null)</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$@Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN") // Reflect over the fields of the receiver and generate a value Map that can use to create Config object. private fun Any.toConfigMap(): Map&lt;String, Any&gt;</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$private fun Config.getCollectionValue(path: String, type: KType, onUnknownKeys: (Set&lt;String&gt;, logger: Logger) -&gt; Unit, nestedPath: String?, baseDirectory: Path?): Collection&lt;Any&gt;</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$private fun Config.getSingleValue(path: String, type: KType, onUnknownKeys: (Set&lt;String&gt;, logger: Logger) -&gt; Unit, nestedPath: String?, baseDirectory: Path?): Any?</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$private fun convertValue(value: Any): Any</ID>
    <ID>ComplexMethod:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onConnectionFinal(event: Event)</ID>
    <ID>ComplexMethod:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onDelivery(event: Event)</ID>
    <ID>ComplexMethod:ConstraintsUtils.kt$ fun AttachmentConstraint.canBeTransitionedFrom(input: AttachmentConstraint, attachment: ContractAttachment): Boolean</ID>
    <ID>ComplexMethod:CordaCliWrapper.kt$fun CordaCliWrapper.start(args: Array&lt;String&gt;)</ID>
    <ID>ComplexMethod:CordaPersistence.kt$CordaPersistence$private fun &lt;T&gt; inTopLevelTransaction(isolationLevel: TransactionIsolationLevel, recoverableFailureTolerance: Int, recoverAnyNestedSQLException: Boolean, statement: DatabaseTransaction.() -&gt; T): T</ID>
    <ID>ComplexMethod:CordaRPCClient.kt$CordaRPCClientConfiguration$override fun equals(other: Any?): Boolean</ID>
    <ID>ComplexMethod:CordaRPCClientTest.kt$CordaRPCClientTest$@Test fun `shutdown command stops the node`()</ID>
    <ID>ComplexMethod:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$private fun doFindCustomSerializer(clazz: Class&lt;*&gt;, declaredType: Type): AMQPSerializer&lt;Any&gt;?</ID>
    <ID>ComplexMethod:DeserializationInput.kt$DeserializationInput$fun readObject(obj: Any, schemas: SerializationSchemas, type: Type, context: SerializationContext): Any</ID>
    <ID>ComplexMethod:DriverDSLImpl.kt$DriverDSLImpl$override fun start()</ID>
    <ID>ComplexMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startNodeInternal(config: NodeConfig, webAddress: NetworkHostAndPort, localNetworkMap: LocalNetworkMap?, parameters: NodeParameters): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>ComplexMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startRegisteredNode(name: CordaX500Name, localNetworkMap: LocalNetworkMap?, parameters: NodeParameters, p2pAddress: NetworkHostAndPort = portAllocation.nextHostAndPort()): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>ComplexMethod:Expect.kt$ fun &lt;S, E : Any&gt; S.genericExpectEvents( isStrict: Boolean = true, stream: S.((E) -&gt; Unit) -&gt; Unit, expectCompose: () -&gt; ExpectCompose&lt;E&gt; )</ID>
    <ID>ComplexMethod:FinalityFlow.kt$FinalityFlow$@Suspendable @Throws(NotaryException::class) override fun call(): SignedTransaction</ID>
    <ID>ComplexMethod:FlattenedList.kt$FlattenedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out ObservableValue&lt;out A&gt;&gt;)</ID>
    <ID>ComplexMethod:FlowMonitor.kt$FlowMonitor$private fun warningMessageForFlowWaitingOnIo(request: FlowIORequest&lt;*&gt;, flow: FlowStateMachineImpl&lt;*&gt;, now: Instant): String</ID>
    <ID>ComplexMethod:FlowStateMachineImpl.kt$FlowStateMachineImpl$ @Suspendable private fun processEventsUntilFlowIsResumed(isDbTransactionOpenOnEntry: Boolean, isDbTransactionOpenOnExit: Boolean): Any?</ID>
    <ID>ComplexMethod:GenerateRpcSslCertsCli.kt$GenerateRpcSslCerts$private fun generateRpcSslCertificates(conf: NodeConfiguration)</ID>
    <ID>ComplexMethod:GenericsTests.kt$GenericsTests$@Test fun nestedSerializationInMultipleContextsDoesntColideGenericTypes()</ID>
    <ID>ComplexMethod:HTTPNetworkRegistrationService.kt$HTTPNetworkRegistrationService$@Throws(CertificateRequestException::class) override fun retrieveCertificates(requestId: String): CertificateResponse</ID>
    <ID>ComplexMethod:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$override fun parseCriteria(criteria: AttachmentQueryCriteria.AttachmentsQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>ComplexMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: CommonQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>ComplexMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: QueryCriteria.VaultQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>ComplexMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$private fun &lt;O, R&gt; parseAggregateFunction(root: Root&lt;O&gt;, expression: CriteriaExpression.AggregateFunctionExpression&lt;O, R&gt;): Expression&lt;out Any?&gt;?</ID>
    <ID>ComplexMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$private fun parse(sorting: Sort)</ID>
    <ID>ComplexMethod:IRS.kt$InterestRateSwap.CommonLeg$override fun equals(other: Any?): Boolean</ID>
    <ID>ComplexMethod:IRS.kt$InterestRateSwap.FloatingLeg$override fun equals(other: Any?): Boolean</ID>
    <ID>ComplexMethod:InteractiveShell.kt$InteractiveShell$ @JvmStatic fun runFlowByNameFragment(nameFragment: String, inputData: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, ansiProgressRenderer: ANSIProgressRenderer, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps))</ID>
    <ID>ComplexMethod:InteractiveShell.kt$InteractiveShell$ private fun maybeAbbreviateGenericType(type: Type, extraRecognisedPackage: String): String</ID>
    <ID>ComplexMethod:InteractiveShell.kt$InteractiveShell$@JvmStatic fun gracefulShutdown(userSessionOut: RenderPrintWriter, cordaRPCOps: CordaRPCOps)</ID>
    <ID>ComplexMethod:InteractiveShell.kt$InteractiveShell$@JvmStatic fun runRPCFromString(input: List&lt;String&gt;, out: RenderPrintWriter, context: InvocationContext&lt;out Any&gt;, cordaRPCOps: InternalCordaRPCOps, inputObjectMapper: ObjectMapper): Any?</ID>
    <ID>ComplexMethod:Kryo.kt$ImmutableClassSerializer$override fun read(kryo: Kryo, input: Input, type: Class&lt;T&gt;): T</ID>
    <ID>ComplexMethod:Kryo.kt$ImmutableClassSerializer$override fun write(kryo: Kryo, output: Output, obj: T)</ID>
    <ID>ComplexMethod:LoadTest.kt$LoadTest$fun run(nodes: Nodes, parameters: RunParameters, random: SplittableRandom)</ID>
    <ID>ComplexMethod:LocalTypeInformationBuilder.kt$ private fun constructorForDeserialization(type: Type): KFunction&lt;Any&gt;?</ID>
    <ID>ComplexMethod:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private fun buildForClass(type: Class&lt;*&gt;, typeIdentifier: TypeIdentifier, isOpaque: Boolean): LocalTypeInformation</ID>
    <ID>ComplexMethod:LoginView.kt$LoginView$tailrec fun login(): NodeMonitorModel?</ID>
    <ID>ComplexMethod:Main.kt$Node$fun dumpDag(f: File)</ID>
    <ID>ComplexMethod:MappedList.kt$MappedList$override fun sourceChanged(change: ListChangeListener.Change&lt;out A&gt;)</ID>
    <ID>ComplexMethod:MerkleTransaction.kt$FilteredTransaction.Companion$ private fun filterWithFun(wtx: WireTransaction, filtering: Predicate&lt;Any&gt;): List&lt;FilteredComponentGroup&gt;</ID>
    <ID>ComplexMethod:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory$private fun &lt;K, V&gt; configuredForNamed(caffeine: Caffeine&lt;K, V&gt;, name: String): Caffeine&lt;K, V&gt;</ID>
    <ID>ComplexMethod:NetworkBootstrapper.kt$NetworkBootstrapper$private fun bootstrap( directory: Path, cordappJars: List&lt;Path&gt;, copyCordapps: CopyCordapps, fromCordform: Boolean, networkParametersOverrides: NetworkParametersOverrides = NetworkParametersOverrides() )</ID>
    <ID>ComplexMethod:NetworkBootstrapper.kt$NetworkBootstrapper$private fun createNodeDirectoriesIfNeeded(directory: Path, fromCordform: Boolean): Boolean</ID>
    <ID>ComplexMethod:NetworkMapUpdater.kt$NetworkMapUpdater$fun updateNetworkMapCache(): Duration</ID>
    <ID>ComplexMethod:NetworkParametersReader.kt$NetworkParametersReader$fun read(): NetworkParametersAndSigned</ID>
    <ID>ComplexMethod:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ private fun pollServerForCertificates(requestId: String): List&lt;X509Certificate&gt;</ID>
    <ID>ComplexMethod:NewTransaction.kt$NewTransaction$fun show(window: Window)</ID>
    <ID>ComplexMethod:NewTransaction.kt$NewTransaction$private fun newTransactionDialog(window: Window)</ID>
    <ID>ComplexMethod:Node.kt$Node$override fun startMessagingService(rpcOps: RPCOps, nodeInfo: NodeInfo, myNotaryIdentity: PartyAndCertificate?, networkParameters: NetworkParameters)</ID>
    <ID>ComplexMethod:NodeNamedCache.kt$DefaultNamedCacheFactory$open protected fun &lt;K, V&gt; configuredForNamed(caffeine: Caffeine&lt;K, V&gt;, name: String): Caffeine&lt;K, V&gt;</ID>
    <ID>ComplexMethod:NodeVaultService.kt$NodeVaultService$@Throws(VaultQueryException::class) private fun &lt;T : ContractState&gt; _queryBy(criteria: QueryCriteria, paging_: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;, skipPagingChecks: Boolean): Vault.Page&lt;T&gt;</ID>
    <ID>ComplexMethod:NodeVaultService.kt$NodeVaultService$private fun makeUpdates(batch: Iterable&lt;CoreTransaction&gt;, statesToRecord: StatesToRecord, previouslySeen: Boolean): List&lt;Vault.Update&lt;ContractState&gt;&gt;</ID>
    <ID>ComplexMethod:ObjectDiffer.kt$ObjectDiffer$fun diff(a: Any?, b: Any?): DiffTree?</ID>
    <ID>ComplexMethod:Obligation.kt$Obligation$override fun verify(tx: LedgerTransaction)</ID>
    <ID>ComplexMethod:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$override fun addNodes(nodes: List&lt;NodeInfo&gt;)</ID>
    <ID>ComplexMethod:PrettyPrint.kt$PrettyPrint$fun prettyPrint(arr: Arrangement)</ID>
    <ID>ComplexMethod:PrettyPrint.kt$PrettyPrint$fun prettyPrintBigDecimal(per: Perceivable&lt;BigDecimal&gt;)</ID>
    <ID>ComplexMethod:PrettyPrint.kt$PrettyPrint$fun prettyPrintBoolean(per: Perceivable&lt;Boolean&gt;)</ID>
    <ID>ComplexMethod:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$@JvmStatic fun premain(argumentsString: String?, instrumentation: Instrumentation)</ID>
    <ID>ComplexMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$ private fun close(notify: Boolean = true)</ID>
    <ID>ComplexMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$// The handler for Artemis messages. private fun artemisMessageHandler(message: ClientMessage)</ID>
    <ID>ComplexMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$// This is the general function that transforms a client side RPC to internal Artemis messages. override fun invoke(proxy: Any, method: Method, arguments: Array&lt;out Any?&gt;?): Any?</ID>
    <ID>ComplexMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$private fun attemptReconnect()</ID>
    <ID>ComplexMethod:RPCServer.kt$RPCServer$private fun clientArtemisMessageHandler(artemisMessage: ClientMessage)</ID>
    <ID>ComplexMethod:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$override fun invoke(proxy: Any, method: Method, args: Array&lt;out Any&gt;?): Any?</ID>
    <ID>ComplexMethod:RemoteTypeCarpenter.kt$SchemaBuildingRemoteTypeCarpenter$override fun carpent(typeInformation: RemoteTypeInformation): Type</ID>
    <ID>ComplexMethod:ReplayedList.kt$ReplayedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out A&gt;)</ID>
    <ID>ComplexMethod:RpcReconnectTests.kt$RpcReconnectTests$ @Test fun `test that the RPC client is able to reconnect and proceed after node failure, restart, or connection reset`()</ID>
    <ID>ComplexMethod:SchemaMigration.kt$SchemaMigration$ private fun migrateOlderDatabaseToUseLiquibase(existingCheckpoints: Boolean): Boolean</ID>
    <ID>ComplexMethod:SchemaMigration.kt$SchemaMigration$private fun doRunMigration(run: Boolean, check: Boolean, existingCheckpoints: Boolean? = null)</ID>
    <ID>ComplexMethod:SendTransactionFlow.kt$DataVendingFlow$@Suspendable override fun call(): Void?</ID>
    <ID>ComplexMethod:ShellCmdLineOptions.kt$ShellCmdLineOptions$private fun toConfigFile(): Config</ID>
    <ID>ComplexMethod:ShellCmdLineOptions.kt$ShellConfigurationFile.ShellConfigFile$fun toShellConfiguration(): ShellConfiguration</ID>
    <ID>ComplexMethod:SignedTransaction.kt$SignedTransaction$// TODO: Verify contract constraints here as well as in LedgerTransaction to ensure that anything being deserialised // from the attachment is trusted. This will require some partial serialisation work to not load the ContractState // objects from the TransactionState. @DeleteForDJVM private fun verifyRegularTransaction(services: ServiceHub, checkSufficientSignatures: Boolean)</ID>
    <ID>ComplexMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$override fun retryFlowFromSafePoint(currentState: StateMachineState)</ID>
    <ID>ComplexMethod:StartedFlowTransition.kt$StartedFlowTransition$override fun transition(): TransitionResult</ID>
    <ID>ComplexMethod:StartedFlowTransition.kt$StartedFlowTransition$private fun collectRelevantErrorsToThrow(flowIORequest: FlowIORequest&lt;*&gt;, checkpoint: Checkpoint): List&lt;Throwable&gt;</ID>
    <ID>ComplexMethod:StatusTransitions.kt$StatusTransitions$ fun verify(tx: LedgerTransaction)</ID>
    <ID>ComplexMethod:StringToMethodCallParser.kt$StringToMethodCallParser$ @Throws(UnparseableCallException::class) fun parse(target: T?, command: String): ParsedMethodCall</ID>
    <ID>ComplexMethod:SwapData.kt$SwapData$private fun getSwapConvention(name: String): FixedIborSwapConvention</ID>
    <ID>ComplexMethod:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$@Test fun testClientServerTlsExchange()</ID>
    <ID>ComplexMethod:TopLevelTransition.kt$TopLevelTransition$override fun transition(): TransitionResult</ID>
    <ID>ComplexMethod:TransactionBuilder.kt$TransactionBuilder$ fun withItems(vararg items: Any)</ID>
    <ID>ComplexMethod:TransactionBuilder.kt$TransactionBuilder$ private fun addMissingDependency(services: ServicesForResolution, wireTx: WireTransaction): Boolean</ID>
    <ID>ComplexMethod:TransactionBuilder.kt$TransactionBuilder$ private fun attachmentConstraintsTransition( constraints: Set&lt;AttachmentConstraint&gt;, attachmentToUse: ContractAttachment, services: ServicesForResolution ): AttachmentConstraint</ID>
    <ID>ComplexMethod:TransactionBuilder.kt$TransactionBuilder$ private fun handleContract( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, outputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, explicitContractAttachment: AttachmentId?, services: ServicesForResolution ): Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;</ID>
    <ID>ComplexMethod:TransactionUtils.kt$ fun createComponentGroups(inputs: List&lt;StateRef&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, attachments: List&lt;SecureHash&gt;, notary: Party?, timeWindow: TimeWindow?, references: List&lt;StateRef&gt;, networkParametersHash: SecureHash?): List&lt;ComponentGroup&gt;</ID>
    <ID>ComplexMethod:TypeIdentifier.kt$TypeIdentifier.Companion$ fun forGenericType(type: Type, resolutionContext: Type = type): TypeIdentifier</ID>
    <ID>ComplexMethod:TypeModellingFingerPrinter.kt$FingerPrintingState$// For a type we haven't seen before, determine the correct path depending on the type of type it is. private fun fingerprintNewType(type: LocalTypeInformation)</ID>
    <ID>ComplexMethod:UniversalContract.kt$UniversalContract$fun &lt;T&gt; replaceStartEnd(p: Perceivable&lt;T&gt;, start: Instant, end: Instant): Perceivable&lt;T&gt;</ID>
    <ID>ComplexMethod:UniversalContract.kt$UniversalContract$fun evalBigDecimal(tx: LedgerTransaction, expr: Perceivable&lt;BigDecimal&gt;): BigDecimal</ID>
    <ID>ComplexMethod:UniversalContract.kt$UniversalContract$fun evalBoolean(tx: LedgerTransaction, expr: Perceivable&lt;Boolean&gt;): Boolean</ID>
    <ID>ComplexMethod:UniversalContract.kt$UniversalContract$override fun verify(tx: LedgerTransaction)</ID>
    <ID>ComplexMethod:Util.kt$fun &lt;T&gt; debugCompare(perLeft: Perceivable&lt;T&gt;, perRight: Perceivable&lt;T&gt;)</ID>
    <ID>ComplexMethod:Util.kt$fun debugCompare(arrLeft: Arrangement, arrRight: Arrangement)</ID>
    <ID>ComplexMethod:Util.kt$fun replaceParty(arrangement: Arrangement, from: Party, to: Party): Arrangement</ID>
    <ID>ComplexMethod:WebServer.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>ConstructorParameterNaming:AdvancedExceptionDialog.kt$AdvancedExceptionDialog$_exception: Throwable</ID>
    <ID>ConstructorParameterNaming:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight$private val _readerValueLoader: () -&gt; T?</ID>
    <ID>ConstructorParameterNaming:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight$private val _writerValueLoader: () -&gt; T = { throw IllegalAccessException("No value loader provided") }</ID>
    <ID>ConstructorParameterNaming:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.Unknown$private val _valueLoader: () -&gt; T?</ID>
    <ID>ConstructorParameterNaming:ByteArrays.kt$ByteSequence$private val _bytes: ByteArray</ID>
    <ID>ConstructorParameterNaming:CommonSchema.kt$CommonSchemaV1.LinearState$_participants: Set&lt;AbstractParty&gt;</ID>
    <ID>ConstructorParameterNaming:CordaClock.kt$MutableClock$private var _delegateClock: Clock</ID>
    <ID>ConstructorParameterNaming:CordaException.kt$CordaException$private var _cause: Throwable? = null</ID>
    <ID>ConstructorParameterNaming:CordaException.kt$CordaException$private var _message: String? = null</ID>
    <ID>ConstructorParameterNaming:CordaException.kt$CordaRuntimeException$private var _cause: Throwable?</ID>
    <ID>ConstructorParameterNaming:CordaException.kt$CordaRuntimeException$private var _message: String?</ID>
    <ID>ConstructorParameterNaming:PortfolioApi.kt$PortfolioApi.AggregatedHistoryView$val IM: Double</ID>
    <ID>ConstructorParameterNaming:PortfolioApi.kt$PortfolioApi.AggregatedHistoryView$val MTM: Double</ID>
    <ID>ConstructorParameterNaming:PortfolioState.kt$PortfolioState$val _parties: Pair&lt;AbstractParty, AbstractParty&gt;</ID>
    <ID>ConstructorParameterNaming:ScheduledActivityObserver.kt$ScheduledActivityObserver$private val FlowLogicRefFactory: FlowLogicRefFactory</ID>
    <ID>ConstructorParameterNaming:SwapData.kt$FixedLeg$val _notional: BigDecimal</ID>
    <ID>ConstructorParameterNaming:SwapData.kt$FloatingLeg$val _notional: BigDecimal</ID>
    <ID>ConstructorParameterNaming:SwapDataView.kt$SwapDataView$var IM: Double? = null</ID>
    <ID>ConstructorParameterNaming:SwapDataView.kt$SwapDataView$var MTM: Double? = null</ID>
    <ID>ConstructorParameterNaming:TypeIdentifier.kt$ReconstitutedParameterizedType$private val _actualTypeArguments: Array&lt;Type&gt;</ID>
    <ID>ConstructorParameterNaming:TypeIdentifier.kt$ReconstitutedParameterizedType$private val _ownerType: Type?</ID>
    <ID>ConstructorParameterNaming:TypeIdentifier.kt$ReconstitutedParameterizedType$private val _rawType: Type</ID>
    <ID>ConstructorParameterNaming:VaultSchema.kt$VaultSchemaV1.VaultFungibleStates$_issuerParty: AbstractParty</ID>
    <ID>ConstructorParameterNaming:VaultSchema.kt$VaultSchemaV1.VaultFungibleStates$_issuerRef: OpaqueBytes</ID>
    <ID>ConstructorParameterNaming:VaultSchema.kt$VaultSchemaV1.VaultFungibleStates$_owner: AbstractParty</ID>
    <ID>ConstructorParameterNaming:VaultSchema.kt$VaultSchemaV1.VaultFungibleStates$_quantity: Long</ID>
    <ID>EmptyCatchBlock:ClockUtilsTest.kt$ClockUtilsTest${ }</ID>
    <ID>EmptyCatchBlock:NodeTerminalView.kt$NodeTerminalView${}</ID>
    <ID>EmptyCatchBlock:ObservablesTests.kt$ObservablesTests${ }</ID>
    <ID>EmptyCatchBlock:PersistentUniquenessProvider.kt$PersistentUniquenessProvider${ }</ID>
    <ID>EmptyCatchBlock:RPCClientProxyHandler.kt$RPCClientProxyHandler${}</ID>
    <ID>EmptyCatchBlock:RPCStabilityTests.kt$RPCStabilityTests${}</ID>
    <ID>EmptyCatchBlock:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests${ }</ID>
    <ID>EmptyCatchBlock:TransactionCallbackTest.kt$TransactionCallbackTest${ }</ID>
    <ID>EmptyCatchBlock:WebServer.kt$WebServer${ }</ID>
    <ID>EmptyClassBlock:ClassLoadingUtilsTest.kt$ClassLoadingUtilsTest$BaseInterface</ID>
    <ID>EmptyClassBlock:ClassLoadingUtilsTest.kt$ClassLoadingUtilsTest$BaseInterface2</ID>
    <ID>EmptyClassBlock:ClassLoadingUtilsTest.kt$ClassLoadingUtilsTest$ConcreteClassWithEmptyConstructor : BaseInterface</ID>
    <ID>EmptyClassBlock:ClassLoadingUtilsTest.kt$ClassLoadingUtilsTest$ConcreteClassWithNonEmptyConstructor : BaseInterface2</ID>
    <ID>EmptyClassBlock:CordaRPCClient.kt$CordaRPCClient$Companion</ID>
    <ID>EmptyDefaultConstructor:FlowRetryTest.kt$AsyncRetryFlow$()</ID>
    <ID>EmptyDefaultConstructor:FlowRetryTest.kt$RetryFlow$()</ID>
    <ID>EmptyDefaultConstructor:FlowRetryTest.kt$ThrowingFlow$()</ID>
    <ID>EmptyElseBlock:CordaCliWrapper.kt${ }</ID>
    <ID>EmptyFunctionBlock:AMQPPrimitiveSerializer.kt$AMQPPrimitiveSerializer${ }</ID>
    <ID>EmptyFunctionBlock:AbstractNode.kt$FlowStarterImpl.&lt;no name provided&gt;${}</ID>
    <ID>EmptyFunctionBlock:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration${ }</ID>
    <ID>EmptyFunctionBlock:AzureContainerPusher.kt$AzureContainerPusher.&lt;no name provided&gt;${ }</ID>
    <ID>EmptyFunctionBlock:BFTSmartNotaryService.kt$BFTSmartNotaryService${ }</ID>
    <ID>EmptyFunctionBlock:CheckpointDumperTest.kt$CheckpointDumperTest.&lt;no name provided&gt;${}</ID>
    <ID>EmptyFunctionBlock:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests.TestOpsImpl${}</ID>
    <ID>EmptyFunctionBlock:CommsContracts.kt$CommsTestContract${ }</ID>
    <ID>EmptyFunctionBlock:ComposableTypePropertySerializer.kt$AMQPCharPropertyWriteStategy${}</ID>
    <ID>EmptyFunctionBlock:ComposableTypePropertySerializer.kt$AMQPPropertyWriteStrategy${}</ID>
    <ID>EmptyFunctionBlock:ConnectionManager.kt$&lt;no name provided&gt;.&lt;no name provided&gt;${}</ID>
    <ID>EmptyFunctionBlock:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest.CashV2${}</ID>
    <ID>EmptyFunctionBlock:CorDappCustomSerializer.kt$CorDappCustomSerializer${}</ID>
    <ID>EmptyFunctionBlock:CordaClassResolverTests.kt$CustomSerializable${ }</ID>
    <ID>EmptyFunctionBlock:CordaClassResolverTests.kt$DefaultSerializableSerializer${ }</ID>
    <ID>EmptyFunctionBlock:CordaMigration.kt$CordaMigration${ }</ID>
    <ID>EmptyFunctionBlock:CordaPersistence.kt$NoOpSubscriber${}</ID>
    <ID>EmptyFunctionBlock:CustomNotaryTest.kt$CustomNotaryTest.CustomNotaryService${}</ID>
    <ID>EmptyFunctionBlock:CustomSerializer.kt$CustomSerializer.CustomSerializerImp${}</ID>
    <ID>EmptyFunctionBlock:DBCheckpointStorageTests.kt$DBCheckpointStorageTests.&lt;no name provided&gt;${}</ID>
    <ID>EmptyFunctionBlock:DummyDealContract.kt$DummyDealContract${}</ID>
    <ID>EmptyFunctionBlock:DummyStates.kt$DoNothingContract${}</ID>
    <ID>EmptyFunctionBlock:GroupAMoreTests.kt$GroupAMoreTests${ }</ID>
    <ID>EmptyFunctionBlock:GroupATests.kt$GroupATests${ }</ID>
    <ID>EmptyFunctionBlock:GroupBTests.kt$GroupBTests${ }</ID>
    <ID>EmptyFunctionBlock:InMemoryTransactionVerifierService.kt$InMemoryTransactionVerifierService${}</ID>
    <ID>EmptyFunctionBlock:InteractiveShellIntegrationTest.kt$FlowForCheckpointDumpingResponder.&lt;no name provided&gt;${ }</ID>
    <ID>EmptyFunctionBlock:InteractiveShellIntegrationTest.kt$MyContract${}</ID>
    <ID>EmptyFunctionBlock:IrsDemoWebApplicationTests.kt$IrsDemoWebApplicationTests${ }</ID>
    <ID>EmptyFunctionBlock:LaunchSpaceshipFlow.kt$LaunchSpaceshipFlow${ }</ID>
    <ID>EmptyFunctionBlock:LaunchSpaceshipFlow.kt$LaunchSpaceshipFlowCorrect${ }</ID>
    <ID>EmptyFunctionBlock:LocalTypeModelTests.kt$LocalTypeModelTests.&lt;no name provided&gt;${}</ID>
    <ID>EmptyFunctionBlock:MyCustomNotaryService.kt$MyCustomValidatingNotaryService${}</ID>
    <ID>EmptyFunctionBlock:NoOpTestDatabaseContext.kt$NoOpTestDatabaseContext${}</ID>
    <ID>EmptyFunctionBlock:NodePerformanceTests.kt$NodePerformanceTests.EmptyFlow${ }</ID>
    <ID>EmptyFunctionBlock:NotaryTestContracts.kt$NotaryTestContract${ }</ID>
    <ID>EmptyFunctionBlock:ObjectBuilder.kt$ConstructorBasedObjectBuilder${}</ID>
    <ID>EmptyFunctionBlock:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ReceiveSplitMessagesFlow.&lt;no name provided&gt;${ }</ID>
    <ID>EmptyFunctionBlock:PersistentIdentityMigration.kt$PersistentIdentityMigration${ }</ID>
    <ID>EmptyFunctionBlock:PersistentIdentityMigrationNewTable.kt$PersistentIdentityMigrationNewTable${ }</ID>
    <ID>EmptyFunctionBlock:SerializationOutputTests.kt$SerializationOutputTests.&lt;no name provided&gt;${ }</ID>
    <ID>EmptyFunctionBlock:SerializationOutputTests.kt$SerializationOutputTests.FooContract${ }</ID>
    <ID>EmptyFunctionBlock:SimpleNotaryService.kt$SimpleNotaryService${}</ID>
    <ID>EmptyFunctionBlock:TestObservableContext.kt$TestObservableContext${ }</ID>
    <ID>EmptyFunctionBlock:TimedFlowTests.kt$TimedFlowTests.TestNotaryService${}</ID>
    <ID>EmptyFunctionBlock:TransactionSerializationTests.kt$TransactionSerializationTests.TestCash${ }</ID>
    <ID>EmptyFunctionBlock:TransitionExecutorImpl.kt$TransitionExecutorImpl${}</ID>
    <ID>EmptyFunctionBlock:UniqueDummyFungibleContract.kt$UniqueDummyFungibleContract${}</ID>
    <ID>EmptyFunctionBlock:UniqueDummyLinearContract.kt$UniqueDummyLinearContract${}</ID>
    <ID>EmptyFunctionBlock:UniquenessProviderTests.kt$UniquenessProviderFactory${}</ID>
    <ID>EmptyFunctionBlock:Utils.kt$&lt;no name provided&gt;${}</ID>
    <ID>EmptyFunctionBlock:VaultQueryTests.kt$VaultQueryTestsBase.MyContractClass${}</ID>
    <ID>EmptyFunctionBlock:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest.ContractImpl${}</ID>
    <ID>EmptyFunctionBlock:VaultUpdateTests.kt$VaultUpdateTests.DummyContract${ }</ID>
    <ID>EmptyFunctionBlock:WebServerPluginRegistry.kt$WebServerPluginRegistry${}</ID>
    <ID>EmptyKtFile:KryoHook.kt$.KryoHook.kt</ID>
    <ID>EmptyKtFile:ValidatingNotaryService.kt$.ValidatingNotaryService.kt</ID>
    <ID>EnumNaming:LoginView.kt$LoginView.LoginStatus$exception</ID>
    <ID>EnumNaming:LoginView.kt$LoginView.LoginStatus$exited</ID>
    <ID>EnumNaming:LoginView.kt$LoginView.LoginStatus$loggedIn</ID>
    <ID>EqualsWithHashCodeExist:IRSUtils.kt$FixedRate : Rate</ID>
    <ID>EqualsWithHashCodeExist:ProgressTracker.kt$ProgressTracker$DONE : Step</ID>
    <ID>EqualsWithHashCodeExist:ProgressTracker.kt$ProgressTracker$STARTING : Step</ID>
    <ID>EqualsWithHashCodeExist:ProgressTracker.kt$ProgressTracker$UNSTARTED : Step</ID>
    <ID>EqualsWithHashCodeExist:Utils.kt$StateRefHere</ID>
    <ID>FinalNewline:</ID>
    <ID>ForbiddenComment:AbstractAttachment.kt$AbstractAttachment$// TODO: read file size information from metadata instead of loading the data.</ID>
    <ID>ForbiddenComment:AbstractCashSelection.kt$AbstractCashSelection$// TODO: future implementation to retrieve contract states from a Vault BLOB store</ID>
    <ID>ForbiddenComment:AbstractCashSelection.kt$AbstractCashSelection$// TODO: make parameters configurable when we get CorDapp configuration.</ID>
    <ID>ForbiddenComment:AbstractCashSelection.kt$AbstractCashSelection$// TODO: revisit the back off strategy for contended spending.</ID>
    <ID>ForbiddenComment:AbstractNode.kt$AbstractNode$// TODO: Use configuration to indicate composite key should be used instead of public key for the identity.</ID>
    <ID>ForbiddenComment:AbstractNode.kt$AbstractNode$// TODO: We need a good way of handling "nice to have" shutdown events, especially those that deal with the</ID>
    <ID>ForbiddenComment:AbstractNode.kt$AbstractNode.&lt;no name provided&gt;$// TODO: Exponential backoff? It should reach max interval of eventHorizon/2.</ID>
    <ID>ForbiddenComment:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$// TODO: This step should not be necessary, as signatures are re-checked in verifyRequiredSignatures.</ID>
    <ID>ForbiddenComment:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$// TODO: use keys from the keyManagementService instead</ID>
    <ID>ForbiddenComment:AffinityExecutor.kt$AffinityExecutor$// TODO: Rename this to executeWithResult</ID>
    <ID>ForbiddenComment:AllButBlacklisted.kt$AllButBlacklisted$// TODO: AutoCloseable::class.java.name,</ID>
    <ID>ForbiddenComment:AllButBlacklisted.kt$AllButBlacklisted$// TODO: add more from java.io.</ID>
    <ID>ForbiddenComment:AllButBlacklisted.kt$AllButBlacklisted$// TODO: add more from java.lang.reflect.</ID>
    <ID>ForbiddenComment:AllButBlacklisted.kt$AllButBlacklisted$// TODO: add more from java.net.</ID>
    <ID>ForbiddenComment:AllButBlacklisted.kt$AllButBlacklisted$// TODO: blacklistedClasses += type.name // add it, so checking is faster next time we encounter this class.</ID>
    <ID>ForbiddenComment:Arrangement.kt$Obligation$// TODO: should be replaced with something that uses Corda assets and/or cash?</ID>
    <ID>ForbiddenComment:Arrangement.kt$Obligation$// TODO: should only be allowed to transfer non-negative amounts</ID>
    <ID>ForbiddenComment:Arrangement.kt$RollOut$// TODO: fixing offset</ID>
    <ID>ForbiddenComment:Arrangement.kt$RollOut$// TODO: think about payment offset (ie. settlement) - probably it doesn't belong on a distributed ledger</ID>
    <ID>ForbiddenComment:ArtemisMessagingComponent.kt$ArtemisMessagingComponent.Companion$// TODO: we might want to make this value configurable.</ID>
    <ID>ForbiddenComment:ArtemisMessagingServer.kt$// TODO: Implement a discovery engine that can trigger builds of new connections when another node registers? (later)</ID>
    <ID>ForbiddenComment:ArtemisMessagingServer.kt$// TODO: Verify that nobody can connect to us and fiddle with our config over the socket due to the secman.</ID>
    <ID>ForbiddenComment:ArtemisMessagingServer.kt$ArtemisMessagingServer$// TODO: Maybe wrap [IOException] on a key store load error so that it's clearly splitting key store loading from</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart$// TODO: Define and document the configuration of the bft-smart cluster.</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart$// TODO: Potentially update the bft-smart API for our use case or rebuild client and server from lower level building</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart$// TODO: Support cluster membership changes. This requires reading about reconfiguration of bft-smart clusters and</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: Hopefully we only need to wait for the client's initial connection to the cluster, and this method can be moved to some startup code.</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: Investigate ConcurrentModificationException in this method.</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: for now we treat all errors as equal, compare by error type as well</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: is it safe use the last message for sender/session/sequence info</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: only return an aggregate if the majority of signatures are replies</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: return an error reported by the majority and not just the first one</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.CordaServiceReplica$// TODO: At the cluster level, join all Sender/Receiver threads.</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Replica$// TODO:</ID>
    <ID>ForbiddenComment:BFTSmartNotaryService.kt$BFTSmartNotaryService.ServiceFlow$// TODO: here we assume that all error will be the same, but there might be invalid onces from mailicious nodes</ID>
    <ID>ForbiddenComment:BankOfCordaClientApi.kt$BankOfCordaClientApi$// TODO: privileged security controls required</ID>
    <ID>ForbiddenComment:BankOfCordaClientApi.kt$BankOfCordaClientApi$// TODO: security controls required</ID>
    <ID>ForbiddenComment:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService$// TODO: A full KeyManagementService implementation needs to record activity to the Audit Service and to limit</ID>
    <ID>ForbiddenComment:BusinessCalendar.kt$BusinessCalendar.Companion$// TODO: Fix addl period logic</ID>
    <ID>ForbiddenComment:BusinessCalendar.kt$BusinessCalendar.Companion$// TODO: The rest.</ID>
    <ID>ForbiddenComment:Cash.kt$Cash$// TODO: This doesn't work with the trader demo, so use the underlying key instead</ID>
    <ID>ForbiddenComment:CashPaymentFlow.kt$CashPaymentFlow$// TODO: Have some way of restricting this to states the caller controls</ID>
    <ID>ForbiddenComment:CashTests.kt$CashTests$// TODO: Optimise this so that we don't throw away and rebuild state that can be shared across tests.</ID>
    <ID>ForbiddenComment:CashViewer.kt$CashViewer$// TODO: Anonymous should probably be italicised or similar</ID>
    <ID>ForbiddenComment:CashViewer.kt$CashViewer.StateRowGraphic$// TODO: Anonymous should probably be italicised or similar</ID>
    <ID>ForbiddenComment:CertRole.kt$CertRole$// TODO: Link to the specification once it has a permanent URL</ID>
    <ID>ForbiddenComment:ClassCarpenter.kt$ClassCarpenterImpl$// TODO: Generate equals/hashCode.</ID>
    <ID>ForbiddenComment:ClassCarpenter.kt$ClassCarpenterImpl$// TODO: Generics.</ID>
    <ID>ForbiddenComment:ClassCarpenter.kt$ClassCarpenterImpl$// TODO: Sandbox the generated code when a security manager is in use.</ID>
    <ID>ForbiddenComment:ClassCarpenter.kt$ClassCarpenterImpl$// TODO: Support annotations.</ID>
    <ID>ForbiddenComment:ClassCarpenter.kt$ClassCarpenterImpl$// TODO: isFoo getter patterns for booleans (this is what Kotlin generates)</ID>
    <ID>ForbiddenComment:ClassWhitelists.kt$GlobalTransientClassWhiteList$// TODO: Need some concept of from which class loader</ID>
    <ID>ForbiddenComment:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$// TODO: Test that timeouts work</ID>
    <ID>ForbiddenComment:CollectSignaturesFlow.kt$CollectSignaturesFlow$// TODO: AbstractStateReplacementFlow needs updating to use this flow.</ID>
    <ID>ForbiddenComment:CollectSignaturesFlow.kt$CollectSignaturesFlow.Companion$// TODO: Make the progress tracker adapt to the number of counterparties to collect from.</ID>
    <ID>ForbiddenComment:CollectSignaturesFlow.kt$SignTransactionFlow$// TODO: We should have a faster way of verifying we own a single key</ID>
    <ID>ForbiddenComment:CollectionSerializer.kt$CollectionSerializer$// TODO: Can we verify the entries in the list?</ID>
    <ID>ForbiddenComment:CommercialPaper.kt$CommercialPaper$// TODO: Consider how to handle the case of mistaken issuances, or other need to patch.</ID>
    <ID>ForbiddenComment:CommercialPaper.kt$CommercialPaper$// TODO: Generalise the notion of an owned instrument into a superclass/supercontract. Consider composition vs inheritance.</ID>
    <ID>ForbiddenComment:CommercialPaper.kt$CommercialPaper$// TODO: Think about how to evolve contracts over time with new commands.</ID>
    <ID>ForbiddenComment:CommercialPaperIssueFlow.kt$CommercialPaperIssueFlow$// TODO: Consider moving these two steps below into generateIssue.</ID>
    <ID>ForbiddenComment:CommercialPaperTests.kt$// TODO: The generate functions aren't tested by these tests: add them.</ID>
    <ID>ForbiddenComment:CompatibilityTest.kt$CompatibilityTest$// TODO: If this type of testing gets momentum, we can create a mini-framework that rides through list of files</ID>
    <ID>ForbiddenComment:CompositeKey.kt$CompositeKey$// TODO: replace with the more extensive, but slower, checkValidity() test.</ID>
    <ID>ForbiddenComment:CompositeKey.kt$CompositeKey.Companion$// TODO: node.encoded.sequence() might be expensive, consider a faster deterministic compareTo implementation</ID>
    <ID>ForbiddenComment:CompositeKey.kt$CompositeKey.NodeAndWeight$// TODO: this might be expensive, consider a faster deterministic compareTo implementation when weights are equal.</ID>
    <ID>ForbiddenComment:CompositeKeyTests.kt$CompositeKeyTests$// TODO: Look into a DSL for building multi-level composite keys if that becomes a common use case</ID>
    <ID>ForbiddenComment:ContractUpgradeFlow.kt$ContractUpgradeFlow.Initiate$// TODO: We need a much faster way of finding our key in the transaction</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$// TODO: check transaction size is within limits</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$// TODO: copy across encumbrances when performing contract upgrades</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$// TODO: exclude encumbrance states from this check</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$// TODO: relax this constraint once upgrading encumbered states is supported.</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction.Companion$// TODO: if there are encumbrance states in the inputs, just copy them across without modifying</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction.Companion$// TODO: re-map encumbrance pointers</ID>
    <ID>ForbiddenComment:CordaClassResolver.kt$CordaClassResolver$// TODO: Later we can support annotations on attachment classes and spin up a proxy via bytecode that we know is harmless.</ID>
    <ID>ForbiddenComment:CordaClassResolver.kt$CordaClassResolver$// TODO: come up with a more efficient way. e.g. segregate the name space by class loader.</ID>
    <ID>ForbiddenComment:CordaRPCClient.kt$CordaRPCClientConfiguration$// TODO: acquire this value from Network Map when supported.</ID>
    <ID>ForbiddenComment:Cordapp.kt$Cordapp.Info.ContractAndWorkflow$// TODO: future work in Gradle cordapp plugins to enforce separation of Contract and Workflow classes into separate jars</ID>
    <ID>ForbiddenComment:CordappImpl.kt$CordappImpl$// TODO: Also add [SchedulableFlow] as a Cordapp class</ID>
    <ID>ForbiddenComment:CordappProviderImpl.kt$CordappProviderImpl$// TODO: Use better supported APIs in Java 9</ID>
    <ID>ForbiddenComment:CordappProviderImplTests.kt$CordappProviderImplTests.Companion$// TODO: Cordapp name should differ from the JAR name</ID>
    <ID>ForbiddenComment:CoreFlowHandlers.kt$NotaryChangeHandler$// TODO: Right now all nodes will automatically approve the notary change. We need to figure out if stricter controls are necessary.</ID>
    <ID>ForbiddenComment:CrossCashTest.kt$CrossCashState$// TODO: Alternative: We may possibly reduce the complexity of the search even further using some form of</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: Check if non-ECC keys satisfy params (i.e. approved/valid RSA modulus size).</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: We currently use SHA256(seed) when retrying, but BIP32 just skips a counter (i) that results to an invalid key.</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: change the val name to a more descriptive one as it's now confusing and looks like a Key type.</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: change val name to SPHINCS256_SHA512. This will break backwards compatibility.</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: perform all cryptographic operations via Crypto.</ID>
    <ID>ForbiddenComment:CryptoUtils.kt$// TODO: SignatureException should be used only for a damaged signature, as per `java.security.Signature.verify()`.</ID>
    <ID>ForbiddenComment:CustomSerializer.kt$CustomSerializer.SubClass$// TODO: should this be a custom serializer at all, or should it just be a plain AMQPSerializer?</ID>
    <ID>ForbiddenComment:CustomSerializer.kt$CustomSerializer.SubClass$// TODO: should this be empty or contain the schema of the super?</ID>
    <ID>ForbiddenComment:DbTransactionsResolver.kt$DbTransactionsResolver$// TODO: This approach has two problems. Analyze and resolve them:</ID>
    <ID>ForbiddenComment:DefaultKryoCustomizer.kt$DefaultKryoCustomizer$// TODO: re-organise registrations into logical groups before v1.0</ID>
    <ID>ForbiddenComment:DigitalSignatureWithCert.kt$// TODO: Rename this to DigitalSignature.WithCert once we're happy for it to be public API. The methods will need documentation</ID>
    <ID>ForbiddenComment:DriverDSLImpl.kt$DriverDSLImpl$// TODO: Derive name from the full picked name, don't just wrap the common name</ID>
    <ID>ForbiddenComment:DriverDSLImpl.kt$DriverDSLImpl$// TODO: remove this once we can bundle quasar properly.</ID>
    <ID>ForbiddenComment:DriverDSLImpl.kt$DriverDSLImpl.Companion$// TODO: There is pending work to fix this issue without custom blacklisting. See: https://r3-cev.atlassian.net/browse/CORDA-2164.</ID>
    <ID>ForbiddenComment:DriverDSLImpl.kt$DriverDSLImpl.LocalNetworkMap$// TODO: this object will copy NodeInfo files from started nodes to other nodes additional-node-infos/</ID>
    <ID>ForbiddenComment:DummyFungibleContract.kt$DummyFungibleContract$// TODO: This doesn't work with the trader demo, so use the underlying key instead</ID>
    <ID>ForbiddenComment:E2ETestKeyManagementService.kt$E2ETestKeyManagementService$// TODO: A full KeyManagementService implementation needs to record activity to the Audit Service and to limit</ID>
    <ID>ForbiddenComment:EncodingUtils.kt$// TODO: follow the crypto-conditions ASN.1 spec, some changes are needed to be compatible with the condition</ID>
    <ID>ForbiddenComment:Envelope.kt$Envelope$// TODO: don't recognise a type descriptor.</ID>
    <ID>ForbiddenComment:Envelope.kt$Envelope$// TODO: make the schema parsing lazy since mostly schemas will have been seen before and we only need it if we</ID>
    <ID>ForbiddenComment:Explorer.kt$Explorer$// TODO: Remove this code when serialisation has been upgraded.</ID>
    <ID>ForbiddenComment:FetchDataFlow.kt$FetchDataFlow$// TODO: Support "large message" response streaming so response sizes are not limited by RAM.</ID>
    <ID>ForbiddenComment:FiberUtils.kt$// TODO: This method uses a built-in Quasar function to make a map of all ThreadLocals. This is probably inefficient, but the only API readily available.</ID>
    <ID>ForbiddenComment:FinanceTypes.kt$// TODO: Make Calendar data come from an oracle</ID>
    <ID>ForbiddenComment:FinanceTypes.kt$Frequency$// TODO: Revisit post-Vega and see if annualCompoundCount is still needed.</ID>
    <ID>ForbiddenComment:FixingFlow.kt$FixingFlow.Fixer$// TODO: this is in no way secure and will be replaced by general session initiation logic in the future</ID>
    <ID>ForbiddenComment:FlowIORequest.kt$FlowIORequest.ForceCheckpoint$// TODO: consider using an empty FlowAsyncOperation instead</ID>
    <ID>ForbiddenComment:FlowLogicRef.kt$FlowLogicRef$// TODO: align this with the existing [FlowRef] in the bank-side API (probably replace some of the API classes)</ID>
    <ID>ForbiddenComment:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$// TODO: Replace with a per app classloader/cordapp provider/cordapp loader - this will do for now</ID>
    <ID>ForbiddenComment:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$// TODO: This is used via RPC but it's probably better if we pass in argument names and values explicitly</ID>
    <ID>ForbiddenComment:GenerateRpcSslCertsCli.kt$GenerateRpcSslCerts$// TODO: consider adding a password strength policy.</ID>
    <ID>ForbiddenComment:GuiUtilities.kt$// TODO: This is a temporary fix for the UI to show the correct issuer identity, this will break when we start randomizing keys. More work is needed here when the identity work is done.</ID>
    <ID>ForbiddenComment:HibernateConfiguration.kt$HibernateConfiguration$// TODO: require mechanism to set schemaOptions (databaseSchema, tablePrefix) which are not global to session</ID>
    <ID>ForbiddenComment:IRS.kt$FloatingRatePaymentEvent$// TODO: Should an uncalculated amount return a zero ? null ? etc.</ID>
    <ID>ForbiddenComment:IRS.kt$InterestRateSwap$// TODO: Confirm: would someone really enter a swap with a negative fixed rate?</ID>
    <ID>ForbiddenComment:IRS.kt$InterestRateSwap$// TODO: further tests</ID>
    <ID>ForbiddenComment:IRS.kt$InterestRateSwap.Commands.Mature$// Trade has matured; no more actions. Cleanup. // TODO: Do we need this?</ID>
    <ID>ForbiddenComment:IRS.kt$InterestRateSwap.State$// TODO: Jexl is purely for prototyping. It may be replaced</ID>
    <ID>ForbiddenComment:IRS.kt$InterestRateSwap.State$// TODO: Whatever we do use must be secure and sandboxed</ID>
    <ID>ForbiddenComment:IRSTests.kt$// TODO: How I want it to look</ID>
    <ID>ForbiddenComment:IRSTests.kt$// TODO: this seems to fail quite dramatically</ID>
    <ID>ForbiddenComment:IRSUtils.kt$// TODO: For further discussion.</ID>
    <ID>ForbiddenComment:IRSUtils.kt$RatioUnit$// TODO: Discuss this type</ID>
    <ID>ForbiddenComment:IdempotentFlow.kt$TimedFlow$// TODO: allow specifying retry settings per flow</ID>
    <ID>ForbiddenComment:IdenticonRenderer.kt$IdenticonRenderer$// TODO: support transparency.</ID>
    <ID>ForbiddenComment:IdentityService.kt$IdentityService$// TODO: This should be done via the network map cache, which is the authoritative source of well known identities</ID>
    <ID>ForbiddenComment:IdentitySyncFlow.kt$IdentitySyncFlow.Send$// TODO: Can this be triggered automatically from [SendTransactionFlow]?</ID>
    <ID>ForbiddenComment:IdentitySyncFlow.kt$IdentitySyncFlow.Send$// TODO: Consider if this too restrictive - we perhaps should be checking the name on the signing certificate in the certificate path instead</ID>
    <ID>ForbiddenComment:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests$// TODO: Generate certificate with an EdDSA key rather than ECDSA</ID>
    <ID>ForbiddenComment:InitialRegistrationCli.kt$InitialRegistration$// TODO: Move node identity generation logic from node to registration helper.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Add a command to view last N lines/tail/control log4j2 loggers.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Add command history.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Command completion.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Configure default renderers, send objects down the pipeline, add support for xml output format.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Do something sensible with commands that return a future.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Fix up the 'dashboard' command which has some rendering issues.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Get rid of the 'java' command, it's kind of worthless.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Make it notice new shell commands added after the node started.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Resurrect or reimplement the mail plugin.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Review or fix the JVM commands which have bitrotted and some are useless.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$InteractiveShell$// TODO: A default renderer could be used, instead of an object mapper. See: http://www.crashub.org/1.3/reference.html#_renderers</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$InteractiveShell$// TODO: This utility is generally useful and might be better moved to the node class, or an RPC, if we can commit to making it stable API.</ID>
    <ID>ForbiddenComment:InternalUtils.kt$// TODO: Add inline back when a new Kotlin version is released and check if the java.lang.VerifyError</ID>
    <ID>ForbiddenComment:InternalUtils.kt$// TODO: Currently the certificate revocation status is not handled here. Nowhere in the code the second parameter is used. Consider adding the support in the future.</ID>
    <ID>ForbiddenComment:IrsDemoClientApi.kt$IRSDemoClientApi$// TODO: Add uploading of files to the HTTP API</ID>
    <ID>ForbiddenComment:KeyStoreConfigHelpers.kt$// TODO: X509Utilities.validateCertificateChain()</ID>
    <ID>ForbiddenComment:Kryo.kt$PublicKeySerializer$// TODO: Instead of encoding to the default X509 format, we could have a custom per key type (space-efficient) serialiser.</ID>
    <ID>ForbiddenComment:LegalNameValidator.kt$LegalNameValidator.Rule.Companion$// TODO: Implement confusable character detection if we add more scripts.</ID>
    <ID>ForbiddenComment:LocalTypeInformationBuilder.kt$// TODO: Revisit this when Kotlin issue is fixed.</ID>
    <ID>ForbiddenComment:LoggingBuyerFlow.kt$LoggingBuyerFlow$// TODO: This is potentially very expensive, and requires transaction details we may no longer have once</ID>
    <ID>ForbiddenComment:MockServices.kt$MockServices.Companion$// TODO: Can we use an X509 principal generator here?</ID>
    <ID>ForbiddenComment:NetParams.kt$NetParamsSigner$// TODO: not supported</ID>
    <ID>ForbiddenComment:NetworkBootstrapper.kt$NetworkBootstrapper$// TODO: pass a commandline parameter to the bootstrapper instead. Better yet, a notary config map</ID>
    <ID>ForbiddenComment:NetworkMapCacheTest.kt$NetworkMapCacheTest$// TODO: Should have a test case with anonymous lookup</ID>
    <ID>ForbiddenComment:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$// TODO: Remove sleep in unit test.</ID>
    <ID>ForbiddenComment:Node.kt$Node.Companion$// TODO: make this configurable.</ID>
    <ID>ForbiddenComment:NodeAttachmentService.kt$NodeAttachmentService$// TODO: PLT-147: The attachment should be randomised to prevent brute force guessing and thus privacy leaks.</ID>
    <ID>ForbiddenComment:NodeAttachmentService.kt$NodeAttachmentService$// TODO: Switch to a two-phase insert so we can handle attachments larger than RAM.</ID>
    <ID>ForbiddenComment:NodeAttachmentService.kt$NodeAttachmentService$// TODO: this is racey. ENT-2870</ID>
    <ID>ForbiddenComment:NodeConfigurationImpl.kt$NodeConfigurationImpl$// TODO: There are two implications here:</ID>
    <ID>ForbiddenComment:NodeInfoConstants.kt$// TODO: Add to Corda node.conf to allow customisation</ID>
    <ID>ForbiddenComment:NodeInfoWatcher.kt$NodeInfoWatcher$// TODO: Use NIO watch service instead?</ID>
    <ID>ForbiddenComment:NodeInterestRates.kt$NodeInterestRates.FixContainer$// TODO: the calendar data needs to be specified for every fix type in the input string</ID>
    <ID>ForbiddenComment:NodeInterestRates.kt$NodeInterestRates.UnknownFix$// TODO: can we split into two? Fix not available (retryable/transient) and unknown (permanent)</ID>
    <ID>ForbiddenComment:NodeSchemaServiceTest.kt$NodeSchemaServiceTest$// TODO: driver limitation: cannot restrict CorDapps that get automatically created by default,</ID>
    <ID>ForbiddenComment:NodeTerminalView.kt$NodeTerminalView$// TODO: Remove this special case once Rick's serialisation work means we can deserialise states that weren't on our own classpath.</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: Optimise this.</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: Perhaps these can be stored in a batch?</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: This is a catch-all solution. But why is the default pageNumber set to be -1 in the first place?</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: This is expensive - is there another way?</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: improve typing of returned other results</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: revisit (use single instance of parser for all queries)</ID>
    <ID>ForbiddenComment:NodeVaultServiceTest.kt$NodeVaultServiceTest$// TODO: Unit test linear state relevancy checks</ID>
    <ID>ForbiddenComment:NodeWebServer.kt$NodeWebServer$// TODO: Redesign</ID>
    <ID>ForbiddenComment:NotaryChangeFlow.kt$NotaryChangeFlow$// TODO: We need a much faster way of finding our key in the transaction</ID>
    <ID>ForbiddenComment:NotaryChangeTests.kt$NotaryChangeTests$// TODO: Add more test cases once we have a general flow/service exception handling mechanism:</ID>
    <ID>ForbiddenComment:NotaryChangeTests.kt$NotaryChangeTests$// TODO: Re-enable the test when parameter currentness checks are in place, ENT-2666.</ID>
    <ID>ForbiddenComment:NotaryError.kt$StateConsumptionDetails$// TODO: include notary timestamp?</ID>
    <ID>ForbiddenComment:NotaryFlow.kt$NotaryFlow.Client$// TODO: This is not required any more once our AMQP serialization supports turning off object referencing.</ID>
    <ID>ForbiddenComment:NotaryFlow.kt$NotaryFlow.Client$// TODO: [CORDA-2274] Perform full transaction verification once verification caching is enabled.</ID>
    <ID>ForbiddenComment:NotaryServiceFlow.kt$NotaryServiceFlow.Companion$// TODO: Determine an appropriate limit and also enforce in the network parameters and the transaction builder.</ID>
    <ID>ForbiddenComment:NotaryUtils.kt$// TODO: if requestSignature was generated over an old version of NotarisationRequest, we need to be able to</ID>
    <ID>ForbiddenComment:OGUtils.kt$// TODO: Do this correctly</ID>
    <ID>ForbiddenComment:Obligation.kt$Obligation$// TODO: Handle proxies nominated by parties, i.e. a central clearing service</ID>
    <ID>ForbiddenComment:ObligationUtils.kt$ObligationUtils$// TODO: A much better (but more complex) solution would be to have two iterators, one for obligations,</ID>
    <ID>ForbiddenComment:OnLedgerAsset.kt$OnLedgerAsset.Companion$// TODO: Check that re-running this on the same transaction multiple times does the right thing.</ID>
    <ID>ForbiddenComment:OnLedgerAsset.kt$OnLedgerAsset.Companion$// TODO: We should be prepared to produce multiple transactions exiting inputs from</ID>
    <ID>ForbiddenComment:OnLedgerAsset.kt$OnLedgerAsset.Companion$// TODO: We should be prepared to produce multiple transactions spending inputs from</ID>
    <ID>ForbiddenComment:OracleUtils.kt$// TODO: we would ordinarily convert clock to same time zone as the index/source would announce in</ID>
    <ID>ForbiddenComment:ParametersUtilities.kt$// TODO: Make this configurable and consistence across driver, bootstrapper, demobench and NetworkMapServer</ID>
    <ID>ForbiddenComment:Perceivable.kt$// TODO: fix should have implied default date and perhaps tenor when used in a rollOut template</ID>
    <ID>ForbiddenComment:Perceivable.kt$Interest$// todo: holidays</ID>
    <ID>ForbiddenComment:PersistentStateService.kt$PersistentStateService$// TODO: Manage version evolution of the schemas via additional tooling.</ID>
    <ID>ForbiddenComment:PortfolioApi.kt$// TODO: Change import namespaces vega -&gt; ....</ID>
    <ID>ForbiddenComment:PortfolioApi.kt$PortfolioApi$// TODO: Stop using localdate.now</ID>
    <ID>ForbiddenComment:PortfolioApi.kt$PortfolioApi$// TODO: enhancement to Vault Query to check for any participant in participants attribute</ID>
    <ID>ForbiddenComment:ProgressTracker.kt$// TODO: Expose the concept of errors.</ID>
    <ID>ForbiddenComment:ProgressTracker.kt$// TODO: It'd be helpful if this class was at least partly thread safe.</ID>
    <ID>ForbiddenComment:ProviderMap.kt$// TODO: Find a way to make JKS work with bouncy castle provider or implement our own provide so we don't have to register bouncy castle provider.</ID>
    <ID>ForbiddenComment:PublicKeySerializer.kt$PublicKeySerializer$// TODO: Instead of encoding to the default X509 format, we could have a custom per key type (space-efficient) serialiser.</ID>
    <ID>ForbiddenComment:RPCStabilityTests.kt$RPCStabilityTests$// TODO: This is ignored because Artemis slow consumers are broken. I'm not deleting it in case we can get the feature fixed.</ID>
    <ID>ForbiddenComment:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$// TODO: read &amp; put entries in batches</ID>
    <ID>ForbiddenComment:RaftTransactionCommitLog.kt$RaftTransactionCommitLog.Commands.CommitTransaction$// TODO: Cluster membership changes need testing.</ID>
    <ID>ForbiddenComment:RaftTransactionCommitLog.kt$RaftTransactionCommitLog.Commands.CommitTransaction$// TODO: I'm wondering if we should support resizing notary clusters, or if we could require users to</ID>
    <ID>ForbiddenComment:RaftUniquenessProvider.kt$RaftUniquenessProvider$// TODO: use local transport for client-server communications</ID>
    <ID>ForbiddenComment:RatesFixFlow.kt$RatesFixFlow$// TODO: Kick to a user confirmation / ui flow if it's out of bounds instead of raising an exception.</ID>
    <ID>ForbiddenComment:RatesFixFlow.kt$RatesFixFlow.FixQueryFlow$// TODO: add deadline to receive</ID>
    <ID>ForbiddenComment:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$// TODO: This could be done in parallel with other fetches for extra speed.</ID>
    <ID>ForbiddenComment:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$// TODO: this operation should not require an explicit transaction</ID>
    <ID>ForbiddenComment:RestrictedEntityManager.kt$RestrictedEntityManager$// TODO: Figure out which other methods on EntityManager need to be blocked?</ID>
    <ID>ForbiddenComment:ScheduledActivityObserver.kt$ScheduledActivityObserver.Companion$// TODO: Beware we are calling dynamically loaded contract code inside here.</ID>
    <ID>ForbiddenComment:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$// TODO: the queries below are not atomic so we need to allow enough time for the scheduler to finish. Would be better to query scheduler.</ID>
    <ID>ForbiddenComment:SendTransactionFlow.kt$DataVendingFlow$// Security TODO: Check for abnormally large or malformed data requests</ID>
    <ID>ForbiddenComment:SerializationHelper.kt$// TODO: surely we check it is concrete at this point with no TypeVariables</ID>
    <ID>ForbiddenComment:SerializationOutputTests.kt$SerializationOutputTests$// TODO: Generic interfaces / superclasses</ID>
    <ID>ForbiddenComment:SerializationOutputTests.kt$SerializationOutputTests$// TODO: add some schema assertions to check correctly formed.</ID>
    <ID>ForbiddenComment:SerializationScheme.kt$SerializationFactoryImpl$// TODO: This is read-mostly. Probably a faster implementation to be found.</ID>
    <ID>ForbiddenComment:ServiceHub.kt$ServicesForResolution$// TODO: future implementation to use a Vault state ref -&gt; contract state BLOB table and perform single query bulk load</ID>
    <ID>ForbiddenComment:ServiceHubCoreInternal.kt$ServiceHubCoreInternal$// TODO: This should really be called ServiceHubInternal but that name is already taken by net.corda.node.services.api.ServiceHubInternal.</ID>
    <ID>ForbiddenComment:ServiceHubInternal.kt$WritableTransactionStorage$// TODO: Throw an exception if trying to add a transaction with fewer signatures than an existing entry.</ID>
    <ID>ForbiddenComment:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$// TODO: check only one (or until one is resolved successfully), max recursive invocations check?</ID>
    <ID>ForbiddenComment:SharedMemoryIncremental.kt$SharedMemoryIncremental$// TODO: Do we really need 16 bytes? Given that we care about Int it should be enough to have 4</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: Verify contract constraints here as well as in LedgerTransaction to ensure that anything being deserialised</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: We could probably optimise the below by</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: We need a much better way of structuring this data.</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: allow non-blocking verification.</ID>
    <ID>ForbiddenComment:SimmFlow.kt$SimmFlow.Receiver$// TODO: The attachments need to be added somewhere</ID>
    <ID>ForbiddenComment:SimmFlow.kt$SimmFlow.Receiver$// TODO: handle failures</ID>
    <ID>ForbiddenComment:SimmFlow.kt$SimmFlow.Requester$// TODO: In the real world, this would be tolerance aware for different types</ID>
    <ID>ForbiddenComment:SimmFlow.kt$SimmFlow.Requester$// TODO: The attachments need to be added somewhere</ID>
    <ID>ForbiddenComment:SimmFlow.kt$SimmFlow.Requester$// TODO: handle failures</ID>
    <ID>ForbiddenComment:SinglePartyNotaryService.kt$SinglePartyNotaryService$// TODO: Log the request here. Benchmarking shows that logging is expensive and we might get better performance</ID>
    <ID>ForbiddenComment:StateMachineManagerUtils.kt$// TODO: instead of replacing the progress tracker after constructing the flow logic, we should inject it during fiber deserialization</ID>
    <ID>ForbiddenComment:Structures.kt$MoveCommand$// TODO: Replace Class here with a general contract constraints object</ID>
    <ID>ForbiddenComment:SwapData.kt$SwapData$// TODO: Fix below to be correct - change tenor and reference data</ID>
    <ID>ForbiddenComment:SwapDataView.kt$// TODO: Should be able to display an array ?</ID>
    <ID>ForbiddenComment:ThrowableSerializer.kt$ThrowableSerializer$// TODO: This will need reworking when we have multiple class loaders</ID>
    <ID>ForbiddenComment:TransactionBuilder.kt$TransactionBuilder$// TODO: Add support for making recursive resolution optional if it becomes an issue.</ID>
    <ID>ForbiddenComment:TransactionBuilder.kt$TransactionBuilder$// TODO: add link to docsite page, when there is one.</ID>
    <ID>ForbiddenComment:TransactionState.kt$TransactionState$// TODO: Implement the contract sandbox loading of the contract attachments</ID>
    <ID>ForbiddenComment:TransactionState.kt$TransactionState$// TODO: add link to docsite page, when there is one.</ID>
    <ID>ForbiddenComment:TransactionUtils.kt$// TODO: [ENT-2666] Implement network parameters fuzzy checking. By design in Corda network we have propagation time delay.</ID>
    <ID>ForbiddenComment:TransactionUtils.kt$// TODO: we could avoid deserialising unrelated signers.</ID>
    <ID>ForbiddenComment:TransactionVerificationException.kt$TransactionVerificationException$// TODO: Make this descend from TransactionVerificationException so that untrusted attachments cause flows to be hospitalized.</ID>
    <ID>ForbiddenComment:TransactionVerificationException.kt$TransactionVerificationException.TransactionRequiredContractUnspecifiedException$// TODO: add reference to documentation</ID>
    <ID>ForbiddenComment:TransactionViewer.kt$TransactionViewer.ContractStatesView$// TODO: Anonymous should probably be italicised or similar</ID>
    <ID>ForbiddenComment:TransformTypes.kt$TransformTypes$// TODO: annotated with some annotation</ID>
    <ID>ForbiddenComment:TransformTypes.kt$TransformTypes$// TODO: it would be awesome to auto build this list by scanning for transform annotations themselves</ID>
    <ID>ForbiddenComment:TwoPartyDealFlow.kt$TwoPartyDealFlow$// TODO: Also, the term Deal is used here where we might prefer Agreement.</ID>
    <ID>ForbiddenComment:TwoPartyDealFlow.kt$TwoPartyDealFlow$// TODO: Make this flow more generic.</ID>
    <ID>ForbiddenComment:TwoPartyDealFlow.kt$TwoPartyDealFlow$// TODO: The subclasses should probably be broken out into individual flows rather than making this an ever expanding collection of subclasses.</ID>
    <ID>ForbiddenComment:TwoPartyTradeFlow.kt$TwoPartyTradeFlow$// TODO: Common elements in multi-party transaction consensus and signing should be refactored into a superclass of this</ID>
    <ID>ForbiddenComment:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer.RECORDING$// TODO: Currently triggers a race condition on Team City. See https://github.com/corda/corda/issues/733.</ID>
    <ID>ForbiddenComment:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$// FIXME: Knowledge of confidential identities is lost on node shutdown, so Bob's node now refuses to sign the</ID>
    <ID>ForbiddenComment:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$// TODO: Verify that the result was inserted into the transaction database.</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract$// TODO: calendar + rolling conventions</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract$// TODO: look into schedule for final dates</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract$// TODO: not sure this is necessary??</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract$// TODO: think about multi layered rollouts</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract$// TODO: we may have to save original start date in order to roll out correctly</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract.Commands.Split$// todo: Who should sign this?</ID>
    <ID>ForbiddenComment:VaultFiller.kt$VaultFiller$// TODO: need to make all FungibleAsset commands (issue, move, exit) generic</ID>
    <ID>ForbiddenComment:VaultSchema.kt$VaultSchemaV1.VaultStates$// TODO: create a distinct table to hold serialized state data (once DBTransactionStore is encrypted)</ID>
    <ID>ForbiddenComment:VaultWithCashTest.kt$// TODO: Move this to the cash contract tests once mock services are further split up.</ID>
    <ID>ForbiddenComment:WebServerConfig.kt$WebServerConfig$// TODO: remove this once config format is updated</ID>
    <ID>ForbiddenComment:WebServerConfig.kt$WebServerConfig$// TODO: replace with credentials supplied by a user</ID>
    <ID>ForbiddenComment:WireTransaction.kt$WireTransaction$// TODO: prevent notary field from being set if there are no inputs and no time-window.</ID>
    <ID>ForbiddenComment:WireTransaction.kt$WireTransaction$// TODO: revisit once Deterministic JVM code updated</ID>
    <ID>ForbiddenComment:X509Utilities.kt$CertificateType.LEGAL_IDENTITY$// TODO: Identity certs should have tight name constraints on child certificates</ID>
    <ID>FunctionNaming:ArtemisRpcTests.kt$ArtemisRpcTests$@Test fun rpc_client_certificate_untrusted_to_server()</ID>
    <ID>FunctionNaming:ArtemisRpcTests.kt$ArtemisRpcTests$@Test fun rpc_with_no_ssl_on_client_side_and_ssl_on_server_side()</ID>
    <ID>FunctionNaming:ArtemisRpcTests.kt$ArtemisRpcTests$@Test fun rpc_with_ssl_disabled()</ID>
    <ID>FunctionNaming:ArtemisRpcTests.kt$ArtemisRpcTests$@Test fun rpc_with_ssl_enabled()</ID>
    <ID>FunctionNaming:ContractFunctions.kt$// building an fx swap using abstract swap fun fx_swap2( expiry: String, notional: Long, strike: Double, foreignCurrency: Currency, domesticCurrency: Currency, partyA: Party, partyB: Party )</ID>
    <ID>FunctionNaming:ContractFunctions.kt$fun fx_swap( expiry: String, notional: BigDecimal, strike: BigDecimal, foreignCurrency: Currency, domesticCurrency: Currency, partyA: Party, partyB: Party )</ID>
    <ID>FunctionNaming:Currencies.kt$fun &lt;T : Any&gt; AMOUNT(amount: Double, token: T): Amount&lt;T&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun &lt;T : Any&gt; AMOUNT(amount: Int, token: T): Amount&lt;T&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun &lt;T : Any&gt; AMOUNT(amount: Long, token: T): Amount&lt;T&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun DOLLARS(amount: Double): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun DOLLARS(amount: Int): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun DOLLARS(amount: Long): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun POUNDS(amount: Double): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun POUNDS(amount: Int): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun POUNDS(amount: Long): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun SWISS_FRANCS(amount: Double): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun SWISS_FRANCS(amount: Int): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun SWISS_FRANCS(amount: Long): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:InteractiveShell.kt$InteractiveShell$private fun _startShell(configuration: ShellConfiguration, classLoader: ClassLoader? = null)</ID>
    <ID>FunctionNaming:LedgerDSLInterpreter.kt$LedgerDSLInterpreter$ fun _transaction( transactionLabel: String?, transactionBuilder: TransactionBuilder, dsl: T.() -&gt; EnforceVerifyOrFail ): WireTransaction</ID>
    <ID>FunctionNaming:LedgerDSLInterpreter.kt$LedgerDSLInterpreter$ fun _tweak(dsl: LedgerDSLInterpreter&lt;T&gt;.() -&gt; Unit)</ID>
    <ID>FunctionNaming:LedgerDSLInterpreter.kt$LedgerDSLInterpreter$ fun _unverifiedTransaction( transactionLabel: String?, transactionBuilder: TransactionBuilder, dsl: T.() -&gt; Unit ): WireTransaction</ID>
    <ID>FunctionNaming:NodeHandleTests.kt$NodeHandleTests$@Test fun object_defined_functions_are_static_for_node_rpc_ops()</ID>
    <ID>FunctionNaming:NodeVaultService.kt$NodeVaultService$@Throws(VaultQueryException::class) private fun &lt;T : ContractState&gt; _queryBy( criteria: QueryCriteria, paging_: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;, skipPagingChecks: Boolean ): Vault.Page&lt;T&gt;</ID>
    <ID>FunctionNaming:ProgressTracker.kt$ProgressTracker$private fun _allSteps(level: Int = 0): List&lt;Pair&lt;Int, Step&gt;&gt;</ID>
    <ID>FunctionNaming:ProgressTracker.kt$ProgressTracker$private fun _allStepsLabels(level: Int = 0): List&lt;Pair&lt;Int, String&gt;&gt;</ID>
    <ID>FunctionNaming:SerializationOutput.kt$SerializationOutput$internal fun &lt;T : Any&gt; _serialize(obj: T, context: SerializationContext): SerializedBytes&lt;T&gt;</ID>
    <ID>FunctionNaming:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$ fun _attachment( contractClassName: ContractClassName, attachmentId: AttachmentId, signers: List&lt;PublicKey&gt;, jarManifestAttributes: Map&lt;String, String&gt; )</ID>
    <ID>FunctionNaming:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$ fun _attachment(contractClassName: ContractClassName)</ID>
    <ID>FunctionNaming:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$ fun _attachment(contractClassName: ContractClassName, attachmentId: AttachmentId, signers: List&lt;PublicKey&gt;)</ID>
    <ID>FunctionNaming:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$ fun _tweak(dsl: TransactionDSLInterpreter.() -&gt; EnforceVerifyOrFail): EnforceVerifyOrFail</ID>
    <ID>FunctionNaming:VaultService.kt$VaultService$ @Throws(VaultQueryException::class) fun &lt;T : ContractState&gt; _queryBy( criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt; ): Vault.Page&lt;T&gt;</ID>
    <ID>FunctionNaming:VaultService.kt$VaultService$ @Throws(VaultQueryException::class) fun &lt;T : ContractState&gt; _trackBy( criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt; ): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>FunctionParameterNaming:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight$_value: T</ID>
    <ID>FunctionParameterNaming:IdenticonRenderer.kt$IdenticonRenderer$_invert: Boolean</ID>
    <ID>FunctionParameterNaming:NodeVaultService.kt$NodeVaultService$paging_: PageSpecification</ID>
    <ID>FunctionParameterNaming:SwapDataView.kt$IM: InitialMarginTriple? = null</ID>
    <ID>LargeClass:AMQPBridgeTest.kt$AMQPBridgeTest</ID>
    <ID>LargeClass:ANSIProgressRenderer.kt$ANSIProgressRenderer</ID>
    <ID>LargeClass:AbstractNode.kt$AbstractNode&lt;S&gt; : SingletonSerializeAsToken</ID>
    <ID>LargeClass:ActionExecutorImpl.kt$ActionExecutorImpl : ActionExecutor</ID>
    <ID>LargeClass:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase&lt;K, V, E, out EK&gt;</ID>
    <ID>LargeClass:ArtemisMessagingTest.kt$ArtemisMessagingTest</ID>
    <ID>LargeClass:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests</ID>
    <ID>LargeClass:AuthDBTests.kt$AuthDBTests : NodeBasedTest</ID>
    <ID>LargeClass:BootstrapperView.kt$BootstrapperView : View</ID>
    <ID>LargeClass:Cap.kt$Cap</ID>
    <ID>LargeClass:CashTests.kt$CashTests</ID>
    <ID>LargeClass:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests</ID>
    <ID>LargeClass:CheckpointAgent.kt$CheckpointHook : ClassFileTransformer</ID>
    <ID>LargeClass:CheckpointDumper.kt$CheckpointDumper</ID>
    <ID>LargeClass:ClassCarpenter.kt$ClassCarpenterImpl : ClassCarpenter</ID>
    <ID>LargeClass:ClassCarpenterTest.kt$ClassCarpenterTest</ID>
    <ID>LargeClass:ClockUtilsTest.kt$ClockUtilsTest</ID>
    <ID>LargeClass:CommercialPaperTests.kt$CommercialPaperTestsGeneric</ID>
    <ID>LargeClass:CompatibleTransactionTests.kt$CompatibleTransactionTests</ID>
    <ID>LargeClass:CompositeKeyTests.kt$CompositeKeyTests</ID>
    <ID>LargeClass:ConcatenatedList.kt$ConcatenatedList&lt;A&gt; : TransformationList</ID>
    <ID>LargeClass:ConfigParsingTest.kt$ConfigParsingTest</ID>
    <ID>LargeClass:ConnectionStateMachine.kt$ConnectionStateMachine : BaseHandler</ID>
    <ID>LargeClass:ConstraintsPropagationTests.kt$ConstraintsPropagationTests</ID>
    <ID>LargeClass:CordaClassResolverTests.kt$CordaClassResolverTests</ID>
    <ID>LargeClass:CordaRPCClientTest.kt$CordaRPCClientTest : NodeBasedTest</ID>
    <ID>LargeClass:CordaRPCOpsImpl.kt$CordaRPCOpsImpl : InternalCordaRPCOpsAutoCloseable</ID>
    <ID>LargeClass:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest</ID>
    <ID>LargeClass:CordaX500NameTest.kt$CordaX500NameTest</ID>
    <ID>LargeClass:CordappConstraintsTests.kt$CordappConstraintsTests</ID>
    <ID>LargeClass:Crypto.kt$Crypto</ID>
    <ID>LargeClass:CryptoUtilsTest.kt$CryptoUtilsTest</ID>
    <ID>LargeClass:DBTransactionStorageTests.kt$DBTransactionStorageTests</ID>
    <ID>LargeClass:DeserializeNeedingCarpentrySimpleTypesTest.kt$DeserializeNeedingCarpentrySimpleTypesTest : AmqpCarpenterBase</ID>
    <ID>LargeClass:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests : AmqpCarpenterBase</ID>
    <ID>LargeClass:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests</ID>
    <ID>LargeClass:Driver.kt$DriverParameters</ID>
    <ID>LargeClass:DriverDSLImpl.kt$DriverDSLImpl : InternalDriverDSL</ID>
    <ID>LargeClass:EdDSATests.kt$EdDSATests</ID>
    <ID>LargeClass:EnumEvolvabilityTests.kt$EnumEvolvabilityTests</ID>
    <ID>LargeClass:EvolvabilityTests.kt$EvolvabilityTests</ID>
    <ID>LargeClass:FlowFrameworkTests.kt$FlowFrameworkTests</ID>
    <ID>LargeClass:FlowLogic.kt$FlowLogic&lt;out T&gt;</ID>
    <ID>LargeClass:FlowStateMachineImpl.kt$FlowStateMachineImpl&lt;R&gt; : FiberFlowStateMachineFlowFiber</ID>
    <ID>LargeClass:GenericsTests.kt$GenericsTests</ID>
    <ID>LargeClass:HibernateConfigurationTest.kt$HibernateConfigurationTest</ID>
    <ID>LargeClass:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser : AbstractQueryCriteriaParserIQueryCriteriaParser</ID>
    <ID>LargeClass:HibernateStatistics.kt$DelegatingStatisticsService : StatisticsService</ID>
    <ID>LargeClass:IRS.kt$IRS</ID>
    <ID>LargeClass:IRS.kt$InterestRateSwap : Contract</ID>
    <ID>LargeClass:IRSTests.kt$IRSTests</ID>
    <ID>LargeClass:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest</ID>
    <ID>LargeClass:InteractiveShell.kt$InteractiveShell</ID>
    <ID>LargeClass:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest</ID>
    <ID>LargeClass:InternalMockNetwork.kt$InternalMockNetwork : AutoCloseable</ID>
    <ID>LargeClass:JacksonSupportTest.kt$JacksonSupportTest</ID>
    <ID>LargeClass:JarScanningCordappLoader.kt$JarScanningCordappLoader : CordappLoaderTemplate</ID>
    <ID>LargeClass:KryoTests.kt$KryoTests</ID>
    <ID>LargeClass:LedgerTransaction.kt$LedgerTransaction : FullTransaction</ID>
    <ID>LargeClass:LedgerTransactionQueryTests.kt$LedgerTransactionQueryTests</ID>
    <ID>LargeClass:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder</ID>
    <ID>LargeClass:MockNodeMessagingService.kt$MockNodeMessagingService : SingletonSerializeAsTokenMessagingService</ID>
    <ID>LargeClass:Network.kt$Network : CordaView</ID>
    <ID>LargeClass:NetworkBootstrapper.kt$NetworkBootstrapper : NetworkBootstrapperWithOverridableParameters</ID>
    <ID>LargeClass:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests</ID>
    <ID>LargeClass:NetworkBootstrapperTest.kt$NetworkBootstrapperTest</ID>
    <ID>LargeClass:NetworkBuilder.kt$NetworkBuilderImpl : NetworkBuilder</ID>
    <ID>LargeClass:NetworkMapUpdater.kt$NetworkMapUpdater : AutoCloseable</ID>
    <ID>LargeClass:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest</ID>
    <ID>LargeClass:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest</ID>
    <ID>LargeClass:NetworkRegistrationHelper.kt$NetworkRegistrationHelper</ID>
    <ID>LargeClass:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest</ID>
    <ID>LargeClass:NewTransaction.kt$NewTransaction : Fragment</ID>
    <ID>LargeClass:Node.kt$Node : AbstractNode</ID>
    <ID>LargeClass:NodeAttachmentService.kt$NodeAttachmentService : AttachmentStorageInternalSingletonSerializeAsToken</ID>
    <ID>LargeClass:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest</ID>
    <ID>LargeClass:NodeConfigurationImpl.kt$NodeConfigurationImpl : NodeConfiguration</ID>
    <ID>LargeClass:NodeConfigurationImplTest.kt$NodeConfigurationImplTest</ID>
    <ID>LargeClass:NodeInterestRatesTest.kt$NodeInterestRatesTest</ID>
    <ID>LargeClass:NodeStartup.kt$NodeStartup : NodeStartupLogging</ID>
    <ID>LargeClass:NodeTabView.kt$NodeTabView : Fragment</ID>
    <ID>LargeClass:NodeTerminalView.kt$NodeTerminalView : Fragment</ID>
    <ID>LargeClass:NodeVaultService.kt$NodeVaultService : SingletonSerializeAsTokenVaultServiceInternal</ID>
    <ID>LargeClass:NodeVaultServiceTest.kt$NodeVaultServiceTest</ID>
    <ID>LargeClass:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests</ID>
    <ID>LargeClass:OGSwapPricingExample.kt$SwapPricingExample</ID>
    <ID>LargeClass:Obligation.kt$Obligation&lt;P : Any&gt; : Contract</ID>
    <ID>LargeClass:ObligationTests.kt$ObligationTests</ID>
    <ID>LargeClass:ObligationUtils.kt$ObligationUtils</ID>
    <ID>LargeClass:ObservablesTests.kt$ObservablesTests</ID>
    <ID>LargeClass:P2PMessagingClient.kt$P2PMessagingClient : SingletonSerializeAsTokenMessagingServiceAddressToArtemisQueueResolver</ID>
    <ID>LargeClass:PartialMerkleTreeTest.kt$PartialMerkleTreeTest</ID>
    <ID>LargeClass:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests</ID>
    <ID>LargeClass:PersistentNetworkMapCache.kt$PersistentNetworkMapCache : NetworkMapCacheInternalSingletonSerializeAsToken</ID>
    <ID>LargeClass:PersistentUniquenessProvider.kt$PersistentUniquenessProvider : UniquenessProviderSingletonSerializeAsToken</ID>
    <ID>LargeClass:PortfolioApi.kt$PortfolioApi</ID>
    <ID>LargeClass:PrettyPrint.kt$PrettyPrint</ID>
    <ID>LargeClass:ProgressTrackerTest.kt$ProgressTrackerTest</ID>
    <ID>LargeClass:PropertyTest.kt$PropertyTest</ID>
    <ID>LargeClass:PropertyValidationTest.kt$PropertyValidationTest</ID>
    <ID>LargeClass:ProtonWrapperTests.kt$ProtonWrapperTests</ID>
    <ID>LargeClass:QueryCriteriaUtils.kt$Builder</ID>
    <ID>LargeClass:RPCClientProxyHandler.kt$RPCClientProxyHandler : InvocationHandler</ID>
    <ID>LargeClass:RPCDriver.kt$RPCDriverDSL : InternalDriverDSL</ID>
    <ID>LargeClass:RPCServer.kt$RPCServer</ID>
    <ID>LargeClass:RPCStabilityTests.kt$RPCStabilityTests</ID>
    <ID>LargeClass:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest</ID>
    <ID>LargeClass:RpcReconnectTests.kt$RpcReconnectTests</ID>
    <ID>LargeClass:SerializationOutputTests.kt$SerializationOutputTests</ID>
    <ID>LargeClass:SignedTransaction.kt$SignedTransaction : TransactionWithSignatures</ID>
    <ID>LargeClass:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager : StateMachineManagerStateMachineManagerInternal</ID>
    <ID>LargeClass:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest</ID>
    <ID>LargeClass:StartedFlowTransition.kt$StartedFlowTransition : Transition</ID>
    <ID>LargeClass:StatusTransitionsTest.kt$StatusTransitionsTest</ID>
    <ID>LargeClass:TLSAuthenticationTests.kt$TLSAuthenticationTests</ID>
    <ID>LargeClass:ToggleFieldTest.kt$ToggleFieldTest</ID>
    <ID>LargeClass:TopLevelTransition.kt$TopLevelTransition : Transition</ID>
    <ID>LargeClass:TransactionBuilder.kt$TransactionBuilder</ID>
    <ID>LargeClass:TransactionEncumbranceTests.kt$TransactionEncumbranceTests</ID>
    <ID>LargeClass:TransactionTests.kt$TransactionTests</ID>
    <ID>LargeClass:TransactionVerifierServiceInternal.kt$Verifier</ID>
    <ID>LargeClass:TutorialTestDSL.kt$TutorialTestDSL</ID>
    <ID>LargeClass:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests</ID>
    <ID>LargeClass:UniquenessProviderTests.kt$UniquenessProviderTests</ID>
    <ID>LargeClass:UniversalContract.kt$UniversalContract : Contract</ID>
    <ID>LargeClass:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests</ID>
    <ID>LargeClass:VaultFiller.kt$VaultFiller</ID>
    <ID>LargeClass:VaultQueryTests.kt$VaultQueryTests : VaultQueryTestsBaseVaultQueryParties</ID>
    <ID>LargeClass:VaultQueryTests.kt$VaultQueryTestsBase : VaultQueryParties</ID>
    <ID>LargeClass:VaultStateMigrationTest.kt$VaultStateMigrationTest</ID>
    <ID>LargeClass:VaultWithCashTest.kt$VaultWithCashTest</ID>
    <ID>LargeClass:WireTransaction.kt$WireTransaction : TraversableTransaction</ID>
    <ID>LargeClass:X509Utilities.kt$X509Utilities</ID>
    <ID>LargeClass:X509UtilitiesTest.kt$X509UtilitiesTest</ID>
    <ID>LongMethod:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$private fun clientArtemisMessageHandler(artemisMessage: ClientMessage)</ID>
    <ID>LongMethod:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$private fun onSocketConnected(connected: Boolean)</ID>
    <ID>LongMethod:AMQPBridgeTest.kt$AMQPBridgeTest$@Test fun `test acked and nacked messages`()</ID>
    <ID>LongMethod:AMQPBridgeTest.kt$AMQPBridgeTest$private fun createAMQPServer(maxMessageSize: Int = MAX_MESSAGE_SIZE): AMQPServer</ID>
    <ID>LongMethod:AMQPBridgeTest.kt$AMQPBridgeTest$private fun createArtemis(sourceQueueName: String?, crlCheckSoftFail: Boolean = true): Triple&lt;ArtemisMessagingServer, ArtemisMessagingClient, BridgeManager&gt;</ID>
    <ID>LongMethod:AMQPChannelHandler.kt$AMQPChannelHandler$override fun userEventTriggered(ctx: ChannelHandlerContext, evt: Any)</ID>
    <ID>LongMethod:AMQPChannelHandler.kt$AMQPChannelHandler$override fun write(ctx: ChannelHandlerContext, msg: Any, promise: ChannelPromise)</ID>
    <ID>LongMethod:AMQPClient.kt$AMQPClient.ClientChannelInitializer$override fun initChannel(ch: SocketChannel)</ID>
    <ID>LongMethod:AMQPExceptionsTests.kt$AMQPExceptionsTests$// However, if its a shiny new AMQPNotSerializable one, we have cool new toys, so // lets make sure those are set @Test fun catchAMQPNotSerializable()</ID>
    <ID>LongMethod:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel$ fun interpret(serializationSchemas: SerializationSchemas): Map&lt;TypeDescriptor, RemoteTypeInformation&gt;</ID>
    <ID>LongMethod:AMQPRemoteTypeModelTests.kt$AMQPRemoteTypeModelTests$@Test fun `round-trip some types through AMQP serialisations`()</ID>
    <ID>LongMethod:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme$private fun registerCustomSerializers(context: SerializationContext, factory: SerializerFactory)</ID>
    <ID>LongMethod:AMQPServer.kt$AMQPServer.ServerChannelInitializer$override fun initChannel(ch: SocketChannel)</ID>
    <ID>LongMethod:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser$// Make sure our inputs aren't designed to blow things up. private fun validate(typeString: String)</ID>
    <ID>LongMethod:ANSIProgressRenderer.kt$ANSIProgressRenderer$// Create a new tree of steps that also holds a reference to the parent of each step. This is required to uniquely identify each step // (assuming that each step label is unique at a given level). private fun transformTree(inputTree: List&lt;InputTreeStep&gt;): List&lt;ProgressStep&gt;</ID>
    <ID>LongMethod:ANSIProgressRenderer.kt$ANSIProgressRenderer$// Returns number of lines rendered. private fun renderLevel(ansi: Ansi, error: Boolean): Int</ID>
    <ID>LongMethod:ANSIProgressRenderer.kt$ANSIProgressRenderer$fun printingBody()</ID>
    <ID>LongMethod:ANSIProgressRenderer.kt$ANSIProgressRenderer$private fun renderInternal(flowProgressHandle: FlowProgressHandle&lt;*&gt;?)</ID>
    <ID>LongMethod:ANSIProgressRenderer.kt$StdoutANSIProgressRenderer$override fun setup()</ID>
    <ID>LongMethod:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$@Test fun `number of cached factories must be bounded by maxFactories`()</ID>
    <ID>LongMethod:AbstractCashSelection.kt$AbstractCashSelection$ @Suspendable fun unconsumedCashStatesForSpending(services: ServiceHub, amount: Amount&lt;Currency&gt;, onlyFromIssuerParties: Set&lt;AbstractParty&gt; = emptySet(), notary: Party? = null, lockId: UUID, withIssuerRefs: Set&lt;OpaqueBytes&gt; = emptySet()): List&lt;StateAndRef&lt;Cash.State&gt;&gt;</ID>
    <ID>LongMethod:AbstractCashSelection.kt$AbstractCashSelection$private fun attemptSpend(services: ServiceHub, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, stateAndRefs: MutableList&lt;StateAndRef&lt;Cash.State&gt;&gt;): Boolean</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$ private fun loadNotaryClusterIdentity(serviceLegalName: CordaX500Name): Pair&lt;PartyAndCertificate, KeyPair&gt;</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$ private fun obtainIdentity(): Pair&lt;PartyAndCertificate, KeyPair&gt;</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$fun &lt;T : SerializeAsToken&gt; installCordaService(serviceClass: Class&lt;T&gt;): T</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$open fun start(): S</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$private fun createAndStoreLegalIdentity(alias: String): PartyAndCertificate</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$private fun installCordaServices()</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$private fun makeCordappLoader(configuration: NodeConfiguration, versionInfo: VersionInfo): CordappLoader</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$private fun updateNodeInfo(identity: PartyAndCertificate, identityKeyPair: KeyPair, publish: Boolean): Triple&lt;MutableSet&lt;KeyPair&gt;, NodeInfoAndSigned, PartyAndCertificate?&gt;</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$private fun validateKeyStores(): X509Certificate</ID>
    <ID>LongMethod:AbstractRPCTest.kt$AbstractRPCTest$inline fun &lt;reified I : RPCOps&gt; RPCDriverDSL.testProxy( ops: I, rpcUser: User = rpcTestUser, clientConfiguration: CordaRPCClientConfiguration = CordaRPCClientConfiguration.DEFAULT, serverConfiguration: RPCServerConfiguration = RPCServerConfiguration.DEFAULT, queueDrainTimeout: Duration = 5.seconds ): TestProxy&lt;I&gt;</ID>
    <ID>LongMethod:ActionExecutorImpl.kt$ActionExecutorImpl$@Suspendable override fun executeAction(fiber: FlowFiber, action: Action)</ID>
    <ID>LongMethod:AdditionP2PAddressModeTest.kt$AdditionP2PAddressModeTest$@Test fun `runs nodes with one configured to use additionalP2PAddresses`()</ID>
    <ID>LongMethod:AdvancedExceptionDialog.kt$//Attach a stacktrace for the exception that was used in the initialization of the dialog. fun AdvancedExceptionDialog.withStacktrace() : AdvancedExceptionDialog</ID>
    <ID>LongMethod:AffinityExecutorTests.kt$AffinityExecutorTests$@Test fun `pooled executor`()</ID>
    <ID>LongMethod:AffinityExecutorTests.kt$AffinityExecutorTests$@Test fun `single threaded affinity executor runs on correct thread`()</ID>
    <ID>LongMethod:AggregatedList.kt$AggregatedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out E&gt;)</ID>
    <ID>LongMethod:AggregatedList.kt$AggregatedList$private fun addItem(addedItem: E): Int?</ID>
    <ID>LongMethod:AggregatedList.kt$AggregatedList$private fun removeItem(removedItem: E): Pair&lt;Int, AggregationGroup&lt;E, A&gt;&gt;?</ID>
    <ID>LongMethod:AggregatedListTest.kt$AggregatedListTest$@Test fun removeWorks()</ID>
    <ID>LongMethod:Amount.kt$Amount.Companion$ @JvmStatic fun parseCurrency(input: String): Amount&lt;Currency&gt;</ID>
    <ID>LongMethod:Amount.kt$AmountTransfer$ fun apply(balances: List&lt;SourceAndAmount&lt;T, P&gt;&gt;, newRef: Any? = null): List&lt;SourceAndAmount&lt;T, P&gt;&gt;</ID>
    <ID>LongMethod:AmountTests.kt$AmountTests$@Test fun `amount transfer aggregation`()</ID>
    <ID>LongMethod:AmountTests.kt$AmountTests$@Test fun `amount transfer apply`()</ID>
    <ID>LongMethod:AmountTests.kt$AmountTests$@Test fun `amount transfers equality`()</ID>
    <ID>LongMethod:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$private fun set(key: K, value: V, logWarning: Boolean, store: (K, V) -&gt; V?): Boolean</ID>
    <ID>LongMethod:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight$fun alsoWrite(_value: T)</ID>
    <ID>LongMethod:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$@Test fun `concurrent test purge between A and B`()</ID>
    <ID>LongMethod:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$@Test fun `test no purge with only a single transaction`()</ID>
    <ID>LongMethod:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$@Test fun `test purge mid-way in a single transaction`()</ID>
    <ID>LongMethod:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.TestThread$private fun doActivity()</ID>
    <ID>LongMethod:ArtemisMessagingServer.kt$ArtemisMessagingServer$// TODO: Maybe wrap [IOException] on a key store load error so that it's clearly splitting key store loading from // Artemis IO errors @Throws(IOException::class, AddressBindingException::class, KeyStoreException::class) private fun configureAndStartServer()</ID>
    <ID>LongMethod:ArtemisMessagingServer.kt$ArtemisMessagingServer$private fun createArtemisConfig()</ID>
    <ID>LongMethod:ArtemisMessagingTest.kt$ArtemisMessagingTest$@Before fun setUp()</ID>
    <ID>LongMethod:ArtemisRpcTests.kt$ArtemisRpcTests$private fun testSslCommunication(nodeSSlconfig: MutualSslConfiguration, brokerSslOptions: BrokerRpcSslOptions?, useSslForBroker: Boolean, clientSslOptions: ClientRpcSslOptions?, address: NetworkHostAndPort = ports.nextHostAndPort(), adminAddress: NetworkHostAndPort = ports.nextHostAndPort(), baseDirectory: Path = tempFolder.root.toPath() )</ID>
    <ID>LongMethod:AttachmentDemo.kt$@Suppress("DEPRECATION") // DOCSTART 1 fun recipient(rpc: CordaRPCOps, webPort: Int)</ID>
    <ID>LongMethod:AttachmentDemo.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:AttachmentDemoTest.kt$AttachmentDemoTest$// run with a 10,000,000 bytes in-memory zip file. In practice, a slightly bigger file will be used (~10,002,000 bytes). @Test fun `attachment demo using a 10MB zip file`()</ID>
    <ID>LongMethod:AttachmentDownloadServlet.kt$AttachmentDownloadServlet$@Throws(IOException::class) override fun doGet(req: HttpServletRequest, resp: HttpServletResponse)</ID>
    <ID>LongMethod:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$override fun execute(database: Database?)</ID>
    <ID>LongMethod:AttachmentsClassLoader.kt$AttachmentsClassLoader$private fun checkAttachments(attachments: List&lt;Attachment&gt;)</ID>
    <ID>LongMethod:AttachmentsClassLoader.kt$AttachmentsClassLoader.Companion$ private fun setOrDecorateURLStreamHandlerFactory()</ID>
    <ID>LongMethod:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$ fun &lt;T&gt; withAttachmentsClassloaderContext(attachments: List&lt;Attachment&gt;, params: NetworkParameters, txId: SecureHash, isAttachmentTrusted: (Attachment) -&gt; Boolean, parent: ClassLoader = ClassLoader.getSystemClassLoader(), block: (ClassLoader) -&gt; T): T</ID>
    <ID>LongMethod:AttachmentsClassLoaderSerializationTests.kt$AttachmentsClassLoaderSerializationTests$@Test fun `Can serialize and deserialize with an attachment classloader`()</ID>
    <ID>LongMethod:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Allow loading an untrusted contract jar if another attachment exists that was signed by a trusted uploader - intersection of keys match existing attachment`()</ID>
    <ID>LongMethod:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Allow loading an untrusted contract jar if another attachment exists that was signed with the same keys and uploaded by a trusted uploader`()</ID>
    <ID>LongMethod:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Attachments with inherited trust do not grant trust to attachments being loaded (no chain of trust)`()</ID>
    <ID>LongMethod:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Cannot load an untrusted contract jar if no other attachment exists that was signed with the same keys and uploaded by a trusted uploader`()</ID>
    <ID>LongMethod:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Cannot load an untrusted contract jar if no other attachment exists that was signed with the same keys`()</ID>
    <ID>LongMethod:AuthDBTests.kt$AuthDBTests$@Before override fun setUp()</ID>
    <ID>LongMethod:AzureBackend.kt$AzureBackend.Companion$fun fromContext(context: Context): AzureBackend</ID>
    <ID>LongMethod:AzureInstantiator.kt$AzureInstantiator$override fun instantiateContainer(imageId: String, portsToOpen: List&lt;Int&gt;, instanceName: String, env: Map&lt;String, String&gt;?): CompletableFuture&lt;Pair&lt;String, Map&lt;Int, Int&gt;&gt;&gt;</ID>
    <ID>LongMethod:BCCryptoServiceTests.kt$BCCryptoServiceTests$private fun createKeystore(alias: String, keyPair: KeyPair) : CertificateStoreSupplier</ID>
    <ID>LongMethod:BCCryptoServiceTests.kt$BCCryptoServiceTests$private fun generateKeyAndSignForScheme(cryptoService: BCCryptoService, signatureScheme: SignatureScheme)</ID>
    <ID>LongMethod:BFTNotaryServiceTests.kt$BFTNotaryServiceTests$@Test fun `detect double spend`()</ID>
    <ID>LongMethod:BFTNotaryServiceTests.kt$BFTNotaryServiceTests$@Test fun `transactions can be re-notarised outside their time window`()</ID>
    <ID>LongMethod:BFTNotaryServiceTests.kt$BFTNotaryServiceTests$@Test fun `transactions outside their time window are rejected`()</ID>
    <ID>LongMethod:BFTNotaryServiceTests.kt$BFTNotaryServiceTests.Companion$fun startBftClusterAndNode(clusterSize: Int, mockNet: InternalMockNetwork, exposeRaces: Boolean = false): Pair&lt;Party, TestStartedNode&gt;</ID>
    <ID>LongMethod:BFTSmart.kt$BFTSmart.Replica$protected fun commitInputStates( states: List&lt;StateRef&gt;, txId: SecureHash, callerName: CordaX500Name, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; = emptyList() )</ID>
    <ID>LongMethod:BFTSmartNotaryService.kt$BFTSmartNotaryService$private fun createMap(): AppendOnlyPersistentMap&lt;StateRef, SecureHash, CommittedState, PersistentStateRef&gt;</ID>
    <ID>LongMethod:BankOfCordaWebApi.kt$BankOfCordaWebApi$ @POST @Path("issue-asset-request") @Consumes(MediaType.APPLICATION_JSON) fun issueAssetRequest(params: IssueRequestParams): Response</ID>
    <ID>LongMethod:Base58Test.kt$Base58Test$@Test fun testDecode()</ID>
    <ID>LongMethod:BlobInspector.kt$BlobInspector$fun run(out: PrintStream): Int</ID>
    <ID>LongMethod:BootstrapperView.kt$BootstrapperView$private fun processSelectedDirectory(dir: File)</ID>
    <ID>LongMethod:BridgeControlListener.kt$BridgeControlListener$fun start()</ID>
    <ID>LongMethod:BridgeControlListener.kt$BridgeControlListener$private fun processControlMessage(msg: ClientMessage)</ID>
    <ID>LongMethod:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$// The Main authentication logic, responsible for running all the configured checks for each user type // and return the actual User and principals private fun authenticateAndAuthorise(username: String, certificates: Array&lt;X509Certificate&gt;?, password: String): Pair&lt;String, List&lt;RolePrincipal&gt;&gt;</ID>
    <ID>LongMethod:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$override fun login(): Boolean</ID>
    <ID>LongMethod:BusinessCalendar.kt$BusinessCalendar.Companion$ @JvmStatic fun createGenericSchedule(startDate: LocalDate, period: Frequency, calendar: BusinessCalendar = EMPTY, dateRollConvention: DateRollConvention = DateRollConvention.Following, noOfAdditionalPeriods: Int = Integer.MAX_VALUE, endDate: LocalDate? = null, periodOffset: Int? = null): List&lt;LocalDate&gt;</ID>
    <ID>LongMethod:Cap.kt$Cap$@Test fun `first fixing`()</ID>
    <ID>LongMethod:Cap.kt$Cap$@Test fun `second fixing`()</ID>
    <ID>LongMethod:Caplet.kt$Caplet$@Test fun fixing()</ID>
    <ID>LongMethod:Cash.kt$Cash$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:CashExitFlow.kt$CashExitFlow$ @Suspendable @Throws(CashException::class) override fun call(): AbstractCashFlow.Result</ID>
    <ID>LongMethod:CashPaymentFlow.kt$CashPaymentFlow$@Suspendable override fun call(): AbstractCashFlow.Result</ID>
    <ID>LongMethod:CashPaymentFlowTests.kt$CashPaymentFlowTests$@Test fun `pay some cash`()</ID>
    <ID>LongMethod:CashSelectionH2Impl.kt$CashSelectionH2Impl$// We are using an H2 specific means of selecting a minimum set of rows that match a request amount of coins: // 1) There is no standard SQL mechanism of calculating a cumulative total on a field and restricting row selection on the // running total of such an accumulator // 2) H2 uses session variables to perform this accumulator function: // http://www.h2database.com/html/functions.html#set // 3) H2 does not support JOIN's in FOR UPDATE (hence we are forced to execute 2 queries) override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>LongMethod:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$// This is using PostgreSQL window functions for selecting a minimum set of rows that match a request amount of coins: // 1) This may also be possible with user-defined functions (e.g. using PL/pgSQL) // 2) The window function accumulated column (`total`) does not include the current row (starts from 0) and cannot // appear in the WHERE clause, hence restricting row selection and adjusting the returned total in the outer query. // 3) Currently (version 9.6), FOR UPDATE cannot be specified with window functions override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>LongMethod:CashSelectionSQLServerImpl.kt$CashSelectionSQLServerImpl$// This is one MSSQL implementation of the query to select just enough cash states to meet the desired amount. // We select the cash states with smaller amounts first so that as the result, we minimize the numbers of // unspent cash states remaining in the vault. // // If there is not enough cash, the query will return an empty resultset, which should signal to the caller // of an exception, since the desired amount is assumed to always &gt; 0. // NOTE: The other two implementations, H2 and PostgresSQL, behave differently in this case - they return // all in the vault instead of nothing. That seems to give the caller an extra burden to verify total returned // &gt;= amount. // In addition, extra data fetched results in unnecessary I/O. // Nevertheless, if so desired, we can achieve the same by changing the last FROM clause to // FROM CTE LEFT JOIN Boundary AS B ON 1 = 1 // WHERE B.seqNo IS NULL OR CTE.seqNo &lt;= B.seqNo // // Common Table Expression and Windowed functions help make the query more readable. // Query plan does index scan on pennies_idx, which may be unavoidable due to the nature of the query. override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>LongMethod:CashSelectionTest.kt$CashSelectionTest$@Test fun `cash selection sees states added in the same transaction`()</ID>
    <ID>LongMethod:CashSelectionTest.kt$CashSelectionTest$@Test fun `don't return extra coins if the selected amount has been reached`()</ID>
    <ID>LongMethod:CashSelectionTest.kt$CashSelectionTest$@Test fun `select cash states issued by single transaction and give change`()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$// Double spend. @Test fun chainCashDoubleSpendFailsWith()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$// TODO: Optimise this so that we don't throw away and rebuild state that can be shared across tests. @Before fun setUp()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun `extended issue examples`()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun exitLedger()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun generateSimpleSpendWithChange()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun generateSpendMixedDeposits()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun generateSpendTwiceWithinATransaction()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun multiIssuer()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun multiSpend()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun testMergeSplit()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun trivial()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun trivialMismatches()</ID>
    <ID>LongMethod:CashUtils.kt$CashUtils$ @JvmStatic @JvmOverloads @Throws(InsufficientBalanceException::class) @Suspendable fun generateSpend(services: ServiceHub, tx: TransactionBuilder, payments: List&lt;PartyAndAmount&lt;Currency&gt;&gt;, ourIdentity: PartyAndCertificate, onlyFromParties: Set&lt;AbstractParty&gt; = emptySet(), anonymous: Boolean = true): Pair&lt;TransactionBuilder, List&lt;PublicKey&gt;&gt;</ID>
    <ID>LongMethod:CertRoleTests.kt$CertRoleTests$@Test fun `check cert roles verify for various cert hierarchies`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `AMPQ Client to Server connection fails when client's certificate is revoked and soft fail is disabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `AMPQ Client to Server connection fails when client's certificate is revoked and soft fail is enabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `AMPQ Client to Server connection fails when servers's certificate is revoked and soft fail is enabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `AMPQ Client to Server connection fails when servers's certificate is revoked`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `AMPQ Client to Server connection succeeds when CRL cannot be obtained and soft fail is enabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `AMPQ Client to Server connection succeeds when CRL retrieval is forbidden and soft fail is enabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `Revocation status chceck fails when the CRL distribution point is not set and soft fail is disabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `Revocation status chceck succeds when the CRL distribution point is not set and soft fail is enabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `Simple AMPQ Client to Server connection works and soft fail is disabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `Simple AMPQ Client to Server connection works and soft fail is enabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `verify CRL algorithms`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$private fun Pair&lt;CertificateStoreSupplier, MutualSslConfiguration&gt;.recreateNodeCaAndTlsCertificates(nodeCaCrlDistPoint: String, tlsCrlDistPoint: String?): X509Certificate</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$private fun createClient(targetPort: Int, crlCheckSoftFail: Boolean, nodeCrlDistPoint: String = "http://${server.hostAndPort}/crl/node.crl", tlsCrlDistPoint: String? = "http://${server.hostAndPort}/crl/empty.crl", maxMessageSize: Int = MAX_MESSAGE_SIZE): Pair&lt;AMQPClient, X509Certificate&gt;</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$private fun createServer(port: Int, name: CordaX500Name = ALICE_NAME, crlCheckSoftFail: Boolean, nodeCrlDistPoint: String = "http://${server.hostAndPort}/crl/node.crl", tlsCrlDistPoint: String? = "http://${server.hostAndPort}/crl/empty.crl", maxMessageSize: Int = MAX_MESSAGE_SIZE): Pair&lt;AMQPServer, X509Certificate&gt;</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$private fun replaceCrlDistPointCaCertificate(currentCaCert: X509Certificate, certType: CertificateType, issuerKeyPair: KeyPair, crlDistPoint: String?, crlIssuer: X500Name? = null): X509Certificate</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.Companion$fun createRevocationList(clrServer: CrlServer, signatureAlgorithm: String, caCertificate: X509Certificate, caPrivateKey: PrivateKey, endpoint: String, indirect: Boolean, vararg serialNumbers: BigInteger): X509CRL</ID>
    <ID>LongMethod:CheckpointAgent.kt$CheckpointAgent.Companion$fun parseArguments(argumentsString: String?)</ID>
    <ID>LongMethod:CheckpointAgent.kt$CheckpointHook$@JvmStatic fun readExit(input: Input, clazz: Class&lt;*&gt;, value: Any?)</ID>
    <ID>LongMethod:CheckpointAgent.kt$CheckpointHook$private fun &lt;T&gt; getArrayValue(clazz: Class&lt;T&gt;, value: Any?): String?</ID>
    <ID>LongMethod:CheckpointAgent.kt$CheckpointHook$private fun instrumentClass(clazz: CtClass): CtClass?</ID>
    <ID>LongMethod:CheckpointAgent.kt$CheckpointHook$private fun prettyStatsTree(indent: Int, statsInfo: StatsInfo, identityInfo: IdentityInfo, builder: StringBuilder)</ID>
    <ID>LongMethod:CheckpointAgent.kt$fun readTree(events: List&lt;StatsEvent&gt;, index: Int, idMap: IdentityHashMap&lt;Any, IdentityInfo&gt; = IdentityHashMap()): Pair&lt;Int, IdentityInfo&gt;</ID>
    <ID>LongMethod:CheckpointAgent.kt$fun readTrees(events: List&lt;StatsEvent&gt;, index: Int, idMap: IdentityHashMap&lt;Any, IdentityInfo&gt;): Pair&lt;Int, List&lt;Pair&lt;StatsInfo, IdentityInfo&gt;&gt;&gt;</ID>
    <ID>LongMethod:CheckpointDumper.kt$CheckpointDumper$fun dump()</ID>
    <ID>LongMethod:CheckpointDumper.kt$CheckpointDumper$fun start(tokenizableServices: List&lt;Any&gt;)</ID>
    <ID>LongMethod:CheckpointDumper.kt$CheckpointDumper$private fun Checkpoint.toJson(id: UUID, now: Instant): CheckpointJson</ID>
    <ID>LongMethod:CheckpointDumper.kt$CheckpointDumper$private fun FlowIORequest&lt;*&gt;.toSuspendedOn(suspendedTimestamp: Instant, now: Instant): SuspendedOn</ID>
    <ID>LongMethod:CheckpointVerifier.kt$CheckpointVerifier$ fun verifyCheckpointsCompatible( checkpointStorage: CheckpointStorage, currentCordapps: List&lt;Cordapp&gt;, platformVersion: Int, serviceHub: ServiceHub, tokenizableServices: List&lt;Any&gt; )</ID>
    <ID>LongMethod:ClassCarpenter.kt$ClassCarpenterImpl$ override fun build(schema: Schema): Class&lt;*&gt;</ID>
    <ID>LongMethod:ClassCarpenter.kt$ClassCarpenterImpl$ private fun validateSchema(schema: Schema)</ID>
    <ID>LongMethod:ClassCarpenter.kt$ClassCarpenterImpl$private fun ClassWriter.generateClassConstructor(schema: Schema)</ID>
    <ID>LongMethod:ClassCarpenter.kt$ClassCarpenterImpl$private fun ClassWriter.generateStaticEnumConstructor(schema: Schema)</ID>
    <ID>LongMethod:ClassCarpenter.kt$ClassCarpenterImpl$private fun generateClass(classSchema: Schema): Class&lt;*&gt;</ID>
    <ID>LongMethod:ClassCarpenterTest.kt$ClassCarpenterTest$@Test fun `generate multiple interfaces`()</ID>
    <ID>LongMethod:ClassCarpenterTest.kt$ClassCarpenterTest$@Test fun `interface implementing interface`()</ID>
    <ID>LongMethod:ClassCarpenterTest.kt$ClassCarpenterTest$@Test fun `string arrays`()</ID>
    <ID>LongMethod:ClassCarpenterTest.kt$ClassCarpenterTest$@Test fun prims()</ID>
    <ID>LongMethod:ClassCarpenterTestUtils.kt$AmqpCarpenterBase$protected fun RemoteTypeInformation.rename(from: TypeIdentifier, to: TypeIdentifier): RemoteTypeInformation</ID>
    <ID>LongMethod:ClassCarpentingTypeLoaderTests.kt$ClassCarpentingTypeLoaderTests$@Test fun `carpent some related classes`()</ID>
    <ID>LongMethod:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$@Test fun `complex ListenableFuture`()</ID>
    <ID>LongMethod:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$@Test fun `complex observables`()</ID>
    <ID>LongMethod:ClientRpcTutorial.kt$// START 6 fun generateTransactions(proxy: CordaRPCOps)</ID>
    <ID>LongMethod:ClientRpcTutorial.kt$@Suppress("DEPRECATION") fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:ClockUtilsTest.kt$ClockUtilsTest$@Test @Suspendable fun `test waiting for a deadline with multiple clock advance and incomplete Guava future on Fibers`()</ID>
    <ID>LongMethod:ClockUtilsTest.kt$ClockUtilsTest$@Test @Suspendable fun `test waiting for a deadline with multiple clock advance and incomplete JDK8 future on Fibers`()</ID>
    <ID>LongMethod:CollectSignaturesFlow.kt$CollectSignaturesFlow$@Suspendable override fun call(): SignedTransaction</ID>
    <ID>LongMethod:CollectSignaturesFlow.kt$SignTransactionFlow$@Suspendable override fun call(): SignedTransaction</ID>
    <ID>LongMethod:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests$@Test fun `successfully collects signatures when sessions are initiated with both AnonymousParty and WellKnownParty`()</ID>
    <ID>LongMethod:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkAllParamsAreOfTheSameType(old: CommandDescription, new: CommandDescription): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>LongMethod:CommandLineInterface.kt$CommandLineInterface$fun run(parsedArgs: CliParser)</ID>
    <ID>LongMethod:CommercialPaper.kt$CommercialPaper$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:CommercialPaperTests.kt$CommercialPaperTestsGeneric$@Test fun `issue move and then redeem`()</ID>
    <ID>LongMethod:CommercialPaperTests.kt$CommercialPaperTestsGeneric$@Test fun `trade lifecycle test`()</ID>
    <ID>LongMethod:CompatibilityTest.kt$CompatibilityTest$private fun assertSchemasMatch(original: Schema, reserialized: Schema)</ID>
    <ID>LongMethod:CompatibleTransactionTests.kt$CompatibleTransactionTests$@Test fun `Command visibility tests`()</ID>
    <ID>LongMethod:CompatibleTransactionTests.kt$CompatibleTransactionTests$@Test fun `FilteredTransaction constructors and compatibility`()</ID>
    <ID>LongMethod:CompatibleTransactionTests.kt$CompatibleTransactionTests$@Test fun `FilteredTransaction signer manipulation tests`()</ID>
    <ID>LongMethod:CompatibleTransactionTests.kt$CompatibleTransactionTests$@Test fun `Merkle root computations`()</ID>
    <ID>LongMethod:CompatibleTransactionTests.kt$CompatibleTransactionTests$@Test fun `WireTransaction constructors and compatibility`()</ID>
    <ID>LongMethod:CompatibleTransactionTests.kt$CompatibleTransactionTests$@Test fun `parameters hash visibility`()</ID>
    <ID>LongMethod:CompositeKeyTests.kt$CompositeKeyTests$@Test fun `Test save to keystore`()</ID>
    <ID>LongMethod:CompositeKeyTests.kt$CompositeKeyTests$@Test() fun `composite key constraints`()</ID>
    <ID>LongMethod:CompositeKeyTests.kt$CompositeKeyTests$@Test() fun `composite key validation with graph cycle detection`()</ID>
    <ID>LongMethod:ConcatenatedList.kt$ConcatenatedList$// This is where we create a listener for a *nested* list. Note that 'indexMap' doesn't need to be adjusted on any // of these changes as the indices of nested lists don't change, just their contents. private fun createListener(wrapped: WrappedObservableList&lt;A&gt;): ListChangeListener&lt;A&gt;</ID>
    <ID>LongMethod:ConcatenatedList.kt$ConcatenatedList$// This is where we handle changes to the *source* list. override fun sourceChanged(change: ListChangeListener.Change&lt;out ObservableList&lt;A&gt;&gt;)</ID>
    <ID>LongMethod:ConcatenatedListTest.kt$ConcatenatedListTest$@Test fun addWorks()</ID>
    <ID>LongMethod:ConcatenatedListTest.kt$ConcatenatedListTest$@Test fun permutationWorks()</ID>
    <ID>LongMethod:ConcatenatedListTest.kt$ConcatenatedListTest$@Test fun removeWorks()</ID>
    <ID>LongMethod:ConfigExporter.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:ConfigUtilities.kt$// For Iterables figure out the type parameter and apply the same logic as above on the individual elements. private fun Iterable&lt;*&gt;.toConfigIterable(field: Field): Iterable&lt;Any?&gt;</ID>
    <ID>LongMethod:ConfigUtilities.kt$// Problems: // - Forces you to have a primary constructor with all fields of name and type matching the configuration file structure. // - Encourages weak bean-like types. // - Cannot support a many-to-one relationship between configuration file structures and configuration domain type. This is essential for versioning of the configuration files. // - It's complicated and based on reflection, meaning problems with it are typically found at runtime. // - It doesn't support validation errors in a structured way. If something goes wrong, it throws exceptions, which doesn't support good usability practices like displaying all the errors at once. fun &lt;T : Any&gt; Config.parseAs(clazz: KClass&lt;T&gt;, onUnknownKeys: ((Set&lt;String&gt;, logger: Logger) -&gt; Unit) = UnknownConfigKeysPolicy.FAIL::handle, nestedPath: String? = null, baseDirectory: Path? = null): T</ID>
    <ID>LongMethod:ConfigUtilities.kt$// TODO Move this to KeyStoreConfigHelpers. fun MutualSslConfiguration.configureDevKeyAndTrustStores(myLegalName: CordaX500Name, signingCertificateStore: FileBasedCertificateStoreSupplier, certificatesDirectory: Path, cryptoService: CryptoService? = null)</ID>
    <ID>LongMethod:ConfigUtilities.kt$@Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN") // Reflect over the fields of the receiver and generate a value Map that can use to create Config object. private fun Any.toConfigMap(): Map&lt;String, Any&gt;</ID>
    <ID>LongMethod:ConfigUtilities.kt$ConfigHelper$fun loadConfig(baseDirectory: Path, configFile: Path = baseDirectory / "node.conf", allowMissingConfig: Boolean = false, configOverrides: Config = ConfigFactory.empty()): Config</ID>
    <ID>LongMethod:ConfigUtilities.kt$private fun Config.getCollectionValue(path: String, type: KType, onUnknownKeys: (Set&lt;String&gt;, logger: Logger) -&gt; Unit, nestedPath: String?, baseDirectory: Path?): Collection&lt;Any&gt;</ID>
    <ID>LongMethod:ConfigUtilities.kt$private fun Config.getSingleValue(path: String, type: KType, onUnknownKeys: (Set&lt;String&gt;, logger: Logger) -&gt; Unit, nestedPath: String?, baseDirectory: Path?): Any?</ID>
    <ID>LongMethod:ConnectionStateMachine.kt$ConnectionStateMachine$fun transportProcessInput(msg: ByteBuf)</ID>
    <ID>LongMethod:ConnectionStateMachine.kt$ConnectionStateMachine$fun transportProcessOutput(ctx: ChannelHandlerContext)</ID>
    <ID>LongMethod:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onConnectionFinal(event: Event)</ID>
    <ID>LongMethod:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onDelivery(event: Event)</ID>
    <ID>LongMethod:ConnectionStateMachine.kt$ConnectionStateMachine$private fun getSender(target: String): Sender</ID>
    <ID>LongMethod:ConnectionStateMachine.kt$ConnectionStateMachine$private fun transmitMessages(sender: Sender)</ID>
    <ID>LongMethod:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test @Ignore // TODO(mike): rework fun `Happy path for Hash to Signature Constraint migration`()</ID>
    <ID>LongMethod:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Attachment canBeTransitionedFrom behaves as expected`()</ID>
    <ID>LongMethod:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Fail early in the TransactionBuilder when attempting to change the hash of the HashConstraint on the spending transaction`()</ID>
    <ID>LongMethod:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Input states contract version may be lower that current contract version`()</ID>
    <ID>LongMethod:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `On contract annotated with NoConstraintPropagation there is no platform check for propagation, but the transaction builder can't use the AutomaticPlaceholderConstraint`()</ID>
    <ID>LongMethod:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Transaction validation fails, when constraints do not propagate correctly`()</ID>
    <ID>LongMethod:ContractDefinition.kt$ContractDefinition$/* @Test fun `builder problem - should not compile`() { val arr = arrange { actions { acmeCorp may { "execute" anytime { acmeCorp may { "problem" anytime { highStreetBank.gives(acmeCorp, 1.M, USD) } } } } } } assertTrue( arr is Actions ) if (arr is Actions) { assertEquals(1, arr.actions.size) } } */ @Test fun `builder problem - legal`()</ID>
    <ID>LongMethod:ContractJarTestUtils.kt$ContractJarTestUtils$fun signContractJar(jarURL: URL, copyFirst: Boolean, keyStoreDir: Path? = null, alias: String = "testAlias", pwd: String = "testPassword"): Pair&lt;Path, PublicKey&gt;</ID>
    <ID>LongMethod:ContractJarTestUtils.kt$ContractJarTestUtils$private fun createTestClass(workingDir: Path, className: String, packages: List&lt;String&gt;, versionSeed: Int = 0): Path</ID>
    <ID>LongMethod:ContractUpgradeFlowRPCTest.kt$ContractUpgradeFlowRPCTest$@Test fun `2 parties contract upgrade using RPC`()</ID>
    <ID>LongMethod:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest$@Test fun `2 parties contract upgrade`()</ID>
    <ID>LongMethod:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest$@Test fun `upgrade Cash to v2`()</ID>
    <ID>LongMethod:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$ fun resolve(services: ServicesForResolution, sigs: List&lt;TransactionSignature&gt;): ContractUpgradeLedgerTransaction</ID>
    <ID>LongMethod:ContractUpgradeUtils.kt$ContractUpgradeUtils$fun &lt;OldState : ContractState, NewState : ContractState&gt; assembleUpgradeTx( stateAndRef: StateAndRef&lt;OldState&gt;, upgradedContractClass: Class&lt;out UpgradedContract&lt;OldState, NewState&gt;&gt;, privacySalt: PrivacySalt, services: ServicesForResolution ): ContractUpgradeWireTransaction</ID>
    <ID>LongMethod:CorDappInfoServlet.kt$CorDappInfoServlet$@Throws(IOException::class) override fun doGet(req: HttpServletRequest, resp: HttpServletResponse)</ID>
    <ID>LongMethod:CorDappSerializerTests.kt$CorDappSerializerTests$@Test fun testWithWhitelistAllowed()</ID>
    <ID>LongMethod:CordaCliWrapper.kt$fun CordaCliWrapper.start(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:CordaFutureImpl.kt$ fun &lt;V&gt; Collection&lt;CordaFuture&lt;out V&gt;&gt;.transpose(): CordaFuture&lt;List&lt;V&gt;&gt;</ID>
    <ID>LongMethod:CordaFutureImplTest.kt$CordaFutureTest$@Test fun `flatMap works`()</ID>
    <ID>LongMethod:CordaFutureImplTest.kt$CordaFutureTest$@Test fun `map works`()</ID>
    <ID>LongMethod:CordaModule.kt$CordaModule$override fun setupModule(context: SetupContext)</ID>
    <ID>LongMethod:CordaPersistence.kt$CordaPersistence$private fun &lt;T&gt; inTopLevelTransaction(isolationLevel: TransactionIsolationLevel, recoverableFailureTolerance: Int, recoverAnyNestedSQLException: Boolean, statement: DatabaseTransaction.() -&gt; T): T</ID>
    <ID>LongMethod:CordaRPCClient.kt$CordaRPCClientConfiguration$ @Suppress("DEPRECATION") @JvmOverloads fun copy( connectionMaxRetryInterval: Duration = this.connectionMaxRetryInterval, minimumServerProtocolVersion: Int = this.minimumServerProtocolVersion, trackRpcCallSites: Boolean = this.trackRpcCallSites, reapInterval: Duration = this.reapInterval, observationExecutorPoolSize: Int = this.observationExecutorPoolSize, cacheConcurrencyLevel: Int = this.cacheConcurrencyLevel, connectionRetryInterval: Duration = this.connectionRetryInterval, connectionRetryIntervalMultiplier: Double = this.connectionRetryIntervalMultiplier, maxReconnectAttempts: Int = this.maxReconnectAttempts, maxFileSize: Int = this.maxFileSize, deduplicationCacheExpiry: Duration = this.deduplicationCacheExpiry ): CordaRPCClientConfiguration</ID>
    <ID>LongMethod:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$@Test fun `a client can successfully unsubscribe a reconnecting observable`()</ID>
    <ID>LongMethod:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$@Test fun `rpc client calls and returned observables continue working when the server crashes and restarts`()</ID>
    <ID>LongMethod:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$@Test fun `rpc client calls and returned observables continue working when there is failover between servers`()</ID>
    <ID>LongMethod:CordaRPCClientTest.kt$CordaRPCClientTest$@Test fun `flow initiator via RPC`()</ID>
    <ID>LongMethod:CordaRPCClientTest.kt$CordaRPCClientTest$@Test fun `shutdown command stops the node`()</ID>
    <ID>LongMethod:CordaRPCOps.kt$ @Deprecated("For automated upgrades, consider using the `gracefulShutdown` command in an SSH session instead.") fun CordaRPCOps.pendingFlowsCount(): DataFeed&lt;Int, Pair&lt;Int, Int&gt;&gt;</ID>
    <ID>LongMethod:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$override fun nodeDiagnosticInfo(): NodeDiagnosticInfo</ID>
    <ID>LongMethod:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$override fun terminate(drainPendingFlows: Boolean)</ID>
    <ID>LongMethod:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$@Test fun `cash issue accepted`()</ID>
    <ID>LongMethod:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$@Test fun `issue and move`()</ID>
    <ID>LongMethod:CordappConstraintsTests.kt$CordappConstraintsTests$@Test @Ignore // TODO(mike): rework fun `issue cash and transfer using hash to signature constraints migration`()</ID>
    <ID>LongMethod:CordappConstraintsTests.kt$CordappConstraintsTests$@Test fun `issue and consume cash using hash constraints`()</ID>
    <ID>LongMethod:CordappConstraintsTests.kt$CordappConstraintsTests$@Test fun `issue and consume cash using signature constraints`()</ID>
    <ID>LongMethod:CordappConstraintsTests.kt$CordappConstraintsTests$@Test fun `issue cash using hash and signature constraints`()</ID>
    <ID>LongMethod:CordappConstraintsTests.kt$CordappConstraintsTests$@Test fun `issue cash using signature constraints`()</ID>
    <ID>LongMethod:CordappSmokeTest.kt$CordappSmokeTest$@Test fun `FlowContent appName returns the filename of the CorDapp jar`()</ID>
    <ID>LongMethod:CordappSmokeTest.kt$CordappSmokeTest$private fun createNodeInfoWithSingleIdentity(name: CordaX500Name, nodeKeyPair: KeyPair, identityCertPublicKey: PublicKey): NodeInfo</ID>
    <ID>LongMethod:CrossCashTest.kt$CrossCashState$override fun toString(): String</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$// key generation test @Test fun `Generate key pairs`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `ECDSA K1 keyPair from entropy`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `ECDSA R1 keyPair from entropy`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `ECDSA secp256K1 deterministic key generation`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `ECDSA secp256R1 deterministic key generation`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `ECDSA secp256k1 full process keygen-sign-verify`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `ECDSA secp256r1 full process keygen-sign-verify`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `EDDSA ed25519 full process keygen-sign-verify`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `EdDSA ed25519 deterministic key generation`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `RSA full process keygen-sign-verify`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `SPHINCS-256 full process keygen-sign-verify`()</ID>
    <ID>LongMethod:CustomCordapp.kt$CustomCordapp$@VisibleForTesting internal fun packageAsJar(file: Path)</ID>
    <ID>LongMethod:CustomCordapp.kt$CustomCordapp$private fun signJar(jarFile: Path)</ID>
    <ID>LongMethod:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$ override fun register(customSerializer: CustomSerializer&lt;out Any&gt;)</ID>
    <ID>LongMethod:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$private fun doFindCustomSerializer(clazz: Class&lt;*&gt;, declaredType: Type): AMQPSerializer&lt;Any&gt;?</ID>
    <ID>LongMethod:CustomVaultQuery.kt$CustomVaultQuery.Service$fun rebalanceCurrencyReserves(): List&lt;Amount&lt;Currency&gt;&gt;</ID>
    <ID>LongMethod:DBCheckpointStorageTests.kt$DBCheckpointStorageTests$@Test fun `add checkpoint and then remove after 'restart'`()</ID>
    <ID>LongMethod:DBCheckpointStorageTests.kt$DBCheckpointStorageTests$@Test fun `add two checkpoints then remove first one`()</ID>
    <ID>LongMethod:DBCheckpointStorageTests.kt$DBCheckpointStorageTests$@Test fun `verify checkpoints compatible`()</ID>
    <ID>LongMethod:DBNetworkParametersStorageTest.kt$DBNetworkParametersStorageTest$@Before fun setUp()</ID>
    <ID>LongMethod:DBTransactionStorage.kt$DBTransactionStorage.Companion$fun createTransactionsMap(cacheFactory: NamedCacheFactory) : AppendOnlyPersistentMapBase&lt;SecureHash, TxCacheValue, DBTransaction, String&gt;</ID>
    <ID>LongMethod:DataUploadServlet.kt$DataUploadServlet$@Throws(IOException::class) override fun doPost(req: HttpServletRequest, resp: HttpServletResponse)</ID>
    <ID>LongMethod:DbMapDeadlockTest.kt$DbMapDeadlockTest$fun recreateDeadlock(hikariProperties: Properties)</ID>
    <ID>LongMethod:DbTransactionsResolver.kt$DbTransactionsResolver$@Suspendable override fun downloadDependencies()</ID>
    <ID>LongMethod:DefaultKryoCustomizer.kt$DefaultKryoCustomizer$fun customize(kryo: Kryo, publicKeySerializer: Serializer&lt;PublicKey&gt; = PublicKeySerializer): Kryo</ID>
    <ID>LongMethod:DefaultKryoCustomizer.kt$DefaultKryoCustomizer.ContractAttachmentSerializer$@Suppress("UNCHECKED_CAST") override fun read(kryo: Kryo, input: Input, type: Class&lt;ContractAttachment&gt;): ContractAttachment</ID>
    <ID>LongMethod:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$override fun transition(): TransitionResult</ID>
    <ID>LongMethod:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$private fun TransitionBuilder.confirmMessageTransition(sessionState: SessionState, message: ConfirmSessionMessage)</ID>
    <ID>LongMethod:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$private fun TransitionBuilder.endMessageTransition()</ID>
    <ID>LongMethod:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$private fun TransitionBuilder.errorMessageTransition(sessionState: SessionState, payload: ErrorSessionMessage)</ID>
    <ID>LongMethod:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$private fun TransitionBuilder.rejectMessageTransition(sessionState: SessionState, payload: RejectSessionMessage)</ID>
    <ID>LongMethod:DeserializationInput.kt$DeserializationInput$fun readObject(obj: Any, schemas: SerializationSchemas, type: Type, context: SerializationContext): Any</ID>
    <ID>LongMethod:DeserializationInput.kt$DeserializationInput.Companion$@VisibleForTesting @Throws(AMQPNoTypeNotSerializableException::class) fun &lt;T&gt; withDataBytes( byteSequence: ByteSequence, encodingWhitelist: EncodingWhitelist, task: (ByteBuffer) -&gt; T ) : T</ID>
    <ID>LongMethod:DeserializeNeedingCarpentryOfEnumsTest.kt$DeserializeNeedingCarpentryOfEnumsTest$@Test fun compositeIncludingEnums()</ID>
    <ID>LongMethod:DeserializeNeedingCarpentrySimpleTypesTest.kt$DeserializeNeedingCarpentrySimpleTypesTest$@Test fun manyTypes()</ID>
    <ID>LongMethod:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$@Test fun arrayOfTypes()</ID>
    <ID>LongMethod:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$@Test fun listOfType()</ID>
    <ID>LongMethod:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$@Test fun repeatedTypesAreRecognised()</ID>
    <ID>LongMethod:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$@Test fun verySimpleType()</ID>
    <ID>LongMethod:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$@Test fun arrayOfArrayOfIntArray()</ID>
    <ID>LongMethod:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$@Test fun testByteArray()</ID>
    <ID>LongMethod:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$@Test fun testCharArray()</ID>
    <ID>LongMethod:Disruption.kt$fun &lt;A&gt; Nodes.withDisruptions(disruptions: List&lt;DisruptionSpec&gt;, mainRandom: SplittableRandom, action: () -&gt; A): A</ID>
    <ID>LongMethod:DistributedServiceTests.kt$DistributedServiceTests$// TODO This should be in RaftNotaryServiceTests @Test fun `cluster survives if a notary is killed`()</ID>
    <ID>LongMethod:DistributedServiceTests.kt$DistributedServiceTests$private fun setup(compositeIdentity: Boolean = false, testBlock: () -&gt; Unit)</ID>
    <ID>LongMethod:DockerInstantiator.kt$DockerInstantiator$override fun instantiateContainer(imageId: String, portsToOpen: List&lt;Int&gt;, instanceName: String, env: Map&lt;String, String&gt;?): CompletableFuture&lt;Pair&lt;String, Map&lt;Int, Int&gt;&gt;&gt;</ID>
    <ID>LongMethod:Driver.kt$ fun &lt;A&gt; driver(defaultParameters: DriverParameters = DriverParameters(), dsl: DriverDSL.() -&gt; A): A</ID>
    <ID>LongMethod:Driver.kt$DriverParameters$fun copy( isDebug: Boolean, driverDirectory: Path, portAllocation: PortAllocation, debugPortAllocation: PortAllocation, systemProperties: Map&lt;String, String&gt;, useTestClock: Boolean, startNodesInProcess: Boolean, waitForAllNodesToFinish: Boolean, notarySpecs: List&lt;NotarySpec&gt;, extraCordappPackagesToScan: List&lt;String&gt;, jmxPolicy: JmxPolicy, networkParameters: NetworkParameters )</ID>
    <ID>LongMethod:Driver.kt$DriverParameters$fun copy( isDebug: Boolean, driverDirectory: Path, portAllocation: PortAllocation, debugPortAllocation: PortAllocation, systemProperties: Map&lt;String, String&gt;, useTestClock: Boolean, startNodesInProcess: Boolean, waitForAllNodesToFinish: Boolean, notarySpecs: List&lt;NotarySpec&gt;, extraCordappPackagesToScan: List&lt;String&gt;, jmxPolicy: JmxPolicy, networkParameters: NetworkParameters, cordappsForAllNodes: Set&lt;TestCordapp&gt;? )</ID>
    <ID>LongMethod:DriverDSL.kt$DriverDSL$ fun startNode( defaultParameters: NodeParameters = NodeParameters(), providedName: CordaX500Name? = defaultParameters.providedName, rpcUsers: List&lt;User&gt; = defaultParameters.rpcUsers, verifierType: VerifierType = defaultParameters.verifierType, customOverrides: Map&lt;String, Any?&gt; = defaultParameters.customOverrides, startInSameProcess: Boolean? = defaultParameters.startInSameProcess, maximumHeapSize: String = defaultParameters.maximumHeapSize, logLevelOverride: String? = defaultParameters.logLevelOverride ): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$ fun &lt;DI : DriverDSL, D : InternalDriverDSL, A&gt; genericDriver( defaultParameters: DriverParameters = DriverParameters(), driverDslWrapper: (DriverDSLImpl) -&gt; D, coerce: (D) -&gt; DI, dsl: DI.() -&gt; A ): A</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$override fun start()</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun establishRpc(config: NodeConfig, processDeathFuture: CordaFuture&lt;out Process&gt;): CordaFuture&lt;CordaRPCOps&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startNodeInternal(config: NodeConfig, webAddress: NetworkHostAndPort, localNetworkMap: LocalNetworkMap?, parameters: NodeParameters): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startNodeRegistration( providedName: CordaX500Name, rootCert: X509Certificate, networkServicesConfig: NetworkServicesConfig, customOverrides: Map&lt;String, Any?&gt; = mapOf() ): CordaFuture&lt;NodeConfig&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startNotaryIdentityGeneration(): CordaFuture&lt;List&lt;NotaryInfo&gt;&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startNotaryRegistration( spec: NotarySpec, rootCert: X509Certificate, compatibilityZone: CompatibilityZoneParams ): CordaFuture&lt;NotaryInfo&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startRaftNotaryCluster(spec: NotarySpec, localNetworkMap: LocalNetworkMap?): CordaFuture&lt;List&lt;NodeHandle&gt;&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startRegisteredNode(name: CordaX500Name, localNetworkMap: LocalNetworkMap?, parameters: NodeParameters, p2pAddress: NetworkHostAndPort = portAllocation.nextHostAndPort()): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl.Companion$private fun startInProcessNode( executorService: ScheduledExecutorService, config: NodeConfig ): CordaFuture&lt;Pair&lt;NodeWithInfo, Thread&gt;&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl.Companion$private fun startOutOfProcessNode( config: NodeConfig, quasarJarPath: String, debugPort: Int?, overriddenSystemProperties: Map&lt;String, String&gt;, maximumHeapSize: String, logLevelOverride: String?, vararg extraCmdLineFlag: String ): Process</ID>
    <ID>LongMethod:DriverDSLImpl.kt$NetworkVisibilityController.VisibilityHandle$fun listen(rpc: CordaRPCOps): CordaFuture&lt;Unit&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$fun &lt;A&gt; internalDriver( isDebug: Boolean = DriverParameters().isDebug, driverDirectory: Path = DriverParameters().driverDirectory, portAllocation: PortAllocation = DriverParameters().portAllocation, debugPortAllocation: PortAllocation = DriverParameters().debugPortAllocation, systemProperties: Map&lt;String, String&gt; = DriverParameters().systemProperties, useTestClock: Boolean = DriverParameters().useTestClock, startNodesInProcess: Boolean = DriverParameters().startNodesInProcess, extraCordappPackagesToScan: List&lt;String&gt; = DriverParameters().extraCordappPackagesToScan, waitForAllNodesToFinish: Boolean = DriverParameters().waitForAllNodesToFinish, notarySpecs: List&lt;NotarySpec&gt; = DriverParameters().notarySpecs, jmxPolicy: JmxPolicy = DriverParameters().jmxPolicy, networkParameters: NetworkParameters = DriverParameters().networkParameters, compatibilityZone: CompatibilityZoneParams? = null, notaryCustomOverrides: Map&lt;String, Any?&gt; = DriverParameters().notaryCustomOverrides, inMemoryDB: Boolean = DriverParameters().inMemoryDB, cordappsForAllNodes: Collection&lt;TestCordappInternal&gt;? = null, dsl: DriverDSLImpl.() -&gt; A ): A</ID>
    <ID>LongMethod:DummyFungibleContract.kt$DummyFungibleContract$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:DummyFungibleContract.kt$DummyFungibleContract.State$ override fun generateMappedObject(schema: MappedSchema): PersistentState</ID>
    <ID>LongMethod:DummyLinearContract.kt$DummyLinearContract.State$override fun generateMappedObject(schema: MappedSchema): PersistentState</ID>
    <ID>LongMethod:DumpHistoryOnErrorInterceptor.kt$DumpHistoryOnErrorInterceptor$@Suspendable override fun executeTransition( fiber: FlowFiber, previousState: StateMachineState, event: Event, transition: TransitionResult, actionExecutor: ActionExecutor ): Pair&lt;FlowContinuation, StateMachineState&gt;</ID>
    <ID>LongMethod:EdDSATests.kt$EdDSATests$@Test fun `PureEdDSA Ed25519 test vectors`()</ID>
    <ID>LongMethod:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$@Test fun defaultAnnotationIsAddedToEnvelopeAndDeserialised()</ID>
    <ID>LongMethod:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$@Test fun doubleRenameAnnotationIsAdded()</ID>
    <ID>LongMethod:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$@Test fun multiEnums()</ID>
    <ID>LongMethod:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$@Test fun renameAnnotationIsAdded()</ID>
    <ID>LongMethod:EnumEvolveTests.kt$EnumEvolveTests$@Test fun deserializeWithRename()</ID>
    <ID>LongMethod:EnumEvolveTests.kt$EnumEvolveTests$@Test fun multiOperations()</ID>
    <ID>LongMethod:EnumTests.kt$EnumTests$@Test fun deserialiseSimpleTest()</ID>
    <ID>LongMethod:EnumTransforms.kt$EnumTransforms$ private fun validateNoCycles(constants: Map&lt;String, Int&gt;)</ID>
    <ID>LongMethod:ErrorCodeLoggingTests.kt$ErrorCodeLoggingTests$// This is used to detect broken logging which can be caused by loggers being initialized // before the initLogging() call is made @Test fun `When logging is set to error level, there are no other levels logged after node startup`()</ID>
    <ID>LongMethod:ErrorFlowTransition.kt$ErrorFlowTransition$// Buffer error messages in Initiating sessions, return the initialised ones. private fun bufferErrorMessagesInInitiatingSessions( sessions: Map&lt;SessionId, SessionState&gt;, errorMessages: List&lt;ErrorSessionMessage&gt; ): Pair&lt;List&lt;SessionState.Initiated&gt;, Map&lt;SessionId, SessionState&gt;&gt;</ID>
    <ID>LongMethod:ErrorFlowTransition.kt$ErrorFlowTransition$override fun transition(): TransitionResult</ID>
    <ID>LongMethod:Eventually.kt$ inline fun &lt;R&gt; eventually( duration: Duration = Duration.ofSeconds(5), waitBetween: Duration = Duration.ofMillis(100), waitBefore: Duration = waitBetween, test: () -&gt; R): R</ID>
    <ID>LongMethod:EvolvabilityTests.kt$EvolvabilityTests$@Test fun addMandatoryFieldWithAltReorderedConstructor()</ID>
    <ID>LongMethod:EvolvabilityTests.kt$EvolvabilityTests$@Test fun addMandatoryFieldWithAltReorderedConstructorAndRemoval()</ID>
    <ID>LongMethod:EvolvabilityTests.kt$EvolvabilityTests$@Test fun changeSubType()</ID>
    <ID>LongMethod:EvolvabilityTests.kt$EvolvabilityTests$@Test fun moreComplexNonNullWithReorder()</ID>
    <ID>LongMethod:EvolvabilityTests.kt$EvolvabilityTests$@Test fun multiVersion()</ID>
    <ID>LongMethod:EvolvabilityTests.kt$EvolvabilityTests$@Test fun multiVersionWithRemoval()</ID>
    <ID>LongMethod:Expect.kt$ fun &lt;S, E : Any&gt; S.genericExpectEvents( isStrict: Boolean = true, stream: S.((E) -&gt; Unit) -&gt; Unit, expectCompose: () -&gt; ExpectCompose&lt;E&gt; )</ID>
    <ID>LongMethod:Expect.kt$ExpectComposeState.Companion$fun &lt;E : Any&gt; fromExpectCompose(expectCompose: ExpectCompose&lt;E&gt;): ExpectComposeState&lt;E&gt;</ID>
    <ID>LongMethod:Explorer.kt$Explorer$@Throws(IOException::class) fun open(config: NodeConfigWrapper, onExit: (NodeConfigWrapper) -&gt; Unit)</ID>
    <ID>LongMethod:ExternalIdMappingTest.kt$ExternalIdMappingTest$@Test fun `Two states can be mapped to a single externalId`()</ID>
    <ID>LongMethod:ExternalIdMappingTest.kt$ExternalIdMappingTest$@Test fun `externalIds query criteria test`()</ID>
    <ID>LongMethod:FXFwdTimeOption.kt$FXFwdTimeOption$@Test fun `maturity, bank exercise`()</ID>
    <ID>LongMethod:FXFwdTimeOption.kt$FXFwdTimeOption$@Test fun `maturity, corp exercise`()</ID>
    <ID>LongMethod:FetchDataFlow.kt$FetchDataFlow$@Suspendable @Throws(HashNotFound::class, MissingNetworkParameters::class) override fun call(): Result&lt;T&gt;</ID>
    <ID>LongMethod:FiberDeserializationCheckingInterceptor.kt$FiberDeserializationChecker$fun start(checkpointSerializationContext: CheckpointSerializationContext)</ID>
    <ID>LongMethod:FinalityFlow.kt$FinalityFlow$@Suspendable @Throws(NotaryException::class) override fun call(): SignedTransaction</ID>
    <ID>LongMethod:FlattenedList.kt$FlattenedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out ObservableValue&lt;out A&gt;&gt;)</ID>
    <ID>LongMethod:FlattenedListTest.kt$FlattenedListTest$@Test fun addWorks()</ID>
    <ID>LongMethod:FlowCheckpointVersionNodeStartupCheckTest.kt$FlowCheckpointVersionNodeStartupCheckTest$@Test fun `restart node with mismatch between suspended flow and installed CorDapps`()</ID>
    <ID>LongMethod:FlowCookbook.kt$InitiatorFlow$@Suppress("RemoveExplicitTypeArguments") @Suspendable override fun call()</ID>
    <ID>LongMethod:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$@Ignore("Some changes in startup order make this test's assumptions fail.") @Test fun `flow with send will resend on interrupted restart`()</ID>
    <ID>LongMethod:FlowFrameworkTests.kt$FlowFrameworkTests$@Test fun `FlowException thrown on other side`()</ID>
    <ID>LongMethod:FlowFrameworkTests.kt$FlowFrameworkTests$@Test fun `non-FlowException thrown on other side`()</ID>
    <ID>LongMethod:FlowFrameworkTripartyTests.kt$FlowFrameworkTripartyTests$@Test fun `FlowException thrown and there is a 3rd unrelated party flow`()</ID>
    <ID>LongMethod:FlowFrameworkTripartyTests.kt$FlowFrameworkTripartyTests$@Test fun `receiving from multiple parties`()</ID>
    <ID>LongMethod:FlowFrameworkTripartyTests.kt$FlowFrameworkTripartyTests$@Test fun `sending to multiple parties`()</ID>
    <ID>LongMethod:FlowManager.kt$NodeFlowManager$@Synchronized override fun &lt;F : FlowLogic&lt;*&gt;&gt; registerInitiatedFlow(initiator: Class&lt;out FlowLogic&lt;*&gt;&gt;, responder: Class&lt;F&gt;)</ID>
    <ID>LongMethod:FlowMessaging.kt$FlowMessagingImpl$@Suspendable override fun sendSessionMessage(destination: Destination, message: SessionMessage, deduplicationId: SenderDeduplicationId)</ID>
    <ID>LongMethod:FlowRetryTest.kt$InitiatorFlow$@Suspendable override fun call(): Any</ID>
    <ID>LongMethod:FlowStackSnapshot.kt$FlowStackSnapshotFactoryImpl$private fun extractStackSnapshotFromFiber(fiber: Fiber&lt;*&gt;, stackTrace: List&lt;StackTraceElement&gt;, flowClass: Class&lt;out FlowLogic&lt;*&gt;&gt;): FlowStackSnapshot</ID>
    <ID>LongMethod:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$@Test fun `persistFlowStackSnapshot stack traces are aligned with stack objects`()</ID>
    <ID>LongMethod:FlowStateMachineImpl.kt$FlowStateMachineImpl$ @Suspendable private fun processEventsUntilFlowIsResumed(isDbTransactionOpenOnEntry: Boolean, isDbTransactionOpenOnExit: Boolean): Any?</ID>
    <ID>LongMethod:FlowStateMachineImpl.kt$FlowStateMachineImpl$@Suspendable override fun &lt;R : Any&gt; suspend(ioRequest: FlowIORequest&lt;R&gt;, maySkipCheckpoint: Boolean): R</ID>
    <ID>LongMethod:FlowStateMachineImpl.kt$FlowStateMachineImpl$@Suspendable override fun &lt;R&gt; subFlow(subFlow: FlowLogic&lt;R&gt;): R</ID>
    <ID>LongMethod:FlowStateMachineImpl.kt$FlowStateMachineImpl$@Suspendable override fun run()</ID>
    <ID>LongMethod:FlowStateMachineImpl.kt$FlowStateMachineImpl$private fun Throwable.fillInLocalStackTrace(): Throwable</ID>
    <ID>LongMethod:FlowWatchPrintingSubscriber.kt$FlowWatchPrintingSubscriber$// TODO Add progress tracker? private fun createStateMachinesRow(smmUpdate: StateMachineUpdate)</ID>
    <ID>LongMethod:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$@Suspendable override fun call(): SecureHash</ID>
    <ID>LongMethod:FxTransactionBuildTutorial.kt$ForeignExchangeRemoteFlow$@Suspendable override fun call()</ID>
    <ID>LongMethod:FxTransactionBuildTutorialTest.kt$FxTransactionBuildTutorialTest$@Test fun `Run ForeignExchangeFlow to completion`()</ID>
    <ID>LongMethod:GenerateRpcSslCertsCli.kt$GenerateRpcSslCerts$private fun generateRpcSslCertificates(conf: NodeConfiguration)</ID>
    <ID>LongMethod:Generator.kt$Generator.Companion$ fun &lt;A&gt; frequency(generators: List&lt;Pair&lt;Double, Generator&lt;A&gt;&gt;&gt;): Generator&lt;A&gt;</ID>
    <ID>LongMethod:Generator.kt$Generator.Companion$fun &lt;A&gt; pickN(number: Int, list: List&lt;A&gt;)</ID>
    <ID>LongMethod:Generator.kt$Generator.Companion$fun &lt;A&gt; replicatePoisson(meanSize: Double, generator: Generator&lt;A&gt;, atLeastOne: Boolean = false)</ID>
    <ID>LongMethod:GenericsTests.kt$GenericsTests$// // If this doesn't blow up all is fine private fun fingerprintingDiffersStrip(state: Any)</ID>
    <ID>LongMethod:GenericsTests.kt$GenericsTests$@Test fun nestedGenericsReferencesByteArrayViaSerializedBytes()</ID>
    <ID>LongMethod:GenericsTests.kt$GenericsTests$@Test fun nestedSerializationInMultipleContextsDoesntColideGenericTypes()</ID>
    <ID>LongMethod:GenericsTests.kt$GenericsTests$@Test fun nestedSerializationOfGenerics()</ID>
    <ID>LongMethod:GenericsTests.kt$GenericsTests$@Test fun nestedSerializationWhereGenericDoesntImpactFingerprint()</ID>
    <ID>LongMethod:HTTPNetworkRegistrationService.kt$HTTPNetworkRegistrationService$@Throws(CertificateRequestException::class) override fun retrieveCertificates(requestId: String): CertificateResponse</ID>
    <ID>LongMethod:HardRestartTest.kt$HardRestartTest$@Test fun restartLongPingPongFlowRandomly()</ID>
    <ID>LongMethod:HardRestartTest.kt$HardRestartTest$@Test fun restartRecursiveFlowRandomly()</ID>
    <ID>LongMethod:HardRestartTest.kt$HardRestartTest$@Test fun restartShortPingPongFlowRandomly()</ID>
    <ID>LongMethod:HardRestartTest.kt$HardRestartTest$@Test fun softRestartLongPingPongFlowRandomly()</ID>
    <ID>LongMethod:HardRestartTest.kt$HardRestartTest.RecursiveA$@Suspendable override fun call(): String</ID>
    <ID>LongMethod:HibernateColumnConverterTests.kt$HibernateColumnConverterTests$// AbstractPartyToX500NameAsStringConverter could cause circular flush of Hibernate session because it is invoked during flush, and a // cache miss was doing a flush. This also checks that loading during flush does actually work. @Test fun `issue some cash on a notary that exists only in the database to check cache loading works in our identity column converters during flush of vault update`()</ID>
    <ID>LongMethod:HibernateConfiguration.kt$HibernateConfiguration$private fun makeSessionFactoryForSchemas(schemas: Set&lt;MappedSchema&gt;): SessionFactory</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$ @Test fun `composite or query across VaultStates, VaultLinearStates and DummyLinearStates`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$ @Test fun `query fungible states by owner party`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$ @Test fun `query fungible states by participants`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$ @Test fun `select by composite primary between VaultStates, VaultLinearStates and DummyLinearStates`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$ @Test fun `three way join by composite primary between VaultStates, VaultLinearStates and DummyLinearStates`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$ @Test fun `with sorting on attribute from common table`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$ @Test fun `with sorting on attribute from custom table`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$@Before fun setUp()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$@Test fun `calculate and order by cash balance for owner and currency`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$@Test fun `calculate cash balances`()</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$private fun collectionComparisonToPredicate(column: Path&lt;out Any?&gt;, columnPredicate: CollectionExpression&lt;*&gt;): Predicate</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$override fun parseCriteria(criteria: AttachmentQueryCriteria.AttachmentsQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun &lt;L : StatePersistable&gt; parseCriteria(criteria: QueryCriteria.VaultCustomQueryCriteria&lt;L&gt;): Collection&lt;Predicate&gt;</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: CommonQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: QueryCriteria.FungibleAssetQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: QueryCriteria.LinearStateQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: QueryCriteria.VaultQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$private fun &lt;O, R&gt; parseAggregateFunction(root: Root&lt;O&gt;, expression: CriteriaExpression.AggregateFunctionExpression&lt;O, R&gt;): Expression&lt;out Any?&gt;?</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$private fun parse(sorting: Sort)</ID>
    <ID>LongMethod:HospitalisingInterceptor.kt$HospitalisingInterceptor$@Suspendable override fun executeTransition( fiber: FlowFiber, previousState: StateMachineState, event: Event, transition: TransitionResult, actionExecutor: ActionExecutor ): Pair&lt;FlowContinuation, StateMachineState&gt;</ID>
    <ID>LongMethod:IRS.kt$IRS$@Test fun `first fixing`()</ID>
    <ID>LongMethod:IRS.kt$InterestRateSwap$ fun generateAgreement(floatingLeg: FloatingLeg, fixedLeg: FixedLeg, calculation: Calculation, common: Common, oracle: Party, notary: Party): TransactionBuilder</ID>
    <ID>LongMethod:IRS.kt$InterestRateSwap$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:IRS.kt$InterestRateSwap$private fun verifyFixCommand(inputs: List&lt;State&gt;, outputs: List&lt;State&gt;, command: CommandWithParties&lt;Commands.Refix&gt;)</ID>
    <ID>LongMethod:IRS.kt$InterestRateSwap.FloatingLeg$fun copy(floatingRatePayer: AbstractParty = this.floatingRatePayer, notional: Amount&lt;Currency&gt; = this.notional, paymentFrequency: Frequency = this.paymentFrequency, effectiveDate: LocalDate = this.effectiveDate, effectiveDateAdjustment: DateRollConvention? = this.effectiveDateAdjustment, terminationDate: LocalDate = this.terminationDate, terminationDateAdjustment: DateRollConvention? = this.terminationDateAdjustment, dayCountBasisDay: DayCountBasisDay = this.dayCountBasisDay, dayCountBasisYear: DayCountBasisYear = this.dayCountBasisYear, dayInMonth: Int = this.dayInMonth, paymentRule: PaymentRule = this.paymentRule, paymentDelay: Int = this.paymentDelay, paymentCalendar: BusinessCalendar = this.paymentCalendar, interestPeriodAdjustment: AccrualAdjustment = this.interestPeriodAdjustment, rollConvention: DateRollConvention = this.rollConvention, fixingRollConvention: DateRollConvention = this.fixingRollConvention, resetDayInMonth: Int = this.resetDayInMonth, fixingPeriod: Int = this.fixingPeriodOffset, resetRule: PaymentRule = this.resetRule, fixingsPerPayment: Frequency = this.fixingsPerPayment, fixingCalendar: BusinessCalendar = this.fixingCalendar, index: String = this.index, indexSource: String = this.indexSource, indexTenor: Tenor = this.indexTenor )</ID>
    <ID>LongMethod:IRSDemoTest.kt$IRSDemoTest$@Test fun `runs IRS demo`()</ID>
    <ID>LongMethod:IRSTests.kt$IRSTests$ @Test fun generateIRSandFixSome()</ID>
    <ID>LongMethod:IRSTests.kt$IRSTests$ fun trade(): LedgerDSL&lt;TestTransactionDSLInterpreter, TestLedgerDSLInterpreter&gt;</ID>
    <ID>LongMethod:IRSTests.kt$IRSTests$ fun tradegroups(): LedgerDSL&lt;TestTransactionDSLInterpreter, TestLedgerDSLInterpreter&gt;</ID>
    <ID>LongMethod:IRSTests.kt$IRSTests$@Test fun `ensure trade date and termination date checks are done pt1`()</ID>
    <ID>LongMethod:IRSTests.kt$IRSTests$@Test fun `ensure trade date and termination date checks are done pt2`()</ID>
    <ID>LongMethod:IRSTests.kt$IRSTests$@Test fun `expression calculation testing`()</ID>
    <ID>LongMethod:IRSTests.kt$IRSTests$@Test fun `various fixing tests`()</ID>
    <ID>LongMethod:IRSTests.kt$fun createDummyIRS(irsSelect: Int): InterestRateSwap.State</ID>
    <ID>LongMethod:IdenticonRenderer.kt$IdenticonRenderer$ private fun render(code: Int, patchSize: Double, backgroundColor: Color = Color.WHITE): Image</ID>
    <ID>LongMethod:IdenticonRenderer.kt$IdenticonRenderer$private fun drawPatch(g: GraphicsContext, x: Double, y: Double, patchIndex: Int, turn: Int, patchSize: Double, _invert: Boolean, color: PatchColor)</ID>
    <ID>LongMethod:IdentityServiceInternal.kt$IdentityServiceInternal$ @Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) fun verifyAndRegisterIdentity(trustAnchor: TrustAnchor, identity: PartyAndCertificate, isNewRandomIdentity: Boolean = false): PartyAndCertificate?</ID>
    <ID>LongMethod:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$@Test fun `it should be possible to migrate all existing identities to new hash function`()</ID>
    <ID>LongMethod:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$@Test fun `don't offer other's identities confidential identities`()</ID>
    <ID>LongMethod:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$@Test fun `sync confidential identities`()</ID>
    <ID>LongMethod:InMemoryIdentityService.kt$InMemoryIdentityService$@Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) private fun verifyAndRegisterIdentity(trustAnchor: TrustAnchor, identity: PartyAndCertificate): PartyAndCertificate?</ID>
    <ID>LongMethod:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests$ @Test fun `assert ownership`()</ID>
    <ID>LongMethod:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `fourth get outside first transaction from empty cache with invalidate in the middle returns result of third loader`()</ID>
    <ID>LongMethod:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `fourth get outside first transaction from empty cache with nested invalidate in the middle returns result of third loader`()</ID>
    <ID>LongMethod:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `other thread get outside first transaction with invalidate in the middle returns result of other thread`()</ID>
    <ID>LongMethod:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `transaction started before invalidating thread commits does not cache until after the other thread commits`()</ID>
    <ID>LongMethod:Injectors.kt$fun startPublishingFixedRateInjector( metricRegistry: MetricRegistry, parallelism: Int, overallDuration: Duration, injectionRate: Rate, queueSizeMetricName: String = "QueueSize", workDurationMetricName: String = "WorkDuration", work: () -&gt; Unit )</ID>
    <ID>LongMethod:Injectors.kt$fun startTightLoopInjector( parallelism: Int, numberOfInjections: Int, queueBound: Int, work: () -&gt; Unit )</ID>
    <ID>LongMethod:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$fun installShellExtensions(): Int</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$ @JvmStatic fun runFlowByNameFragment(nameFragment: String, inputData: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, ansiProgressRenderer: ANSIProgressRenderer, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps))</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$ @Throws(NoApplicableConstructor::class) fun &lt;T&gt; runFlowFromString(invoke: (Class&lt;out FlowLogic&lt;T&gt;&gt;, Array&lt;out Any?&gt;) -&gt; FlowProgressHandle&lt;T&gt;, inputData: String, clazz: Class&lt;out FlowLogic&lt;T&gt;&gt;, om: ObjectMapper): FlowProgressHandle&lt;T&gt;</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$// TODO Filtering on error/success when we will have some sort of flow auditing, for now it doesn't make much sense. @JvmStatic fun runStateMachinesView(out: RenderPrintWriter, rpcOps: CordaRPCOps): Any?</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$@JvmStatic fun gracefulShutdown(userSessionOut: RenderPrintWriter, cordaRPCOps: CordaRPCOps)</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$@JvmStatic fun killFlowById(id: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps))</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$@JvmStatic fun runRPCFromString(input: List&lt;String&gt;, out: RenderPrintWriter, context: InvocationContext&lt;out Any&gt;, cordaRPCOps: InternalCordaRPCOps, inputObjectMapper: ObjectMapper): Any?</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$fun runLocalShell(onExit: () -&gt; Unit = {})</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$fun startShell(configuration: ShellConfiguration, classLoader: ClassLoader? = null, standalone: Boolean = false)</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$private fun &lt;T&gt; getMatchingConstructorParamsAndTypes(parser: StringToMethodCallParser&lt;FlowLogic&lt;T&gt;&gt;, inputData: String, clazz: Class&lt;out FlowLogic&lt;T&gt;&gt;) : List&lt;Pair&lt;String, Type&gt;&gt;</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$private fun _startShell(configuration: ShellConfiguration, classLoader: ClassLoader? = null)</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell.ShellLifecycle$fun start(config: Properties, localUserName: String = "", localUserPassword: String = ""): Shell</ID>
    <ID>LongMethod:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$@Ignore @Test fun `ssh run flows via standalone shell over ssl to node`()</ID>
    <ID>LongMethod:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$@Ignore @Test fun `ssh runs flows via standalone shell`()</ID>
    <ID>LongMethod:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$@Test fun `dumpCheckpoints creates zip with json file for suspended flow`()</ID>
    <ID>LongMethod:InteractiveShellTest.kt$InteractiveShellTest$@Test fun niceTypeNamesInErrors()</ID>
    <ID>LongMethod:InternalMockNetwork.kt$InternalMockNetwork$private fun createNodeImpl(parameters: InternalMockNodeParameters, nodeFactory: (MockNodeArgs) -&gt; MockNode, start: Boolean): MockNode</ID>
    <ID>LongMethod:InternalMockNetwork.kt$private fun mockNodeConfiguration(certificatesDirectory: Path): NodeConfiguration</ID>
    <ID>LongMethod:InternalMockNetworkTests.kt$InternalMockNetworkTests$ @Test fun `skip unhandled messages`()</ID>
    <ID>LongMethod:InternalUtils.kt$// TODO: Add inline back when a new Kotlin version is released and check if the java.lang.VerifyError // returns in the IRSSimulationTest. If not, commit the inline back. @DeleteForDJVM fun &lt;T&gt; logElapsedTime(label: String, logger: Logger? = null, body: () -&gt; T): T</ID>
    <ID>LongMethod:Interpolators.kt$CubicSplineInterpolator$private fun computeSplineFunction(): SplineFunction</ID>
    <ID>LongMethod:IssueCash.kt$IssueCash$@JvmStatic fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:JacksonSupport.kt$JacksonSupport.X509CertificateSerializer$override fun serialize(value: X509Certificate, gen: JsonGenerator, serializers: SerializerProvider)</ID>
    <ID>LongMethod:JacksonSupportTest.kt$JacksonSupportTest$@Test fun TransactionSignature()</ID>
    <ID>LongMethod:JacksonSupportTest.kt$JacksonSupportTest$@Test fun `NodeInfo serialization`()</ID>
    <ID>LongMethod:JacksonSupportTest.kt$JacksonSupportTest$@Test fun `SignedTransaction (WireTransaction)`()</ID>
    <ID>LongMethod:JarScanningCordappLoader.kt$JarScanningCordappLoader$private fun RestrictedScanResult.toCordapp(url: RestrictedURL): CordappImpl</ID>
    <ID>LongMethod:JarScanningCordappLoader.kt$JarScanningCordappLoader$private fun loadCordapps(): List&lt;CordappImpl&gt;</ID>
    <ID>LongMethod:JarScanningCordappLoader.kt$JarScanningCordappLoader$private fun parseCordappInfo(manifest: Manifest?, defaultName: String): Cordapp.Info</ID>
    <ID>LongMethod:JarSignatureTestUtils.kt$JarSignatureTestUtils$fun Path.addManifest(fileName: String, vararg entry: Pair&lt;Attributes.Name, String&gt;)</ID>
    <ID>LongMethod:KMSUtils.kt$ fun freshCertificate(identityService: IdentityService, subjectPublicKey: PublicKey, issuer: PartyAndCertificate, issuerSigner: ContentSigner): PartyAndCertificate</ID>
    <ID>LongMethod:KeyStoreGenerator.kt$KeyStoreGenerator$fun writeKeyStore(output: OutputStream, alias: String, password: CharArray)</ID>
    <ID>LongMethod:KotlinIntegrationTestingTutorial.kt$KotlinIntegrationTestingTutorial$@Test fun `alice bob cash exchange example`()</ID>
    <ID>LongMethod:Kryo.kt$ImmutableClassSerializer$override fun read(kryo: Kryo, input: Input, type: Class&lt;T&gt;): T</ID>
    <ID>LongMethod:Kryo.kt$ImmutableClassSerializer$override fun write(kryo: Kryo, output: Output, obj: T)</ID>
    <ID>LongMethod:KryoCheckpointSerializer.kt$KryoCheckpointSerializer$override fun &lt;T : Any&gt; deserialize(byteSequence: ByteSequence, clazz: Class&lt;T&gt;, context: CheckpointSerializationContext): T</ID>
    <ID>LongMethod:KryoStreamsTest.kt$KryoStreamsTest$@Test fun `ByteBufferOutputStream works`()</ID>
    <ID>LongMethod:KryoTests.kt$KryoTests$@Test fun rxSubscriptionsAreNotSerialized()</ID>
    <ID>LongMethod:LargeTransactionsTest.kt$LargeTransactionsTest$@Test fun checkCanSendLargeTransactions()</ID>
    <ID>LongMethod:LedgerDSLInterpreter.kt$Verifies$ fun failsWith(expectedMessage: String?): EnforceVerifyOrFail</ID>
    <ID>LongMethod:LedgerTransaction.kt$LedgerTransaction$ private fun createLtxForVerification(): LedgerTransaction</ID>
    <ID>LongMethod:LedgerTransaction.kt$LedgerTransaction$@Deprecated("LedgerTransactions should not be created directly, use WireTransaction.toLedgerTransaction instead.") fun copy(inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt; = this.inputs, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt; = this.outputs, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt; = this.commands, attachments: List&lt;Attachment&gt; = this.attachments, id: SecureHash = this.id, notary: Party? = this.notary, timeWindow: TimeWindow? = this.timeWindow, privacySalt: PrivacySalt = this.privacySalt, networkParameters: NetworkParameters? = this.networkParameters ): LedgerTransaction</ID>
    <ID>LongMethod:LedgerTransaction.kt$LedgerTransaction$@Deprecated("LedgerTransactions should not be created directly, use WireTransaction.toLedgerTransaction instead.") fun copy(inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt ): LedgerTransaction</ID>
    <ID>LongMethod:LedgerTransaction.kt$LedgerTransaction.Companion$@CordaInternal internal fun create( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt, networkParameters: NetworkParameters, references: List&lt;StateAndRef&lt;ContractState&gt;&gt;, componentGroups: List&lt;ComponentGroup&gt;? = null, serializedInputs: List&lt;SerializedStateAndRef&gt;? = null, serializedReferences: List&lt;SerializedStateAndRef&gt;? = null, isAttachmentTrusted: (Attachment) -&gt; Boolean ): LedgerTransaction</ID>
    <ID>LongMethod:LeftOuterJoinedMapTest.kt$LeftOuterJoinedMapTest$// TODO perhaps these are too brittle because they test indices that are not stable. Use Expect dsl? @Test fun addWorks()</ID>
    <ID>LongMethod:LeftOuterJoinedMapTest.kt$LeftOuterJoinedMapTest$@Test fun removeWorks()</ID>
    <ID>LongMethod:LoadTest.kt$ fun runLoadTests(configuration: LoadTestConfiguration, tests: List&lt;Pair&lt;LoadTest&lt;*, *&gt;, LoadTest.RunParameters&gt;&gt;)</ID>
    <ID>LongMethod:LoadTest.kt$LoadTest$fun run(nodes: Nodes, parameters: RunParameters, random: SplittableRandom)</ID>
    <ID>LongMethod:LocalTypeInformationBuilder.kt$ private fun constructorForDeserialization(type: Type): KFunction&lt;Any&gt;?</ID>
    <ID>LongMethod:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$ private fun buildNonAtomic(rawType: Class&lt;*&gt;, type: Type, typeIdentifier: TypeIdentifier, typeParameterInformation: List&lt;LocalTypeInformation&gt;): LocalTypeInformation</ID>
    <ID>LongMethod:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private fun buildForClass(type: Class&lt;*&gt;, typeIdentifier: TypeIdentifier, isOpaque: Boolean): LocalTypeInformation</ID>
    <ID>LongMethod:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private fun buildForParameterised( rawType: Class&lt;*&gt;, type: ParameterizedType, typeIdentifier: TypeIdentifier.Parameterised, isOpaque: Boolean): LocalTypeInformation</ID>
    <ID>LongMethod:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private fun makeConstructorPairedProperty(constructorIndex: Int, descriptor: PropertyDescriptor, constructorInformation: LocalConstructorInformation): LocalPropertyInformation?</ID>
    <ID>LongMethod:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private fun missingMandatoryConstructorProperties( constructorInformation: LocalConstructorInformation, properties: Map&lt;PropertyName, LocalPropertyInformation&gt; ): List&lt;LocalConstructorParameterInformation&gt;</ID>
    <ID>LongMethod:LocalTypeModelTests.kt$LocalTypeModelTests$@Test fun `Primitives and collections`()</ID>
    <ID>LongMethod:LocalTypeModelTests.kt$LocalTypeModelTests$@Test fun `transitive types are non-composable creates non-composable type`()</ID>
    <ID>LongMethod:LoginView.kt$LoginView$tailrec fun login(): NodeMonitorModel?</ID>
    <ID>LongMethod:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$@Test fun `login with invalid certificate chain`()</ID>
    <ID>LongMethod:Main.kt$Main$override fun start(stage: Stage)</ID>
    <ID>LongMethod:Main.kt$Node$fun avalancheLoop()</ID>
    <ID>LongMethod:Main.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:Main.kt$private fun runLoadTest(loadTestConfiguration: LoadTestConfiguration)</ID>
    <ID>LongMethod:Main.kt$private fun runStabilityTest(loadTestConfiguration: LoadTestConfiguration)</ID>
    <ID>LongMethod:MappedList.kt$MappedList$override fun sourceChanged(change: ListChangeListener.Change&lt;out A&gt;)</ID>
    <ID>LongMethod:MatcherTests.kt$MatcherTests$@Test fun `nested items indent`()</ID>
    <ID>LongMethod:MaxTransactionSizeTests.kt$MaxTransactionSizeTests$@Test fun `check transaction will fail when exceed max transaction size limit`()</ID>
    <ID>LongMethod:MerkleTransaction.kt$FilteredTransaction.Companion$fun &lt;T : Any&gt; filter(t: T, componentGroupIndex: Int, internalIndex: Int)</ID>
    <ID>LongMethod:MockAttachmentStorage.kt$MockAttachmentStorage$private fun importAttachmentInternal(jar: InputStream, uploader: String, contractClassNames: List&lt;ContractClassName&gt;? = null, attachmentId: AttachmentId? = null, signers: List&lt;PublicKey&gt; = emptyList()): AttachmentId</ID>
    <ID>LongMethod:MockCordappProvider.kt$MockCordappProvider$fun addMockCordapp( contractClassName: ContractClassName, attachments: MockAttachmentStorage, contractHash: AttachmentId? = null, signers: List&lt;PublicKey&gt; = emptyList(), jarManifestAttributes: Map&lt;String,String&gt; = emptyMap() ): AttachmentId</ID>
    <ID>LongMethod:MockNodeMessagingService.kt$MockNodeMessagingService$ fun start(network: InMemoryMessagingNetwork, manuallyPumped: Boolean, id: Int, notaryService: PartyAndCertificate?)</ID>
    <ID>LongMethod:MockNodeMessagingService.kt$MockNodeMessagingService$ private fun getNextQueue(q: LinkedBlockingQueue&lt;InMemoryMessagingNetwork.MessageTransfer&gt;, block: Boolean): Pair&lt;InMemoryMessagingNetwork.MessageTransfer, List&lt;Handler&gt;&gt;?</ID>
    <ID>LongMethod:MockNodeMessagingService.kt$MockNodeMessagingService$private fun pumpReceiveInternal(block: Boolean): InMemoryMessagingNetwork.MessageTransfer?</ID>
    <ID>LongMethod:MockServices.kt$MockServices.Companion$ @JvmStatic @JvmOverloads fun makeTestDatabaseAndMockServices(cordappPackages: List&lt;String&gt;, identityService: IdentityService, initialIdentity: TestIdentity, networkParameters: NetworkParameters = testNetworkParameters(modifiedTime = Instant.MIN), vararg moreKeys: KeyPair): Pair&lt;CordaPersistence, MockServices&gt;</ID>
    <ID>LongMethod:MockServices.kt$MockServices.Companion$ @JvmStatic @JvmOverloads fun makeTestDatabaseAndPersistentServices( cordappPackages: List&lt;String&gt;, initialIdentity: TestIdentity, networkParameters: NetworkParameters = testNetworkParameters(modifiedTime = Instant.MIN), moreKeys: Set&lt;KeyPair&gt;, moreIdentities: Set&lt;PartyAndCertificate&gt; ): Pair&lt;CordaPersistence, MockServices&gt;</ID>
    <ID>LongMethod:MultiMemberCompositeSchemaToClassCarpenterTests.kt$MultiMemberCompositeSchemaToClassCarpenterTests$@Test fun calculatedValues()</ID>
    <ID>LongMethod:NetParams.kt$NetParamsSigner$override fun runProgram(): Int</ID>
    <ID>LongMethod:Network.kt$Network$private fun NodeInfo.render(): MapViewComponents</ID>
    <ID>LongMethod:Network.kt$Network$private fun NodeInfo.renderButton(mapLabel: Label): Button</ID>
    <ID>LongMethod:Network.kt$Network$private fun fireBulletBetweenNodes(senderParty: Party, destParty: Party, startType: String, endType: String)</ID>
    <ID>LongMethod:NetworkBootstrapper.kt$NetworkBootstrapper$private fun bootstrap( directory: Path, cordappJars: List&lt;Path&gt;, copyCordapps: CopyCordapps, fromCordform: Boolean, networkParametersOverrides: NetworkParametersOverrides = NetworkParametersOverrides() )</ID>
    <ID>LongMethod:NetworkBootstrapper.kt$NetworkBootstrapper$private fun createNodeDirectoriesIfNeeded(directory: Path, fromCordform: Boolean): Boolean</ID>
    <ID>LongMethod:NetworkBootstrapper.kt$NetworkBootstrapper$private fun installNetworkParameters( notaryInfos: List&lt;NotaryInfo&gt;, whitelist: Map&lt;String, List&lt;AttachmentId&gt;&gt;, existingNetParams: NetworkParameters?, nodeDirs: List&lt;Path&gt;, networkParametersOverrides: NetworkParametersOverrides ): NetworkParameters</ID>
    <ID>LongMethod:NetworkBootstrapper.kt$NetworkBootstrapper$private fun loadNetworkParameters(nodeDirs: List&lt;Path&gt;): NetworkParameters?</ID>
    <ID>LongMethod:NetworkBootstrapper.kt$NetworkBootstrapper.Companion$private fun generateNodeInfo(nodeDir: Path): Path</ID>
    <ID>LongMethod:NetworkBuilder.kt$NetworkBuilderImpl$override fun build(): CompletableFuture&lt;Pair&lt;List&lt;NodeInstance&gt;, Context&gt;&gt;</ID>
    <ID>LongMethod:NetworkMapServer.kt$NetworkMapServer.InMemoryNetworkMapService$@POST @Path("publish") @Consumes(MediaType.APPLICATION_OCTET_STREAM) fun publishNodeInfo(input: InputStream): Response</ID>
    <ID>LongMethod:NetworkMapTest.kt$NetworkMapTest$@Test fun `parameters update test`()</ID>
    <ID>LongMethod:NetworkMapTest.kt$NetworkMapTest$@Test fun `test node heartbeat`()</ID>
    <ID>LongMethod:NetworkMapTest.kt$NetworkMapTest.Companion$@JvmStatic @Parameterized.Parameters(name = "{0}") fun runParams()</ID>
    <ID>LongMethod:NetworkMapUpdater.kt$NetworkMapUpdater$fun start(trustRoot: X509Certificate, currentParametersHash: SecureHash, ourNodeInfo: SignedNodeInfo, networkParameters: NetworkParameters, keyManagementService: KeyManagementService, networkParameterAcceptanceSettings: NetworkParameterAcceptanceSettings)</ID>
    <ID>LongMethod:NetworkMapUpdater.kt$NetworkMapUpdater$fun updateNetworkMapCache(): Duration</ID>
    <ID>LongMethod:NetworkMapUpdater.kt$NetworkMapUpdater$private fun handleUpdateNetworkParameters(networkMapClient: NetworkMapClient, update: ParametersUpdate)</ID>
    <ID>LongMethod:NetworkMapUpdater.kt$NetworkMapUpdater$private fun watchForNodeInfoFiles(): Subscription</ID>
    <ID>LongMethod:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `auto acceptance checks are correct`()</ID>
    <ID>LongMethod:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `emit new parameters update info on parameters update from network map`()</ID>
    <ID>LongMethod:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `process add node updates from network map, with additional node infos from dir`()</ID>
    <ID>LongMethod:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `process remove node updates from network map, with additional node infos from dir`()</ID>
    <ID>LongMethod:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `remove node from filesystem deletes it from network map cache`()</ID>
    <ID>LongMethod:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `remove node info file, but node in network map server`()</ID>
    <ID>LongMethod:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$private fun createMockNetworkMapCache(): NetworkMapCacheInternal</ID>
    <ID>LongMethod:NetworkParameterOverridesSpec.kt$NetworkParameterOverridesSpec.PackageOwnershipSpec$override fun parseValid(configuration: Config): Validated&lt;PackageOwner, Configuration.Validation.Error&gt;</ID>
    <ID>LongMethod:NetworkParameters.kt$NetworkParameters$ fun copy(minimumPlatformVersion: Int = this.minimumPlatformVersion, notaries: List&lt;NotaryInfo&gt; = this.notaries, maxMessageSize: Int = this.maxMessageSize, maxTransactionSize: Int = this.maxTransactionSize, modifiedTime: Instant = this.modifiedTime, epoch: Int = this.epoch, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = this.whitelistedContractImplementations ): NetworkParameters</ID>
    <ID>LongMethod:NetworkParameters.kt$NetworkParameters$ fun copy(minimumPlatformVersion: Int = this.minimumPlatformVersion, notaries: List&lt;NotaryInfo&gt; = this.notaries, maxMessageSize: Int = this.maxMessageSize, maxTransactionSize: Int = this.maxTransactionSize, modifiedTime: Instant = this.modifiedTime, epoch: Int = this.epoch, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = this.whitelistedContractImplementations, eventHorizon: Duration = this.eventHorizon ): NetworkParameters</ID>
    <ID>LongMethod:NetworkParametersReader.kt$NetworkParametersReader$fun read(): NetworkParametersAndSigned</ID>
    <ID>LongMethod:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$// This function is resolving and signing WireTransaction with special parameters. private fun TransactionBuilder.toSignedTransactionWithParameters(parameters: NetworkParameters?, services: ServiceHub): SignedTransaction</ID>
    <ID>LongMethod:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$@Test fun `incorrect triangle of transactions`()</ID>
    <ID>LongMethod:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$@Test fun `request parameters that are not in the storage`()</ID>
    <ID>LongMethod:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$@Test fun `transaction chain out of order parameters`()</ID>
    <ID>LongMethod:NetworkParametersTest.kt$NetworkParametersTest$@Test fun `package ownership checks are correct`()</ID>
    <ID>LongMethod:NetworkParametersTest.kt$NetworkParametersTest$@Test fun `that we can copy while preserving the event horizon`()</ID>
    <ID>LongMethod:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ fun generateKeysAndRegister()</ID>
    <ID>LongMethod:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ private fun pollServerForCertificates(requestId: String): List&lt;X509Certificate&gt;</ID>
    <ID>LongMethod:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ private fun submitOrResumeCertificateSigningRequest(publicKey: PublicKey, contentSigner: ContentSigner): String</ID>
    <ID>LongMethod:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$private fun validateCertificates(registeringPublicKey: PublicKey, certificates: List&lt;X509Certificate&gt;)</ID>
    <ID>LongMethod:NetworkRegistrationHelper.kt$NodeRegistrationHelper$private fun createSSLKeystore(nodeCaPublicKey: PublicKey, nodeCaContentSigner: ContentSigner, nodeCaCertificateChain: List&lt;X509Certificate&gt;, tlsCertCrlIssuer: X500Name?)</ID>
    <ID>LongMethod:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$@Test fun `successful registration`()</ID>
    <ID>LongMethod:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$private fun createRegistrationHelper(certRole: CertRole = CertRole.NODE_CA, dynamicResponse: (JcaPKCS10CertificationRequest) -&gt; List&lt;X509Certificate&gt;): NetworkRegistrationHelper</ID>
    <ID>LongMethod:NewTransaction.kt$NewTransaction$fun show(window: Window)</ID>
    <ID>LongMethod:NewTransaction.kt$NewTransaction$private fun newTransactionDialog(window: Window)</ID>
    <ID>LongMethod:Node.kt$Node$ override fun startDatabase()</ID>
    <ID>LongMethod:Node.kt$Node$ private fun tryDetectIfNotPublicHost(host: String): String?</ID>
    <ID>LongMethod:Node.kt$Node$override fun startMessagingService(rpcOps: RPCOps, nodeInfo: NodeInfo, myNotaryIdentity: PartyAndCertificate?, networkParameters: NetworkParameters)</ID>
    <ID>LongMethod:NodeAttachmentService.kt$NodeAttachmentService$// TODO: PLT-147: The attachment should be randomised to prevent brute force guessing and thus privacy leaks. private fun import(jar: InputStream, uploader: String?, filename: String?): AttachmentId</ID>
    <ID>LongMethod:NodeAttachmentService.kt$NodeAttachmentService.Companion$// Just iterate over the entries with verification enabled: should be good enough to catch mistakes. // Note that JarInputStream won't throw any kind of error at all if the file stream is in fact not // a ZIP! It'll just pretend it's an empty archive, which is kind of stupid but that's how it works. // So we have to check to ensure we found at least one item. // // For signed Jars add additional checks to close security holes left by the default jarSigner verifier: // - All entries listed in the Manifest are in the JAR file. // - No extra files in the JAR that were not listed in the Manifest. // Together with the check that all entries need to be signed by the same signers that is performed when the signers are read, // it should close any possibility of foul play. internal fun checkIsAValidJAR(stream: InputStream)</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `The strict JAR verification function fails signed JARs with removed or extra files that are valid according to the usual jarsigner`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `all non contract jars not trusted if all are uploaded by non trusted uploaders`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `attachments can be queried by providing a intersection of signers using an EQUAL statement - EQUAL containing a single public key`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `attachments can be queried by providing a intersection of signers using an EQUAL statement - EQUAL containing multiple public keys`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `contract class, versioning and signing metadata can be used to search`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `corrupt entry throws exception`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `development mode - retrieve latest versions of signed contracts - multiple versions of same version id exist in store`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `jar not trusted if different key but same contract`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `jar trusted if the signing keys are an intersection of an existing trusted jar's signers`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `jar with inherited trust does not grant trust to other jars (no chain of trust)`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `missing is not cached`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `non contract jar trusted if trusted jar with same key present`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `sorting and compound conditions work`()</ID>
    <ID>LongMethod:NodeBasedTest.kt$NodeBasedTest$@JvmOverloads fun startNode(legalName: CordaX500Name, platformVersion: Int = PLATFORM_VERSION, rpcUsers: List&lt;User&gt; = emptyList(), configOverrides: Map&lt;String, Any&gt; = emptyMap(), flowManager: FlowManager = NodeFlowManager(FlowOverrideConfig())): NodeWithInfo</ID>
    <ID>LongMethod:NodeConfigTest.kt$NodeConfigTest$@Test fun `reading node configuration allows systemProperties and custom`()</ID>
    <ID>LongMethod:NodeConfigTest.kt$NodeConfigTest$@Test fun `reading node configuration`()</ID>
    <ID>LongMethod:NodeConfigTest.kt$NodeConfigTest$@Test fun `reading webserver configuration`()</ID>
    <ID>LongMethod:NodeConfigTest.kt$NodeConfigTest$private fun createConfig( legalName: CordaX500Name = CordaX500Name(organisation = "Unknown", locality = "Nowhere", country = "GB"), p2pPort: Int = -1, rpcPort: Int = -1, rpcAdminPort: Int = -1, webPort: Int = -1, h2port: Int = -1, notary: NotaryService?, users: List&lt;User&gt; = listOf(user("guest")), issuableCurrencies: List&lt;String&gt; = emptyList() ): NodeConfig</ID>
    <ID>LongMethod:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$private fun testNodeConfiguration(): NodeConfigurationImpl</ID>
    <ID>LongMethod:NodeController.kt$NodeController$ fun validate(nodeData: NodeData): NodeConfigWrapper?</ID>
    <ID>LongMethod:NodeController.kt$NodeController$fun runCorda(pty: R3Pty, config: NodeConfigWrapper): Boolean</ID>
    <ID>LongMethod:NodeControllerTest.kt$NodeControllerTest$private fun createConfig( organisation: String = "Unknown", p2pPort: Int = 0, rpcPort: Int = 0, rpcAdminPort: Int = 0, webPort: Int = 0, h2port: Int = 0, notary: NotaryService? = null, users: List&lt;User&gt; = listOf(user("guest")) ): NodeConfigWrapper</ID>
    <ID>LongMethod:NodeCopier.kt$NodeCopier$fun copyBootstrapperFiles(nodeCacheDir: File)</ID>
    <ID>LongMethod:NodeCopier.kt$NodeCopier$internal fun mergeConfigs(configInCacheDir: File, rpcSettings: ConfigValue, sshSettings: ConfigValue, mergeMode: Mode = Mode.NODE)</ID>
    <ID>LongMethod:NodeInfo.kt$NodeInfoSigner$override fun runProgram(): Int</ID>
    <ID>LongMethod:NodeInfoFilesCopier.kt$NodeInfoFilesCopier$private fun atomicCopy(source: Path, destination: Path)</ID>
    <ID>LongMethod:NodeInfoWatcher.kt$NodeInfoWatcher$private fun pollDirectory(): List&lt;NodeInfoUpdate&gt;</ID>
    <ID>LongMethod:NodeKeystoreCheckTest.kt$NodeKeystoreCheckTest$@Test fun `node should throw exception if cert path does not chain to the trust root`()</ID>
    <ID>LongMethod:NodeMonitorModel.kt$NodeMonitorModel$ fun register(nodeHostAndPort: NetworkHostAndPort, username: String, password: String)</ID>
    <ID>LongMethod:NodeNamedCache.kt$DefaultNamedCacheFactory$open protected fun &lt;K, V&gt; configuredForNamed(caffeine: Caffeine&lt;K, V&gt;, name: String): Caffeine&lt;K, V&gt;</ID>
    <ID>LongMethod:NodePerformanceTests.kt$NodePerformanceTests$@Test fun `empty flow per second`()</ID>
    <ID>LongMethod:NodePerformanceTests.kt$NodePerformanceTests$@Test fun `self pay rate`()</ID>
    <ID>LongMethod:NodeProcess.kt$NodeProcess.Factory$private fun waitForNode(process: Process, config: NodeConfig, client: CordaRPCClient)</ID>
    <ID>LongMethod:NodeRPCTests.kt$NodeRPCTests$@Test fun `run nodeDiagnosticInfo`()</ID>
    <ID>LongMethod:NodeSchedulerService.kt$NodeSchedulerService$private fun getFlow(scheduledState: ScheduledStateRef): FlowLogic&lt;*&gt;?</ID>
    <ID>LongMethod:NodeSchedulerService.kt$NodeSchedulerService$private fun runLoopFunction()</ID>
    <ID>LongMethod:NodeSchedulerService.kt$NodeSchedulerService.Companion$ // We should try to make the Clock used in our code injectable (for tests etc) and to use the extension below // to wait in our code, rather than &lt;code&gt;Thread.sleep()&lt;/code&gt; or other time-based pauses. @Suspendable @VisibleForTesting // We specify full classpath on SettableFuture to differentiate it from the Quasar class of the same name fun awaitWithDeadline(clock: CordaClock, deadline: Instant, future: Future&lt;*&gt; = GuavaSettableFuture.create&lt;Any&gt;()): Boolean</ID>
    <ID>LongMethod:NodeSchedulerServiceTest.kt$NodeSchedulerPersistenceTest$@Ignore("Temporarily") @Test fun `test that if schedule is updated then the flow is invoked on the correct schedule`()</ID>
    <ID>LongMethod:NodeSchedulerServiceTest.kt$NodeSchedulerPersistenceTest$@Test fun `test that schedule is persisted`()</ID>
    <ID>LongMethod:NodeStartup.kt$NodeStartup$fun initialiseAndRun(cmdLineOptions: SharedNodeCmdLineOptions, afterNodeInitialisation: RunAfterNodeInitialisation, requireCertificates: Boolean = false): Int</ID>
    <ID>LongMethod:NodeStartup.kt$NodeStartup$fun isNodeRunningAt(baseDirectory: Path): Boolean</ID>
    <ID>LongMethod:NodeStartup.kt$NodeStartup$fun startNode(node: Node, startTime: Long)</ID>
    <ID>LongMethod:NodeStartup.kt$NodeStartup$open fun drawBanner(versionInfo: VersionInfo)</ID>
    <ID>LongMethod:NodeStartup.kt$NodeStartup$private fun lookupMachineNameAndMaybeWarn(): String</ID>
    <ID>LongMethod:NodeStartup.kt$NodeStartup$protected open fun logStartupInfo(versionInfo: VersionInfo, conf: NodeConfiguration)</ID>
    <ID>LongMethod:NodeStartup.kt$NodeStartupCli$override fun runProgram(): Int</ID>
    <ID>LongMethod:NodeStartup.kt$fun CliWrapperBase.initLogging(baseDirectory: Path): Boolean</ID>
    <ID>LongMethod:NodeStatePersistenceTests.kt$NodeStatePersistenceTests$@Test fun `persistent state survives node restart without reinitialising database schema`()</ID>
    <ID>LongMethod:NodeStatePersistenceTests.kt$NodeStatePersistenceTests$@Test fun `persistent state survives node restart`()</ID>
    <ID>LongMethod:NodeTabView.kt$NodeTabView$private fun Pane.nearestCityField(): ComboBox&lt;WorldMapLocation&gt;</ID>
    <ID>LongMethod:NodeTabView.kt$NodeTabView$private fun launchNode(config: NodeConfigWrapper)</ID>
    <ID>LongMethod:NodeTerminalView.kt$NodeTerminalView$/* * We only want to run one web server for each node. * So disable the "launch" button when we have * launched the web server and only reenable it when * the web server has exited. */ private fun configureWebButton(config: NodeConfigWrapper)</ID>
    <ID>LongMethod:NodeTerminalView.kt$NodeTerminalView$@Suppress("DEPRECATION") private fun initialise(config: NodeConfigWrapper, ops: CordaRPCOps)</ID>
    <ID>LongMethod:NodeTerminalView.kt$NodeTerminalView$fun open(config: NodeConfigWrapper, onExit: (Int) -&gt; Unit)</ID>
    <ID>LongMethod:NodeTest.kt$NodeTest$@Test fun `Node can start with multiple keypairs for its identity`()</ID>
    <ID>LongMethod:NodeTest.kt$NodeTest$@Test fun `clear network map cache works`()</ID>
    <ID>LongMethod:NodeTest.kt$NodeTest$private fun createConfig(nodeName: CordaX500Name): NodeConfigurationImpl</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$ private fun bootstrapContractStateTypes()</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$@Suspendable @Throws(StatesNotAvailableException::class) override fun &lt;T : FungibleState&lt;*&gt;&gt; tryLockFungibleStatesForSpending( lockId: UUID, eligibleStatesQuery: QueryCriteria, amount: Amount&lt;*&gt;, contractStateType: Class&lt;out T&gt; ): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$@Throws(StatesNotAvailableException::class) override fun softLockReserve(lockId: UUID, stateRefs: NonEmptySet&lt;StateRef&gt;)</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$@Throws(VaultQueryException::class) private fun &lt;T : ContractState&gt; _queryBy(criteria: QueryCriteria, paging_: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;, skipPagingChecks: Boolean): Vault.Page&lt;T&gt;</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$fun makeUpdate(tx: WireTransaction): Vault.Update&lt;ContractState&gt;?</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$fun resolveAndMakeUpdate(tx: CoreTransaction): Vault.Update&lt;ContractState&gt;?</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$override fun softLockRelease(lockId: UUID, stateRefs: NonEmptySet&lt;StateRef&gt;?)</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$private fun processAndNotify(updates: List&lt;Vault.Update&lt;ContractState&gt;&gt;, previouslySeen: Boolean)</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$private fun recordUpdate(update: Vault.Update&lt;ContractState&gt;, previouslySeen: Boolean): Vault.Update&lt;ContractState&gt;</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$private fun saveStates(session: Session, states: Map&lt;StateRef, StateAndRef&lt;ContractState&gt;&gt;)</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$// TODO: Unit test linear state relevancy checks @Test fun `correct updates are generated for general transactions`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test @Ignore fun `trackByCriteria filters updates and snapshots`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `attempt to lock states already soft locked by me`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `correct updates are generated when changing notaries`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `fungible state selection test`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `lock additional states to some already soft locked by me`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `soft locking attempt concurrent reserve`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `soft locking partial reserve states fails`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `states soft locking query granularity`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `states soft locking reserve and release`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `unconsumedStatesForSpending from specific issuer party and refs`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun addNoteToTransaction()</ID>
    <ID>LongMethod:NodeWebServer.kt$NodeWebServer$private fun buildServletContextHandler(localRpc: CordaRPCOps): ServletContextHandler</ID>
    <ID>LongMethod:NodeWebServer.kt$NodeWebServer$private fun initWebServer(localRpc: CordaRPCOps): Server</ID>
    <ID>LongMethod:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$override fun verifyTransaction(requestPayload: NotarisationPayload)</ID>
    <ID>LongMethod:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests$@Test fun `should re-sign a transaction with an expired time-window`()</ID>
    <ID>LongMethod:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests$@Test fun `should report conflict when inputs are reused across transactions`()</ID>
    <ID>LongMethod:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests$@Test fun `should sign identical transaction multiple times (notarisation is idempotent)`()</ID>
    <ID>LongMethod:NotaryChangeTests.kt$NotaryChangeTests$@Test fun `should not break encumbrance links`()</ID>
    <ID>LongMethod:NotaryCopier.kt$NotaryCopier$private fun copyNotaryBootstrapperFiles(nodeCacheDir: File)</ID>
    <ID>LongMethod:NotaryServiceFlow.kt$NotaryServiceFlow$@Suspendable override fun call(): Void?</ID>
    <ID>LongMethod:NotaryWhitelistTests.kt$NotaryWhitelistTests$ @Test fun `can't perform a regular transaction on a de-listed notary`()</ID>
    <ID>LongMethod:NotaryWhitelistTests.kt$NotaryWhitelistTests$@Test fun `should reject transaction when a dependency does not contain notary in whitelist`()</ID>
    <ID>LongMethod:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$// obtains the data and calculates the grid of results private fun calculate(runner: CalculationRunner)</ID>
    <ID>LongMethod:OGSwapPricingExample.kt$SwapPricingExample$// Create a fixed vs libor 3m swap private fun createStub3mFixedVsLibor3mSwap(): Trade</ID>
    <ID>LongMethod:OGSwapPricingExample.kt$SwapPricingExample$// Create an overnight averaged vs libor 3m swap with spread private fun createOvernightAveragedWithSpreadVsLibor3mSwap(): Trade</ID>
    <ID>LongMethod:OGSwapPricingExample.kt$SwapPricingExample$// create a libor 3m vs libor 6m basis swap with spread private fun createBasisLibor3mVsLibor6mWithSpreadSwap(): Trade</ID>
    <ID>LongMethod:OGSwapPricingExample.kt$SwapPricingExample$// obtains the data and calculates the grid of results private fun calculate(runner: CalculationRunner)</ID>
    <ID>LongMethod:OGTrade.kt$OGTrade$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:ObjectDiffer.kt$ObjectDiffer$fun diff(a: Any?, b: Any?): DiffTree?</ID>
    <ID>LongMethod:ObjectSerializer.kt$EvolutionObjectSerializer.Companion$fun make(localTypeInformation: LocalTypeInformation.Composable, remoteTypeInformation: RemoteTypeInformation.Composable, constructor: LocalConstructorInformation, properties: Map&lt;String, LocalPropertyInformation&gt;, classLoader: ClassLoader, mustPreserveData: Boolean): EvolutionObjectSerializer</ID>
    <ID>LongMethod:ObjectSerializer.kt$ObjectSerializer.Companion$private fun makeForComposable(typeInformation: LocalTypeInformation.Composable, typeNotation: CompositeType, typeDescriptor: Symbol, factory: LocalSerializerFactory): ComposableObjectSerializer</ID>
    <ID>LongMethod:Obligation.kt$ fun &lt;P : AbstractParty, T : Any&gt; sumAmountsDue(balances: Map&lt;Pair&lt;P, P&gt;, Amount&lt;T&gt;&gt;): Map&lt;P, Long&gt;</ID>
    <ID>LongMethod:Obligation.kt$Obligation$ @VisibleForTesting private fun verifySetLifecycleCommand(inputs: List&lt;FungibleAsset&lt;Terms&lt;P&gt;&gt;&gt;, outputs: List&lt;FungibleAsset&lt;Terms&lt;P&gt;&gt;&gt;, tx: LedgerTransaction, setLifecycleCommand: CommandWithParties&lt;Commands.SetLifecycle&gt;)</ID>
    <ID>LongMethod:Obligation.kt$Obligation$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:Obligation.kt$Obligation$private fun verifyNetCommand(tx: LedgerTransaction, command: CommandWithParties&lt;NetCommand&gt;)</ID>
    <ID>LongMethod:Obligation.kt$Obligation$private fun verifySettleCommand(tx: LedgerTransaction, inputs: List&lt;FungibleAsset&lt;Terms&lt;P&gt;&gt;&gt;, outputs: List&lt;FungibleAsset&lt;Terms&lt;P&gt;&gt;&gt;, command: CommandWithParties&lt;Commands.Settle&lt;P&gt;&gt;, groupingKey: Issued&lt;Terms&lt;P&gt;&gt;)</ID>
    <ID>LongMethod:ObligationTests.kt$ObligationTests$ @Test fun `generate set lifecycle`()</ID>
    <ID>LongMethod:ObligationTests.kt$ObligationTests$@Test fun `cash settlement`()</ID>
    <ID>LongMethod:ObligationTests.kt$ObligationTests$@Test fun `close-out netting`()</ID>
    <ID>LongMethod:ObligationTests.kt$ObligationTests$@Test fun `commodity settlement`()</ID>
    <ID>LongMethod:ObligationTests.kt$ObligationTests$@Test fun `exit single product obligation`()</ID>
    <ID>LongMethod:ObligationTests.kt$ObligationTests$@Test fun `issue debt`()</ID>
    <ID>LongMethod:ObligationTests.kt$ObligationTests$@Test fun `nettability of settlement contracts`()</ID>
    <ID>LongMethod:ObligationTests.kt$ObligationTests$@Test fun `payment default`()</ID>
    <ID>LongMethod:ObligationTests.kt$ObligationTests$@Test fun `payment netting`()</ID>
    <ID>LongMethod:ObligationTests.kt$ObligationTests$@Test fun multiIssuer()</ID>
    <ID>LongMethod:ObligationTests.kt$ObligationTests$@Test fun testMergeSplit()</ID>
    <ID>LongMethod:ObligationTests.kt$ObligationTests$@Test fun trivial()</ID>
    <ID>LongMethod:ObligationTests.kt$ObligationTests$@Test fun trivialMismatches()</ID>
    <ID>LongMethod:ObligationUtils.kt$ObligationUtils$ @JvmStatic fun &lt;P : Any&gt; generateSetLifecycle(tx: TransactionBuilder, statesAndRefs: List&lt;StateAndRef&lt;Obligation.State&lt;P&gt;&gt;&gt;, lifecycle: Obligation.Lifecycle, notary: Party)</ID>
    <ID>LongMethod:ObligationUtils.kt$ObligationUtils$ @JvmStatic fun &lt;P : Any&gt; generateSettle(tx: TransactionBuilder, statesAndRefs: Iterable&lt;StateAndRef&lt;Obligation.State&lt;P&gt;&gt;&gt;, assetStatesAndRefs: Iterable&lt;StateAndRef&lt;FungibleAsset&lt;P&gt;&gt;&gt;, moveCommand: MoveCommand, notary: Party)</ID>
    <ID>LongMethod:ObligationUtils.kt$ObligationUtils$@JvmStatic fun &lt;P : Any&gt; generatePaymentNetting(tx: TransactionBuilder, issued: Issued&lt;Obligation.Terms&lt;P&gt;&gt;, notary: Party, vararg inputs: StateAndRef&lt;Obligation.State&lt;P&gt;&gt;)</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `bufferUntilDatabaseCommit delays until transaction closed repeatable`()</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `bufferUntilDatabaseCommit delays until transaction closed`()</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `bufferUntilDatabaseCommit propagates error if transaction rolled back`()</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `bufferUntilDatabaseCommit swallows if transaction rolled back`()</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `check wrapping in db tx restarts if we pass through zero subscribers`()</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `combine tee and bufferUntilDatabaseCommit`()</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `new transaction open in observer when wrapped`()</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `tee correctly copies observations to multiple observers`()</ID>
    <ID>LongMethod:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow$@Suspendable override fun call(): SignedTransaction</ID>
    <ID>LongMethod:OnLedgerAsset.kt$OnLedgerAsset.Companion$ @Throws(InsufficientBalanceException::class) @JvmStatic fun &lt;S : FungibleAsset&lt;T&gt;, T : Any&gt; generateExit(tx: TransactionBuilder, amountIssued: Amount&lt;Issued&lt;T&gt;&gt;, assetStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData, generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData): Set&lt;PublicKey&gt;</ID>
    <ID>LongMethod:OnLedgerAsset.kt$OnLedgerAsset.Companion$ @Throws(InsufficientBalanceException::class) @JvmStatic fun &lt;S : FungibleAsset&lt;T&gt;, T : Any&gt; generateSpend(tx: TransactionBuilder, payments: List&lt;PartyAndAmount&lt;T&gt;&gt;, acceptableStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData): Pair&lt;TransactionBuilder, List&lt;PublicKey&gt;&gt;</ID>
    <ID>LongMethod:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$@Test fun `flows draining mode suspends consumption of initial session messages`()</ID>
    <ID>LongMethod:P2PMessagingClient.kt$P2PMessagingClient$ fun run()</ID>
    <ID>LongMethod:P2PMessagingClient.kt$P2PMessagingClient$ fun start(myIdentity: PublicKey, serviceIdentity: PublicKey?, maxMessageSize: Int, advertisedAddress: NetworkHostAndPort = serverAddress)</ID>
    <ID>LongMethod:P2PMessagingClient.kt$P2PMessagingClient$ fun stop()</ID>
    <ID>LongMethod:P2PMessagingClient.kt$P2PMessagingClient$private fun InnerState.registerBridgeControl(session: ClientSession, inboxes: List&lt;String&gt;)</ID>
    <ID>LongMethod:P2PMessagingClient.kt$P2PMessagingConsumer$override fun start()</ID>
    <ID>LongMethod:ParametersUtilities.kt$@JvmOverloads fun testNetworkParameters( notaries: List&lt;NotaryInfo&gt; = emptyList(), minimumPlatformVersion: Int = 1, modifiedTime: Instant = Instant.now(), maxMessageSize: Int = 10485760, // TODO: Make this configurable and consistence across driver, bootstrapper, demobench and NetworkMapServer maxTransactionSize: Int = maxMessageSize * 50, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = emptyMap(), epoch: Int = 1, eventHorizon: Duration = 30.days, packageOwnership: Map&lt;String, PublicKey&gt; = emptyMap() ): NetworkParameters</ID>
    <ID>LongMethod:PartialMerkleTree.kt$PartialMerkleTree.Companion$ private fun buildPartialTree( root: MerkleTree, includeHashes: List&lt;SecureHash&gt;, usedHashes: MutableList&lt;SecureHash&gt; ): Pair&lt;Boolean, PartialTree&gt;</ID>
    <ID>LongMethod:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$@Before fun init()</ID>
    <ID>LongMethod:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$@Test fun `Find leaf index`()</ID>
    <ID>LongMethod:PartyAndCertificate.kt$PartyAndCertificate$ fun verify(trustAnchor: TrustAnchor): PKIXCertPathValidatorResult</ID>
    <ID>LongMethod:PersistentIdentityMigrationNewTableTest.kt$PersistentIdentityMigrationNewTableTest$@Before fun setUp()</ID>
    <ID>LongMethod:PersistentIdentityMigrationNewTableTest.kt$PersistentIdentityMigrationNewTableTest$private fun addNetworkParameters()</ID>
    <ID>LongMethod:PersistentIdentityService.kt$PersistentIdentityService$ @Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) private fun verifyAndRegisterIdentity(trustAnchor: TrustAnchor, identity: PartyAndCertificate): PartyAndCertificate?</ID>
    <ID>LongMethod:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests$ @Test fun `assert ownership`()</ID>
    <ID>LongMethod:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$override fun addNodes(nodes: List&lt;NodeInfo&gt;)</ID>
    <ID>LongMethod:PersistentScheduledFlowRepositoryTest.kt$PersistentScheduledFlowRepositoryTest$@Test fun `test that item is rescheduled`()</ID>
    <ID>LongMethod:PersistentStateServiceTests.kt$PersistentStateServiceTests$@Test fun `test child objects are persisted`()</ID>
    <ID>LongMethod:PersistentUniquenessProvider.kt$PersistentUniquenessProvider$private fun commitOne( states: List&lt;StateRef&gt;, txId: SecureHash, callerIdentity: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; )</ID>
    <ID>LongMethod:PersistentUniquenessProvider.kt$PersistentUniquenessProvider.Companion$fun createMap(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;StateRef, SecureHash, CommittedState, PersistentStateRef&gt;</ID>
    <ID>LongMethod:PortAllocationTest.kt$PortAllocationTest$@Test(timeout = 120_000) fun `should support multiprocess port allocation`()</ID>
    <ID>LongMethod:PortfolioApi.kt$PortfolioApi$ @GET @Path("{party}/portfolio/history/aggregated") @Produces(MediaType.APPLICATION_JSON) fun getPartyPortfolioHistoryAggregated(@PathParam("party") partyName: String): Response</ID>
    <ID>LongMethod:PortfolioApi.kt$PortfolioApi$ @GET @Path("{party}/trades") @Produces(MediaType.APPLICATION_JSON) fun getPartyTrades(@PathParam("party") partyName: String): Response</ID>
    <ID>LongMethod:PortfolioApiUtils.kt$PortfolioApiUtils$fun createTradeView(rpc: CordaRPCOps, state: IRSState): TradeView</ID>
    <ID>LongMethod:PortfolioApiUtils.kt$PortfolioApiUtils$fun createValuations(state: PortfolioState, portfolio: Portfolio): ValuationsView</ID>
    <ID>LongMethod:PortfolioSwap.kt$PortfolioSwap$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:PrettyPrint.kt$PrettyPrint$fun prettyPrint(arr: Arrangement)</ID>
    <ID>LongMethod:PrettyPrint.kt$PrettyPrint$fun prettyPrintBigDecimal(per: Perceivable&lt;BigDecimal&gt;)</ID>
    <ID>LongMethod:PrettyPrint.kt$PrettyPrint$fun prettyPrintBoolean(per: Perceivable&lt;Boolean&gt;)</ID>
    <ID>LongMethod:ProcessUtilities.kt$ProcessUtilities$fun startJavaProcess( className: String, arguments: List&lt;String&gt;, classPath: List&lt;String&gt; = defaultClassPath, workingDirectory: Path? = null, jdwpPort: Int? = null, extraJvmArguments: List&lt;String&gt; = emptyList(), maximumHeapSize: String? = null ): Process</ID>
    <ID>LongMethod:ProfileController.kt$ProfileController$ @Throws(IOException::class) fun openProfile(): List&lt;InstallConfig&gt;?</ID>
    <ID>LongMethod:ProfileController.kt$ProfileController$ @Throws(IOException::class) fun saveProfile(): Boolean</ID>
    <ID>LongMethod:ProgressTrackerTest.kt$ProgressTrackerTest$@Test fun `steps tree index counts children steps`()</ID>
    <ID>LongMethod:ProgressTrackerTest.kt$ProgressTrackerTest$@Test fun `steps tree index counts two levels of children steps`()</ID>
    <ID>LongMethod:ProgressTrackerTest.kt$ProgressTrackerTest$@Test fun `structure changes are pushed down when progress trackers are added`()</ID>
    <ID>LongMethod:ProgressTrackerTest.kt$ProgressTrackerTest$@Test fun `structure changes are pushed down when progress trackers are removed`()</ID>
    <ID>LongMethod:PropertyDescriptor.kt$PropertyDescriptor$ fun validate()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$@Test fun `Client Failover for multiple IP`()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$@Test fun `Message sent from AMQP to non-existent Artemis inbox is rejected and client disconnects`()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$@Test fun `Send a message from AMQP to Artemis inbox`()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$@Test fun `Send a message larger then maxMessageSize from AMQP to Artemis inbox`()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$@Test fun `Simple AMPQ Client to Server`()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$@Test fun `Test AMQP Client with invalid root certificate`()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$@Test fun `shared AMQPClient threadpool tests`()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$private fun createArtemisServerAndClient(maxMessageSize: Int = MAX_MESSAGE_SIZE): Pair&lt;ArtemisMessagingServer, ArtemisMessagingClient&gt;</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$private fun createClient(maxMessageSize: Int = MAX_MESSAGE_SIZE): AMQPClient</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$private fun createServer(port: Int, name: CordaX500Name = ALICE_NAME, maxMessageSize: Int = MAX_MESSAGE_SIZE, crlCheckSoftFail: Boolean = true): AMQPServer</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$private fun createSharedThreadsClient(sharedEventGroup: EventLoopGroup, id: Int, maxMessageSize: Int = MAX_MESSAGE_SIZE): AMQPClient</ID>
    <ID>LongMethod:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$ override operator fun get(key: PublicKey): KeyOwningIdentity?</ID>
    <ID>LongMethod:QuasarInstrumentationHook.kt$ fun recordUsedInstrumentedCallStack()</ID>
    <ID>LongMethod:QuasarInstrumentationHook.kt$PackageTree$ fun toGlobs(excludeTree: PackageTree): List&lt;Glob&gt;</ID>
    <ID>LongMethod:QuasarInstrumentationHook.kt$QuasarInstrumentationHook$override fun transform( loader: ClassLoader?, className: String, classBeingRedefined: Class&lt;*&gt;?, protectionDomain: ProtectionDomain?, classfileBuffer: ByteArray ): ByteArray</ID>
    <ID>LongMethod:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$@JvmStatic fun premain(argumentsString: String?, instrumentation: Instrumentation)</ID>
    <ID>LongMethod:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$fun copy( participants: List&lt;AbstractParty&gt;? = this.participants, owner: List&lt;AbstractParty&gt;? = this.owner, quantity: ColumnPredicate&lt;Long&gt;? = this.quantity, issuer: List&lt;AbstractParty&gt;? = this.issuer, issuerRef: List&lt;OpaqueBytes&gt;? = this.issuerRef, status: Vault.StateStatus = this.status, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = this.contractStateTypes ): FungibleAssetQueryCriteria</ID>
    <ID>LongMethod:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun copy( status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, stateRefs: List&lt;StateRef&gt;? = null, notary: List&lt;AbstractParty&gt;? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: Vault.RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt; = emptySet(), constraints: Set&lt;Vault.ConstraintInfo&gt; = emptySet(), participants: List&lt;AbstractParty&gt;? = null ): VaultQueryCriteria</ID>
    <ID>LongMethod:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun copy( status: Vault.StateStatus = this.status, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = this.contractStateTypes, stateRefs: List&lt;StateRef&gt;? = this.stateRefs, notary: List&lt;AbstractParty&gt;? = this.notary, softLockingCondition: SoftLockingCondition? = this.softLockingCondition, timeCondition: TimeCondition? = this.timeCondition ): VaultQueryCriteria</ID>
    <ID>LongMethod:RPCApi.kt$RPCApi.ClientToServer.Companion$fun fromClientMessage(message: ClientMessage): ClientToServer</ID>
    <ID>LongMethod:RPCApi.kt$RPCApi.ServerToClient.Companion$fun fromClientMessage(context: SerializationContext, message: ClientMessage): ServerToClient</ID>
    <ID>LongMethod:RPCClient.kt$RPCClient$fun start( rpcOpsClass: Class&lt;I&gt;, username: String, password: String, externalTrace: Trace? = null, impersonatedActor: Actor? = null, targetLegalIdentity: CordaX500Name? = null ): RPCConnection&lt;I&gt;</ID>
    <ID>LongMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$ fun start()</ID>
    <ID>LongMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$ private fun close(notify: Boolean = true)</ID>
    <ID>LongMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$// The handler for Artemis messages. private fun artemisMessageHandler(message: ClientMessage)</ID>
    <ID>LongMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$// This is the general function that transforms a client side RPC to internal Artemis messages. override fun invoke(proxy: Any, method: Method, arguments: Array&lt;out Any?&gt;?): Any?</ID>
    <ID>LongMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$private fun attemptReconnect()</ID>
    <ID>LongMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$private fun cleanUpOnConnectionLoss()</ID>
    <ID>LongMethod:RPCDriver.kt$RPCDriverDSL$fun &lt;I : RPCOps&gt; startRpcServerWithBrokerRunning( rpcUser: User = rpcTestUser, nodeLegalName: CordaX500Name = fakeNodeLegalName, configuration: RPCServerConfiguration = RPCServerConfiguration.DEFAULT, ops: I, brokerHandle: RpcBrokerHandle, queueDrainTimeout: Duration = 5.seconds ): RpcServerHandle</ID>
    <ID>LongMethod:RPCDriver.kt$RPCDriverDSL$fun startRpcBroker( serverName: String = "driver-rpc-server-${random63BitValue()}", rpcUser: User = rpcTestUser, maxFileSize: Int = MAX_MESSAGE_SIZE, maxBufferedBytesPerClient: Long = 10L * MAX_MESSAGE_SIZE, customPort: NetworkHostAndPort? = null ): CordaFuture&lt;RpcBrokerHandle&gt;</ID>
    <ID>LongMethod:RPCDriver.kt$RPCDriverDSL$private fun startInVmRpcBroker( rpcUser: User = rpcTestUser, maxFileSize: Int = MAX_MESSAGE_SIZE, maxBufferedBytesPerClient: Long = 10L * MAX_MESSAGE_SIZE ): CordaFuture&lt;RpcBrokerHandle&gt;</ID>
    <ID>LongMethod:RPCDriver.kt$RPCDriverDSL.Companion$private fun ConfigurationImpl.configureCommonSettings(maxFileSize: Int, maxBufferedBytesPerClient: Long)</ID>
    <ID>LongMethod:RPCDriver.kt$RandomRpcUser.Companion$@JvmStatic fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:RPCDriver.kt$fun &lt;A&gt; rpcDriver( isDebug: Boolean = false, driverDirectory: Path = Paths.get("build") / "rpc-driver" / getTimestampAsDirectoryName(), portAllocation: PortAllocation = globalPortAllocation, debugPortAllocation: PortAllocation = globalDebugPortAllocation, systemProperties: Map&lt;String, String&gt; = emptyMap(), useTestClock: Boolean = false, startNodesInProcess: Boolean = false, waitForNodesToFinish: Boolean = false, extraCordappPackagesToScan: List&lt;String&gt; = emptyList(), notarySpecs: List&lt;NotarySpec&gt; = emptyList(), externalTrace: Trace? = null, @Suppress("DEPRECATION") jmxPolicy: JmxPolicy = JmxPolicy(), networkParameters: NetworkParameters = testNetworkParameters(), notaryCustomOverrides: Map&lt;String, Any?&gt; = emptyMap(), inMemoryDB: Boolean = true, cordappsForAllNodes: Collection&lt;TestCordappInternal&gt;? = null, dsl: RPCDriverDSL.() -&gt; A ): A</ID>
    <ID>LongMethod:RPCPerformanceTests.kt$RPCPerformanceTests$ @Test fun `consumption rate`()</ID>
    <ID>LongMethod:RPCPerformanceTests.kt$RPCPerformanceTests$@Test fun `big messages`()</ID>
    <ID>LongMethod:RPCPerformanceTests.kt$RPCPerformanceTests$@Test fun `measure Megabytes per second for simple RPCs`()</ID>
    <ID>LongMethod:RPCPermissionsTests.kt$RPCPermissionsTests$@Test fun `joe user can call different methods matching to a wildcard`()</ID>
    <ID>LongMethod:RPCSecurityManagerImpl.kt$RPCPermissionResolver$override fun resolvePermission(representation: String): Permission</ID>
    <ID>LongMethod:RPCSecurityManagerImpl.kt$RPCSecurityManagerImpl.Companion$// Build internal Shiro securityManager instance private fun buildImpl(config: AuthServiceConfig, cacheFactory: NamedCacheFactory): DefaultSecurityManager</ID>
    <ID>LongMethod:RPCSecurityManagerTest.kt$RPCSecurityManagerTest$private fun checkUserActions(permissions: Set&lt;String&gt;, permitted: Set&lt;List&lt;String&gt;&gt;)</ID>
    <ID>LongMethod:RPCServer.kt$RPCServer$fun start(activeMqServerControl: ActiveMQServerControl)</ID>
    <ID>LongMethod:RPCServer.kt$RPCServer$private fun clientArtemisMessageHandler(artemisMessage: ClientMessage)</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$ @Test fun `server cleans up queues after disconnected clients`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test @Ignore // TODO: This is ignored because Artemis slow consumers are broken. I'm not deleting it in case we can get the feature fixed. fun `slow consumers are kicked`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test fun `3 server failover`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test fun `client cleans up leaked observables`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test fun `client reconnects to rebooted server`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test fun `connection failover fails, rpc calls throw`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test fun `deduplication in the client`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test fun `deduplication in the server`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test fun `observables error when connection breaks`()</ID>
    <ID>LongMethod:RaftNotaryServiceTests.kt$RaftNotaryServiceTests$@Test fun `detect double spend`()</ID>
    <ID>LongMethod:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$ fun commitTransaction(raftCommit: Commit&lt;Commands.CommitTransaction&gt;): NotaryError?</ID>
    <ID>LongMethod:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$ override fun install(reader: SnapshotReader)</ID>
    <ID>LongMethod:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$ override fun snapshot(writer: SnapshotWriter)</ID>
    <ID>LongMethod:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$@Test fun `transactions can be re-notarised outside their time window`()</ID>
    <ID>LongMethod:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$private fun createReplica(myAddress: NetworkHostAndPort, clusterAddress: NetworkHostAndPort? = null): CompletableFuture&lt;Member&gt;</ID>
    <ID>LongMethod:RaftUniquenessProvider.kt$RaftUniquenessProvider$fun start()</ID>
    <ID>LongMethod:RaftUniquenessProvider.kt$RaftUniquenessProvider$override fun commit( states: List&lt;StateRef&gt;, txId: SecureHash, callerIdentity: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; ): CordaFuture&lt;UniquenessProvider.Result&gt;</ID>
    <ID>LongMethod:RaftUniquenessProvider.kt$RaftUniquenessProvider.Companion$fun createMap(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;StateRef, Pair&lt;Long, SecureHash&gt;, CommittedState, String&gt;</ID>
    <ID>LongMethod:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest$@Test fun `sent to flow hospital on error and retry on node restart`()</ID>
    <ID>LongMethod:ReceiveTransactionFlow.kt$ReceiveTransactionFlow$@Suppress("KDocMissingDocumentation") @Suspendable @Throws(SignatureException::class, AttachmentResolutionException::class, TransactionResolutionException::class, TransactionVerificationException::class) override fun call(): SignedTransaction</ID>
    <ID>LongMethod:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$override fun invoke(proxy: Any, method: Method, args: Array&lt;out Any&gt;?): Any?</ID>
    <ID>LongMethod:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$private tailrec fun establishConnectionWithRetry(retryInterval: Duration = 1.seconds, roundRobinIndex: Int = 0): CordaRPCConnection</ID>
    <ID>LongMethod:ReferenceInputStateTests.kt$ReferenceStateTests$@Test fun `Can't use old reference states`()</ID>
    <ID>LongMethod:ReferenceInputStateTests.kt$ReferenceStateTests$@Test fun `create a reference state then refer to it multiple times`()</ID>
    <ID>LongMethod:ReferenceInputStateTests.kt$ReferenceStateTests.ExampleContract$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$@Test fun `check old ref state is consumed when update used in tx with relevant states`()</ID>
    <ID>LongMethod:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$@Test fun `check ref state is persisted when used in tx with relevant states`()</ID>
    <ID>LongMethod:RemoteSerializerFactory.kt$DefaultRemoteSerializerFactory$private fun getUncached( remoteTypeInformation: RemoteTypeInformation, localTypeInformation: LocalTypeInformation ): AMQPSerializer&lt;Any&gt;</ID>
    <ID>LongMethod:ReplayedList.kt$ReplayedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out A&gt;)</ID>
    <ID>LongMethod:ReplayedListTest.kt$ReplayedListTest$@Test fun addWorks()</ID>
    <ID>LongMethod:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$// DOCSTART 2 private fun makeTransactions(signFirstTX: Boolean = true, withAttachment: SecureHash? = null): Pair&lt;SignedTransaction, SignedTransaction&gt;</ID>
    <ID>LongMethod:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$@Test fun `triangle of transactions resolves fine`()</ID>
    <ID>LongMethod:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$private fun contractUpgradeChain(): SignedTransaction</ID>
    <ID>LongMethod:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$private fun makeLargeTransactionChain(chainLength: Int): SignedTransaction</ID>
    <ID>LongMethod:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$private fun notaryChangeChain(): SignedTransaction</ID>
    <ID>LongMethod:RetryFlowMockTest.kt$RetryFlowMockTest$@Test fun `Restart does not set senderUUID`()</ID>
    <ID>LongMethod:RoundTripObservableSerializerTests.kt$RoundTripObservableSerializerTests$@Test fun roundTripTest1()</ID>
    <ID>LongMethod:RoundTripTests.kt$RoundTripTests$@Test fun canSerializeClassesWithUntypedProperties()</ID>
    <ID>LongMethod:RpcClientObservableDeSerializer.kt$RpcClientObservableDeSerializer$ override fun readObject(obj: Any, schemas: SerializationSchemas, input: DeserializationInput, context: SerializationContext ): Observable&lt;*&gt;</ID>
    <ID>LongMethod:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest$@Test fun `FlowException is received by the RPC client only if in devMode`()</ID>
    <ID>LongMethod:RpcReconnectTests.kt$RpcReconnectTests$ @Test fun `test that the RPC client is able to reconnect and proceed after node failure, restart, or connection reset`()</ID>
    <ID>LongMethod:RpcServerObservableSerializer.kt$RpcServerObservableSerializer$override fun writeDescribedObject( obj: Observable&lt;*&gt;, data: Data, type: Type, output: SerializationOutput, context: SerializationContext )</ID>
    <ID>LongMethod:RpcSslTest.kt$RpcSslTest$@Test fun `RPC client using ssl is able to run a command`()</ID>
    <ID>LongMethod:RpcSslTest.kt$RpcSslTest$@Test fun `RPC client using ssl will fail if connecting to a node that cannot present a matching certificate`()</ID>
    <ID>LongMethod:RpcSslTest.kt$RpcSslTest$@Test fun `The system RPC user can not connect to the rpc broker without the node's key`()</ID>
    <ID>LongMethod:SSHServerTest.kt$SSHServerTest$@Ignore @Test fun `ssh runs flows`()</ID>
    <ID>LongMethod:SSHServerTest.kt$SSHServerTest$@Test fun `ssh respects permissions`()</ID>
    <ID>LongMethod:SSLHelper.kt$LoggingTrustManagerWrapper$private fun certPathToString(certPath: Array&lt;out X509Certificate&gt;?): String</ID>
    <ID>LongMethod:SSLHelper.kt$internal fun createClientSslHelper(target: NetworkHostAndPort, expectedRemoteLegalNames: Set&lt;CordaX500Name&gt;, keyManagerFactory: KeyManagerFactory, trustManagerFactory: TrustManagerFactory): SslHandler</ID>
    <ID>LongMethod:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$@Test fun `test that when states are being spent at the same time that schedules trigger everything is processed`()</ID>
    <ID>LongMethod:ScheduledFlowTests.kt$ScheduledFlowTests$@Test fun `create and run scheduled flow then wait for result`()</ID>
    <ID>LongMethod:ScheduledFlowTests.kt$ScheduledFlowTests$@Test fun `run a whole batch of scheduled flows`()</ID>
    <ID>LongMethod:ScheduledFlowsDrainingModeTest.kt$ScheduledFlowsDrainingModeTest$@Test fun `flows draining mode ignores scheduled flows until unset`()</ID>
    <ID>LongMethod:SchemaMigration.kt$SchemaMigration$ private fun migrateOlderDatabaseToUseLiquibase(existingCheckpoints: Boolean): Boolean</ID>
    <ID>LongMethod:SchemaMigration.kt$SchemaMigration$private fun doRunMigration(run: Boolean, check: Boolean, existingCheckpoints: Boolean? = null)</ID>
    <ID>LongMethod:SchemaTest.kt$SchemaTest$@Test fun describe_with_nested_properties_does_not_show_sensitive_values()</ID>
    <ID>LongMethod:SchemaTest.kt$SchemaTest$@Test fun describe_with_nested_properties_list_does_not_show_sensitive_values()</ID>
    <ID>LongMethod:SchemaTest.kt$SchemaTest$@Test fun validation_with_nested_properties()</ID>
    <ID>LongMethod:SchemaTest.kt$SchemaTest$@Test fun validation_with_unknown_properties()</ID>
    <ID>LongMethod:SchemaTest.kt$SchemaTest$@Test fun validation_with_wrong_nested_properties()</ID>
    <ID>LongMethod:SendTransactionFlow.kt$DataVendingFlow$@Suspendable override fun call(): Void?</ID>
    <ID>LongMethod:SerializationOutput.kt$SerializationOutput$internal fun &lt;T : Any&gt; _serialize(obj: T, context: SerializationContext): SerializedBytes&lt;T&gt;</ID>
    <ID>LongMethod:SerializationOutputTests.kt$SerializationOutputTests$@Test fun `class constructor is invoked on deserialisation`()</ID>
    <ID>LongMethod:SerializationOutputTests.kt$SerializationOutputTests$@Test fun `test complex throwables serialize`()</ID>
    <ID>LongMethod:SerializationOutputTests.kt$SerializationOutputTests$@Test fun `test suppressed throwables serialize`()</ID>
    <ID>LongMethod:SerializationOutputTests.kt$SerializationOutputTests$@Test fun `test transaction state`()</ID>
    <ID>LongMethod:SerializationOutputTests.kt$SerializationOutputTests$@Test fun isPrimitive()</ID>
    <ID>LongMethod:SerializationOutputTests.kt$SerializationOutputTests$private inline fun &lt;reified T : Any&gt; serdes(obj: T, factory: SerializerFactory = defaultFactory(), freshDeserializationFactory: SerializerFactory = defaultFactory(), expectedEqual: Boolean = true, expectDeserializedEqual: Boolean = true): T</ID>
    <ID>LongMethod:SerializationPropertyOrdering.kt$SerializationPropertyOrdering$@Suppress("UNCHECKED_CAST") @Test fun randomOrderSetter()</ID>
    <ID>LongMethod:SerializationPropertyOrdering.kt$SerializationPropertyOrdering$@Test fun randomOrder()</ID>
    <ID>LongMethod:SerializerFactoryBuilder.kt$SerializerFactoryBuilder$@JvmStatic @DeleteForDJVM fun build( whitelist: ClassWhitelist, carpenterClassLoader: ClassLoader, lenientCarpenterEnabled: Boolean = false, descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry = DefaultDescriptorBasedSerializerRegistry(), allowEvolution: Boolean = true, overrideFingerPrinter: FingerPrinter? = null, onlyCustomSerializers: Boolean = false, mustPreserveDataWhenEvolving: Boolean = false): SerializerFactory</ID>
    <ID>LongMethod:SerializerFactoryBuilder.kt$SerializerFactoryBuilder$@JvmStatic @DeleteForDJVM fun build( whitelist: ClassWhitelist, classCarpenter: ClassCarpenter, descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry = DefaultDescriptorBasedSerializerRegistry(), allowEvolution: Boolean = true, overrideFingerPrinter: FingerPrinter? = null, onlyCustomSerializers: Boolean = false, mustPreserveDataWhenEvolving: Boolean = false): SerializerFactory</ID>
    <ID>LongMethod:SerializerFactoryBuilder.kt$SerializerFactoryBuilder$private fun makeFactory(whitelist: ClassWhitelist, classCarpenter: ClassCarpenter, descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry, allowEvolution: Boolean, overrideFingerPrinter: FingerPrinter?, onlyCustomSerializers: Boolean, mustPreserveDataWhenEvolving: Boolean): SerializerFactory</ID>
    <ID>LongMethod:ServiceHubConcurrentUsageTest.kt$ServiceHubConcurrentUsageTest$@Test fun `operations requiring a transaction work from another thread`()</ID>
    <ID>LongMethod:ServiceHubInternal.kt$ServiceHubInternal.Companion$fun recordTransactions(statesToRecord: StatesToRecord, txs: Collection&lt;SignedTransaction&gt;, validatedTransactions: WritableTransactionStorage, stateMachineRecordedTransactionMapping: StateMachineRecordedTransactionMappingStorage, vaultService: VaultServiceInternal, database: CordaPersistence)</ID>
    <ID>LongMethod:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$// We may need to recursively chase transactions if there are notary changes. fun inner(stateRef: StateRef, forContractClassName: String?): Attachment</ID>
    <ID>LongMethod:SettingsModelTest.kt$SettingsModelTest$@Test fun `test save config and rollback`()</ID>
    <ID>LongMethod:SharedMemoryIncremental.kt$SharedMemoryIncremental$override fun nextPort(): Int</ID>
    <ID>LongMethod:ShutdownManager.kt$ShutdownManager$fun shutdown()</ID>
    <ID>LongMethod:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$@Test fun `HashConstraint cannot be migrated to SignatureConstraint if a HashConstraint is specified for one state and another uses an AutomaticPlaceholderConstraint`()</ID>
    <ID>LongMethod:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$@Test fun `can evolve from lower contract class version to higher one`()</ID>
    <ID>LongMethod:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$@Test fun `WhitelistConstraint cannot be migrated to SignatureConstraint if platform version is not 4 or greater`()</ID>
    <ID>LongMethod:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$@Test fun `auto migration from WhitelistConstraint to SignatureConstraint will only transition states that do not have a constraint specified`()</ID>
    <ID>LongMethod:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$@Test fun `auto migration from WhitelistConstraint to SignatureConstraint`()</ID>
    <ID>LongMethod:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$@Test fun `can evolve from lower contract class version to higher one`()</ID>
    <ID>LongMethod:SignatureConstraintVersioningTests.kt$ConsumeMessage$@Suspendable override fun call(): SignedTransaction</ID>
    <ID>LongMethod:SignatureConstraintVersioningTests.kt$SignatureConstraintVersioningTests$ fun upgradeCorDappBetweenTransactions( cordapp: CustomCordapp, newCordapp: CustomCordapp, whiteListedCordapps: Map&lt;ContractClassName, List&lt;CustomCordapp&gt;&gt;, systemProperties: Map&lt;String, String&gt;, startNodesInProcess: Boolean, minimumPlatformVersion: Int = 4, specifyExistingConstraint: Boolean = false, addAnotherAutomaticConstraintState: Boolean = false ): Pair&lt;CoreTransaction, CoreTransaction&gt;</ID>
    <ID>LongMethod:SignatureConstraintVersioningTests.kt$SignatureConstraintVersioningTests$private fun DriverDSL.createConsumingTransaction( nodeName: CordaX500Name, cordapp: CustomCordapp, specifyExistingConstraint: Boolean, addAnotherAutomaticConstraintState: Boolean ): SignedTransaction</ID>
    <ID>LongMethod:SignedNodeInfo.kt$SignedNodeInfo$// TODO Add root cert param (or TrustAnchor) to make sure all the identities belong to the same root fun verified(): NodeInfo</ID>
    <ID>LongMethod:SignedNodeInfoTest.kt$SignedNodeInfoTest$private fun createNodeInfoWithSingleIdentity(name: CordaX500Name, nodeKeyPair: KeyPair, identityCertPublicKey: PublicKey): NodeInfo</ID>
    <ID>LongMethod:SignedTransaction.kt$SignedTransaction$// TODO: Verify contract constraints here as well as in LedgerTransaction to ensure that anything being deserialised // from the attachment is trusted. This will require some partial serialisation work to not load the ContractState // objects from the TransactionState. @DeleteForDJVM private fun verifyRegularTransaction(services: ServiceHub, checkSufficientSignatures: Boolean)</ID>
    <ID>LongMethod:SimmFlow.kt$SimmFlow.Receiver$ @Suspendable private fun agreeValuation(portfolio: Portfolio, asOf: LocalDate, valuer: Party): PortfolioValuation</ID>
    <ID>LongMethod:SimmFlow.kt$SimmFlow.Requester$@Suspendable private fun agreeValuation(portfolio: Portfolio, asOf: LocalDate, valuer: Party): PortfolioValuation</ID>
    <ID>LongMethod:SimmValuationTest.kt$SimmValuationTest$@Test fun `runs SIMM valuation demo`()</ID>
    <ID>LongMethod:SinglePartyNotaryService.kt$SinglePartyNotaryService$ @Suspendable open fun commitInputStates( inputs: List&lt;StateRef&gt;, txId: SecureHash, caller: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; )</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$// The flow's event queue may be non-empty in case it shut down abruptly. We handle outstanding events here. private fun drainFlowEventQueue(flow: Flow)</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$override fun killFlow(id: StateMachineRunId): Boolean</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$override fun retryFlowFromSafePoint(currentState: StateMachineState)</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$override fun start(tokenizableServices: List&lt;Any&gt;)</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private fun &lt;A&gt; startFlowInternal( invocationContext: InvocationContext, flowLogic: FlowLogic&lt;A&gt;, flowStart: FlowStart, ourIdentity: Party, deduplicationHandler: DeduplicationHandler?, isStartIdempotent: Boolean ): CordaFuture&lt;FlowStateMachine&lt;A&gt;&gt;</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private fun addAndStartFlow(id: StateMachineRunId, flow: Flow)</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private fun createFlowFromCheckpoint( id: StateMachineRunId, checkpoint: Checkpoint, isAnyCheckpointPersisted: Boolean, isStartIdempotent: Boolean, initialDeduplicationHandler: DeduplicationHandler? ): Flow</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private fun onExistingSessionMessage(sessionMessage: ExistingSessionMessage, deduplicationHandler: DeduplicationHandler, sender: Party)</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private fun onSessionInit(sessionMessage: InitialSessionMessage, sender: Party, event: ExternalEvent.ExternalMessageEvent)</ID>
    <ID>LongMethod:StabilityTest.kt$StabilityTest$fun crossCashTest(replication: Int)</ID>
    <ID>LongMethod:StabilityTest.kt$StabilityTest$fun selfIssueTest(replication: Int)</ID>
    <ID>LongMethod:StaffedFlowHospital.kt$StaffedFlowHospital$ fun flowErrored(flowFiber: FlowFiber, currentState: StateMachineState, errors: List&lt;Throwable&gt;)</ID>
    <ID>LongMethod:StaffedFlowHospital.kt$StaffedFlowHospital$ fun sessionInitErrored(sessionMessage: InitialSessionMessage, sender: Party, event: ExternalEvent.ExternalMessageEvent, error: Throwable)</ID>
    <ID>LongMethod:StandaloneShell.kt$StandaloneShell$override fun runProgram(): Int</ID>
    <ID>LongMethod:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$@Test fun args_to_config()</ID>
    <ID>LongMethod:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$@Test fun cmd_options_override_config_from_file()</ID>
    <ID>LongMethod:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$@Test fun cmd_options_to_config_from_file()</ID>
    <ID>LongMethod:StartedFlowTransition.kt$StartedFlowTransition$override fun transition(): TransitionResult</ID>
    <ID>LongMethod:StartedFlowTransition.kt$StartedFlowTransition$private fun TransitionBuilder.sendInitialSessionMessagesIfNeeded(sourceSessions: Set&lt;SessionId&gt;)</ID>
    <ID>LongMethod:StartedFlowTransition.kt$StartedFlowTransition$private fun TransitionBuilder.sendToSessionsTransition(sourceSessionIdToMessage: Map&lt;SessionId, SerializedBytes&lt;Any&gt;&gt;)</ID>
    <ID>LongMethod:StartedFlowTransition.kt$StartedFlowTransition$private fun collectEndedEmptySessionErrors(sessionIds: Collection&lt;SessionId&gt;, checkpoint: Checkpoint): List&lt;Throwable&gt;</ID>
    <ID>LongMethod:StartedFlowTransition.kt$StartedFlowTransition$private fun collectRelevantErrorsToThrow(flowIORequest: FlowIORequest&lt;*&gt;, checkpoint: Checkpoint): List&lt;Throwable&gt;</ID>
    <ID>LongMethod:StartedFlowTransition.kt$StartedFlowTransition$private fun pollSessionMessages(sessions: SessionMap, sessionIds: Set&lt;SessionId&gt;): PollResult?</ID>
    <ID>LongMethod:StartedFlowTransition.kt$StartedFlowTransition$private fun sendAndReceiveTransition(flowIORequest: FlowIORequest.SendAndReceive): TransitionResult</ID>
    <ID>LongMethod:StateMachineState.kt$Checkpoint.Companion$fun create( invocationContext: InvocationContext, flowStart: FlowStart, flowLogicClass: Class&lt;FlowLogic&lt;*&gt;&gt;, frozenFlowLogic: SerializedBytes&lt;FlowLogic&lt;*&gt;&gt;, ourIdentity: Party, subFlowVersion: SubFlowVersion, isEnabledTimedFlow: Boolean ): Try&lt;Checkpoint&gt;</ID>
    <ID>LongMethod:StatusTransitions.kt$StatusTransitions$ fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:StatusTransitionsTest.kt$StatusTransitionsTest$@Test fun `basic correct cases`()</ID>
    <ID>LongMethod:StatusTransitionsTest.kt$StatusTransitionsTest$@Test fun `role change signer correct`()</ID>
    <ID>LongMethod:StringToMethodCallParser.kt$StringToMethodCallParser$ @Throws(UnparseableCallException::class) fun parse(target: T?, command: String): ParsedMethodCall</ID>
    <ID>LongMethod:StringToMethodCallParser.kt$StringToMethodCallParser$ @Throws(UnparseableCallException::class) fun parseArguments(methodNameHint: String, parameters: List&lt;Pair&lt;String, Type&gt;&gt;, args: String): Array&lt;Any?&gt;</ID>
    <ID>LongMethod:StructuresTests.kt$AttachmentTest$@Test fun `openAsJAR does not leak file handle if attachment has corrupted manifest`()</ID>
    <ID>LongMethod:SwapDataView.kt$fun SwapData.toView(viewingParty: Party, portfolio: Portfolio? = null, presentValue: MultiCurrencyAmount? = null, IM: InitialMarginTriple? = null): SwapDataView</ID>
    <ID>LongMethod:SwapExample.kt$SwapExample$fun main(@Suppress("UNUSED_PARAMETER") args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:SwapExample.kt$SwapExample$fun testingEqualitymain(@Suppress("UNUSED_PARAMETER") args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$@Suspendable override fun call(): LinkedHashMap&lt;Party, AnonymousParty&gt;</ID>
    <ID>LongMethod:SwapIdentitiesFlowTests.kt$SwapIdentitiesFlowTests$@Test fun `issue key`()</ID>
    <ID>LongMethod:TLSAuthenticationTests.kt$TLSAuthenticationTests$private fun buildTLSFactories( rootCAScheme: SignatureScheme, intermediateCAScheme: SignatureScheme, client1CAScheme: SignatureScheme, client1TLSScheme: SignatureScheme, client2CAScheme: SignatureScheme, client2TLSScheme: SignatureScheme ): Pair&lt;SSLServerSocketFactory, SSLSocketFactory&gt;</ID>
    <ID>LongMethod:TLSAuthenticationTests.kt$TLSAuthenticationTests$private fun buildTLSSockets( serverSocketFactory: SSLServerSocketFactory, clientSocketFactory: SSLSocketFactory, serverPort: Int = 0, // Use 0 to get first free socket. clientPort: Int = 0, // Use 0 to get first free socket. cipherSuitesServer: Array&lt;String&gt; = CORDA_TLS_CIPHER_SUITES, cipherSuitesClient: Array&lt;String&gt; = CORDA_TLS_CIPHER_SUITES ): Pair&lt;SSLServerSocket, SSLSocket&gt;</ID>
    <ID>LongMethod:TLSAuthenticationTests.kt$TLSAuthenticationTests$private fun testConnect(serverSocket: ServerSocket, clientSocket: SSLSocket, expectedCipherSuite: String)</ID>
    <ID>LongMethod:TestCommsFlow.kt$TestCommsFlowInitiator$@Suspendable override fun call(): List&lt;String&gt;</ID>
    <ID>LongMethod:TestDSL.kt$TestLedgerDSLInterpreter$override fun verifies(): EnforceVerifyOrFail</ID>
    <ID>LongMethod:TestDSL.kt$TestLedgerDSLInterpreter$private fun &lt;R&gt; recordTransactionWithTransactionMap( transactionLabel: String?, transactionBuilder: TransactionBuilder, dsl: TestTransactionDSLInterpreter.() -&gt; R, transactionMap: HashMap&lt;SecureHash, WireTransactionWithLocation&gt; = HashMap(), /** If set to true, will add dummy components to [transactionBuilder] to make it valid. */ fillTransaction: Boolean ): WireTransaction</ID>
    <ID>LongMethod:TestNotaryFlow.kt$TestNotaryFlow$@Suspendable override fun call(): String</ID>
    <ID>LongMethod:ThrowableSerializer.kt$ThrowableSerializer$override fun fromProxy(proxy: ThrowableProxy): Throwable</ID>
    <ID>LongMethod:TimedFlowTests.kt$TimedFlowTests$@Test fun `timed flow can update its ETA`()</ID>
    <ID>LongMethod:TimedFlowTests.kt$TimedFlowTests$@Test fun `timed flow cannot update its ETA to less than default`()</ID>
    <ID>LongMethod:TimedFlowTests.kt$TimedFlowTests.Companion$private fun startClusterAndNode(mockNet: InternalMockNetwork): Triple&lt;Party, TestStartedNode, TestStartedNode&gt;</ID>
    <ID>LongMethod:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$@Test fun testClientServerTlsExchange()</ID>
    <ID>LongMethod:ToggleFieldTest.kt$ToggleFieldTest$ @Test fun `leaked thread propagates holder to non-global thread, with warning`()</ID>
    <ID>LongMethod:ToggleFieldTest.kt$ToggleFieldTest$@Test fun `inherited values are poisoned on clear`()</ID>
    <ID>LongMethod:TopLevelTransition.kt$TopLevelTransition$private fun enterSubFlowTransition(event: Event.EnterSubFlow): TransitionResult</ID>
    <ID>LongMethod:TopLevelTransition.kt$TopLevelTransition$private fun flowFinishTransition(event: Event.FlowFinish): TransitionResult</ID>
    <ID>LongMethod:TopLevelTransition.kt$TopLevelTransition$private fun leaveSubFlowTransition(): TransitionResult</ID>
    <ID>LongMethod:TopLevelTransition.kt$TopLevelTransition$private fun suspendTransition(event: Event.Suspend): TransitionResult</ID>
    <ID>LongMethod:TraderDemo.kt$TraderDemo$fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:TraderDemoClientApi.kt$TraderDemoClientApi$fun runIssuer(amount: Amount&lt;Currency&gt;, buyerName: CordaX500Name, sellerName: CordaX500Name)</ID>
    <ID>LongMethod:TraderDemoTest.kt$TraderDemoTest$@Test fun `Test restart node during flow works properly`()</ID>
    <ID>LongMethod:TraderDemoTest.kt$TraderDemoTest$@Test fun `runs trader demo`()</ID>
    <ID>LongMethod:TransactionBuilder.kt$TransactionBuilder$ private fun addMissingDependency(services: ServicesForResolution, wireTx: WireTransaction): Boolean</ID>
    <ID>LongMethod:TransactionBuilder.kt$TransactionBuilder$ private fun handleContract( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, outputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, explicitContractAttachment: AttachmentId?, services: ServicesForResolution ): Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;</ID>
    <ID>LongMethod:TransactionBuilder.kt$TransactionBuilder$ private fun resolveStatePointers(transactionState: TransactionState&lt;*&gt;)</ID>
    <ID>LongMethod:TransactionBuilder.kt$TransactionBuilder$ private fun selectAttachmentConstraint( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, attachmentToUse: ContractAttachment, services: ServicesForResolution): AttachmentConstraint</ID>
    <ID>LongMethod:TransactionBuilder.kt$TransactionBuilder$ private fun selectContractAttachmentsAndOutputStateConstraints( services: ServicesForResolution, serializationContext: SerializationContext?): Pair&lt;Collection&lt;SecureHash&gt;, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt;</ID>
    <ID>LongMethod:TransactionBuilder.kt$TransactionBuilder$@CordaInternal internal fun toWireTransactionWithContext(services: ServicesForResolution, serializationContext: SerializationContext? = null): WireTransaction</ID>
    <ID>LongMethod:TransactionBuilder.kt$TransactionBuilder$private fun addMissingAttachment(missingClass: String, services: ServicesForResolution, originalException: Throwable): Boolean</ID>
    <ID>LongMethod:TransactionBuilderTest.kt$TransactionBuilderTest$@Before fun setup()</ID>
    <ID>LongMethod:TransactionBuilderTest.kt$TransactionBuilderTest$@Test fun `automatic signature constraint`()</ID>
    <ID>LongMethod:TransactionDataModel.kt$PartiallyResolvedTransaction.Companion$fun fromSignedTransaction( transaction: SignedTransaction, inputTransactions: Map&lt;StateRef, SignedTransaction?&gt; ): PartiallyResolvedTransaction</ID>
    <ID>LongMethod:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$@Test fun `correct encumbrance state must be provided`()</ID>
    <ID>LongMethod:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$@Test fun `encumbered states cannot be assigned to different notaries`()</ID>
    <ID>LongMethod:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$@Test fun `non bi-directional encumbrance will fail`()</ID>
    <ID>LongMethod:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$@Test fun `states must be bi-directionally encumbered`()</ID>
    <ID>LongMethod:TransactionGenerator.kt$TransactionGenerator$fun writeFailure(output: OutputStream)</ID>
    <ID>LongMethod:TransactionGenerator.kt$TransactionGenerator$fun writeSuccess(output: OutputStream)</ID>
    <ID>LongMethod:TransactionOrderingTests.kt$TransactionOrderingTests$@Test fun `Out of order transactions are recorded in vault correctly`()</ID>
    <ID>LongMethod:TransactionSignatureTest.kt$TransactionSignatureTest$@Test fun `Verify multi-tx signature`()</ID>
    <ID>LongMethod:TransactionTests.kt$TransactionTests$@Test fun `general transactions cannot change notary`()</ID>
    <ID>LongMethod:TransactionTests.kt$TransactionTests$@Test fun `signed transaction missing signatures - CompositeKey`()</ID>
    <ID>LongMethod:TransactionTests.kt$TransactionTests$@Test fun `signed transaction missing signatures`()</ID>
    <ID>LongMethod:TransactionTests.kt$TransactionTests$@Test fun `transactions with no inputs can have any notary`()</ID>
    <ID>LongMethod:TransactionUtils.kt$ fun &lt;T : Any&gt; deserialiseComponentGroup(componentGroups: List&lt;ComponentGroup&gt;, clazz: KClass&lt;T&gt;, groupEnum: ComponentGroupEnum, forceDeserialize: Boolean = false, factory: SerializationFactory = SerializationFactory.defaultFactory, context: SerializationContext = factory.defaultContext): List&lt;T&gt;</ID>
    <ID>LongMethod:TransactionUtils.kt$ fun createComponentGroups(inputs: List&lt;StateRef&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, attachments: List&lt;SecureHash&gt;, notary: Party?, timeWindow: TimeWindow?, references: List&lt;StateRef&gt;, networkParametersHash: SecureHash?): List&lt;ComponentGroup&gt;</ID>
    <ID>LongMethod:TransactionUtils.kt$ fun deserialiseCommands(componentGroups: List&lt;ComponentGroup&gt;, forceDeserialize: Boolean = false, factory: SerializationFactory = SerializationFactory.defaultFactory, context: SerializationContext = factory.defaultContext): List&lt;Command&lt;*&gt;&gt;</ID>
    <ID>LongMethod:TransactionUtils.kt$ fun isAttachmentTrusted(attachment: Attachment, service: AttachmentStorage?): Boolean</ID>
    <ID>LongMethod:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyConstraintsValidity(contractAttachmentsByContract: Map&lt;ContractClassName, ContractAttachment&gt;)</ID>
    <ID>LongMethod:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyContracts()</ID>
    <ID>LongMethod:TransactionVerifierServiceInternal.kt$Verifier$// Using basic graph theory, a full cycle of encumbered (co-dependent) states should exist to achieve bi-directional // encumbrances. This property is important to ensure that no states involved in an encumbrance-relationship // can be spent on their own. Briefly, if any of the states is having more than one encumbrance references by // other states, a full cycle detection will fail. As a result, all of the encumbered states must be present // as "from" and "to" only once (or zero times if no encumbrance takes place). For instance, // a -&gt; b // c -&gt; b and a -&gt; b // b -&gt; a b -&gt; c // do not satisfy the bi-directionality (full cycle) property. // // In the first example "b" appears twice in encumbrance ("to") list and "c" exists in the encumbered ("from") list only. // Due the above, one could consume "a" and "b" in the same transaction and then, because "b" is already consumed, "c" cannot be spent. // // Similarly, the second example does not form a full cycle because "a" and "c" exist in one of the lists only. // As a result, one can consume "b" and "c" in the same transactions, which will make "a" impossible to be spent. // // On other hand the following are valid constructions: // a -&gt; b a -&gt; c // b -&gt; c and c -&gt; b // c -&gt; a b -&gt; a // and form a full cycle, meaning that the bi-directionality property is satisfied. private fun checkBidirectionalOutputEncumbrances(statesAndEncumbrance: List&lt;Pair&lt;Int, Int&gt;&gt;)</ID>
    <ID>LongMethod:TransactionViewer.kt$TransactionViewer.ContractStatesView$private fun getCell(contractState: StateAndRef&lt;ContractState&gt;): Node</ID>
    <ID>LongMethod:TransformsSchema.kt$TransformsSchema$@Suppress("NAME_SHADOWING") override fun toString(): String</ID>
    <ID>LongMethod:TransformsSchema.kt$TransformsSchema.Companion$ override fun newInstance(described: Any?): TransformsSchema</ID>
    <ID>LongMethod:TransitionDiagnosticRecord.kt$TransitionDiagnosticRecord$override fun toString(): String</ID>
    <ID>LongMethod:TransitionExecutorImpl.kt$TransitionExecutorImpl$@Suspendable override fun executeTransition( fiber: FlowFiber, previousState: StateMachineState, event: Event, transition: TransitionResult, actionExecutor: ActionExecutor ): Pair&lt;FlowContinuation, StateMachineState&gt;</ID>
    <ID>LongMethod:TutorialContract.kt$CommercialPaper$// DOCSTART 3 override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:TutorialTestDSL.kt$TutorialTestDSL$// DOCSTART 10 @Test fun `chain commercial tweak`()</ID>
    <ID>LongMethod:TutorialTestDSL.kt$TutorialTestDSL$// DOCSTART 8 @Test fun `chain commercial paper`()</ID>
    <ID>LongMethod:TutorialTestDSL.kt$TutorialTestDSL$// DOCSTART 9 @Test fun `chain commercial paper double spend`()</ID>
    <ID>LongMethod:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$@Suspendable override fun call(): SignedTransaction</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$@Test fun `check dependencies of sale asset are resolved`()</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$@Test fun `shutdown and restore`()</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$@Test fun `track works`()</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$@Test fun `trade cash for commercial paper`()</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$@Test(expected = InsufficientBalanceException::class) fun `trade cash for commercial paper fails using soft locking`()</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$private fun LedgerDSL&lt;TestTransactionDSLInterpreter, TestLedgerDSLInterpreter&gt;.fillUpForBuyerAndInsertFakeTransactions( withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, notary: Party, node: TestStartedNode, identity: Party, notaryNode: TestStartedNode, vararg extraSigningNodes: TestStartedNode ): Triple&lt;Vault&lt;ContractState&gt;, List&lt;WireTransaction&gt;, Map&lt;SecureHash,SignedTransaction&gt;&gt;</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$private fun LedgerDSL&lt;TestTransactionDSLInterpreter, TestLedgerDSLInterpreter&gt;.fillUpForSeller( withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, amount: Amount&lt;Issued&lt;Currency&gt;&gt;, attachmentID: SecureHash?, notary: Party): Pair&lt;Vault&lt;ContractState&gt;, List&lt;WireTransaction&gt;&gt;</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$private fun LedgerDSL&lt;TestTransactionDSLInterpreter, TestLedgerDSLInterpreter&gt;.runWithError( bobError: Boolean, aliceError: Boolean, expectedMessageSubstring: String )</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$private fun insertFakeTransactions( wtxToSign: List&lt;WireTransaction&gt;, node: TestStartedNode, identity: Party, notaryNode: TestStartedNode, vararg extraSigningNodes: TestStartedNode): Map&lt;SecureHash, SignedTransaction&gt;</ID>
    <ID>LongMethod:TypeLoader.kt$ClassCarpentingTypeLoader$override fun load( remoteTypeInformation: Collection&lt;RemoteTypeInformation&gt;, context: SerializationContext ): Map&lt;TypeIdentifier, Type&gt;</ID>
    <ID>LongMethod:TypeModellingFingerPrinter.kt$FingerPrintingState$// For a type we haven't seen before, determine the correct path depending on the type of type it is. private fun fingerprintNewType(type: LocalTypeInformation)</ID>
    <ID>LongMethod:TypeParameterUtils.kt$ private fun inferTypeVariables(actualClass: Class&lt;*&gt;, declaredClass: Class&lt;*&gt;, declaredType: ParameterizedType): Type?</ID>
    <ID>LongMethod:UniversalContract.kt$UniversalContract$fun evalBigDecimal(tx: LedgerTransaction, expr: Perceivable&lt;BigDecimal&gt;): BigDecimal</ID>
    <ID>LongMethod:UniversalContract.kt$UniversalContract$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:UnstartedFlowTransition.kt$UnstartedFlowTransition$// Initialise initiated session, store initial payload, send confirmation back. private fun TransitionBuilder.initialiseInitiatedSession(flowStart: FlowStart.Initiated)</ID>
    <ID>LongMethod:Util.kt$fun &lt;T&gt; debugCompare(perLeft: Perceivable&lt;T&gt;, perRight: Perceivable&lt;T&gt;)</ID>
    <ID>LongMethod:Util.kt$fun debugCompare(arrLeft: Arrangement, arrRight: Arrangement)</ID>
    <ID>LongMethod:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$override fun parseValid(configuration: Config): Validated&lt;NodeConfiguration, Configuration.Validation.Error&gt;</ID>
    <ID>LongMethod:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$@Test fun `should re-sign a transaction with an expired time-window`()</ID>
    <ID>LongMethod:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$@Test fun `should reject transaction without network parameters`()</ID>
    <ID>LongMethod:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$@Test fun `should report conflict when inputs are reused across transactions`()</ID>
    <ID>LongMethod:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$@Test fun `should sign identical transaction multiple times (notarisation is idempotent)`()</ID>
    <ID>LongMethod:VaultFiller.kt$VaultFiller$ fun fillWithSomeTestCash(howMuch: Amount&lt;Currency&gt;, issuerServices: ServiceHub, atLeastThisManyStates: Int, atMostThisManyStates: Int, issuedBy: PartyAndReference, owner: AbstractParty? = null, rng: Random? = null, statesToRecord: StatesToRecord = StatesToRecord.ONLY_RELEVANT): Vault&lt;Cash.State&gt;</ID>
    <ID>LongMethod:VaultFiller.kt$VaultFiller$@JvmOverloads fun fillWithSomeTestDeals(dealIds: List&lt;String&gt;, issuerServices: ServiceHub = services, participants: List&lt;AbstractParty&gt; = emptyList(), includeMe: Boolean = true): Vault&lt;DealState&gt;</ID>
    <ID>LongMethod:VaultFiller.kt$VaultFiller$@JvmOverloads fun fillWithSomeTestLinearAndDealStates(numberToCreate: Int, externalId: String? = null, participants: List&lt;AbstractParty&gt; = emptyList(), linearString: String = "", linearNumber: Long = 0L, linearBoolean: Boolean = false, linearTimestamp: Instant = now()): Vault&lt;LinearState&gt;</ID>
    <ID>LongMethod:VaultFiller.kt$VaultFiller$@JvmOverloads fun fillWithSomeTestLinearStates(numberToCreate: Int, externalId: String? = null, participants: List&lt;AbstractParty&gt; = emptyList(), uniqueIdentifier: UniqueIdentifier? = null, linearString: String = "", linearNumber: Long = 0L, linearBoolean: Boolean = false, linearTimestamp: Instant = now(), constraint: AttachmentConstraint = AutomaticPlaceholderConstraint, includeMe: Boolean = true): Vault&lt;LinearState&gt;</ID>
    <ID>LongMethod:VaultFiller.kt$VaultFiller.Companion$fun calculateRandomlySizedAmounts(howMuch: Amount&lt;Currency&gt;, min: Int, max: Int, rng: Random): LongArray</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$ @Test fun trackCashStates_unconsumed()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$@Test fun `track by of contract state interface returns updates of all states`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$@Test fun `track by of super class only returns updates of sub classes of tracked type`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$@Test fun `track by only returns updates of tracked type`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$@Test fun trackCashStates_all()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$@Test fun trackCashStates_consumed()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$@Test fun trackDealStates()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$@Test fun trackLinearStates()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$ // specifying Query on Commercial Paper contract state attributes @Test fun `custom query using JPA - commercial paper schema V1 single attribute`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$// specifying Query on Commercial Paper contract state attributes @Test fun `custom query using JPA - commercial paper schema V1 - multiple attributes`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$// specifying Query on Linear state attributes @Test fun `unconsumed linear heads for linearId between two timestamps for a given external id`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$// test paging with aggregate function and group by clause @Test fun `test paging with aggregate function and group by clause`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `aggregate functions count by contract type and state status`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `aggregate functions sum by issuer and currency and sort by aggregate sum`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `aggregate functions with single group clause`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `aggregate functions without group clause`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `composite query for fungible and linear states for multiple participants`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `composite query for fungible and linear states`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `query by contract states constraint type and data`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `query by contract states constraint type`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `query with sort criteria works even when multiple pages have the same value for the sort criteria field`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `query with sort criteria works with pagination`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `state relevancy queries`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `unconsumed cash states sorted by state ref txnId and index`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `unconsumed cash states sorted by state ref`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `unconsumed fungible assets for selected issuer parties`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `unconsumed states with soft locking`()</ID>
    <ID>LongMethod:VaultRestartTest.kt$VaultRestartTest$@Test fun `restart and query vault after adding some cash states`()</ID>
    <ID>LongMethod:VaultStateMigration.kt$VaultStateMigration$override fun execute(database: Database?)</ID>
    <ID>LongMethod:VaultStateMigrationTest.kt$VaultStateMigrationTest$// Used to generate a persistent database for further testing. @Test @Ignore fun `Create persistent DB`()</ID>
    <ID>LongMethod:VaultStateMigrationTest.kt$VaultStateMigrationTest$@Test fun `Check state fields are correct`()</ID>
    <ID>LongMethod:VaultStateMigrationTest.kt$VaultStateMigrationTest$@Test fun `State with non-owning key for our name marked as relevant`()</ID>
    <ID>LongMethod:VaultStateMigrationTest.kt$VaultStateMigrationTest$private fun addNetworkParameters()</ID>
    <ID>LongMethod:VaultWithCashTest.kt$VaultWithCashTest$@Test fun `consuming multiple contract state types`()</ID>
    <ID>LongMethod:VaultWithCashTest.kt$VaultWithCashTest$@Test fun `issue and attempt double spend`()</ID>
    <ID>LongMethod:VaultWithCashTest.kt$VaultWithCashTest$@Test fun `issue and spend total correctly and irrelevant ignored`()</ID>
    <ID>LongMethod:VaultWithCashTest.kt$VaultWithCashTest$@Test fun `sequencing LinearStates works`()</ID>
    <ID>LongMethod:VaultWithCashTest.kt$VaultWithCashTest$@Test fun `spending cash in vault of mixed state types works`()</ID>
    <ID>LongMethod:VirtualCordapps.kt$VirtualCordapp$ fun generateBFTSmartNotary(versionInfo: VersionInfo): CordappImpl</ID>
    <ID>LongMethod:VirtualCordapps.kt$VirtualCordapp$ fun generateCore(versionInfo: VersionInfo): CordappImpl</ID>
    <ID>LongMethod:VirtualCordapps.kt$VirtualCordapp$ fun generateRaftNotary(versionInfo: VersionInfo): CordappImpl</ID>
    <ID>LongMethod:VirtualCordapps.kt$VirtualCordapp$ fun generateSimpleNotary(versionInfo: VersionInfo): CordappImpl</ID>
    <ID>LongMethod:WebServer.kt$WebServer$@Throws(IOException::class) fun open(config: NodeConfigWrapper): CordaFuture&lt;URI&gt;</ID>
    <ID>LongMethod:WebServer.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:WhitelistGenerator.kt$fun generateWhitelist(networkParameters: NetworkParameters?, excludeContracts: List&lt;ContractClassName&gt;, cordappJars: List&lt;ContractsJar&gt;, includeContracts: List&lt;ContractClassName&gt;, optionalCordappJars: List&lt;ContractsJar&gt;): Map&lt;ContractClassName, List&lt;AttachmentId&gt;&gt;</ID>
    <ID>LongMethod:WireTransaction.kt$WireTransaction$@DeleteForDJVM override fun toString(): String</ID>
    <ID>LongMethod:WireTransaction.kt$WireTransaction$private fun toLedgerTransactionInternal( resolveIdentity: (PublicKey) -&gt; Party?, resolveAttachment: (SecureHash) -&gt; Attachment?, resolveStateRefAsSerialized: (StateRef) -&gt; SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?, resolveParameters: (SecureHash?) -&gt; NetworkParameters?, resolveContractAttachment: (StateRef) -&gt; Attachment, isAttachmentTrusted: (Attachment) -&gt; Boolean ): LedgerTransaction</ID>
    <ID>LongMethod:WireTransaction.kt$WireTransaction.Companion$ @CordaInternal fun resolveStateRefBinaryComponent(stateRef: StateRef, services: ServicesForResolution): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?</ID>
    <ID>LongMethod:WithReferencedStatesFlow.kt$WithReferencedStatesFlow$@Suspendable override fun call(): T</ID>
    <ID>LongMethod:WorkflowTransactionBuildTutorial.kt$RecordCompletionFlow$@Suspendable override fun call()</ID>
    <ID>LongMethod:WorkflowTransactionBuildTutorial.kt$SubmitCompletionFlow$@Suspendable override fun call(): StateAndRef&lt;TradeApprovalContract.State&gt;</ID>
    <ID>LongMethod:WorkflowTransactionBuildTutorial.kt$TradeApprovalContract$ override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:WorkflowTransactionBuildTutorialTest.kt$WorkflowTransactionBuildTutorialTest$@Test fun `Run workflow to completion`()</ID>
    <ID>LongMethod:X509NameConstraintsTest.kt$X509NameConstraintsTest$@Test fun `illegal common name`()</ID>
    <ID>LongMethod:X509NameConstraintsTest.kt$X509NameConstraintsTest$@Test fun `x500 name with correct cn and extra attribute`()</ID>
    <ID>LongMethod:X509NameConstraintsTest.kt$X509NameConstraintsTest$private fun makeKeyStores(subjectName: X500Name, nameConstraints: NameConstraints): Pair&lt;X509KeyStore, X509KeyStore&gt;</ID>
    <ID>LongMethod:X509Utilities.kt$X509Utilities$ @JvmStatic fun createCertificate(certificateType: CertificateType, issuerCertificate: X509Certificate, issuerKeyPair: KeyPair, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Duration, Duration&gt; = DEFAULT_VALIDITY_WINDOW, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null): X509Certificate</ID>
    <ID>LongMethod:X509Utilities.kt$X509Utilities$ fun createCertificate(certificateType: CertificateType, issuer: X500Principal, issuerKeyPair: KeyPair, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Date, Date&gt;, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null): X509Certificate</ID>
    <ID>LongMethod:X509Utilities.kt$X509Utilities$ fun createPartialCertificate(certificateType: CertificateType, issuer: X500Principal, issuerPublicKey: PublicKey, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Date, Date&gt;, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null): X509v3CertificateBuilder</ID>
    <ID>LongMethod:X509UtilitiesTest.kt$X509UtilitiesTest$@Test fun `create server cert and use in SSL socket`()</ID>
    <ID>LongMethod:X509UtilitiesTest.kt$X509UtilitiesTest$@Test fun `create server certificate in keystore for SSL`()</ID>
    <ID>LongMethod:X509UtilitiesTest.kt$X509UtilitiesTest$private fun createValidServerCertIncludeCRL(signatureSchemeRoot: SignatureScheme, signatureSchemeChild: SignatureScheme)</ID>
    <ID>LongMethod:ZeroCouponBond.kt$ZeroCouponBond$@Test fun move()</ID>
    <ID>LongParameterList:AMQPSerializer.kt$AMQPSerializer$(obj: Any, data: Data, type: Type, output: SerializationOutput, context: SerializationContext, debugIndent: Int = 0)</ID>
    <ID>LongParameterList:AbstractCashSelection.kt$AbstractCashSelection$(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean)</ID>
    <ID>LongParameterList:AbstractCashSelection.kt$AbstractCashSelection$(services: ServiceHub, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, stateAndRefs: MutableList&lt;StateAndRef&lt;Cash.State&gt;&gt;)</ID>
    <ID>LongParameterList:AbstractCashSelection.kt$AbstractCashSelection$(services: ServiceHub, amount: Amount&lt;Currency&gt;, onlyFromIssuerParties: Set&lt;AbstractParty&gt; = emptySet(), notary: Party? = null, lockId: UUID, withIssuerRefs: Set&lt;OpaqueBytes&gt; = emptySet())</ID>
    <ID>LongParameterList:AbstractNode.kt$(databaseConfig: DatabaseConfig, wellKnownPartyFromX500Name: (CordaX500Name) -&gt; Party?, wellKnownPartyFromAnonymous: (AbstractParty) -&gt; Party?, schemaService: SchemaService, hikariProperties: Properties, cacheFactory: NamedCacheFactory, customClassLoader: ClassLoader?)</ID>
    <ID>LongParameterList:AbstractNode.kt$(hikariProperties: Properties, databaseConfig: DatabaseConfig, schemas: Set&lt;MappedSchema&gt;, metricRegistry: MetricRegistry? = null, cordappLoader: CordappLoader? = null, currentDir: Path? = null, ourName: CordaX500Name)</ID>
    <ID>LongParameterList:ArtemisMessagingServer.kt$ArtemisMessagingServer$(name: String, send: Boolean = false, consume: Boolean = false, createDurableQueue: Boolean = false, deleteDurableQueue: Boolean = false, createNonDurableQueue: Boolean = false, deleteNonDurableQueue: Boolean = false, manage: Boolean = false, browse: Boolean = false)</ID>
    <ID>LongParameterList:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$(configuration: MutualSslConfiguration, address: NetworkHostAndPort, adminAddress: NetworkHostAndPort, securityManager: RPCSecurityManager, maxMessageSize: Int, jmxEnabled: Boolean, baseDirectory: Path, shouldStartLocalShell: Boolean)</ID>
    <ID>LongParameterList:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$(configuration: MutualSslConfiguration, address: NetworkHostAndPort, adminAddress: NetworkHostAndPort, sslOptions: BrokerRpcSslOptions, securityManager: RPCSecurityManager, maxMessageSize: Int, jmxEnabled: Boolean, baseDirectory: Path, shouldStartLocalShell: Boolean)</ID>
    <ID>LongParameterList:ArtemisRpcTests.kt$ArtemisRpcTests$(nodeSSlconfig: MutualSslConfiguration, brokerSslOptions: BrokerRpcSslOptions?, useSslForBroker: Boolean, clientSslOptions: ClientRpcSslOptions?, address: NetworkHostAndPort = ports.nextHostAndPort(), adminAddress: NetworkHostAndPort = ports.nextHostAndPort(), baseDirectory: Path = tempFolder.root.toPath() )</ID>
    <ID>LongParameterList:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$(attachments: List&lt;Attachment&gt;, params: NetworkParameters, txId: SecureHash, isAttachmentTrusted: (Attachment) -&gt; Boolean, parent: ClassLoader = ClassLoader.getSystemClassLoader(), block: (ClassLoader) -&gt; T)</ID>
    <ID>LongParameterList:BFTSmart.kt$BFTSmart.Replica$( states: List&lt;StateRef&gt;, txId: SecureHash, callerName: CordaX500Name, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; = emptyList() )</ID>
    <ID>LongParameterList:BusinessCalendar.kt$BusinessCalendar.Companion$(startDate: LocalDate, period: Frequency, calendar: BusinessCalendar = EMPTY, dateRollConvention: DateRollConvention = DateRollConvention.Following, noOfAdditionalPeriods: Int = Integer.MAX_VALUE, endDate: LocalDate? = null, periodOffset: Int? = null)</ID>
    <ID>LongParameterList:Cash.kt$Cash$(inputs: List&lt;State&gt;, outputs: List&lt;State&gt;, tx: LedgerTransaction, issueCommand: CommandWithParties&lt;Commands.Issue&gt;, currency: Currency, issuer: PartyAndReference)</ID>
    <ID>LongParameterList:CashUtils.kt$CashUtils$(services: ServiceHub, tx: TransactionBuilder, amount: Amount&lt;Currency&gt;, ourIdentity: PartyAndCertificate, to: AbstractParty, onlyFromParties: Set&lt;AbstractParty&gt; = emptySet(), anonymous: Boolean = true)</ID>
    <ID>LongParameterList:CashUtils.kt$CashUtils$(services: ServiceHub, tx: TransactionBuilder, payments: List&lt;PartyAndAmount&lt;Currency&gt;&gt;, ourIdentity: PartyAndCertificate, onlyFromParties: Set&lt;AbstractParty&gt; = emptySet(), anonymous: Boolean = true)</ID>
    <ID>LongParameterList:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$(port: Int, name: CordaX500Name = ALICE_NAME, crlCheckSoftFail: Boolean, nodeCrlDistPoint: String = "http://${server.hostAndPort}/crl/node.crl", tlsCrlDistPoint: String? = "http://${server.hostAndPort}/crl/empty.crl", maxMessageSize: Int = MAX_MESSAGE_SIZE)</ID>
    <ID>LongParameterList:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.Companion$(clrServer: CrlServer, signatureAlgorithm: String, caCertificate: X509Certificate, caPrivateKey: PrivateKey, endpoint: String, indirect: Boolean, vararg serialNumbers: BigInteger)</ID>
    <ID>LongParameterList:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$(baseDirectory: Path, certificatesDirectoryName: String = DEFAULT_CERTIFICATES_DIRECTORY_NAME, keyStoreFileName: String = KeyStore.DEFAULT_STORE_FILE_NAME, keyStorePassword: String = KeyStore.DEFAULT_STORE_PASSWORD, keyPassword: String = keyStorePassword, trustStoreFileName: String = TrustStore.DEFAULT_STORE_FILE_NAME, trustStorePassword: String = TrustStore.DEFAULT_STORE_PASSWORD)</ID>
    <ID>LongParameterList:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$(certificatesDirectory: Path, keyStoreFileName: String = KeyStore.DEFAULT_STORE_FILE_NAME, keyStorePassword: String = KeyStore.DEFAULT_STORE_PASSWORD, keyPassword: String = keyStorePassword, trustStoreFileName: String = TrustStore.DEFAULT_STORE_FILE_NAME, trustStorePassword: String = TrustStore.DEFAULT_STORE_PASSWORD, trustStoreKeyPassword: String = TrustStore.DEFAULT_KEY_PASSWORD, useOpenSsl: Boolean = false)</ID>
    <ID>LongParameterList:ContractAttachment.kt$ContractAttachment.Companion$(attachment: Attachment, contract: ContractClassName, additionalContracts: Set&lt;ContractClassName&gt; = emptySet(), uploader: String? = null, signerKeys: List&lt;PublicKey&gt; = emptyList(), version: Int = DEFAULT_CORDAPP_VERSION)</ID>
    <ID>LongParameterList:ContractFunctions.kt$(expiry: String, notional: BigDecimal, strike: BigDecimal, foreignCurrency: Currency, domesticCurrency: Currency, partyA: Party, partyB: Party)</ID>
    <ID>LongParameterList:ContractFunctions.kt$(expiry: String, notional: Long, strike: Double, foreignCurrency: Currency, domesticCurrency: Currency, partyA: Party, partyB: Party)</ID>
    <ID>LongParameterList:ContractFunctions.kt$(partyA: Party, amountA: BigDecimal, currencyA: Currency, partyB: Party, amountB: BigDecimal, currencyB: Currency)</ID>
    <ID>LongParameterList:ContractJarTestUtils.kt$ContractJarTestUtils$(workingDir: Path, contractNames: List&lt;String&gt;, signed: Boolean = false, version: Int = 1, generateManifest: Boolean = true, jarFileName : String? = null)</ID>
    <ID>LongParameterList:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt; = this.inputs, notary: Party = this.notary, legacyContractAttachment: Attachment = this.legacyContractAttachment, upgradedContractClassName: ContractClassName = this.upgradedContract::class.java.name, upgradedContractAttachment: Attachment = this.upgradedContractAttachment, id: SecureHash = this.id, privacySalt: PrivacySalt = this.privacySalt, sigs: List&lt;TransactionSignature&gt; = this.sigs, networkParameters: NetworkParameters = this.networkParameters )</ID>
    <ID>LongParameterList:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction.Companion$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, notary: Party, legacyContractAttachment: Attachment, upgradedContractAttachment: Attachment, id: SecureHash, privacySalt: PrivacySalt, sigs: List&lt;TransactionSignature&gt;, networkParameters: NetworkParameters, upgradedContract: UpgradedContract&lt;ContractState, *&gt; )</ID>
    <ID>LongParameterList:CordaRPCClient.kt$CordaRPCClient$(username: String, password: String, externalTrace: Trace?, impersonatedActor: Actor?, targetLegalIdentity: CordaX500Name?, gracefulReconnect: Boolean = false)</ID>
    <ID>LongParameterList:CordaRPCClient.kt$CordaRPCClientConfiguration$( connectionMaxRetryInterval: Duration = this.connectionMaxRetryInterval, minimumServerProtocolVersion: Int = this.minimumServerProtocolVersion, trackRpcCallSites: Boolean = this.trackRpcCallSites, reapInterval: Duration = this.reapInterval, observationExecutorPoolSize: Int = this.observationExecutorPoolSize, cacheConcurrencyLevel: Int = this.cacheConcurrencyLevel, connectionRetryInterval: Duration = this.connectionRetryInterval, connectionRetryIntervalMultiplier: Double = this.connectionRetryIntervalMultiplier, maxReconnectAttempts: Int = this.maxReconnectAttempts, maxFileSize: Int = this.maxFileSize, deduplicationCacheExpiry: Duration = this.deduplicationCacheExpiry )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("UNUSED_PARAMETER") flowConstructor: (A, B, C, D, E) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("UNUSED_PARAMETER") flowConstructor: (A, B, C, D, E, F) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E, arg5: F )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("unused_parameter") flowConstructor: (A, B, C, D, E) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("unused_parameter") flowConstructor: (A, B, C, D, E, F) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E, arg5: F )</ID>
    <ID>LongParameterList:Driver.kt$DriverParameters$( isDebug: Boolean, driverDirectory: Path, portAllocation: PortAllocation, debugPortAllocation: PortAllocation, systemProperties: Map&lt;String, String&gt;, useTestClock: Boolean, startNodesInProcess: Boolean, waitForAllNodesToFinish: Boolean, notarySpecs: List&lt;NotarySpec&gt;, extraCordappPackagesToScan: List&lt;String&gt;, jmxPolicy: JmxPolicy, networkParameters: NetworkParameters )</ID>
    <ID>LongParameterList:Driver.kt$DriverParameters$( isDebug: Boolean, driverDirectory: Path, portAllocation: PortAllocation, debugPortAllocation: PortAllocation, systemProperties: Map&lt;String, String&gt;, useTestClock: Boolean, startNodesInProcess: Boolean, waitForAllNodesToFinish: Boolean, notarySpecs: List&lt;NotarySpec&gt;, extraCordappPackagesToScan: List&lt;String&gt;, jmxPolicy: JmxPolicy, networkParameters: NetworkParameters, cordappsForAllNodes: Set&lt;TestCordapp&gt;? )</ID>
    <ID>LongParameterList:DriverDSL.kt$DriverDSL$( defaultParameters: NodeParameters = NodeParameters(), providedName: CordaX500Name? = defaultParameters.providedName, rpcUsers: List&lt;User&gt; = defaultParameters.rpcUsers, verifierType: VerifierType = defaultParameters.verifierType, customOverrides: Map&lt;String, Any?&gt; = defaultParameters.customOverrides, startInSameProcess: Boolean? = defaultParameters.startInSameProcess, maximumHeapSize: String = defaultParameters.maximumHeapSize )</ID>
    <ID>LongParameterList:DriverDSL.kt$DriverDSL$( defaultParameters: NodeParameters = NodeParameters(), providedName: CordaX500Name? = defaultParameters.providedName, rpcUsers: List&lt;User&gt; = defaultParameters.rpcUsers, verifierType: VerifierType = defaultParameters.verifierType, customOverrides: Map&lt;String, Any?&gt; = defaultParameters.customOverrides, startInSameProcess: Boolean? = defaultParameters.startInSameProcess, maximumHeapSize: String = defaultParameters.maximumHeapSize, logLevelOverride: String? = defaultParameters.logLevelOverride )</ID>
    <ID>LongParameterList:DriverDSLImpl.kt$( isDebug: Boolean = DriverParameters().isDebug, driverDirectory: Path = DriverParameters().driverDirectory, portAllocation: PortAllocation = DriverParameters().portAllocation, debugPortAllocation: PortAllocation = DriverParameters().debugPortAllocation, systemProperties: Map&lt;String, String&gt; = DriverParameters().systemProperties, useTestClock: Boolean = DriverParameters().useTestClock, startNodesInProcess: Boolean = DriverParameters().startNodesInProcess, extraCordappPackagesToScan: List&lt;String&gt; = DriverParameters().extraCordappPackagesToScan, waitForAllNodesToFinish: Boolean = DriverParameters().waitForAllNodesToFinish, notarySpecs: List&lt;NotarySpec&gt; = DriverParameters().notarySpecs, jmxPolicy: JmxPolicy = DriverParameters().jmxPolicy, networkParameters: NetworkParameters = DriverParameters().networkParameters, compatibilityZone: CompatibilityZoneParams? = null, notaryCustomOverrides: Map&lt;String, Any?&gt; = DriverParameters().notaryCustomOverrides, inMemoryDB: Boolean = DriverParameters().inMemoryDB, cordappsForAllNodes: Collection&lt;TestCordappInternal&gt;? = null, dsl: DriverDSLImpl.() -&gt; A )</ID>
    <ID>LongParameterList:DriverDSLImpl.kt$DriverDSLImpl.Companion$( config: NodeConfig, quasarJarPath: String, debugPort: Int?, overriddenSystemProperties: Map&lt;String, String&gt;, maximumHeapSize: String, logLevelOverride: String?, vararg extraCmdLineFlag: String )</ID>
    <ID>LongParameterList:DummyFungibleContract.kt$DummyFungibleContract$(inputs: List&lt;State&gt;, outputs: List&lt;State&gt;, tx: LedgerTransaction, issueCommand: CommandWithParties&lt;Commands.Issue&gt;, currency: Currency, issuer: PartyAndReference)</ID>
    <ID>LongParameterList:IRS.kt$FloatingRatePaymentEvent$(date: LocalDate = this.date, accrualStartDate: LocalDate = this.accrualStartDate, accrualEndDate: LocalDate = this.accrualEndDate, dayCountBasisDay: DayCountBasisDay = this.dayCountBasisDay, dayCountBasisYear: DayCountBasisYear = this.dayCountBasisYear, fixingDate: LocalDate = this.fixingDate, notional: Amount&lt;Currency&gt; = this.notional, rate: Rate = this.rate)</ID>
    <ID>LongParameterList:IRS.kt$InterestRateSwap$(floatingLeg: FloatingLeg, fixedLeg: FixedLeg, calculation: Calculation, common: Common, oracle: Party, notary: Party)</ID>
    <ID>LongParameterList:IRS.kt$InterestRateSwap.FixedLeg$(fixedRatePayer: AbstractParty = this.fixedRatePayer, notional: Amount&lt;Currency&gt; = this.notional, paymentFrequency: Frequency = this.paymentFrequency, effectiveDate: LocalDate = this.effectiveDate, effectiveDateAdjustment: DateRollConvention? = this.effectiveDateAdjustment, terminationDate: LocalDate = this.terminationDate, terminationDateAdjustment: DateRollConvention? = this.terminationDateAdjustment, dayCountBasisDay: DayCountBasisDay = this.dayCountBasisDay, dayCountBasisYear: DayCountBasisYear = this.dayCountBasisYear, dayInMonth: Int = this.dayInMonth, paymentRule: PaymentRule = this.paymentRule, paymentDelay: Int = this.paymentDelay, paymentCalendar: BusinessCalendar = this.paymentCalendar, interestPeriodAdjustment: AccrualAdjustment = this.interestPeriodAdjustment, fixedRate: FixedRate = this.fixedRate)</ID>
    <ID>LongParameterList:IRS.kt$InterestRateSwap.FloatingLeg$(floatingRatePayer: AbstractParty = this.floatingRatePayer, notional: Amount&lt;Currency&gt; = this.notional, paymentFrequency: Frequency = this.paymentFrequency, effectiveDate: LocalDate = this.effectiveDate, effectiveDateAdjustment: DateRollConvention? = this.effectiveDateAdjustment, terminationDate: LocalDate = this.terminationDate, terminationDateAdjustment: DateRollConvention? = this.terminationDateAdjustment, dayCountBasisDay: DayCountBasisDay = this.dayCountBasisDay, dayCountBasisYear: DayCountBasisYear = this.dayCountBasisYear, dayInMonth: Int = this.dayInMonth, paymentRule: PaymentRule = this.paymentRule, paymentDelay: Int = this.paymentDelay, paymentCalendar: BusinessCalendar = this.paymentCalendar, interestPeriodAdjustment: AccrualAdjustment = this.interestPeriodAdjustment, rollConvention: DateRollConvention = this.rollConvention, fixingRollConvention: DateRollConvention = this.fixingRollConvention, resetDayInMonth: Int = this.resetDayInMonth, fixingPeriod: Int = this.fixingPeriodOffset, resetRule: PaymentRule = this.resetRule, fixingsPerPayment: Frequency = this.fixingsPerPayment, fixingCalendar: BusinessCalendar = this.fixingCalendar, index: String = this.index, indexSource: String = this.indexSource, indexTenor: Tenor = this.indexTenor )</ID>
    <ID>LongParameterList:IdenticonRenderer.kt$IdenticonRenderer$(g: GraphicsContext, x: Double, y: Double, patchIndex: Int, turn: Int, patchSize: Double, _invert: Boolean, color: PatchColor)</ID>
    <ID>LongParameterList:Injectors.kt$( metricRegistry: MetricRegistry, parallelism: Int, overallDuration: Duration, injectionRate: Rate, queueSizeMetricName: String = "QueueSize", workDurationMetricName: String = "WorkDuration", work: () -&gt; Unit )</ID>
    <ID>LongParameterList:InteractiveShell.kt$InteractiveShell$(nameFragment: String, inputData: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, ansiProgressRenderer: ANSIProgressRenderer, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps))</ID>
    <ID>LongParameterList:InternalTestUtils.kt$(hikariProperties: Properties, databaseConfig: DatabaseConfig, wellKnownPartyFromX500Name: (CordaX500Name) -&gt; Party?, wellKnownPartyFromAnonymous: (AbstractParty) -&gt; Party?, schemaService: SchemaService = NodeSchemaService(), internalSchemas: Set&lt;MappedSchema&gt; = NodeSchemaService().internalSchemas(), cacheFactory: NamedCacheFactory = TestingNamedCacheFactory(), ourName: CordaX500Name = TestIdentity(ALICE_NAME, 70).name)</ID>
    <ID>LongParameterList:InternalTestUtils.kt$(inputs: List&lt;StateRef&gt;, attachments: List&lt;SecureHash&gt;, outputs: List&lt;TransactionState&lt;*&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt = PrivacySalt())</ID>
    <ID>LongParameterList:JarSignatureTestUtils.kt$JarSignatureTestUtils$(alias: String = "Test", storePassword: String = "secret!", name: String = CODE_SIGNER.toString(), keyalg: String = "RSA", keyPassword: String = storePassword, storeName: String = "_teststore")</ID>
    <ID>LongParameterList:LedgerTransaction.kt$LedgerTransaction$(inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt; = this.inputs, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt; = this.outputs, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt; = this.commands, attachments: List&lt;Attachment&gt; = this.attachments, id: SecureHash = this.id, notary: Party? = this.notary, timeWindow: TimeWindow? = this.timeWindow, privacySalt: PrivacySalt = this.privacySalt, networkParameters: NetworkParameters? = this.networkParameters )</ID>
    <ID>LongParameterList:LedgerTransaction.kt$LedgerTransaction$(inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt )</ID>
    <ID>LongParameterList:LedgerTransaction.kt$LedgerTransaction.Companion$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt, networkParameters: NetworkParameters, references: List&lt;StateAndRef&lt;ContractState&gt;&gt;, componentGroups: List&lt;ComponentGroup&gt;? = null, serializedInputs: List&lt;SerializedStateAndRef&gt;? = null, serializedReferences: List&lt;SerializedStateAndRef&gt;? = null, isAttachmentTrusted: (Attachment) -&gt; Boolean )</ID>
    <ID>LongParameterList:MockServices.kt$MockServices.Companion$( cordappLoader: CordappLoader, identityService: IdentityService, networkParameters: NetworkParameters, initialIdentity: TestIdentity, moreKeys: Set&lt;KeyPair&gt;, keyManagementService: KeyManagementService, schemaService: SchemaService, persistence: CordaPersistence )</ID>
    <ID>LongParameterList:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$(copyCordapps: CopyCordapps = CopyCordapps.FirstRunOnly, packageOwnership: Map&lt;String, PublicKey&gt;? = emptyMap(), minimumPlatformVerison: Int? = PLATFORM_VERSION, maxMessageSize: Int? = DEFAULT_MAX_MESSAGE_SIZE, maxTransactionSize: Int? = DEFAULT_MAX_TRANSACTION_SIZE, eventHorizon: Duration? = 30.days)</ID>
    <ID>LongParameterList:NetworkMapUpdater.kt$NetworkMapUpdater$(trustRoot: X509Certificate, currentParametersHash: SecureHash, ourNodeInfo: SignedNodeInfo, networkParameters: NetworkParameters, keyManagementService: KeyManagementService, networkParameterAcceptanceSettings: NetworkParameterAcceptanceSettings)</ID>
    <ID>LongParameterList:NetworkParameters.kt$NetworkParameters$(minimumPlatformVersion: Int = this.minimumPlatformVersion, notaries: List&lt;NotaryInfo&gt; = this.notaries, maxMessageSize: Int = this.maxMessageSize, maxTransactionSize: Int = this.maxTransactionSize, modifiedTime: Instant = this.modifiedTime, epoch: Int = this.epoch, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = this.whitelistedContractImplementations )</ID>
    <ID>LongParameterList:NetworkParameters.kt$NetworkParameters$(minimumPlatformVersion: Int = this.minimumPlatformVersion, notaries: List&lt;NotaryInfo&gt; = this.notaries, maxMessageSize: Int = this.maxMessageSize, maxTransactionSize: Int = this.maxTransactionSize, modifiedTime: Instant = this.modifiedTime, epoch: Int = this.epoch, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = this.whitelistedContractImplementations, eventHorizon: Duration = this.eventHorizon )</ID>
    <ID>LongParameterList:NodeConfigTest.kt$NodeConfigTest$( legalName: CordaX500Name = CordaX500Name(organisation = "Unknown", locality = "Nowhere", country = "GB"), p2pPort: Int = -1, rpcPort: Int = -1, rpcAdminPort: Int = -1, webPort: Int = -1, h2port: Int = -1, notary: NotaryService?, users: List&lt;User&gt; = listOf(user("guest")), issuableCurrencies: List&lt;String&gt; = emptyList() )</ID>
    <ID>LongParameterList:NodeControllerTest.kt$NodeControllerTest$( organisation: String = "Unknown", p2pPort: Int = 0, rpcPort: Int = 0, rpcAdminPort: Int = 0, webPort: Int = 0, h2port: Int = 0, notary: NotaryService? = null, users: List&lt;User&gt; = listOf(user("guest")) )</ID>
    <ID>LongParameterList:NodeParameters.kt$NodeParameters$( providedName: CordaX500Name?, rpcUsers: List&lt;User&gt;, verifierType: VerifierType, customOverrides: Map&lt;String, Any?&gt;, startInSameProcess: Boolean?, maximumHeapSize: String )</ID>
    <ID>LongParameterList:NodeParameters.kt$NodeParameters$( providedName: CordaX500Name?, rpcUsers: List&lt;User&gt;, verifierType: VerifierType, customOverrides: Map&lt;String, Any?&gt;, startInSameProcess: Boolean?, maximumHeapSize: String, additionalCordapps: Collection&lt;TestCordapp&gt; = emptySet(), flowOverrides: Map&lt;out Class&lt;out FlowLogic&lt;*&gt;&gt;, Class&lt;out FlowLogic&lt;*&gt;&gt;&gt; )</ID>
    <ID>LongParameterList:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction.Companion$(inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, notary: Party, newNotary: Party, id: SecureHash, sigs: List&lt;TransactionSignature&gt;, networkParameters: NetworkParameters)</ID>
    <ID>LongParameterList:ObjectSerializer.kt$ComposableObjectWriter$(obj: Any, data: Data, type: Type, output: SerializationOutput, context: SerializationContext, debugIndent: Int)</ID>
    <ID>LongParameterList:ObjectSerializer.kt$EvolutionObjectSerializer.Companion$(localTypeInformation: LocalTypeInformation.Composable, remoteTypeInformation: RemoteTypeInformation.Composable, constructor: LocalConstructorInformation, properties: Map&lt;String, LocalPropertyInformation&gt;, classLoader: ClassLoader, mustPreserveData: Boolean)</ID>
    <ID>LongParameterList:ObligationUtils.kt$ObligationUtils$(tx: TransactionBuilder, obligor: AbstractParty, acceptableContract: SecureHash, amount: Amount&lt;Issued&lt;Currency&gt;&gt;, dueBefore: Instant, beneficiary: AbstractParty, notary: Party)</ID>
    <ID>LongParameterList:ObligationUtils.kt$ObligationUtils$(tx: TransactionBuilder, obligor: AbstractParty, issuanceDef: Obligation.Terms&lt;P&gt;, pennies: Long, beneficiary: AbstractParty, notary: Party)</ID>
    <ID>LongParameterList:OnLedgerAsset.kt$OnLedgerAsset.Companion$(tx: TransactionBuilder, amount: Amount&lt;T&gt;, to: AbstractParty, acceptableStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData)</ID>
    <ID>LongParameterList:OnLedgerAsset.kt$OnLedgerAsset.Companion$(tx: TransactionBuilder, amountIssued: Amount&lt;Issued&lt;T&gt;&gt;, assetStates: List&lt;StateAndRef&lt;S&gt;&gt;, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData, generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData)</ID>
    <ID>LongParameterList:OnLedgerAsset.kt$OnLedgerAsset.Companion$(tx: TransactionBuilder, amountIssued: Amount&lt;Issued&lt;T&gt;&gt;, assetStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData, generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData)</ID>
    <ID>LongParameterList:OnLedgerAsset.kt$OnLedgerAsset.Companion$(tx: TransactionBuilder, payments: List&lt;PartyAndAmount&lt;T&gt;&gt;, acceptableStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData)</ID>
    <ID>LongParameterList:ParametersUtilities.kt$( notaries: List&lt;NotaryInfo&gt; = emptyList(), minimumPlatformVersion: Int = 1, modifiedTime: Instant = Instant.now(), maxMessageSize: Int = 10485760, // TODO: Make this configurable and consistence across driver, bootstrapper, demobench and NetworkMapServer maxTransactionSize: Int = maxMessageSize * 50, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = emptyMap(), epoch: Int = 1, eventHorizon: Duration = 30.days, packageOwnership: Map&lt;String, PublicKey&gt; = emptyMap() )</ID>
    <ID>LongParameterList:PersistentUniquenessProvider.kt$PersistentUniquenessProvider$( states: List&lt;StateRef&gt;, txId: SecureHash, callerIdentity: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; )</ID>
    <ID>LongParameterList:PhysicalLocationStructures.kt$WorldCoordinate$(screenWidth: Double, screenHeight: Double, topLatitude: Double, bottomLatitude: Double, leftLongitude: Double, rightLongitude: Double)</ID>
    <ID>LongParameterList:ProcessUtilities.kt$ProcessUtilities$( arguments: List&lt;String&gt;, classPath: List&lt;String&gt; = defaultClassPath, workingDirectory: Path? = null, jdwpPort: Int? = null, extraJvmArguments: List&lt;String&gt; = emptyList(), maximumHeapSize: String? = null )</ID>
    <ID>LongParameterList:ProcessUtilities.kt$ProcessUtilities$( className: String, arguments: List&lt;String&gt;, classPath: List&lt;String&gt; = defaultClassPath, workingDirectory: Path? = null, jdwpPort: Int? = null, extraJvmArguments: List&lt;String&gt; = emptyList(), maximumHeapSize: String? = null )</ID>
    <ID>LongParameterList:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$( participants: List&lt;AbstractParty&gt;? = this.participants, owner: List&lt;AbstractParty&gt;? = this.owner, quantity: ColumnPredicate&lt;Long&gt;? = this.quantity, issuer: List&lt;AbstractParty&gt;? = this.issuer, issuerRef: List&lt;OpaqueBytes&gt;? = this.issuerRef, status: Vault.StateStatus = this.status, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = this.contractStateTypes )</ID>
    <ID>LongParameterList:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, stateRefs: List&lt;StateRef&gt;? = null, notary: List&lt;AbstractParty&gt;? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: Vault.RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt; = emptySet(), constraints: Set&lt;Vault.ConstraintInfo&gt; = emptySet(), participants: List&lt;AbstractParty&gt;? = null )</ID>
    <ID>LongParameterList:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = this.status, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = this.contractStateTypes, stateRefs: List&lt;StateRef&gt;? = this.stateRefs, notary: List&lt;AbstractParty&gt;? = this.notary, softLockingCondition: SoftLockingCondition? = this.softLockingCondition, timeCondition: TimeCondition? = this.timeCondition )</ID>
    <ID>LongParameterList:RPCClient.kt$RPCClient$( rpcOpsClass: Class&lt;I&gt;, username: String, password: String, externalTrace: Trace? = null, impersonatedActor: Actor? = null, targetLegalIdentity: CordaX500Name? = null )</ID>
    <ID>LongParameterList:RPCDriver.kt$( isDebug: Boolean = false, driverDirectory: Path = Paths.get("build") / "rpc-driver" / getTimestampAsDirectoryName(), portAllocation: PortAllocation = globalPortAllocation, debugPortAllocation: PortAllocation = globalDebugPortAllocation, systemProperties: Map&lt;String, String&gt; = emptyMap(), useTestClock: Boolean = false, startNodesInProcess: Boolean = false, waitForNodesToFinish: Boolean = false, extraCordappPackagesToScan: List&lt;String&gt; = emptyList(), notarySpecs: List&lt;NotarySpec&gt; = emptyList(), externalTrace: Trace? = null, @Suppress("DEPRECATION") jmxPolicy: JmxPolicy = JmxPolicy(), networkParameters: NetworkParameters = testNetworkParameters(), notaryCustomOverrides: Map&lt;String, Any?&gt; = emptyMap(), inMemoryDB: Boolean = true, cordappsForAllNodes: Collection&lt;TestCordappInternal&gt;? = null, dsl: RPCDriverDSL.() -&gt; A )</ID>
    <ID>LongParameterList:RPCDriver.kt$RPCDriverDSL$( rpcUser: User = rpcTestUser, nodeLegalName: CordaX500Name = fakeNodeLegalName, configuration: RPCServerConfiguration = RPCServerConfiguration.DEFAULT, ops: I, brokerHandle: RpcBrokerHandle, queueDrainTimeout: Duration = 5.seconds )</ID>
    <ID>LongParameterList:RPCDriver.kt$RPCDriverDSL$( rpcUser: User = rpcTestUser, nodeLegalName: CordaX500Name = fakeNodeLegalName, maxFileSize: Int = MAX_MESSAGE_SIZE, maxBufferedBytesPerClient: Long = 10L * MAX_MESSAGE_SIZE, configuration: RPCServerConfiguration = RPCServerConfiguration.DEFAULT, ops: I, queueDrainTimeout: Duration = 5.seconds )</ID>
    <ID>LongParameterList:RPCDriver.kt$RPCDriverDSL$( serverName: String = "driver-rpc-server-${random63BitValue()}", rpcUser: User = rpcTestUser, nodeLegalName: CordaX500Name = fakeNodeLegalName, maxFileSize: Int = MAX_MESSAGE_SIZE, maxBufferedBytesPerClient: Long = 5L * MAX_MESSAGE_SIZE, configuration: RPCServerConfiguration = RPCServerConfiguration.DEFAULT, customPort: NetworkHostAndPort? = null, ops: I )</ID>
    <ID>LongParameterList:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$(name: String, send: Boolean = false, consume: Boolean = false, createDurableQueue: Boolean = false, deleteDurableQueue: Boolean = false, createNonDurableQueue: Boolean = false, deleteNonDurableQueue: Boolean = false, manage: Boolean = false, browse: Boolean = false)</ID>
    <ID>LongParameterList:SerializationEnvironment.kt$SerializationEnvironment.Companion$( serializationFactory: SerializationFactory, p2pContext: SerializationContext, rpcServerContext: SerializationContext? = null, rpcClientContext: SerializationContext? = null, storageContext: SerializationContext? = null, checkpointContext: CheckpointSerializationContext? = null, checkpointSerializer: CheckpointSerializer? = null )</ID>
    <ID>LongParameterList:SerializerFactoryBuilder.kt$SerializerFactoryBuilder$( whitelist: ClassWhitelist, carpenterClassLoader: ClassLoader, lenientCarpenterEnabled: Boolean = false, descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry = DefaultDescriptorBasedSerializerRegistry(), allowEvolution: Boolean = true, overrideFingerPrinter: FingerPrinter? = null, onlyCustomSerializers: Boolean = false, mustPreserveDataWhenEvolving: Boolean = false)</ID>
    <ID>LongParameterList:SerializerFactoryBuilder.kt$SerializerFactoryBuilder$( whitelist: ClassWhitelist, classCarpenter: ClassCarpenter, descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry = DefaultDescriptorBasedSerializerRegistry(), allowEvolution: Boolean = true, overrideFingerPrinter: FingerPrinter? = null, onlyCustomSerializers: Boolean = false, mustPreserveDataWhenEvolving: Boolean = false)</ID>
    <ID>LongParameterList:SerializerFactoryBuilder.kt$SerializerFactoryBuilder$(whitelist: ClassWhitelist, classCarpenter: ClassCarpenter, descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry, allowEvolution: Boolean, overrideFingerPrinter: FingerPrinter?, onlyCustomSerializers: Boolean, mustPreserveDataWhenEvolving: Boolean)</ID>
    <ID>LongParameterList:ServiceHubInternal.kt$ServiceHubInternal.Companion$(statesToRecord: StatesToRecord, txs: Collection&lt;SignedTransaction&gt;, validatedTransactions: WritableTransactionStorage, stateMachineRecordedTransactionMapping: StateMachineRecordedTransactionMappingStorage, vaultService: VaultServiceInternal, database: CordaPersistence)</ID>
    <ID>LongParameterList:SignatureConstraintVersioningTests.kt$SignatureConstraintVersioningTests$( cordapp: CustomCordapp, newCordapp: CustomCordapp, whiteListedCordapps: Map&lt;ContractClassName, List&lt;CustomCordapp&gt;&gt;, systemProperties: Map&lt;String, String&gt;, startNodesInProcess: Boolean, minimumPlatformVersion: Int = 4, specifyExistingConstraint: Boolean = false, addAnotherAutomaticConstraintState: Boolean = false )</ID>
    <ID>LongParameterList:SinglePartyNotaryService.kt$SinglePartyNotaryService$( inputs: List&lt;StateRef&gt;, txId: SecureHash, caller: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; )</ID>
    <ID>LongParameterList:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$( flowLogic: FlowLogic&lt;A&gt;, initiatingMessageDeduplicationHandler: DeduplicationHandler, peerSession: FlowSessionImpl, initiatedSessionId: SessionId, initiatingMessage: InitialSessionMessage, senderCoreFlowVersion: Int?, initiatedFlowInfo: FlowInfo )</ID>
    <ID>LongParameterList:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$( invocationContext: InvocationContext, flowLogic: FlowLogic&lt;A&gt;, flowStart: FlowStart, ourIdentity: Party, deduplicationHandler: DeduplicationHandler?, isStartIdempotent: Boolean )</ID>
    <ID>LongParameterList:StateMachineState.kt$Checkpoint.Companion$( invocationContext: InvocationContext, flowStart: FlowStart, flowLogicClass: Class&lt;FlowLogic&lt;*&gt;&gt;, frozenFlowLogic: SerializedBytes&lt;FlowLogic&lt;*&gt;&gt;, ourIdentity: Party, subFlowVersion: SubFlowVersion, isEnabledTimedFlow: Boolean )</ID>
    <ID>LongParameterList:TLSAuthenticationTests.kt$TLSAuthenticationTests$( rootCAScheme: SignatureScheme, intermediateCAScheme: SignatureScheme, client1CAScheme: SignatureScheme, client1TLSScheme: SignatureScheme, client2CAScheme: SignatureScheme, client2TLSScheme: SignatureScheme )</ID>
    <ID>LongParameterList:TLSAuthenticationTests.kt$TLSAuthenticationTests$( serverSocketFactory: SSLServerSocketFactory, clientSocketFactory: SSLSocketFactory, serverPort: Int = 0, // Use 0 to get first free socket. clientPort: Int = 0, // Use 0 to get first free socket. cipherSuitesServer: Array&lt;String&gt; = CORDA_TLS_CIPHER_SUITES, cipherSuitesClient: Array&lt;String&gt; = CORDA_TLS_CIPHER_SUITES )</ID>
    <ID>LongParameterList:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$(contractClassName: ContractClassName, label: String?, notary: Party, encumbrance: Int?, attachmentConstraint: AttachmentConstraint, contractState: ContractState)</ID>
    <ID>LongParameterList:TransactionUtils.kt$(componentGroups: List&lt;ComponentGroup&gt;, clazz: KClass&lt;T&gt;, groupEnum: ComponentGroupEnum, forceDeserialize: Boolean = false, factory: SerializationFactory = SerializationFactory.defaultFactory, context: SerializationContext = factory.defaultContext)</ID>
    <ID>LongParameterList:TransactionUtils.kt$(inputs: List&lt;StateRef&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, attachments: List&lt;SecureHash&gt;, notary: Party?, timeWindow: TimeWindow?, references: List&lt;StateRef&gt;, networkParametersHash: SecureHash?)</ID>
    <ID>LongParameterList:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$( withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, amount: Amount&lt;Issued&lt;Currency&gt;&gt;, attachmentID: SecureHash?, notary: Party)</ID>
    <ID>LongParameterList:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$( withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, notary: Party, node: TestStartedNode, identity: Party, notaryNode: TestStartedNode, vararg extraSigningNodes: TestStartedNode )</ID>
    <ID>LongParameterList:UniquenessProvider.kt$UniquenessProvider$( states: List&lt;StateRef&gt;, txId: SecureHash, callerIdentity: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow? = null, references: List&lt;StateRef&gt; = emptyList() )</ID>
    <ID>LongParameterList:VaultFiller.kt$VaultFiller$(howMuch: Amount&lt;Currency&gt;, issuerServices: ServiceHub, atLeastThisManyStates: Int, atMostThisManyStates: Int, issuedBy: PartyAndReference, owner: AbstractParty? = null, rng: Random? = null, statesToRecord: StatesToRecord = StatesToRecord.ONLY_RELEVANT)</ID>
    <ID>LongParameterList:VaultFiller.kt$VaultFiller$(howMuch: Amount&lt;Currency&gt;, issuerServices: ServiceHub, thisManyStates: Int, issuedBy: PartyAndReference, owner: AbstractParty? = null, rng: Random? = null, statesToRecord: StatesToRecord = StatesToRecord.ONLY_RELEVANT)</ID>
    <ID>LongParameterList:VaultFiller.kt$VaultFiller$(numberToCreate: Int, externalId: String? = null, participants: List&lt;AbstractParty&gt; = emptyList(), linearString: String = "", linearNumber: Long = 0L, linearBoolean: Boolean = false, linearTimestamp: Instant = now())</ID>
    <ID>LongParameterList:VaultFiller.kt$VaultFiller$(numberToCreate: Int, externalId: String? = null, participants: List&lt;AbstractParty&gt; = emptyList(), uniqueIdentifier: UniqueIdentifier? = null, linearString: String = "", linearNumber: Long = 0L, linearBoolean: Boolean = false, linearTimestamp: Instant = now(), constraint: AttachmentConstraint = AutomaticPlaceholderConstraint, includeMe: Boolean = true)</ID>
    <ID>LongParameterList:VaultService.kt$Vault.StateMetadata$( ref: StateRef = this.ref, contractStateClassName: String = this.contractStateClassName, recordedTime: Instant = this.recordedTime, consumedTime: Instant? = this.consumedTime, status: Vault.StateStatus = this.status, notary: AbstractParty? = this.notary, lockId: String? = this.lockId, lockUpdateTime: Instant? = this.lockUpdateTime )</ID>
    <ID>LongParameterList:VaultService.kt$Vault.StateMetadata$( ref: StateRef = this.ref, contractStateClassName: String = this.contractStateClassName, recordedTime: Instant = this.recordedTime, consumedTime: Instant? = this.consumedTime, status: Vault.StateStatus = this.status, notary: AbstractParty? = this.notary, lockId: String? = this.lockId, lockUpdateTime: Instant? = this.lockUpdateTime, relevancyStatus: Vault.RelevancyStatus? )</ID>
    <ID>LongParameterList:WireTransaction.kt$WireTransaction$( resolveIdentity: (PublicKey) -&gt; Party?, resolveAttachment: (SecureHash) -&gt; Attachment?, resolveStateRefAsSerialized: (StateRef) -&gt; SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?, resolveParameters: (SecureHash?) -&gt; NetworkParameters?, resolveContractAttachment: (StateRef) -&gt; Attachment, isAttachmentTrusted: (Attachment) -&gt; Boolean )</ID>
    <ID>LongParameterList:WireTransaction.kt$WireTransaction.Companion$(inputs: List&lt;StateRef&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, attachments: List&lt;SecureHash&gt;, notary: Party?, timeWindow: TimeWindow?)</ID>
    <ID>LongParameterList:X509Utilities.kt$X509Utilities$(certificateType: CertificateType, issuer: X500Principal, issuerKeyPair: KeyPair, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Date, Date&gt;, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null)</ID>
    <ID>LongParameterList:X509Utilities.kt$X509Utilities$(certificateType: CertificateType, issuer: X500Principal, issuerPublicKey: PublicKey, issuerSigner: ContentSigner, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Date, Date&gt;, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null)</ID>
    <ID>LongParameterList:X509Utilities.kt$X509Utilities$(certificateType: CertificateType, issuer: X500Principal, issuerPublicKey: PublicKey, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Date, Date&gt;, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null)</ID>
    <ID>LongParameterList:X509Utilities.kt$X509Utilities$(certificateType: CertificateType, issuerCertificate: X509Certificate, issuerKeyPair: KeyPair, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Duration, Duration&gt; = DEFAULT_VALIDITY_WINDOW, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null)</ID>
    <ID>LongParameterList:internalAccessTestHelpers.kt$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt, networkParameters: NetworkParameters, references: List&lt;StateAndRef&lt;ContractState&gt;&gt;, componentGroups: List&lt;ComponentGroup&gt;? = null, serializedInputs: List&lt;SerializedStateAndRef&gt;? = null, serializedReferences: List&lt;SerializedStateAndRef&gt;? = null, isAttachmentTrusted: (Attachment) -&gt; Boolean )</ID>
    <ID>MagicNumber:AMQPBridgeTest.kt$AMQPBridgeTest$3</ID>
    <ID>MagicNumber:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme$128</ID>
    <ID>MagicNumber:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$128</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.CHOICE$7</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.COMPOSITE_TYPE$5</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.FIELD$4</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.OBJECT_DESCRIPTOR$3</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.REFERENCED_OBJECT$8</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.RESTRICTED_TYPE$6</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.TRANSFORM_ELEMENT$10</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.TRANSFORM_ELEMENT_KEY$11</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.TRANSFORM_SCHEMA$9</ID>
    <ID>MagicNumber:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme$128</ID>
    <ID>MagicNumber:AMQPServer.kt$AMQPServer$100</ID>
    <ID>MagicNumber:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$128</ID>
    <ID>MagicNumber:AbstractCashSelection.kt$AbstractCashSelection$3</ID>
    <ID>MagicNumber:AbstractCashSelection.kt$AbstractCashSelection$4</ID>
    <ID>MagicNumber:AbstractCashSelection.kt$AbstractCashSelection$5</ID>
    <ID>MagicNumber:AbstractNode.kt$AbstractNode$50</ID>
    <ID>MagicNumber:AccessOrderLinkedHashMap.kt$AccessOrderLinkedHashMap$0.75f</ID>
    <ID>MagicNumber:AccessOrderLinkedHashMap.kt$AccessOrderLinkedHashMap$16</ID>
    <ID>MagicNumber:AdditionP2PAddressModeTest.kt$AdditionP2PAddressModeTest$1234</ID>
    <ID>MagicNumber:AllExceptionMapper.kt$AllExceptionMapper$500</ID>
    <ID>MagicNumber:Amount.kt$AmountTransfer$31</ID>
    <ID>MagicNumber:ArraySerializer.kt$ArraySerializer$4</ID>
    <ID>MagicNumber:ArtemisMessagingClient.kt$ArtemisMessagingClient$30000</ID>
    <ID>MagicNumber:ArtemisMessagingClient.kt$ArtemisMessagingClient$60000</ID>
    <ID>MagicNumber:ArtemisMessagingServer.kt$ArtemisMessagingServer$10L</ID>
    <ID>MagicNumber:ArtemisMessagingServer.kt$ArtemisMessagingServer$2000</ID>
    <ID>MagicNumber:ArtemisMessagingTest.kt$ArtemisMessagingTest$100_000</ID>
    <ID>MagicNumber:ArtemisMessagingTest.kt$ArtemisMessagingTest$200</ID>
    <ID>MagicNumber:ArtemisMessagingTest.kt$ArtemisMessagingTest$3</ID>
    <ID>MagicNumber:ArtemisMessagingTest.kt$ArtemisMessagingTest$5</ID>
    <ID>MagicNumber:ArtemisMessagingTest.kt$ArtemisMessagingTest$50_000</ID>
    <ID>MagicNumber:ArtemisRpcTests.kt$ArtemisRpcTests$10000</ID>
    <ID>MagicNumber:ArtemisRpcTests.kt$ArtemisRpcTests.TestRpcOpsImpl$1000</ID>
    <ID>MagicNumber:AttachmentDemo.kt$10006</ID>
    <ID>MagicNumber:AttachmentDemo.kt$10009</ID>
    <ID>MagicNumber:AttachmentDemo.kt$10010</ID>
    <ID>MagicNumber:AttachmentDemoTest.kt$AttachmentDemoTest$10_000_000</ID>
    <ID>MagicNumber:AttachmentLoadingTests.kt$AttachmentLoadingTests$1234</ID>
    <ID>MagicNumber:AttachmentsClassLoader.kt$AttachmentsClassLoader$4</ID>
    <ID>MagicNumber:AuthDBTests.kt$AuthDBTests$1500</ID>
    <ID>MagicNumber:AuthDBTests.kt$AuthDBTests$50</ID>
    <ID>MagicNumber:AzureSmbVolume.kt$AzureSmbVolume$5000</ID>
    <ID>MagicNumber:BFTSmart.kt$BFTSmart.Client$100</ID>
    <ID>MagicNumber:BFTSmart.kt$BFTSmart.Replica.&lt;no name provided&gt;$20000</ID>
    <ID>MagicNumber:BFTSmartConfigInternal.kt$3</ID>
    <ID>MagicNumber:BFTSmartConfigInternal.kt$BFTSmartConfigInternal$200</ID>
    <ID>MagicNumber:BlobWriter.kt$3</ID>
    <ID>MagicNumber:BlobWriter.kt$4</ID>
    <ID>MagicNumber:BlobWriter.kt$5</ID>
    <ID>MagicNumber:BlobWriter.kt$6</ID>
    <ID>MagicNumber:BootstrapperView.kt$BootstrapperView$4</ID>
    <ID>MagicNumber:BusinessCalendar.kt$BusinessCalendar.Companion$30.0</ID>
    <ID>MagicNumber:BusinessCalendar.kt$BusinessCalendar.Companion$360.0</ID>
    <ID>MagicNumber:ByteArrays.kt$10</ID>
    <ID>MagicNumber:ByteArrays.kt$16</ID>
    <ID>MagicNumber:ByteArrays.kt$4</ID>
    <ID>MagicNumber:ByteArrays.kt$ByteSequence$31</ID>
    <ID>MagicNumber:ByteBufferStreams.kt$1024</ID>
    <ID>MagicNumber:ByteBufferStreams.kt$256</ID>
    <ID>MagicNumber:ByteBufferStreams.kt$64</ID>
    <ID>MagicNumber:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$3</ID>
    <ID>MagicNumber:CashViewer.kt$CashViewer$5.0</ID>
    <ID>MagicNumber:CashViewer.kt$CashViewer.CashWidget$10.0</ID>
    <ID>MagicNumber:CashViewer.kt$CashViewer.CashWidget$300</ID>
    <ID>MagicNumber:CashViewer.kt$CashViewer.StateRowGraphic$16</ID>
    <ID>MagicNumber:CashViewer.kt$CashViewer.StateRowGraphic$30.0</ID>
    <ID>MagicNumber:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$10</ID>
    <ID>MagicNumber:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$3</ID>
    <ID>MagicNumber:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$5</ID>
    <ID>MagicNumber:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.Companion$10</ID>
    <ID>MagicNumber:ClassCarpenter.kt$ClassCarpenterImpl$3</ID>
    <ID>MagicNumber:ClientRpcExample.kt$ClientRpcExample$3</ID>
    <ID>MagicNumber:ClientRpcTutorial.kt$0.7</ID>
    <ID>MagicNumber:ClientRpcTutorial.kt$0.8</ID>
    <ID>MagicNumber:ClientRpcTutorial.kt$1000</ID>
    <ID>MagicNumber:ClientRpcTutorial.kt$10000</ID>
    <ID>MagicNumber:ClientRpcTutorial.kt$2000</ID>
    <ID>MagicNumber:CommercialPaperIssueFlow.kt$CommercialPaperIssueFlow$10</ID>
    <ID>MagicNumber:CommercialPaperIssueFlow.kt$CommercialPaperIssueFlow$30</ID>
    <ID>MagicNumber:CompositeKey.kt$CompositeKey$31</ID>
    <ID>MagicNumber:CompositeSignature.kt$CompositeSignature$1024</ID>
    <ID>MagicNumber:ConfigExporter.kt$3</ID>
    <ID>MagicNumber:ConnectionManager.kt$ConnectionManager$22</ID>
    <ID>MagicNumber:ConnectionStateMachine.kt$ConnectionStateMachine$1500</ID>
    <ID>MagicNumber:ConnectionStateMachine.kt$ConnectionStateMachine$4</ID>
    <ID>MagicNumber:CordaPersistence.kt$DatabaseConfig.Defaults$100L</ID>
    <ID>MagicNumber:CordaRPCClient.kt$CordaRPCClient$128</ID>
    <ID>MagicNumber:CordaRPCClient.kt$CordaRPCClientConfiguration$3</ID>
    <ID>MagicNumber:CordaRPCClient.kt$CordaRPCClientConfiguration$31</ID>
    <ID>MagicNumber:CordaRPCClient.kt$CordaRPCClientConfiguration$5</ID>
    <ID>MagicNumber:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$10</ID>
    <ID>MagicNumber:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$4</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest$10</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest$100</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest$1000</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest$120</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest$123</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest$20</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest$2000</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest.StandaloneCashRpcClient$10000</ID>
    <ID>MagicNumber:CordaSecurityProvider.kt$CordaSecurityProvider$0.1</ID>
    <ID>MagicNumber:CordappConstraintsTests.kt$CordappConstraintsTests$1000</ID>
    <ID>MagicNumber:CordappConstraintsTests.kt$CordappConstraintsTests$500</ID>
    <ID>MagicNumber:CordappSmokeTest.kt$CordappSmokeTest$1234</ID>
    <ID>MagicNumber:CrossCashTest.kt$1000</ID>
    <ID>MagicNumber:CrossCashTest.kt$10000</ID>
    <ID>MagicNumber:CrossCashTest.kt$3000</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$2048</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$256</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$3</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$3072</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$4</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$5</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$6</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$8</ID>
    <ID>MagicNumber:CryptoUtils.kt$8</ID>
    <ID>MagicNumber:Dashboard.kt$Dashboard$10</ID>
    <ID>MagicNumber:Dashboard.kt$Dashboard$30.0</ID>
    <ID>MagicNumber:Dashboard.kt$Dashboard$350</ID>
    <ID>MagicNumber:DefaultKryoCustomizer.kt$DefaultKryoCustomizer.ContractAttachmentSerializer$32</ID>
    <ID>MagicNumber:DistributedServiceTests.kt$DistributedServiceTests$10</ID>
    <ID>MagicNumber:DistributedServiceTests.kt$DistributedServiceTests$100</ID>
    <ID>MagicNumber:DistributedServiceTests.kt$DistributedServiceTests$20</ID>
    <ID>MagicNumber:DistributedServiceTests.kt$DistributedServiceTests$3</ID>
    <ID>MagicNumber:DistributedServiceTests.kt$DistributedServiceTests$30</ID>
    <ID>MagicNumber:DistributedServiceTests.kt$DistributedServiceTests$5</ID>
    <ID>MagicNumber:DistributedServiceTests.kt$DistributedServiceTests$50</ID>
    <ID>MagicNumber:DriverDSLImpl.kt$DriverDSLImpl$1000</ID>
    <ID>MagicNumber:DriverDSLImpl.kt$DriverDSLImpl$5</ID>
    <ID>MagicNumber:DriverDSLImpl.kt$DriverDSLImpl$60</ID>
    <ID>MagicNumber:DriverTests.kt$DriverTests$200</ID>
    <ID>MagicNumber:DriverTests.kt$DriverTests$3</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F193</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F385</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F469</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4A1</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4B0</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4BB</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4CE</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4DA</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4F0</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F51C</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F537</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F60E</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F634</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F6AB</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x200D</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x2620</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x26A0</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x2705</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x27A1</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x2B05</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0xFE0F</ID>
    <ID>MagicNumber:EventGenerator.kt$ErrorFlowsEventGenerator$0.2</ID>
    <ID>MagicNumber:EventGenerator.kt$ErrorFlowsEventGenerator$0.3</ID>
    <ID>MagicNumber:EventGenerator.kt$ErrorFlowsEventGenerator$0.7</ID>
    <ID>MagicNumber:EventGenerator.kt$ErrorFlowsEventGenerator$0.8</ID>
    <ID>MagicNumber:EventGenerator.kt$EventGenerator$0.1</ID>
    <ID>MagicNumber:EventGenerator.kt$EventGenerator$0.9</ID>
    <ID>MagicNumber:EventGenerator.kt$EventGenerator$10000</ID>
    <ID>MagicNumber:EventGenerator.kt$EventGenerator$1000000</ID>
    <ID>MagicNumber:Eventually.kt$100</ID>
    <ID>MagicNumber:Eventually.kt$5</ID>
    <ID>MagicNumber:ExceptionsErrorCodeFunctions.kt$3</ID>
    <ID>MagicNumber:ExceptionsErrorCodeFunctions.kt$36</ID>
    <ID>MagicNumber:ExchangeRateModel.kt$1.01</ID>
    <ID>MagicNumber:ExchangeRateModel.kt$1.18</ID>
    <ID>MagicNumber:ExchangeRateModel.kt$1.31</ID>
    <ID>MagicNumber:FinanceTypes.kt$Frequency.BiWeekly$26</ID>
    <ID>MagicNumber:FinanceTypes.kt$Frequency.Daily$365</ID>
    <ID>MagicNumber:FinanceTypes.kt$Frequency.Monthly$12</ID>
    <ID>MagicNumber:FinanceTypes.kt$Frequency.Quarterly$3</ID>
    <ID>MagicNumber:FinanceTypes.kt$Frequency.Quarterly$4</ID>
    <ID>MagicNumber:FinanceTypes.kt$Frequency.SemiAnnual$6</ID>
    <ID>MagicNumber:FinanceTypes.kt$Frequency.Weekly$52</ID>
    <ID>MagicNumber:FixingFlow.kt$FixingFlow.Fixer.&lt;no name provided&gt;$30</ID>
    <ID>MagicNumber:FlowCookbook.kt$InitiatorFlow$30</ID>
    <ID>MagicNumber:FlowCookbook.kt$InitiatorFlow$45</ID>
    <ID>MagicNumber:FlowCookbook.kt$InitiatorFlow$777</ID>
    <ID>MagicNumber:FlowCookbook.kt$ResponderFlow$99</ID>
    <ID>MagicNumber:FlowCookbook.kt$ResponderFlow.&lt;no name provided&gt;$777</ID>
    <ID>MagicNumber:FlowLogic.kt$FlowLogic$300</ID>
    <ID>MagicNumber:FlowLogic.kt$FlowLogic.Companion$5</ID>
    <ID>MagicNumber:FlowMonitor.kt$FlowMonitor$1000</ID>
    <ID>MagicNumber:FlowRetryTest.kt$FlowRetryTest$10</ID>
    <ID>MagicNumber:FlowRetryTest.kt$FlowRetryTest$3</ID>
    <ID>MagicNumber:FlowRetryTest.kt$InitiatorFlow$2000</ID>
    <ID>MagicNumber:FlowStackSnapshot.kt$14</ID>
    <ID>MagicNumber:FlowStackSnapshot.kt$16</ID>
    <ID>MagicNumber:FlowStackSnapshot.kt$64</ID>
    <ID>MagicNumber:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$5</ID>
    <ID>MagicNumber:FlowVersioningTest.kt$FlowVersioningTest$3</ID>
    <ID>MagicNumber:FoundNode.kt$FoundNode$31</ID>
    <ID>MagicNumber:Generator.kt$Generator.Companion$16</ID>
    <ID>MagicNumber:Generator.kt$Generator.Companion$17</ID>
    <ID>MagicNumber:GuiUtilities.kt$1000</ID>
    <ID>MagicNumber:GuiUtilities.kt$1000.0</ID>
    <ID>MagicNumber:HTTPNetworkRegistrationService.kt$HTTPNetworkRegistrationService$10</ID>
    <ID>MagicNumber:HardRestartTest.kt$HardRestartTest$10</ID>
    <ID>MagicNumber:HardRestartTest.kt$HardRestartTest$100</ID>
    <ID>MagicNumber:HardRestartTest.kt$HardRestartTest$1000</ID>
    <ID>MagicNumber:HardRestartTest.kt$HardRestartTest$8</ID>
    <ID>MagicNumber:HashLookupCommandTest.kt$HashLookupCommandTest$2224</ID>
    <ID>MagicNumber:HashLookupCommandTest.kt$HashLookupCommandTest$5000</ID>
    <ID>MagicNumber:HttpUtils.kt$HttpUtils$5</ID>
    <ID>MagicNumber:HttpUtils.kt$HttpUtils$60</ID>
    <ID>MagicNumber:IOUFlowResponder.kt$IOUFlowResponder.&lt;no name provided&gt;$100</ID>
    <ID>MagicNumber:IRS.kt$FloatingRatePaymentEvent$31</ID>
    <ID>MagicNumber:IRS.kt$InterestRateSwap.CommonLeg$31</ID>
    <ID>MagicNumber:IRS.kt$InterestRateSwap.FixedLeg$31</ID>
    <ID>MagicNumber:IRS.kt$InterestRateSwap.FloatingLeg$31</ID>
    <ID>MagicNumber:IRS.kt$RatePaymentEvent$31</ID>
    <ID>MagicNumber:IRS.kt$RatePaymentEvent$360.0</ID>
    <ID>MagicNumber:IRS.kt$RatePaymentEvent$4</ID>
    <ID>MagicNumber:IRS.kt$RatePaymentEvent$8</ID>
    <ID>MagicNumber:IRSDemoDockerTest.kt$IRSDemoDockerTest$120</ID>
    <ID>MagicNumber:IRSDemoDockerTest.kt$IRSDemoDockerTest$8080</ID>
    <ID>MagicNumber:IRSDemoTest.kt$IRSDemoTest$6</ID>
    <ID>MagicNumber:IRSDemoTest.kt$IRSDemoTest$60</ID>
    <ID>MagicNumber:IRSUtils.kt$PercentageRatioUnit$100</ID>
    <ID>MagicNumber:Id.kt$Id$31</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$16</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$90.0</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$0x3</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$10</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$11</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$12</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$13</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$14</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$15</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$16</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$18</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$20</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$21</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$22</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$24</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$256</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$27</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$3</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$32.0f</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$4</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$6</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$7</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$8</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$90</ID>
    <ID>MagicNumber:InputStreamSerializer.kt$InputStreamSerializer$4096</ID>
    <ID>MagicNumber:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$2223</ID>
    <ID>MagicNumber:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$2224</ID>
    <ID>MagicNumber:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$4</ID>
    <ID>MagicNumber:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$5000</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$3</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$5</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$InternalMockNetwork$30000</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$InternalMockNetwork$50</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$InternalMockNetwork.MockNode$1000</ID>
    <ID>MagicNumber:InternalRPCMessagingClient.kt$InternalRPCMessagingClient$30000</ID>
    <ID>MagicNumber:InternalRPCMessagingClient.kt$InternalRPCMessagingClient$60000</ID>
    <ID>MagicNumber:InternalTestUtils.kt$40</ID>
    <ID>MagicNumber:InternalTestUtils.kt$500</ID>
    <ID>MagicNumber:InternalTestUtils.kt$70</ID>
    <ID>MagicNumber:InternalUtils.kt$30</ID>
    <ID>MagicNumber:InternalUtils.kt$InputStreamAndHash.Companion$1024</ID>
    <ID>MagicNumber:Interpolators.kt$CubicSplineInterpolator$3</ID>
    <ID>MagicNumber:Interpolators.kt$CubicSplineInterpolator$3.0</ID>
    <ID>MagicNumber:IrsDemoWebApplication.kt$IrsDemoWebApplication$100</ID>
    <ID>MagicNumber:IrsDemoWebApplication.kt$IrsDemoWebApplication$1000</ID>
    <ID>MagicNumber:JarScanningCordappLoader.kt$CordappLoaderTemplate$36</ID>
    <ID>MagicNumber:JarScanningCordappLoader.kt$CordappLoaderTemplate$64</ID>
    <ID>MagicNumber:JarScanningCordappLoader.kt$JarScanningCordappLoader$1000</ID>
    <ID>MagicNumber:JarSignatureCollector.kt$JarSignatureCollector$1024</ID>
    <ID>MagicNumber:JarSignatureTestUtils.kt$JarSignatureTestUtils$14</ID>
    <ID>MagicNumber:KMSUtils.kt$3650</ID>
    <ID>MagicNumber:Kryo.kt$InputStreamSerializer$4096</ID>
    <ID>MagicNumber:KryoStreams.kt$1024</ID>
    <ID>MagicNumber:KryoStreams.kt$64</ID>
    <ID>MagicNumber:LargeTransactionsTest.kt$LargeTransactionsTest$13</ID>
    <ID>MagicNumber:LargeTransactionsTest.kt$LargeTransactionsTest$15</ID>
    <ID>MagicNumber:LargeTransactionsTest.kt$LargeTransactionsTest$3</ID>
    <ID>MagicNumber:Literal.kt$1000</ID>
    <ID>MagicNumber:Literal.kt$1000000</ID>
    <ID>MagicNumber:LocalSerializationRule.kt$LocalSerializationRule$128</ID>
    <ID>MagicNumber:Main.kt$100</ID>
    <ID>MagicNumber:Main.kt$10000L</ID>
    <ID>MagicNumber:Main.kt$1000L</ID>
    <ID>MagicNumber:Main.kt$20000L</ID>
    <ID>MagicNumber:Main.kt$2000L</ID>
    <ID>MagicNumber:Main.kt$4000L</ID>
    <ID>MagicNumber:Main.kt$5000L</ID>
    <ID>MagicNumber:Main.kt$500L</ID>
    <ID>MagicNumber:Main.kt$Main$600.0</ID>
    <ID>MagicNumber:Main.kt$Main$800.0</ID>
    <ID>MagicNumber:Main.kt$Node$10</ID>
    <ID>MagicNumber:Main.kt$Node$3</ID>
    <ID>MagicNumber:Main.kt$Transaction$5</ID>
    <ID>MagicNumber:MainView.kt$MainView$10.0</ID>
    <ID>MagicNumber:MainView.kt$MainView$12.0</ID>
    <ID>MagicNumber:MainView.kt$MainView$150</ID>
    <ID>MagicNumber:MainView.kt$MainView$30</ID>
    <ID>MagicNumber:MainView.kt$MainView$5.0</ID>
    <ID>MagicNumber:MessageSizeChecksInterceptor.kt$ArtemisMessageSizeChecksInterceptor$4</ID>
    <ID>MagicNumber:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory$1024L</ID>
    <ID>MagicNumber:MockContractAttachment.kt$113</ID>
    <ID>MagicNumber:MockContractAttachment.kt$15</ID>
    <ID>MagicNumber:MockContractAttachment.kt$2</ID>
    <ID>MagicNumber:MockContractAttachment.kt$20</ID>
    <ID>MagicNumber:MockContractAttachment.kt$24</ID>
    <ID>MagicNumber:MockContractAttachment.kt$3</ID>
    <ID>MagicNumber:MockContractAttachment.kt$4</ID>
    <ID>MagicNumber:MockContractAttachment.kt$47</ID>
    <ID>MagicNumber:MockContractAttachment.kt$5</ID>
    <ID>MagicNumber:MockContractAttachment.kt$52</ID>
    <ID>MagicNumber:MockContractAttachment.kt$54</ID>
    <ID>MagicNumber:MockContractAttachment.kt$55</ID>
    <ID>MagicNumber:MockContractAttachment.kt$6</ID>
    <ID>MagicNumber:MockContractAttachment.kt$66</ID>
    <ID>MagicNumber:MockContractAttachment.kt$67</ID>
    <ID>MagicNumber:MockContractAttachment.kt$7</ID>
    <ID>MagicNumber:MockContractAttachment.kt$73</ID>
    <ID>MagicNumber:MockContractAttachment.kt$75</ID>
    <ID>MagicNumber:MockContractAttachment.kt$78</ID>
    <ID>MagicNumber:MockContractAttachment.kt$79</ID>
    <ID>MagicNumber:MockContractAttachment.kt$8</ID>
    <ID>MagicNumber:MockContractAttachment.kt$80</ID>
    <ID>MagicNumber:MockContractAttachment.kt$97</ID>
    <ID>MagicNumber:MockNetworkParametersService.kt$MockNetworkParametersStorage$20</ID>
    <ID>MagicNumber:MockServices.kt$MockServices$10000</ID>
    <ID>MagicNumber:MockServices.kt$MockServices.Companion.&lt;no name provided&gt;$512</ID>
    <ID>MagicNumber:Network.kt$Network$0.8</ID>
    <ID>MagicNumber:Network.kt$Network$1.2</ID>
    <ID>MagicNumber:Network.kt$Network$10</ID>
    <ID>MagicNumber:Network.kt$Network$10.0</ID>
    <ID>MagicNumber:Network.kt$Network$15.0</ID>
    <ID>MagicNumber:Network.kt$Network$180.0</ID>
    <ID>MagicNumber:Network.kt$Network$2.5</ID>
    <ID>MagicNumber:Network.kt$Network$2000.0</ID>
    <ID>MagicNumber:Network.kt$Network$3.0</ID>
    <ID>MagicNumber:Network.kt$Network$300.0</ID>
    <ID>MagicNumber:Network.kt$Network$4</ID>
    <ID>MagicNumber:Network.kt$Network$5.0</ID>
    <ID>MagicNumber:Network.kt$Network$500.0</ID>
    <ID>MagicNumber:Network.kt$Network$6.0</ID>
    <ID>MagicNumber:Network.kt$Network$85.0511</ID>
    <ID>MagicNumber:NetworkBootstrapper.kt$NetworkBootstrapper$3</ID>
    <ID>MagicNumber:NetworkBootstrapper.kt$NetworkBootstrapper$30</ID>
    <ID>MagicNumber:NetworkBootstrapper.kt$NetworkBootstrapper.Companion$3</ID>
    <ID>MagicNumber:NetworkBootstrapper.kt$NetworkBootstrapper.Companion$40</ID>
    <ID>MagicNumber:NetworkHostAndPort.kt$NetworkHostAndPort$0xffff</ID>
    <ID>MagicNumber:NetworkMap.kt$NetworkMap$10</ID>
    <ID>MagicNumber:NetworkMapServer.kt$NetworkMapServer$500</ID>
    <ID>MagicNumber:NetworkMapTest.kt$NetworkMapTest$2000</ID>
    <ID>MagicNumber:NetworkMapTest.kt$NetworkMapTest$5</ID>
    <ID>MagicNumber:NetworkMapUpdater.kt$NetworkMapUpdater$24</ID>
    <ID>MagicNumber:NetworkMapUpdater.kt$NetworkMapUpdater$4</ID>
    <ID>MagicNumber:NetworkMapUpdater.kt$NetworkMapUpdater$50</ID>
    <ID>MagicNumber:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$10</ID>
    <ID>MagicNumber:NetworkRegistrationHelper.kt$NodeRegistrationHelper$10</ID>
    <ID>MagicNumber:NewTransaction.kt$NewTransaction$10.0</ID>
    <ID>MagicNumber:NewTransaction.kt$NewTransaction$16</ID>
    <ID>MagicNumber:NewTransaction.kt$NewTransaction$20.0</ID>
    <ID>MagicNumber:NewTransaction.kt$NewTransaction$40.0</ID>
    <ID>MagicNumber:Node.kt$Node$128</ID>
    <ID>MagicNumber:Node.kt$Node$256</ID>
    <ID>MagicNumber:Node.kt$Node$4</ID>
    <ID>MagicNumber:Node.kt$Node.Companion$171</ID>
    <ID>MagicNumber:Node.kt$Node.Companion$40</ID>
    <ID>MagicNumber:NodeCmdLineOptions.kt$NodeCmdLineOptions$2222</ID>
    <ID>MagicNumber:NodeConfiguration.kt$1024L</ID>
    <ID>MagicNumber:NodeConfiguration.kt$NodeConfiguration$5</ID>
    <ID>MagicNumber:NodeConfiguration.kt$NodeConfiguration.Companion$20</ID>
    <ID>MagicNumber:NodeConfiguration.kt$NodeConfiguration.Companion$300</ID>
    <ID>MagicNumber:NodeConfigurationImpl.kt$NodeConfigurationImpl.Defaults$5</ID>
    <ID>MagicNumber:NodeInfo.kt$NodeInfoSigner$4</ID>
    <ID>MagicNumber:NodeInfoWatcher.kt$NodeInfoWatcher$5</ID>
    <ID>MagicNumber:NodeNamedCache.kt$DefaultNamedCacheFactory$1024L</ID>
    <ID>MagicNumber:NodePerformanceTests.kt$NodePerformanceTests$0.000001</ID>
    <ID>MagicNumber:NodePerformanceTests.kt$NodePerformanceTests$0.001</ID>
    <ID>MagicNumber:NodePerformanceTests.kt$NodePerformanceTests$100</ID>
    <ID>MagicNumber:NodePerformanceTests.kt$NodePerformanceTests$10000</ID>
    <ID>MagicNumber:NodePerformanceTests.kt$NodePerformanceTests$100L</ID>
    <ID>MagicNumber:NodePerformanceTests.kt$NodePerformanceTests$2000L</ID>
    <ID>MagicNumber:NodePerformanceTests.kt$NodePerformanceTests$5</ID>
    <ID>MagicNumber:NodePerformanceTests.kt$NodePerformanceTests$8</ID>
    <ID>MagicNumber:NodeProcess.kt$NodeProcess$60</ID>
    <ID>MagicNumber:NodeProcess.kt$NodeProcess.Factory$120</ID>
    <ID>MagicNumber:NodeProcess.kt$NodeProcess.Factory$5</ID>
    <ID>MagicNumber:NodeRPC.kt$NodeRPC$5</ID>
    <ID>MagicNumber:NodeSchedulerService.kt$NodeSchedulerService$60</ID>
    <ID>MagicNumber:NodeStartup.kt$NodeStartup$10</ID>
    <ID>MagicNumber:NodeStartup.kt$NodeStartup$100.0</ID>
    <ID>MagicNumber:NodeStartup.kt$NodeStartup$1000</ID>
    <ID>MagicNumber:NodeStartup.kt$NodeStartup$20</ID>
    <ID>MagicNumber:NodeStartup.kt$NodeStartup$7</ID>
    <ID>MagicNumber:NodeStartupPerformanceTests.kt$NodeStartupPerformanceTests$10</ID>
    <ID>MagicNumber:NodeStartupPerformanceTests.kt$NodeStartupPerformanceTests$1_000_000.0</ID>
    <ID>MagicNumber:NodeTabView.kt$NodeTabView$24.0</ID>
    <ID>MagicNumber:NodeTerminalView.kt$NodeTerminalView$160</ID>
    <ID>MagicNumber:NodeTerminalView.kt$NodeTerminalView$2.5</ID>
    <ID>MagicNumber:NodeTerminalView.kt$NodeTerminalView$80</ID>
    <ID>MagicNumber:NodeTerminalView.kt$NodeTerminalView.TerminalSettingsProvider$50</ID>
    <ID>MagicNumber:NodeWebServer.kt$NodeWebServer$100</ID>
    <ID>MagicNumber:NodeWebServer.kt$NodeWebServer$32768</ID>
    <ID>MagicNumber:NodeWebServer.kt$NodeWebServer$40</ID>
    <ID>MagicNumber:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$4</ID>
    <ID>MagicNumber:Notarise.kt$10</ID>
    <ID>MagicNumber:Notarise.kt$10003</ID>
    <ID>MagicNumber:NullKeys.kt$NullKeys$32</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$0.015</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$100000000.0</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$12</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$2014</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$2015</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$2021</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$21</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$7</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$9</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.001</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.00123</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.0025</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.0091</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.01</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.015</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.03</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$100000000.0</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$12</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$17</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2013</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2014</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2016</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2020</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2021</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2024</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$22</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$24</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$27</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$3</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$4</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$5</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$6</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$61600000.0</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$7</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$8</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$9</ID>
    <ID>MagicNumber:OGUtils.kt$0.001</ID>
    <ID>MagicNumber:ObjectDiffer.kt$ObjectDiffer$3</ID>
    <ID>MagicNumber:ObjectDiffer.kt$ObjectDiffer$4</ID>
    <ID>MagicNumber:Obligation.kt$Obligation.Terms$30</ID>
    <ID>MagicNumber:OracleUtils.kt$11</ID>
    <ID>MagicNumber:OracleUtils.kt$24</ID>
    <ID>MagicNumber:OracleUtils.kt$45</ID>
    <ID>MagicNumber:OrdinalIO.kt$OrdinalBits$128</ID>
    <ID>MagicNumber:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$10</ID>
    <ID>MagicNumber:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$5</ID>
    <ID>MagicNumber:P2PMessagingClient.kt$P2PMessagingClient$30000</ID>
    <ID>MagicNumber:P2PMessagingClient.kt$P2PMessagingClient$60000</ID>
    <ID>MagicNumber:P2PMessagingClient.kt$P2PMessagingConsumer$10</ID>
    <ID>MagicNumber:P2PMessagingTest.kt$P2PMessagingTest$10</ID>
    <ID>MagicNumber:P2PMessagingTest.kt$P2PMessagingTest$3</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$0.02</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$0.8</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$10</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$20</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$23L</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$5</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$50</ID>
    <ID>MagicNumber:ParametersUtilities.kt$30</ID>
    <ID>MagicNumber:ParametersUtilities.kt$50</ID>
    <ID>MagicNumber:Password.kt$Password$5</ID>
    <ID>MagicNumber:PersistentIdentityMigrationNewTable.kt$PersistentIdentityMigrationNewTable$70</ID>
    <ID>MagicNumber:PersistentNetworkMapCacheTest.kt$PersistentNetworkMapCacheTest$1000</ID>
    <ID>MagicNumber:PersistentTypes.kt$MappedSchema$31</ID>
    <ID>MagicNumber:PersistentUniquenessProvider.kt$PersistentUniquenessProvider$100</ID>
    <ID>MagicNumber:PhysicalLocationStructures.kt$WorldCoordinate$180</ID>
    <ID>MagicNumber:PhysicalLocationStructures.kt$WorldCoordinate$180.0</ID>
    <ID>MagicNumber:PhysicalLocationStructures.kt$WorldCoordinate$360.0</ID>
    <ID>MagicNumber:PhysicalLocationStructures.kt$WorldCoordinate$4</ID>
    <ID>MagicNumber:PhysicalLocationStructures.kt$WorldCoordinate$90</ID>
    <ID>MagicNumber:PortfolioApi.kt$PortfolioApi$2016</ID>
    <ID>MagicNumber:PortfolioApi.kt$PortfolioApi$6</ID>
    <ID>MagicNumber:ProcessUtilitiesTests.kt$ProcessUtilitiesTests$20</ID>
    <ID>MagicNumber:ProfileController.kt$ProfileController$3</ID>
    <ID>MagicNumber:ProgressTracker.kt$ProgressTracker.Step$31</ID>
    <ID>MagicNumber:ProtonWrapperTests.kt$ProtonWrapperTests$1000</ID>
    <ID>MagicNumber:ProtonWrapperTests.kt$ProtonWrapperTests$100_000</ID>
    <ID>MagicNumber:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$20</ID>
    <ID>MagicNumber:R3Pty.kt$R3Pty$30</ID>
    <ID>MagicNumber:RPCClient.kt$RPCClient$30000</ID>
    <ID>MagicNumber:RPCClient.kt$RPCClient$60000</ID>
    <ID>MagicNumber:RPCClientProxyHandler.kt$RPCClientProxyHandler$1000</ID>
    <ID>MagicNumber:RPCClientProxyHandler.kt$RPCClientProxyHandler$16384</ID>
    <ID>MagicNumber:RPCClientProxyHandler.kt$RPCClientProxyHandler$31</ID>
    <ID>MagicNumber:RPCDriver.kt$RPCDriverDSL$10L</ID>
    <ID>MagicNumber:RPCDriver.kt$RPCDriverDSL$5</ID>
    <ID>MagicNumber:RPCDriver.kt$RPCDriverDSL$5L</ID>
    <ID>MagicNumber:RPCDriver.kt$RPCDriverDSL.Companion$10</ID>
    <ID>MagicNumber:RPCDriver.kt$RandomRpcUser.Companion$100</ID>
    <ID>MagicNumber:RPCDriver.kt$RandomRpcUser.Companion$3</ID>
    <ID>MagicNumber:RPCDriver.kt$RandomRpcUser.Companion$4</ID>
    <ID>MagicNumber:RPCServer.kt$RPCServer$5</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$10</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$100</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$1000</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$1024</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$1234</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$12345</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$200</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$250</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$4</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$5</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$500</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$5000</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$54321</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$9999</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests.&lt;no name provided&gt;$1000</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests.DummyOps$1000</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests.SlowConsumerRPCOpsImpl$1000</ID>
    <ID>MagicNumber:RandomFailingProxy.kt$RandomFailingProxy$2000</ID>
    <ID>MagicNumber:RandomFailingProxy.kt$RandomFailingProxy$700</ID>
    <ID>MagicNumber:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps$4</ID>
    <ID>MagicNumber:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$1000</ID>
    <ID>MagicNumber:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$10</ID>
    <ID>MagicNumber:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$9</ID>
    <ID>MagicNumber:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$4</ID>
    <ID>MagicNumber:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$2000</ID>
    <ID>MagicNumber:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$5L</ID>
    <ID>MagicNumber:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$8</ID>
    <ID>MagicNumber:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest$123L</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$10</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$100</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$1000</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$10000</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$12000</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$2000</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$250</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$3</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$4</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$4000</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$5</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$50</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$5000</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$6</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$7</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$8000</ID>
    <ID>MagicNumber:SSHDConfiguration.kt$SSHDConfiguration$0xffff</ID>
    <ID>MagicNumber:SSHServerTest.kt$SSHServerTest$2222</ID>
    <ID>MagicNumber:SSHServerTest.kt$SSHServerTest$5000</ID>
    <ID>MagicNumber:SSLHelper.kt$32</ID>
    <ID>MagicNumber:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$10</ID>
    <ID>MagicNumber:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$100</ID>
    <ID>MagicNumber:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$20</ID>
    <ID>MagicNumber:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$23</ID>
    <ID>MagicNumber:Schema.kt$CompositeType.Companion$3</ID>
    <ID>MagicNumber:Schema.kt$CompositeType.Companion$4</ID>
    <ID>MagicNumber:Schema.kt$Descriptor$0xffff</ID>
    <ID>MagicNumber:Schema.kt$Descriptor$32</ID>
    <ID>MagicNumber:Schema.kt$Field.Companion$3</ID>
    <ID>MagicNumber:Schema.kt$Field.Companion$4</ID>
    <ID>MagicNumber:Schema.kt$Field.Companion$5</ID>
    <ID>MagicNumber:Schema.kt$Field.Companion$6</ID>
    <ID>MagicNumber:Schema.kt$RestrictedType.Companion$3</ID>
    <ID>MagicNumber:Schema.kt$RestrictedType.Companion$4</ID>
    <ID>MagicNumber:Schema.kt$RestrictedType.Companion$5</ID>
    <ID>MagicNumber:SearchField.kt$SearchField$10</ID>
    <ID>MagicNumber:SearchField.kt$SearchField$5.0</ID>
    <ID>MagicNumber:SecureArtemisConfiguration.kt$SecureArtemisConfiguration$128</ID>
    <ID>MagicNumber:SecureArtemisConfiguration.kt$SecureArtemisConfiguration$16</ID>
    <ID>MagicNumber:SecureHash.kt$SecureHash.Companion$32</ID>
    <ID>MagicNumber:SecureHash.kt$SecureHash.SHA256$32</ID>
    <ID>MagicNumber:SelfIssueTest.kt$1000</ID>
    <ID>MagicNumber:SharedMemoryIncremental.kt$SharedMemoryIncremental$16</ID>
    <ID>MagicNumber:ShutdownManager.kt$ShutdownManager$5</ID>
    <ID>MagicNumber:ShutdownManager.kt$ShutdownManager$60</ID>
    <ID>MagicNumber:SimmFlow.kt$100</ID>
    <ID>MagicNumber:SimmFlow.kt$1e-9</ID>
    <ID>MagicNumber:SimmValuationTest.kt$SimmValuationTest$0.1</ID>
    <ID>MagicNumber:SimmValuationTest.kt$SimmValuationTest$1000</ID>
    <ID>MagicNumber:StabilityTest.kt$StabilityTest$100000</ID>
    <ID>MagicNumber:StaffedFlowHospital.kt$StaffedFlowHospital$1.5</ID>
    <ID>MagicNumber:StaffedFlowHospital.kt$StaffedFlowHospital$10</ID>
    <ID>MagicNumber:StaffedFlowHospital.kt$StaffedFlowHospital.DuplicateInsertSpecialist$3</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$10</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$100</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$127</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$3</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$429</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$513</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$629</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$83</ID>
    <ID>MagicNumber:StandaloneShell.kt$StandaloneShell$7</ID>
    <ID>MagicNumber:StateRevisionFlow.kt$StateRevisionFlow.Requester$30</ID>
    <ID>MagicNumber:Structures.kt$PrivacySalt$32</ID>
    <ID>MagicNumber:TargetVersionDependentRules.kt$StateContractValidationEnforcementRule$4</ID>
    <ID>MagicNumber:TestNodeInfoBuilder.kt$TestNodeInfoBuilder$1234</ID>
    <ID>MagicNumber:TestUtils.kt$10000</ID>
    <ID>MagicNumber:TestUtils.kt$30000</ID>
    <ID>MagicNumber:TraderDemo.kt$TraderDemo$1_000_000_000_000</ID>
    <ID>MagicNumber:TraderDemo.kt$TraderDemo$1_100_000_000_000</ID>
    <ID>MagicNumber:TraderDemoClientApi.kt$TraderDemoClientApi$10</ID>
    <ID>MagicNumber:TraderDemoClientApi.kt$TraderDemoClientApi$1000.0</ID>
    <ID>MagicNumber:TraderDemoClientApi.kt$TraderDemoClientApi$3</ID>
    <ID>MagicNumber:TraderDemoTest.kt$TraderDemoTest$100</ID>
    <ID>MagicNumber:TraderDemoTest.kt$TraderDemoTest$5</ID>
    <ID>MagicNumber:TraderDemoTest.kt$TraderDemoTest$95</ID>
    <ID>MagicNumber:TransactionBuilder.kt$TransactionBuilder$4</ID>
    <ID>MagicNumber:TransactionDSLInterpreter.kt$TransactionDSL$30</ID>
    <ID>MagicNumber:TransactionSignature.kt$TransactionSignature$31</ID>
    <ID>MagicNumber:TransactionUtils.kt$100</ID>
    <ID>MagicNumber:TransactionUtils.kt$4</ID>
    <ID>MagicNumber:TransactionVerifierServiceInternal.kt$Verifier$4</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer$15.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer$20.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer$200.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer$26.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer$400.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer.ContractStatesView$10.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer.ContractStatesView$16</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer.ContractStatesView$30.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer.ContractStatesView$5.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer.TransactionWidget$30.0</ID>
    <ID>MagicNumber:TransformsSchema.kt$EnumDefaultSchemaTransform$17</ID>
    <ID>MagicNumber:TransformsSchema.kt$RenameSchemaTransform$11</ID>
    <ID>MagicNumber:TransformsSchema.kt$UnknownTestTransform.Companion$3</ID>
    <ID>MagicNumber:TwoPartyDealFlow.kt$TwoPartyDealFlow.Acceptor$60</ID>
    <ID>MagicNumber:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$30</ID>
    <ID>MagicNumber:UniversalContract.kt$UniversalContract$100.0</ID>
    <ID>MagicNumber:Util.kt$24</ID>
    <ID>MagicNumber:Util.kt$60</ID>
    <ID>MagicNumber:VaultFiller.kt$VaultFiller$3</ID>
    <ID>MagicNumber:VaultRestartTest.kt$VaultRestartTest$500</ID>
    <ID>MagicNumber:VaultStateMigration.kt$VaultStateIterator$1000</ID>
    <ID>MagicNumber:VaultStateMigration.kt$VaultStateIterator.VaultPageTask$10</ID>
    <ID>MagicNumber:WebServer.kt$10</ID>
    <ID>MagicNumber:WebServer.kt$100.0</ID>
    <ID>MagicNumber:WebServer.kt$WebServer$500</ID>
    <ID>MagicNumber:WireTransaction.kt$WireTransaction$4</ID>
    <ID>MagicNumber:WorkflowTransactionBuildTutorial.kt$SubmitCompletionFlow$60</ID>
    <ID>MagicNumber:WorkflowTransactionBuildTutorial.kt$SubmitTradeApprovalFlow$60</ID>
    <ID>MagicNumber:X509Utilities.kt$X509Utilities$3650</ID>
    <ID>MagicNumber:errorAndTerminate.kt$10</ID>
    <ID>MatchingDeclarationName:AMQPSerializerFactories.kt$net.corda.serialization.internal.amqp.AMQPSerializerFactories.kt</ID>
    <ID>MatchingDeclarationName:AMQPTestSerialiationScheme.kt$net.corda.node.internal.serialization.testutils.AMQPTestSerialiationScheme.kt</ID>
    <ID>MatchingDeclarationName:AttachmentDemo.kt$net.corda.attachmentdemo.AttachmentDemo.kt</ID>
    <ID>MatchingDeclarationName:AzureRegistryLocator.kt$net.corda.networkbuilder.containers.push.azure.AzureRegistryLocator.kt</ID>
    <ID>MatchingDeclarationName:CheckpointSerializationScheme.kt$net.corda.serialization.internal.CheckpointSerializationScheme.kt</ID>
    <ID>MatchingDeclarationName:CheckpointSerializationTestHelpers.kt$net.corda.testing.core.internal.CheckpointSerializationTestHelpers.kt</ID>
    <ID>MatchingDeclarationName:ClassCarpenterTestUtils.kt$net.corda.serialization.internal.carpenter.ClassCarpenterTestUtils.kt</ID>
    <ID>MatchingDeclarationName:ConfigException.kt$net.corda.core.cordapp.ConfigException.kt</ID>
    <ID>MatchingDeclarationName:ConfigUtilities.kt$net.corda.node.services.config.ConfigUtilities.kt</ID>
    <ID>MatchingDeclarationName:ContractsDSL.kt$net.corda.core.contracts.ContractsDSL.kt</ID>
    <ID>MatchingDeclarationName:CordaUtils.kt$net.corda.core.internal.CordaUtils.kt</ID>
    <ID>MatchingDeclarationName:CurrencyParameterSensitivitySerialiser.kt$net.corda.vega.plugin.customserializers.CurrencyParameterSensitivitySerialiser.kt</ID>
    <ID>MatchingDeclarationName:FinanceWorkflowsUtils.kt$net.corda.finance.workflows.utils.FinanceWorkflowsUtils.kt</ID>
    <ID>MatchingDeclarationName:FlowStackSnapshot.kt$net.corda.testing.internal.FlowStackSnapshot.kt</ID>
    <ID>MatchingDeclarationName:FlowsExecutionModeRpcTest.kt$net.corda.client.rpc.FlowsExecutionModeRpcTest.kt</ID>
    <ID>MatchingDeclarationName:IRSDemo.kt$net.corda.irs.web.demo.IRSDemo.kt</ID>
    <ID>MatchingDeclarationName:InterestSwapRestAPI.kt$net.corda.irs.web.api.InterestSwapRestAPI.kt</ID>
    <ID>MatchingDeclarationName:InternalTestUtils.kt$net.corda.testing.node.internal.InternalTestUtils.kt</ID>
    <ID>MatchingDeclarationName:IrsDemoClientApi.kt$net.corda.irs.web.demo.IrsDemoClientApi.kt</ID>
    <ID>MatchingDeclarationName:KeyStoreConfigHelpers.kt$net.corda.nodeapi.internal.KeyStoreConfigHelpers.kt</ID>
    <ID>MatchingDeclarationName:Main.kt$net.corda.bootstrapper.Main.kt</ID>
    <ID>MatchingDeclarationName:Measure.kt$net.corda.client.rpc.Measure.kt</ID>
    <ID>MatchingDeclarationName:MockNetworkParametersService.kt$net.corda.testing.node.internal.MockNetworkParametersService.kt</ID>
    <ID>MatchingDeclarationName:NamedCache.kt$net.corda.core.internal.NamedCache.kt</ID>
    <ID>MatchingDeclarationName:NetParams.kt$net.corda.netparams.NetParams.kt</ID>
    <ID>MatchingDeclarationName:NetworkParametersServiceInternal.kt$net.corda.core.internal.NetworkParametersServiceInternal.kt</ID>
    <ID>MatchingDeclarationName:OGSwapPricingCcpExample.kt$net.corda.vega.analytics.example.OGSwapPricingCcpExample.kt</ID>
    <ID>MatchingDeclarationName:OGSwapPricingExample.kt$net.corda.vega.analytics.example.OGSwapPricingExample.kt</ID>
    <ID>MatchingDeclarationName:PlatformSecureRandom.kt$net.corda.core.crypto.internal.PlatformSecureRandom.kt</ID>
    <ID>MatchingDeclarationName:Query.kt$net.corda.webserver.api.Query.kt</ID>
    <ID>MatchingDeclarationName:ReceiveAllFlowTests.kt$net.corda.coretests.flows.ReceiveAllFlowTests.kt</ID>
    <ID>MatchingDeclarationName:ReferenceInputStateTests.kt$net.corda.coretests.transactions.ReferenceInputStateTests.kt</ID>
    <ID>MatchingDeclarationName:RigorousMock.kt$net.corda.testing.internal.RigorousMock.kt</ID>
    <ID>MatchingDeclarationName:RpcServerCordaFutureSerialiser.kt$net.corda.node.serialization.amqp.RpcServerCordaFutureSerialiser.kt</ID>
    <ID>MatchingDeclarationName:SSLHelper.kt$net.corda.nodeapi.internal.protonwrapper.netty.SSLHelper.kt</ID>
    <ID>MatchingDeclarationName:SampleData.kt$net.corda.deterministic.verifier.SampleData.kt</ID>
    <ID>MatchingDeclarationName:SerializationHelper.kt$net.corda.networkbuilder.serialization.SerializationHelper.kt</ID>
    <ID>MatchingDeclarationName:SerializationHelper.kt$net.corda.serialization.internal.amqp.SerializationHelper.kt</ID>
    <ID>MatchingDeclarationName:Specification.kt$net.corda.common.configuration.parsing.internal.Specification.kt</ID>
    <ID>MatchingDeclarationName:SpringDriver.kt$net.corda.test.spring.SpringDriver.kt</ID>
    <ID>MatchingDeclarationName:SupportedTransforms.kt$net.corda.serialization.internal.amqp.SupportedTransforms.kt</ID>
    <ID>MatchingDeclarationName:TargetVersionDependentRules.kt$net.corda.core.internal.rules.TargetVersionDependentRules.kt</ID>
    <ID>MatchingDeclarationName:TestConstants.kt$net.corda.testing.core.TestConstants.kt</ID>
    <ID>MatchingDeclarationName:TestUtils.kt$net.corda.testing.core.TestUtils.kt</ID>
    <ID>MatchingDeclarationName:TransactionTypes.kt$net.corda.explorer.model.TransactionTypes.kt</ID>
    <ID>MatchingDeclarationName:TutorialFlowStateMachines.kt$net.corda.docs.kotlin.tutorial.flowstatemachines.TutorialFlowStateMachines.kt</ID>
    <ID>MatchingDeclarationName:Utils.kt$io.cryptoblk.core.Utils.kt</ID>
    <ID>MatchingDeclarationName:VirtualCordapps.kt$net.corda.node.internal.cordapp.VirtualCordapps.kt</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager : BridgeManager</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager$AMQPBridge</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager$val newBridge = AMQPBridge(queueName, targets, legalNames, amqpConfig, sharedEventLoopGroup!!, artemis!!, bridgeMetricsService)</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$logDebugWithMDC { "Bridged Send to ${legalNames.first()} uuid: ${artemisMessage.getObjectProperty("_AMQ_DUPL_ID")}" }</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$logInfoWithMDC("Rollback rejected message uuid: ${artemisMessage.getObjectProperty("_AMQ_DUPL_ID")}")</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$val msg = "Message exceeds maxMessageSize network parameter, maxMessageSize: [${amqpConfig.maxMessageSize}], message size: [${artemisMessage.bodySize}], " + "dropping message, uuid: ${artemisMessage.getObjectProperty("_AMQ_DUPL_ID")}"</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$val session = sessionFactory.createSession(NODE_P2P_USER, NODE_P2P_USER, false, true, true, false, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPConfigurationImpl$constructor(config: MutualSslConfiguration, maxMessageSize: Int, crlCheckSoftFail: Boolean) : this(config.keyStore.get(), config.trustStore.get(), maxMessageSize, crlCheckSoftFail)</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$import net.corda.nodeapi.internal.ArtemisMessagingComponent.RemoteInboxAddress.Companion.translateLocalQueueToInboxAddress</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest$private</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest$val artemisServer = ArtemisMessagingServer(artemisConfig, artemisAddress.copy(host = "0.0.0.0"), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest$val bridgeManager = AMQPBridgeManager(artemisConfig.p2pSslOptions, artemisAddress, MAX_MESSAGE_SIZE, artemisConfig.crlCheckSoftFail)</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest${ // Note that the opposite of this test (that a connection is established if strict checking is disabled) is carried out by the // ack/nack test above. "Strict CRL checking" means that soft fail mode is disabled. val sourceQueueName = "internal.peers." + BOB.publicKey.toStringShort() val (artemisServer, artemisClient, bridge) = createArtemis(sourceQueueName, crlCheckSoftFail = false) createAMQPServer().use { val connectedFuture = it.onConnection.toFuture() it.start() val connectedResult = connectedFuture.get() assertEquals(false, connectedResult.connected) } bridge.stop() artemisClient.stop() artemisServer.stop() }</ID>
    <ID>MaxLineLength:AMQPChannelHandler.kt$AMQPChannelHandler$"Message for incorrect legal identity ${msg.destinationLegalName} expected ${remoteCert!!.subjectX500Principal}"</ID>
    <ID>MaxLineLength:AMQPChannelHandler.kt$AMQPChannelHandler$eventProcessor = EventProcessor(ch, serverMode, localCert!!.subjectX500Principal.toString(), remoteCert!!.subjectX500Principal.toString(), userName, password)</ID>
    <ID>MaxLineLength:AMQPChannelHandler.kt$AMQPChannelHandler$logErrorWithMDC("Provided certificate subject $remoteX500Name not in expected set $allowedRemoteLegalNames")</ID>
    <ID>MaxLineLength:AMQPChannelHandler.kt$AMQPChannelHandler$require</ID>
    <ID>MaxLineLength:AMQPChannelHandler.kt$AMQPChannelHandler${ logWarnWithMDC("SSL Handshake closed early.") }</ID>
    <ID>MaxLineLength:AMQPClient.kt$AMQPClient.ClientChannelInitializer$log.error("Blocking future connection attempts to $target due to bad certificate on endpoint")</ID>
    <ID>MaxLineLength:AMQPClient.kt$AMQPClient.ClientChannelInitializer$val handler = createClientSslHelper(target, parent.allowedRemoteLegalNames, keyManagerFactory, trustManagerFactory)</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme$( cordappCustomSerializers: Set&lt;SerializationCustomSerializer&lt;*, *&gt;&gt;, cordappSerializationWhitelists: Set&lt;SerializationWhitelist&gt;, serializerFactoriesForContexts: MutableMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt; )</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme$@Suppress("UNUSED") constructor() : this(emptySet(), emptySet(), AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised())</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme$constructor(cordapps: List&lt;Cordapp&gt;) : this(cordapps.customSerializers, cordapps.serializationWhitelists, AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised())</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme$return SerializerFactoryBuilder.build(context.whitelist, context.deserializationClassLoader, context.lenientCarpenterEnabled).apply { register(RpcClientObservableDeSerializer) register(RpcClientCordaFutureSerializer(this)) register(RxNotificationSerializer(this)) }</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$nodeSerializationEnv = createSerializationEnv(classLoader, customSerializers, serializationWhitelists, serializerFactoriesForContexts)</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$p2pContext = if (classLoader != null) AMQP_P2P_CONTEXT.withClassLoader(classLoader) else AMQP_P2P_CONTEXT</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$registerScheme(AMQPClientSerializationScheme(customSerializers, serializationWhitelists, serializerFactoriesForContexts))</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$serializerFactoriesForContexts: MutableMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt; = AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised()</ID>
    <ID>MaxLineLength:AMQPConfiguration.kt$AMQPConfiguration$/** * Enables full debug tracing of all netty and AMQP level packets. This logs aat very high volume and is only for developers. */ @JvmDefault val trace: Boolean get() = false</ID>
    <ID>MaxLineLength:AMQPConfiguration.kt$AMQPConfiguration$/** * Setting crlCheckSoftFail to true allows certificate paths where some leaf certificates do not contain cRLDistributionPoints * and also allows validation to continue if the CRL distribution server is not contactable. */ @JvmDefault val crlCheckSoftFail: Boolean get() = true</ID>
    <ID>MaxLineLength:AMQPConfiguration.kt$AMQPConfiguration$/** * The maximum allowed size for packets, which will be dropped ahead of send. In future may also be enforced on receive, * but currently that is deferred to Artemis and the bridge code. */ val maxMessageSize: Int</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel$cache.getOrPut(typeDescriptor) { interpretationState.run { typeNotation.name.typeIdentifier.interpretIdentifier() } }</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel$typesByIdentifier[typeInformation.typeIdentifier] ?: throw NotSerializableException("Cannot resolve cyclic reference to ${typeInformation.typeIdentifier}")</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel.InterpretationState$ fun TypeIdentifier.interpretIdentifier(): RemoteTypeInformation</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel.InterpretationState$ private fun TypeIdentifier.interpretNoNotation(): RemoteTypeInformation</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel.InterpretationState$ private fun TypeNotation.interpretNotation(identifier: TypeIdentifier): RemoteTypeInformation</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel.InterpretationState$private</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel.InterpretationState$return if (isInterface) RemoteTypeInformation.AnInterface(typeDescriptor, identifier, properties, interfaces, typeParameters) else RemoteTypeInformation.Composable(typeDescriptor, identifier, properties, interfaces, typeParameters)</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel.InterpretationState$val constants = choices.asSequence().mapIndexed { index, choice -&gt; choice.name to index }.toMap(LinkedHashMap())</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModelTests.kt$AMQPRemoteTypeModelTests$C&lt;V&gt; : Superclass</ID>
    <ID>MaxLineLength:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme$@DeleteForDJVM constructor(cordapps: List&lt;Cordapp&gt;) : this(cordapps.customSerializers, cordapps.serializationWhitelists, AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised())</ID>
    <ID>MaxLineLength:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme$private</ID>
    <ID>MaxLineLength:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme$val key = SerializationFactoryCacheKey(context.whitelist, context.deserializationClassLoader, context.preventDataLoss, context.customSerializers)</ID>
    <ID>MaxLineLength:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme${ // This is a hack introduced in version 3 to fix a spring boot issue - CORDA-1747. // It breaks the shell because it overwrites the CordappClassloader with the system classloader that doesn't know about any CorDapps. // In case a spring boot serialization issue with generics is found, a better solution needs to be found to address it. // var contextToUse = context // if (context.useCase == SerializationContext.UseCase.RPCClient) { // contextToUse = context.withClassLoader(getContextClassLoader()) // } val serializerFactory = getSerializerFactory(context) return DeserializationInput(serializerFactory).deserialize(byteSequence, clazz, context) }</ID>
    <ID>MaxLineLength:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme${ with(factory) { register(publicKeySerializer) register(net.corda.serialization.internal.amqp.custom.PrivateKeySerializer) register(net.corda.serialization.internal.amqp.custom.ThrowableSerializer(this)) register(net.corda.serialization.internal.amqp.custom.BigDecimalSerializer) register(net.corda.serialization.internal.amqp.custom.BigIntegerSerializer) register(net.corda.serialization.internal.amqp.custom.CurrencySerializer) register(net.corda.serialization.internal.amqp.custom.OpaqueBytesSubSequenceSerializer(this)) register(net.corda.serialization.internal.amqp.custom.InstantSerializer(this)) register(net.corda.serialization.internal.amqp.custom.DurationSerializer(this)) register(net.corda.serialization.internal.amqp.custom.LocalDateSerializer(this)) register(net.corda.serialization.internal.amqp.custom.LocalDateTimeSerializer(this)) register(net.corda.serialization.internal.amqp.custom.LocalTimeSerializer(this)) register(net.corda.serialization.internal.amqp.custom.ZonedDateTimeSerializer(this)) register(net.corda.serialization.internal.amqp.custom.ZoneIdSerializer(this)) register(net.corda.serialization.internal.amqp.custom.OffsetTimeSerializer(this)) register(net.corda.serialization.internal.amqp.custom.OffsetDateTimeSerializer(this)) register(net.corda.serialization.internal.amqp.custom.OptionalSerializer(this)) register(net.corda.serialization.internal.amqp.custom.YearSerializer(this)) register(net.corda.serialization.internal.amqp.custom.YearMonthSerializer(this)) register(net.corda.serialization.internal.amqp.custom.MonthDaySerializer(this)) register(net.corda.serialization.internal.amqp.custom.PeriodSerializer(this)) register(net.corda.serialization.internal.amqp.custom.ClassSerializer(this)) register(net.corda.serialization.internal.amqp.custom.X509CertificateSerializer) register(net.corda.serialization.internal.amqp.custom.X509CRLSerializer) register(net.corda.serialization.internal.amqp.custom.CertPathSerializer(this)) register(net.corda.serialization.internal.amqp.custom.StringBufferSerializer) register(net.corda.serialization.internal.amqp.custom.InputStreamSerializer) register(net.corda.serialization.internal.amqp.custom.BitSetSerializer(this)) register(net.corda.serialization.internal.amqp.custom.EnumSetSerializer(this)) register(net.corda.serialization.internal.amqp.custom.ContractAttachmentSerializer(this)) registerNonDeterministicSerializers(factory) } // This step is registering custom serializers, which have been added after node initialisation (i.e. via attachments during transaction verification). // Note: the order between the registration of customSerializers and cordappCustomSerializers must be preserved as-is. The reason is the following: // Currently, the serialization infrastructure does not support multiple versions of a class (the first one that is registered dominates). // As a result, when inside a context with attachments class loader, we prioritize serializers loaded on-demand from attachments to serializers that had been // loaded during node initialisation, by scanning the cordapps folder. context.customSerializers.forEach { customSerializer -&gt; factory.registerExternal(CorDappCustomSerializer(customSerializer, factory)) } cordappCustomSerializers.forEach { customSerializer -&gt; factory.registerExternal(CorDappCustomSerializer(customSerializer, factory)) } context.properties[ContextPropertyKeys.SERIALIZERS]?.apply { uncheckedCast&lt;Any, List&lt;CustomSerializer&lt;out Any&gt;&gt;&gt;(this).forEach { factory.register(it) } } }</ID>
    <ID>MaxLineLength:AMQPSerializer.kt$AMQPSerializer$ fun readObject(obj: Any, schemas: SerializationSchemas, input: DeserializationInput, context: SerializationContext): T</ID>
    <ID>MaxLineLength:AMQPSerializer.kt$AMQPSerializer$ fun writeClassInfo(output: SerializationOutput)</ID>
    <ID>MaxLineLength:AMQPSerializer.kt$AMQPSerializer$/** * Textual unique representation of the JVM type this represents. Will be encoded into the AMQP stream and * will appear in the schema. * * This should be unique enough that we can use one global cache of [AMQPSerializer]s and use this as the look up key. */ val typeDescriptor: Symbol</ID>
    <ID>MaxLineLength:AMQPSerializerFactories.kt$ fun createClassCarpenter(context: SerializationContext): ClassCarpenter</ID>
    <ID>MaxLineLength:AMQPServer.kt$AMQPServer$server.group(bossGroup, workerGroup).channel(NioServerSocketChannel::class.java).option(ChannelOption.SO_BACKLOG, 100).handler(LoggingHandler(LogLevel.INFO)).childHandler(ServerChannelInitializer(this))</ID>
    <ID>MaxLineLength:AMQPServer.kt$AMQPServer$val channelFuture = server.bind(hostName, port).sync() // block/throw here as better to know we failed to claim port than carry on</ID>
    <ID>MaxLineLength:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$( cordappCustomSerializers: Set&lt;SerializationCustomSerializer&lt;*, *&gt;&gt;, cordappSerializationWhitelists: Set&lt;SerializationWhitelist&gt;, serializerFactoriesForContexts: MutableMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt; )</ID>
    <ID>MaxLineLength:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$constructor() : this(emptySet(), emptySet(), AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised())</ID>
    <ID>MaxLineLength:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$constructor(cordapps: List&lt;Cordapp&gt;) : this(cordapps.customSerializers, cordapps.serializationWhitelists, AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised())</ID>
    <ID>MaxLineLength:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$return SerializerFactoryBuilder.build(context.whitelist, context.deserializationClassLoader, context.lenientCarpenterEnabled).apply { register(RpcServerObservableSerializer()) register(RpcServerCordaFutureSerializer(this)) register(RxNotificationSerializer(this)) }</ID>
    <ID>MaxLineLength:AMQPTestUtils.kt$val dir = ProjectStructure.projectRootDir / "serialization" / "src" / "test" / "resources" / javaClass.packageName.replace('.', separatorChar)</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser$else -&gt; throw IllegalTypeNameParserStateException("Type name '$typeString' contains illegal character '$c'")</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser$throw IllegalTypeNameParserStateException("Nested depth of type parameters exceeds maximum of $MAX_TYPE_PARAM_DEPTH")</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParserTests.kt$AMQPTypeIdentifierParserTests$assertParsesCompatibly&lt;WithParameters&lt;IntArray, WithParameter&lt;Array&lt;WithParameters&lt;Array&lt;Array&lt;Date&gt;&gt;, UUID&gt;&gt;&gt;&gt;&gt;()</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParserTests.kt$AMQPTypeIdentifierParserTests$verify(" java.util.Map &lt; java.util.Map&lt; java.lang.String, java.lang.Integer &gt;, java.util.Map &lt; java.lang.Long , java.lang.String &gt; &gt;")</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParserTests.kt$AMQPTypeIdentifierParserTests$verify("java.util.List&lt;net.corda.core.contracts.Command&lt;net.corda.core.contracts.Command&lt;net.corda.core.contracts.CommandData&gt;&gt;&gt;")</ID>
    <ID>MaxLineLength:AMQPTypeIdentifiers.kt$AMQPTypeIdentifiers$is TypeIdentifier.Parameterised</ID>
    <ID>MaxLineLength:AMQPTypeIdentifiers.kt$AMQPTypeIdentifiers$private val primitiveByteArrayType = TypeIdentifier.ArrayOf(TypeIdentifier.forClass(Byte::class.javaPrimitiveType!!))</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer$// Create a new tree of steps that also holds a reference to the parent of each step. This is required to uniquely identify each step // (assuming that each step label is unique at a given level). private fun transformTree(inputTree: List&lt;InputTreeStep&gt;): List&lt;ProgressStep&gt;</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer$ansi.a("${IntStream.range(indent, indent).mapToObj { "\t" }.toList().joinToString(separator = "") { s -&gt; s }} $errorIcon ${error.message}")</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer$updatesSubscription</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer$val newTree = transformTree(it.first.map { elem -&gt; InputTreeStep(elem.first, elem.second) }) // Process indices first, as if the tree has changed the associated index with this update is for the old tree. Note // that the one case where this isn't true is the very first update, but in this case the index should be 0 (as this // update is for the initial state). The remapping on a new tree assumes the step at index 0 is always at least current, // so this case is handled there. treeIndex = it.second treeIndexProcessed.add(it.second) if (newTree != tree) { remapIndices(newTree) tree = newTree } draw(true)</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer${ // By combining the two observables, a race condition where both emit items at roughly the same time is avoided. This could // result in steps being incorrectly marked as skipped. Instead, whenever either observable emits an item, a pair of the // last index and last tree is returned, which ensures that updates to either are processed in series. updatesSubscription = combineLatest(treeUpdates, indexUpdates) { tree, index -&gt; Pair(tree, index) }.subscribe( { val newTree = transformTree(it.first.map { elem -&gt; InputTreeStep(elem.first, elem.second) }) // Process indices first, as if the tree has changed the associated index with this update is for the old tree. Note // that the one case where this isn't true is the very first update, but in this case the index should be 0 (as this // update is for the initial state). The remapping on a new tree assumes the step at index 0 is always at least current, // so this case is handled there. treeIndex = it.second treeIndexProcessed.add(it.second) if (newTree != tree) { remapIndices(newTree) tree = newTree } draw(true) }, { done(it) }, { done(null) } ) }</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer${ // If some steps were removed from the progress tracker, we don't want to leave junk hanging around below. val linesToClear = prevLinesDrawn - newLinesDrawn repeat(linesToClear) { ansi.eraseLine() ansi.newline() } ansi.cursorUp(linesToClear) }</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer${ // If there is nothing on the stack at any point, it implies that this step is at the top level and has no parent. null }</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer${ // The top of the stack is at the same or lower level than the current step. Remove items from the top until the topmost // item is at a higher level - this is the parent step. repeat(levelDifference + 1) { stack.pop() } }</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$StdoutANSIProgressRenderer : ANSIProgressRenderer</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$StdoutANSIProgressRenderer$appenderRefs.forEach { config.addAppender(manager.configuration.appenders[it.ref], it.level, it.filter) }</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$StdoutANSIProgressRenderer$loggerFor&lt;StdoutANSIProgressRenderer&gt;().warn("Cannot find console appender - progress tracking may not work as expected")</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$StdoutANSIProgressRenderer$val consoleAppender = manager.configuration.appenders.values.filterIsInstance&lt;ConsoleAppender&gt;().singleOrNull { it.name == "Console-Selector" }</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$checkTrackingState(captor, 2, listOf(stepSuccess(STEP_1_LABEL), stepSkipped(STEP_2_LABEL), stepActive(STEP_3_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$checkTrackingState(captor, 3, listOf(stepSuccess(STEP_1_LABEL), stepSuccess(STEP_2_LABEL), stepActive(STEP_3_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$checkTrackingState(captor, 4, listOf(stepActive(STEP_1_LABEL), stepNotRun(STEP_4_LABEL), stepNotRun(STEP_5_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$checkTrackingState(captor, 5, listOf(stepSuccess(STEP_1_LABEL), stepSuccess(STEP_3_LABEL), stepSuccess(STEP_2_LABEL), stepActive(STEP_3_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$checkTrackingState(captor, 6, listOf(stepSuccess(STEP_1_LABEL), stepSuccess(STEP_3_LABEL), stepSuccess(STEP_2_LABEL), stepActive(STEP_3_LABEL), stepNotRun(STEP_4_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$feedSubject.onNext(listOf(Pair(0, STEP_1_LABEL), Pair(1, STEP_2_LABEL), Pair(1, STEP_3_LABEL), Pair(0, STEP_4_LABEL), Pair(0, STEP_5_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$feedSubject.onNext(listOf(Pair(0, STEP_1_LABEL), Pair(1, STEP_3_LABEL), Pair(0, STEP_2_LABEL), Pair(1, STEP_3_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$feedSubject.onNext(listOf(Pair(0, STEP_1_LABEL), Pair(1, STEP_3_LABEL), Pair(0, STEP_2_LABEL), Pair(1, STEP_3_LABEL), Pair(2, STEP_4_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$flowProgressHandle = FlowProgressHandleImpl(StateMachineRunId.createRandom(), openFuture&lt;String&gt;(), Observable.empty(), stepsTreeIndexFeed, stepsTreeFeed)</ID>
    <ID>MaxLineLength:APIServer.kt$APIServer</ID>
    <ID>MaxLineLength:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$ByteSequence.of(byteArrayOf('c'.toByte(), 'o'.toByte(), 'r'.toByte(), 'd'.toByte(), 'a'.toByte(), 0.toByte(), 0.toByte(), 1.toByte()))</ID>
    <ID>MaxLineLength:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$val backingMap = AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;({ maxFactories }).toSynchronised()</ID>
    <ID>MaxLineLength:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$val deserialized = serialized.deserialize(context = context, serializationFactory = serializationEnvironment.serializationFactory)</ID>
    <ID>MaxLineLength:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$val factory = SerializerFactoryBuilder.build(TESTING_CONTEXT.whitelist, TESTING_CONTEXT.deserializationClassLoader)</ID>
    <ID>MaxLineLength:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$val scheme = object : AbstractAMQPSerializationScheme(emptySet(), emptySet(), backingMap, createSerializerFactoryFactory()) { override fun rpcClientSerializerFactory(context: SerializationContext): SerializerFactory { return factory } override fun rpcServerSerializerFactory(context: SerializationContext): SerializerFactory { return factory } override fun canDeserializeVersion(magic: CordaSerializationMagic, target: SerializationContext.UseCase): Boolean { return true } }</ID>
    <ID>MaxLineLength:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest.&lt;no name provided&gt;$override</ID>
    <ID>MaxLineLength:AbstractAttachment.kt$// We whitelist sources of transaction JARs for now as a temporary state until the DJVM and other security sandboxes // have been integrated, at which point we'll be able to run untrusted code downloaded over the network and this mechanism // can be removed. Because we ARE downloading attachments over the P2P network in anticipation of this upgrade, we // track the source of each attachment in our store. TestDSL is used by LedgerDSLInterpreter when custom attachments // are added in unit test code. val TRUSTED_UPLOADERS = listOf(DEPLOYED_CORDAPP_UPLOADER, RPC_UPLOADER, TESTDSL_UPLOADER)</ID>
    <ID>MaxLineLength:AbstractAttachment.kt$AbstractAttachment.Companion$ @DeleteForDJVM fun SerializeAsTokenContext.attachmentDataLoader(id: SecureHash): () -&gt; ByteArray</ID>
    <ID>MaxLineLength:AbstractCashFlow.kt$AbstractCashFlow$@Suspendable protected</ID>
    <ID>MaxLineLength:AbstractCashFlow.kt$CashException : FlowException</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$ @Suspendable fun unconsumedCashStatesForSpending( services: ServiceHub, amount: Amount&lt;Currency&gt;, onlyFromIssuerParties: Set&lt;AbstractParty&gt; = emptySet(), notary: Party? = null, lockId: UUID, withIssuerRefs: Set&lt;OpaqueBytes&gt; = emptySet() ): List&lt;StateAndRef&lt;Cash.State&gt;&gt;</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$ protected abstract fun executeQuery( connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean ): Boolean</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$log.trace("Coin selection for $amount retrieved ${stateAndRefs.count()} states totalling $totalPennies pennies: $stateAndRefs")</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$log.trace("Coin selection requested $amount but retrieved $totalPennies pennies with state refs: ${stateAndRefs.map { it.ref }}")</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$val durationMillis = (minOf(retrySleep.shl(retryCount), retryCap / 2) * (1.0 + Math.random())).toInt()</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection.Companion$"\nPlease specify an implementation in META-INF/services/${AbstractCashSelection::class.qualifiedName}."</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection.Companion$val cashSelectionAlgos = ServiceLoader.load(AbstractCashSelection::class.java, this::class.java.classLoader).toList()</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection.Companion${ instance.set(cashSelectionAlgo) cashSelectionAlgo }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$" for it exists in the database. This suggests the identity for this node has been lost. Shutting down to prevent network map issues."</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$"Private key for the node legal identity not found (alias $legalIdentityPrivateKeyAlias) but the corresponding public key"</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$"match what's in the key store: $subject. You might need to adjust the configuration of `notary.serviceLegalName`."</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$"or if you don't have one yet, fill out the config file and run corda.jar initial-registration. "</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$( CertificateType.LEGAL_IDENTITY, nodeCaCert.subjectX500Principal, nodeCaCert.publicKey, cryptoService.getSigner(X509Utilities.CORDA_CLIENT_CA), nodeCaCert.subjectX500Principal, legalIdentityPublicKey, // TODO this might be smaller than DEFAULT_VALIDITY_WINDOW, shall we strictly apply DEFAULT_VALIDITY_WINDOW? X509Utilities.getCertificateValidityWindow( DEFAULT_VALIDITY_WINDOW.first, DEFAULT_VALIDITY_WINDOW.second, nodeCaCert) )</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$/** * Should be [rx.schedulers.Schedulers.io] for production, * or [rx.internal.schedulers.CachedThreadScheduler] (with shutdown registered with [runOnStop]) for shared-JVM testing. */ protected abstract val rxIoScheduler: Scheduler</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$// Ideally we should be disabling the FinalityHandler if it's not needed, to prevent any party from submitting transactions to us without // us checking. Previously this was gated on app target version and if there were no apps with target version &lt;= 3 then the handler would // be disabled. However this prevents seemless rolling-upgrades and so it was removed until a better solution comes along. private fun installFinalityHandler()</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$// TODO Cancelling parameters updates - if we do that, how we ensure that no one uses cancelled parameters in the transactions? val networkMapUpdater = NetworkMapUpdater( networkMapCache, NodeInfoWatcher( configuration.baseDirectory, @Suppress("LeakingThis") rxIoScheduler, Duration.ofMillis(configuration.additionalNodeInfoPollingFrequencyMsec) ), networkMapClient, configuration.baseDirectory, configuration.extraNetworkMapKeys, networkParametersStorage ).closeOnStop()</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$// There is already a party in the identity store for this node, but the key has been lost. If this node starts up, it will // publish it's new key to the network map, which Corda cannot currently handle. To prevent this, stop the node from starting. "Private key for the node legal identity not found (alias $legalIdentityPrivateKeyAlias) but the corresponding public key" + " for it exists in the database. This suggests the identity for this node has been lost. Shutting down to prevent network map issues."</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$CheckpointVerifier.verifyCheckpointsCompatible(checkpointStorage, cordappProvider.cordapps, versionInfo.platformVersion, services, tokenizableServices)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$ServiceInstantiationException : CordaException</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$cordapp.initiatedFlows.groupBy { it.requireAnnotation&lt;InitiatedBy&gt;().value.java }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$database.startHikariPool(props, configuration.database, schemaService.internalSchemas(), metricRegistry, this.cordappLoader, configuration.baseDirectory, configuration.myLegalName)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$flowManager.registerInitiatedCoreFlowFactory(ContractUpgradeFlow.Initiate::class, NotaryChangeHandler::class, ::ContractUpgradeHandler)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$flowManager.registerInitiatedCoreFlowFactory(NotaryChangeFlow::class, NotaryChangeHandler::class, ::NotaryChangeHandler)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$flowManager.registerInitiatedCoreFlowFactory(SwapIdentitiesFlow::class, SwapIdentitiesHandler::class, ::SwapIdentitiesHandler)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$if (!cryptoService.containsKey(legalIdentityPrivateKeyAlias) &amp;&amp; !signingCertificateStore.contains(legalIdentityPrivateKeyAlias)) { // Directly use the X500 name to public key map, as the identity service requires the node identity to start correctly. database.transaction { val x500Map = PersistentIdentityService.createX500ToKeyMap(cacheFactory) require(configuration.myLegalName !in x500Map) { // There is already a party in the identity store for this node, but the key has been lost. If this node starts up, it will // publish it's new key to the network map, which Corda cannot currently handle. To prevent this, stop the node from starting. "Private key for the node legal identity not found (alias $legalIdentityPrivateKeyAlias) but the corresponding public key" + " for it exists in the database. This suggests the identity for this node has been lost. Shutting down to prevent network map issues." } } log.info("$legalIdentityPrivateKeyAlias not found in key store, generating fresh key!") createAndStoreLegalIdentity(legalIdentityPrivateKeyAlias) signingCertificateStore = configuration.signingCertificateStore.get() // We need to resync after [createAndStoreLegalIdentity]. } else { checkAliasMismatch(legalIdentityPrivateKeyAlias, signingCertificateStore) }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$log</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$log.error("Corda service ${it.name} failed to instantiate. Reason was: ${e.cause?.rootMessage}", e.cause)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$log.error("Error while adding key fingerprint $it to cordappSignerKeyFingerprintBlacklist due to ${e.message}", e)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$log.warn("Found more than one node registration with our legal name, this is only expected if our keypair has been regenerated")</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$networkParametersStorage.setCurrentParameters(signedNetParams, trustRoot) identityService.loadIdentities(nodeInfo.legalIdentitiesAndCerts) attachments.start() cordappProvider.start() nodeProperties.start() // Place the long term identity key in the KMS. Eventually, this is likely going to be separated again because // the KMS is meant for derived temporary keys used in transactions, and we're not supposed to sign things with // the identity key. But the infrastructure to make that easy isn't here yet. keyManagementService.start(keyPairs) val notaryService = maybeStartNotaryService(myNotaryIdentity) installCordaServices() contractUpgradeService.start() vaultService.start() ScheduledActivityObserver.install(vaultService, schedulerService, flowLogicRefFactory) val frozenTokenizableServices = tokenizableServices!! tokenizableServices = null verifyCheckpointsCompatible(frozenTokenizableServices) checkpointDumper.start(frozenTokenizableServices) smm.start(frozenTokenizableServices) // Shut down the SMM so no Fibers are scheduled. runOnStop += { smm.stop(acceptableLiveFiberCountOnStop()) } (smm as? StateMachineManagerInternal)?.let { val flowMonitor = FlowMonitor({ smm.snapshot().filter { flow -&gt; flow !in smm.flowHospital }.toSet() }, configuration.flowMonitorPeriodMillis, configuration.flowMonitorSuspensionLoggingThresholdMillis) runOnStop += flowMonitor::stop flowMonitor.start() } schedulerService.start() createStartedNode(nodeInfo, rpcOps, notaryService).also { _started = it }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$private</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$protected open</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$protected open fun generateKeyPair(alias: String)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$protected val cacheFactory = cacheFactoryPrototype.bindWithConfig(configuration).bindWithMetrics(metricRegistry).tokenize()</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$return NodeVaultService(platformClock, keyManagementService, services, database, schemaService, cordappLoader.appClassLoader)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$signingCertificateStore = configuration.signingCertificateStore.get()</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$throw ConfigurationException("The name '$legalName' for $NODE_IDENTITY_ALIAS_PREFIX doesn't match what's in the key store: $subject")</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$throw ConfigurationException("The name of the notary service '$serviceLegalName' for $DISTRIBUTED_NOTARY_ALIAS_PREFIX doesn't " + "match what's in the key store: $subject. You might need to adjust the configuration of `notary.serviceLegalName`.")</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$throw IllegalArgumentException("At least one of the keystores or truststore passwords does not match configuration.")</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$throw IllegalStateException("CryptoService and signingCertificateStore are not aligned, the entry for key-alias: $alias is only found in $keyExistsIn")</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val (netParams, signedNetParams) = NetworkParametersReader(trustRoot, networkMapClient, configuration.baseDirectory).read()</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val certificates = if (cryptoService.containsKey(compositeKeyAlias) &amp;&amp; signingCertificateStore.contains(compositeKeyAlias)) { val certificate = signingCertificateStore[compositeKeyAlias] // We have to create the certificate chain for the composite key manually, this is because we don't have a keystore // provider that understand compositeKey-privateKey combo. The cert chain is created using the composite key certificate + // the tail of the private key certificates, as they are both signed by the same certificate chain. listOf(certificate) + privateKeyAliasCertChain.drop(1) } else { checkAliasMismatch(compositeKeyAlias, signingCertificateStore) // If [compositeKeyAlias] does not exist, we assume the notary is CFT, and each cluster member shares the same notary key pair. privateKeyAliasCertChain }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val certificates: List&lt;X509Certificate&gt; = signingCertificateStore.query { getCertificateChain(legalIdentityPrivateKeyAlias) }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val checkpointDumper = CheckpointDumper(checkpointStorage, database, services, services.configuration.baseDirectory)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val cordappProvider = CordappProviderImpl(cordappLoader, CordappConfigFileProvider(configuration.cordappDirectories), attachments).tokenize()</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val extendedServiceConstructor = serviceClass.getDeclaredConstructor(AppServiceHub::class.java).apply { isAccessible = true }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val keyExistsIn: String = if (cryptoService.containsKey(alias)) "CryptoService" else "signingCertificateStore"</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val networkMapClient: NetworkMapClient? = configuration.networkServices?.let { NetworkMapClient(it.networkMapURL, versionInfo) }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val servicesForResolution = ServicesForResolutionImpl(identityService, attachments, cordappProvider, networkParametersStorage, transactionStorage).also { attachments.servicesForResolution = it }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode${ // Directly use the X500 name to public key map, as the identity service requires the node identity to start correctly. database.transaction { val x500Map = PersistentIdentityService.createX500ToKeyMap(cacheFactory) require(configuration.myLegalName !in x500Map) { // There is already a party in the identity store for this node, but the key has been lost. If this node starts up, it will // publish it's new key to the network map, which Corda cannot currently handle. To prevent this, stop the node from starting. "Private key for the node legal identity not found (alias $legalIdentityPrivateKeyAlias) but the corresponding public key" + " for it exists in the database. This suggests the identity for this node has been lost. Shutting down to prevent network map issues." } } log.info("$legalIdentityPrivateKeyAlias not found in key store, generating fresh key!") createAndStoreLegalIdentity(legalIdentityPrivateKeyAlias) signingCertificateStore = configuration.signingCertificateStore.get() // We need to resync after [createAndStoreLegalIdentity]. }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode${ // The following will throw IOException if key file not found or KeyStoreException if keystore password is incorrect. val sslKeyStore = configuration.p2pSslOptions.keyStore.get() val signingCertificateStore = configuration.signingCertificateStore.get() val trustStore = configuration.p2pSslOptions.trustStore.get() AllCertificateStores(trustStore, sslKeyStore, signingCertificateStore) }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode${ checkAliasMismatch(compositeKeyAlias, signingCertificateStore) // If [compositeKeyAlias] does not exist, we assume the notary is CFT, and each cluster member shares the same notary key pair. privateKeyAliasCertChain }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode${ val certificate = signingCertificateStore[compositeKeyAlias] // We have to create the certificate chain for the composite key manually, this is because we don't have a keystore // provider that understand compositeKey-privateKey combo. The cert chain is created using the composite key certificate + // the tail of the private key certificates, as they are both signed by the same certificate chain. listOf(certificate) + privateKeyAliasCertChain.drop(1) }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode${ val loadedServices = cordappLoader.cordapps.flatMap { it.services } // This sets the Cordapp classloader on the contextClassLoader of the current thread, prior to initializing services // Needed because of bug CORDA-2653 - some Corda services can utilise third-party libraries that require access to // the Thread context class loader val oldContextClassLoader: ClassLoader? = Thread.currentThread().contextClassLoader try { Thread.currentThread().contextClassLoader = cordappLoader.appClassLoader loadedServices.forEach { try { installCordaService(it) } catch (e: NoSuchMethodException) { log.error("${it.name}, as a Corda service, must have a constructor with a single parameter of type " + ServiceHub::class.java.name) } catch (e: ServiceInstantiationException) { if (e.cause != null) { log.error("Corda service ${it.name} failed to instantiate. Reason was: ${e.cause?.rootMessage}", e.cause) } else { log.error("Corda service ${it.name} failed to instantiate", e) } } catch (e: Exception) { log.error("Unable to install Corda service ${it.name}", e) } } } finally { Thread.currentThread().contextClassLoader = oldContextClassLoader } }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode.AppServiceHubImpl$require(logicType.isAnnotationPresent(StartableByService::class.java)) { "${logicType.name} was not designed for starting by a CordaService" }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode.ServiceHubInternalImpl$inner</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode.ServiceHubInternalImpl$override val networkParametersService: NetworkParametersStorage get() = this@AbstractNode.networkParametersStorage</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode.ServiceHubInternalImpl$override val transactionVerifierService: TransactionVerifierService get() = this@AbstractNode.transactionVerifierService</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode&lt;S&gt; : SingletonSerializeAsToken</ID>
    <ID>MaxLineLength:AbstractNode.kt$FlowStarterImpl : FlowStarter</ID>
    <ID>MaxLineLength:AbstractNode.kt$JavaTypeDescriptorRegistry.INSTANCE.addDescriptor(AbstractPartyDescriptor(wellKnownPartyFromX500Name, wellKnownPartyFromAnonymous))</ID>
    <ID>MaxLineLength:AbstractNode.kt$ex is HikariPool.PoolInitializationException -&gt; throw CouldNotCreateDataSourceException("Could not connect to the database. Please check your JDBC connection URL, or the connectivity to the database.", ex)</ID>
    <ID>MaxLineLength:AbstractNode.kt$ex.cause is ClassNotFoundException -&gt; throw CouldNotCreateDataSourceException("Could not find the database driver class. Please add it to the 'drivers' folder. See: https://docs.corda.net/corda-configuration-file.html")</ID>
    <ID>MaxLineLength:AbstractNode.kt$return ClientRpcSslOptions(trustStorePath = nodeRpcOptions.sslConfig!!.keyStorePath, trustStorePassword = nodeRpcOptions.sslConfig!!.keyStorePassword)</ID>
    <ID>MaxLineLength:AbstractNode.kt$return CordaPersistence(databaseConfig, schemaService.schemaOptions.keys, jdbcUrl, cacheFactory, attributeConverters, customClassLoader)</ID>
    <ID>MaxLineLength:AbstractNode.kt$val attributeConverters = listOf(PublicKeyToTextConverter(), AbstractPartyToX500NameAsStringConverter(wellKnownPartyFromX500Name, wellKnownPartyFromAnonymous))</ID>
    <ID>MaxLineLength:AbstractNodeTests.kt$AbstractNodeTests$return "jdbc:h2:file:$baseDir/persistence;DB_CLOSE_ON_EXIT=FALSE;LOCK_TIMEOUT=10000;WRITE_DELAY=100;AUTO_SERVER_PORT=0"</ID>
    <ID>MaxLineLength:AbstractNodeTests.kt$AbstractNodeTests${ // Note this test also covers a transaction that CordaPersistence does while it's instantiating: val database = configureDatabase(hikariProperties(freshURL()), DatabaseConfig(), { null }, { null }) val log = mock&lt;Logger&gt;() // Don't care what happens here. // Actually 10 is enough to reproduce old code hang, as pool size is 10 and we leaked 9 connections and 1 is in flight: repeat(100) { logVendorString(database, log) } }</ID>
    <ID>MaxLineLength:AbstractParty.kt$AbstractParty$ override fun equals(other: Any?): Boolean</ID>
    <ID>MaxLineLength:AbstractRPCTest.kt$AbstractRPCTest$startInVmRpcServer(ops = ops, rpcUser = rpcUser, configuration = serverConfiguration, queueDrainTimeout = queueDrainTimeout)</ID>
    <ID>MaxLineLength:AbstractRPCTest.kt$AbstractRPCTest$startRpcClient&lt;I&gt;(broker.hostAndPort!!, rpcUser.username, rpcUser.password, clientConfiguration)</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow$Acceptor&lt;in T&gt; : FlowLogic</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow$Instigator&lt;out S : ContractState, out T : ContractState, out M&gt; : FlowLogic</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow$Proposal&lt;out M&gt;</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$ @Throws(StateReplacementException::class) protected abstract fun verifyProposal(stx: SignedTransaction, proposal: Proposal&lt;T&gt;)</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$require(myKey in requiredKeys) { "Party is not a participant for any of the input states of transaction ${stx.id}" }</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Instigator$@Suspendable private</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Instigator$return excludeHostNode(serviceHub, groupAbstractPartyByWellKnownParty(serviceHub, originalState.state.data.participants)).map { initiateFlow(it.key) to it.value }</ID>
    <ID>MaxLineLength:Action.kt$Action$RetryFlowFromSafePoint : Action</ID>
    <ID>MaxLineLength:Action.kt$Action$ScheduleFlowTimeout : Action</ID>
    <ID>MaxLineLength:Action.kt$Action.PersistCheckpoint$data</ID>
    <ID>MaxLineLength:Action.kt$FlowRemovalReason${ data class OrderlyFinish(val flowReturnValue: Any?) : FlowRemovalReason() data class ErrorFinish(val flowErrors: List&lt;FlowError&gt;) : FlowRemovalReason() object SoftShutdown : FlowRemovalReason() { override fun toString() = "SoftShutdown" } // TODO Should we remove errored flows? How will the flow hospital work? Perhaps keep them in memory for a while, flush // them after a timeout, reload them on flow hospital request. In any case if we ever want to remove them // (e.g. temporarily) then add a case for that here. }</ID>
    <ID>MaxLineLength:ActionExecutorImpl.kt$ActionExecutorImpl$flowMessaging.sendSessionMessage(sessionState.peerParty, existingMessage, SenderDeduplicationId(deduplicationId, action.senderUUID))</ID>
    <ID>MaxLineLength:ActionExecutorImpl.kt$ActionExecutorImpl$private val checkpointBandwidth = metrics.register("Flows.CheckpointVolumeBytesPerSecondCurrent", LatchedGauge(checkpointSizesThisSecond))</ID>
    <ID>MaxLineLength:ActionExecutorImpl.kt$ActionExecutorImpl$private val checkpointBandwidthHist = metrics.register("Flows.CheckpointVolumeBytesPerSecondHist", Histogram(SlidingTimeWindowArrayReservoir(1, TimeUnit.DAYS)))</ID>
    <ID>MaxLineLength:AdditionP2PAddressModeTest.kt$AdditionP2PAddressModeTest$driver</ID>
    <ID>MaxLineLength:AdditionP2PAddressModeTest.kt$AdditionP2PAddressModeTest$haConfig["additionalP2PAddresses"] = ConfigValueFactory.fromIterable(listOf(altAddress))</ID>
    <ID>MaxLineLength:AdditionP2PAddressModeTest.kt$AdditionP2PAddressModeTest$startNode(providedName = DUMMY_BANK_A_NAME, rpcUsers = listOf(testUser), customOverrides = haConfig)</ID>
    <ID>MaxLineLength:AdditionP2PAddressModeTest.kt$AdditionP2PAddressModeTest$startNode(providedName = DUMMY_BANK_B_NAME, rpcUsers = listOf(testUser), customOverrides = mapOf("p2pAddress" to portAllocation.nextHostAndPort().toString()))</ID>
    <ID>MaxLineLength:Address.kt$Address.Companion$return Validated.invalid(sequenceOf("Value format is \"&lt;host(String)&gt;:&lt;port:(Int)&gt;\"").map(mapError).toSet())</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$@Test fun `H2 address`()</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$@Test fun `rpc address`()</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$@Test fun `rpc admin address`()</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$assertThat(exception.addresses).contains(address).withFailMessage("Expected addresses to contain $address but was ${exception.addresses}.")</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$assertThatThrownBy { startNode(customOverrides = overrides(address)).getOrThrow() }</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$driver</ID>
    <ID>MaxLineLength:AffinityExecutor.kt$AffinityExecutor$ fun executeASAP(runnable: () -&gt; Unit)</ID>
    <ID>MaxLineLength:AggregatedList.kt$AggregatedList&lt;A, E : Any, K : Any&gt; : TransformationList</ID>
    <ID>MaxLineLength:AliasPrivateKeyTest.kt$AliasPrivateKeyTest$signingCertStore.query { setPrivateKey(alias, aliasPrivateKey, listOf(NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.ECDSAR1_CERT), "entrypassword") }</ID>
    <ID>MaxLineLength:AliasPrivateKeyTest.kt$AliasPrivateKeyTest$val signingCertStore = CertificateStoreStubs.Signing.withCertificatesDirectory(certificatesDirectory, "keystorepass").get(createNew = true)</ID>
    <ID>MaxLineLength:AliasPrivateKeyTest.kt$AliasPrivateKeyTest${ val alias = "01234567890" val aliasPrivateKey = AliasPrivateKey(alias) val certificatesDirectory = tempFolder.root.toPath() val signingCertStore = CertificateStoreStubs.Signing.withCertificatesDirectory(certificatesDirectory, "keystorepass").get(createNew = true) signingCertStore.query { setPrivateKey(alias, aliasPrivateKey, listOf(NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.ECDSAR1_CERT), "entrypassword") } // We can retrieve the certificate. assertTrue { signingCertStore.contains(alias) } // We can retrieve the certificate. assertEquals(NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.ECDSAR1_CERT, signingCertStore[alias]) // Although we can store an AliasPrivateKey, we cannot retrieve it. But, it's fine as we use certStore for storing/handling certs only. assertThatIllegalArgumentException().isThrownBy { signingCertStore.query { getPrivateKey(alias, "entrypassword") } }.withMessage("Unrecognised algorithm: 1.3.6.1.4.1.50530.1.2") }</ID>
    <ID>MaxLineLength:AllButBlacklisted.kt$AllButBlacklisted : ClassWhitelist</ID>
    <ID>MaxLineLength:AllButBlacklisted.kt$AllButBlacklisted$ override fun hasListed(type: Class&lt;*&gt;): Boolean</ID>
    <ID>MaxLineLength:AllButBlacklisted.kt$AllButBlacklisted$throw IllegalStateException("The $matchType $aMatch of ${type.name} is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:AllButBlacklisted.kt$AllButBlacklisted${ // TODO: blacklistedClasses += type.name // add it, so checking is faster next time we encounter this class. val matchType = if (Class.forName(aMatch).isInterface) "superinterface" else "superclass" throw IllegalStateException("The $matchType $aMatch of ${type.name} is blacklisted, so it cannot be used in serialization.") }</ID>
    <ID>MaxLineLength:Amount.kt$Amount$Companion</ID>
    <ID>MaxLineLength:Amount.kt$Amount$operator</ID>
    <ID>MaxLineLength:Amount.kt$Amount$require(other.displayTokenSize == displayTokenSize) { "Token size mismatch: ${other.displayTokenSize} vs $displayTokenSize" }</ID>
    <ID>MaxLineLength:Amount.kt$Amount${ // Amount represents a static balance of physical assets as managed by the distributed ledger and is not allowed // to become negative a rule further maintained by the Contract verify method. // N.B. If concepts such as an account overdraft are required this should be modelled separately via Obligations, // or similar second order smart contract concepts. require(quantity &gt;= 0) { "Negative amounts are not allowed: $quantity" } }</ID>
    <ID>MaxLineLength:Amount.kt$Amount.Companion$ @JvmStatic @JvmOverloads fun &lt;T : Any&gt; fromDecimal(displayQuantity: BigDecimal, token: T, rounding: RoundingMode = RoundingMode.FLOOR): Amount&lt;T&gt;</ID>
    <ID>MaxLineLength:Amount.kt$Amount.Companion$ @JvmStatic fun &lt;T : Any&gt; Iterable&lt;Amount&lt;T&gt;&gt;.sumOrZero(token: T)</ID>
    <ID>MaxLineLength:Amount.kt$Amount&lt;T : Any&gt; : Comparable</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$ @Suppress("UNUSED") fun novate(centralParty: P): List&lt;AmountTransfer&lt;T, P&gt;&gt;</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$ fun apply(balances: List&lt;SourceAndAmount&lt;T, P&gt;&gt;, newRef: Any? = null): List&lt;SourceAndAmount&lt;T, P&gt;&gt;</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$remaining = SourceAndAmount(payer, balance.amount.copy(quantity = Math.subtractExact(balance.amount.quantity, residual)), newRef)</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$result = 31 * result + (source.hashCode() xor destination.hashCode())</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer.Companion$ @JvmStatic @JvmOverloads fun &lt;T : Any, P : Any&gt; fromDecimal( displayQuantityDelta: BigDecimal, token: T, source: P, destination: P, rounding: RoundingMode = RoundingMode.DOWN ): AmountTransfer&lt;T, P&gt;</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer&lt;T : Any, P : Any&gt;</ID>
    <ID>MaxLineLength:Amount.kt$TokenizableAssetInfo$/** The nominal display unit size of a single token, potentially with trailing decimal display places if the scale parameter is non-zero. */ val displayTokenSize: BigDecimal</ID>
    <ID>MaxLineLength:AmountTest.kt$AmountTest$assertThat(yamlMapper.valueToTree&lt;TextNode&gt;(Amount.parseCurrency("$250000"))).isEqualTo(TextNode("250000.00 USD"))</ID>
    <ID>MaxLineLength:AmountTest.kt$AmountTest$assertThat(yamlMapper.valueToTree&lt;TextNode&gt;(Amount.parseCurrency("£25000000"))).isEqualTo(TextNode("25000000.00 GBP"))</ID>
    <ID>MaxLineLength:AmountTests.kt$AmountTests$val collector = Collectors.toMap&lt;SourceAndAmount&lt;Currency, String&gt;, Pair&lt;String, Currency&gt;, BigDecimal&gt;({ Pair(it.source, it.amount.token) }, { it.amount.toDecimal() }, { x, y -&gt; x + y })</ID>
    <ID>MaxLineLength:AnalyticsEngine.kt$OGSIMMAnalyticsEngine$ override fun calculateSensitivitiesBatch( trades: List&lt;ResolvedSwapTrade&gt;, pricer: DiscountingSwapProductPricer, ratesProvider: ImmutableRatesProvider ): Map&lt;ResolvedSwapTrade, CurrencyAmount&gt;</ID>
    <ID>MaxLineLength:AnalyticsEngine.kt$OGSIMMAnalyticsEngine$val calculatorTotal = RwamBimmNotProductClassesCalculator(fxRateProvider, Currency.EUR, IsdaConfiguration.INSTANCE)</ID>
    <ID>MaxLineLength:AnalyticsEngine.kt$OGSIMMAnalyticsEngine$val t = BimmAnalysisUtils.computeMargin(combinedRatesProvider, normalizer, calculatorTotal, it.value.currencyParameterSensitivities, it.value.multiCurrencyAmount)</ID>
    <ID>MaxLineLength:AnonymousParty.kt$AnonymousParty : DestinationAbstractParty</ID>
    <ID>MaxLineLength:AnotherDummyContract.kt$AnotherDummyContract$return TransactionBuilder(notary).withItems(StateAndContract(state, ANOTHER_DUMMY_PROGRAM_ID), Command(Commands.Create(), owner.party.owningKey))</ID>
    <ID>MaxLineLength:AppServiceHub.kt$AppServiceHub : ServiceHub</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$ fun addOrUpdate(key: K, value: V, updateFn: (K, V) -&gt; Boolean): Boolean</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$ fun addWithDuplicatesAllowed(key: K, value: V, logWarning: Boolean = true): Boolean</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$ operator fun set(key: K, value: V)</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$Transactional.InFlight(this, key, _readerValueLoader = { loadValue(key) }).apply { alsoWrite(value) }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$log.warn("Double insert in ${this.javaClass.name} for entity class $persistentEntityClass key $key, not inserting the second time")</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$oldValueInCache</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase${ // IMPORTANT: The flush is needed because detach() makes the queue of unflushed entries invalid w.r.t. Hibernate internal state if the found entity is unflushed. // We want the detach() so that we rely on our cache memory management and don't retain strong references in the Hibernate session. session.flush() }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase${ // If someone is writing (but not us) // For those not writing, they need to re-load the value from the database (which their database transaction MIGHT see). // For those writing, they need to re-load the value from the database (which their database transaction CAN see). Transactional.InFlight(this, key, { loadValue(key) }, { loadValue(key)!! }) }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase${ // If we found a value already in the database, and we were not already writing, then it's already committed but got evicted. Transactional.Committed(oldValue) }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase${ // Some database transactions, including us, writing, with readers seeing whatever is in the database and writers seeing the (in memory) value. Transactional.InFlight(this, key, _readerValueLoader = { loadValue(key) }).apply { alsoWrite(value) } }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase${ // Someone else is writing, so store away! val retainedValueFromDB = store(key, value) wasWritten = (retainedValueFromDB == null) // If the store function claims the value is new in the DB, then either the value is brand new or updated. In this case, // update the old value in the cache with the new value. Otherwise, leave it as it was before. if (wasWritten) { oldValueInCache.apply { alsoWrite(value) } } else { oldValueInCache } }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase${ val retainedValueFromDB = store(key, value) wasWritten = (retainedValueFromDB == null) // If the value has been updated, then isUnique will be true. In this case, the Committed value needs to be replaced // with InFlight to indicate that this transaction has changed the value associated with this key. Note that this allows // for cases where the value passed to set differs from that in the cache, but an update function has decided that this // differing value should not be written to the database. if (wasWritten) { Transactional.InFlight(this, key, _readerValueLoader = { loadValue(key) }).apply { alsoWrite(value) } } else { oldValueInCache } }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional$InFlight&lt;K, T&gt; : Transactional</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight$// The value from the perspective of the eviction algorithm of the cache. i.e. we want to reveal memory footprint to it etc. override val peekableValue: T? get() = if (writerValueLoader.get() != _writerValueLoader) writerValueLoader.get()() else if (readerValueLoader.get() != _readerValueLoader) readerValueLoader.get()() else null</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight$get() = if (isPresentAsWriter) loadAsWriter() else if (isPresentAsReader) loadAsReader()!! else throw NoSuchElementException("Not present")</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight$get() = if (writerValueLoader.get() != _writerValueLoader) writerValueLoader.get()() else if (readerValueLoader.get() != _readerValueLoader) readerValueLoader.get()() else null</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight${ // Make the lazy loader the writers see actually just return the value that has been set. writerValueLoader.set { _value } // We make all these vals so that the lambdas do not need a reference to this, and so the onCommit only has a weak ref to the value. // We want this so that the cache could evict the value (due to memory constraints etc) without the onCommit callback // retaining what could be a large memory footprint object. val tx = contextTransaction val strongKey = key val strongMap = map if (map.addPendingKey(key, tx)) { // If the transaction commits, update cache to make globally visible if we're first for this key, // and then stop saying the transaction is writing the key. tx.onCommit { strongMap.cache.asMap().computeIfPresent(strongKey) { _, transactional: Transactional&lt;T&gt; -&gt; if (transactional is Transactional.InFlight&lt;*, T&gt;) { transactional.committed.set(true) val value = transactional.peekableValue if (value != null) { Transactional.Committed(value) } else { transactional } } else { transactional } } strongMap.removePendingKey(strongKey, tx) } // If the transaction rolls back, stop saying this transaction is writing the key. tx.onRollback { strongMap.removePendingKey(strongKey, tx) } } }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.Unknown$val readValue = _valueLoader() // We re-write the value into the cache so that any weigher can re-assess the weight based on the loaded value. map.cache.asMap().compute(key) { _, oldValue -&gt; if (oldValue === this@Unknown) { if (readValue == null) Missing() else Committed(readValue) } else oldValue } readValue</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase&lt;K, V, E, out EK&gt;</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapNonConcurrentTest.kt$AppendOnlyPersistentMapNonConcurrentTest$NodeSchemaService(setOf(MappedSchema(AppendOnlyPersistentMapTest::class.java, 1, listOf(AppendOnlyPersistentMapNonConcurrentTest.PersistentMapEntry::class.java))))</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$NodeSchemaService(setOf(MappedSchema(AppendOnlyPersistentMapTest::class.java, 1, listOf(PersistentMapEntry::class.java))))</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.Success) to Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit)</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$val remapped = mapOf(Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.Success, Outcome.Fail) to Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.Success, Outcome.SuccessButErrorOnCommit))</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$val remapped = mapOf(Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.Success, Outcome.Fail) to Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit), Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.Success) to Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit))</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest${ // Writes intentionally do not check the database first, so purging between read and write changes behaviour // Also, a purge after write causes the subsequent read to flush to the database, causing the read to generate a constraint violation when single threaded (in same database transaction). val remapped = mapOf(Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.Success, Outcome.Fail) to Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit), Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.Success) to Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit)) scenario = remapped[scenario] ?: scenario prepopulateIfRequired() val map = createMap() val a = TestThread("A", map, true).apply { phase1.countDown() phase3.countDown() } val b = TestThread("B", map, true).apply { phase1.countDown() phase3.countDown() } try { database.transaction { a.run() map.invalidate() b.run() } } catch (t: PersistenceException) { // This only helps if thrown on commit, otherwise other latches not counted down. assertEquals(t.message, Outcome.SuccessButErrorOnCommit, a.outcome) } a.await(a::phase4) b.await(b::phase4) assertTrue(map.pendingKeysIsEmpty()) }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.Companion$Scenario(false, ReadOrWrite.WriteDuplicateAllowed, ReadOrWrite.Read, Outcome.Success, Outcome.Fail, Outcome.Success)</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.Companion$Scenario(false, ReadOrWrite.WriteDuplicateAllowed, ReadOrWrite.WriteDuplicateAllowed, Outcome.Success, Outcome.SuccessButErrorOnCommit, Outcome.Fail)</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.Companion$Scenario(true, ReadOrWrite.Write, ReadOrWrite.Write, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit)</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.Companion$Scenario(true, ReadOrWrite.WriteDuplicateAllowed, ReadOrWrite.WriteDuplicateAllowed, Outcome.Fail, Outcome.Fail)</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.TestThread$val outcome = if (name == "A") scenario.aExpected else if (singleThreaded) scenario.bExpectedIfSingleThreaded else scenario.bExpected</ID>
    <ID>MaxLineLength:Arrangement.kt$And : Arrangement</ID>
    <ID>MaxLineLength:Arrangement.kt$Obligation$data</ID>
    <ID>MaxLineLength:ArraySerializer.kt$PrimBooleanArraySerializer : PrimArraySerializer</ID>
    <ID>MaxLineLength:ArtemisBroker.kt$fun java.io.IOException.isBindingError()</ID>
    <ID>MaxLineLength:ArtemisMessagingClient.kt$ArtemisMessagingClient$val session = sessionFactory!!.createSession(NODE_P2P_USER, NODE_P2P_USER, false, true, true, false, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:ArtemisMessagingComponent.kt$ArtemisMessagingComponent.Companion$const val PEERS_PREFIX = "${INTERNAL_PREFIX}peers." // TODO Come up with better name for common peers/services queue</ID>
    <ID>MaxLineLength:ArtemisMessagingComponent.kt$ArtemisMessagingComponent.Companion.P2PMessagingHeaders$/** * In the operation mode where we have an out of process bridge we cannot correctly populate the Artemis validated user header * as the TLS does not terminate directly onto Artemis. We therefore use this internal only header to forward * the equivalent information from the Float. */ val bridgedCertificateSubject = SimpleString("sender-subject-name")</ID>
    <ID>MaxLineLength:ArtemisMessagingComponent.kt$ArtemisMessagingComponent.RemoteInboxAddress.Companion$require(address.startsWith(PEERS_PREFIX)) { "Failed to map address: $address to a remote topic as it is not in the $PEERS_PREFIX namespace" }</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$ private fun ConfigurationImpl.configureAddressSecurity(): Configuration</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$acceptorConfigurations = mutableSetOf(p2pAcceptorTcpTransport(NetworkHostAndPort(messagingServerAddress.host, messagingServerAddress.port), config.p2pSslOptions))</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$deleteNonDurableQueue</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$journalBufferSize_AIO = maxMessageSize + JOURNAL_HEADER_SIZE</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$journalBufferSize_NIO = maxMessageSize + JOURNAL_HEADER_SIZE</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$journalFileSize = maxMessageSize + JOURNAL_HEADER_SIZE</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$securityRoles["$INTERNAL_PREFIX#"] = setOf(nodeInternalRole)</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$handle.afterDatabaseTransaction()</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$networkMapCache = PersistentNetworkMapCache(TestingNamedCacheFactory(), database, rigorousMock()).apply { start(emptyList()) }</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$private</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$val (messagingClient, receivedMessages) = createAndStartClientAndServer(clientMaxMessageSize = 100_000, serverMaxMessageSize = 50_000)</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest${ val receivedMessages = LinkedBlockingQueue&lt;ReceivedMessage&gt;() createMessagingServer(maxMessageSize = serverMaxMessageSize).start() val messagingClient = createMessagingClient(platformVersion = platformVersion) messagingClient.addMessageHandler(TOPIC) { message, _, handle -&gt; database.transaction { handle.insideDatabaseTransaction() } handle.afterDatabaseTransaction() // We ACK first so that if it fails we won't get a duplicate in [receivedMessages] receivedMessages.add(message) } startNodeMessagingClient(maxMessageSize = clientMaxMessageSize) // Run after the handlers are added, otherwise (some of) the messages get delivered and discarded / dead-lettered. thread(isDaemon = true) { messagingClient.run() } return Pair(messagingClient, receivedMessages) }</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker$throw AddressBindingException(adminAddressOptional?.let { setOf(it, addresses.primary) } ?: setOf(addresses.primary))</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker$val serverConfiguration = RpcBrokerConfiguration(baseDirectory, maxMessageSize, jmxEnabled, addresses.primary, adminAddressOptional, sslOptions, useSsl, nodeConfiguration, shouldStartLocalShell)</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker.&lt;no name provided&gt;$return arrayOf(AppConfigurationEntry(name, AppConfigurationEntry.LoginModuleControlFlag.REQUIRED, options))</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$return ArtemisRpcBroker(address, adminAddress, null, false, securityManager, maxMessageSize, jmxEnabled, baseDirectory, configuration, shouldStartLocalShell)</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$return ArtemisRpcBroker(address, adminAddress, sslOptions, true, securityManager, maxMessageSize, jmxEnabled, baseDirectory, configuration, shouldStartLocalShell)</ID>
    <ID>MaxLineLength:ArtemisRpcTests.kt$ArtemisRpcTests$ArtemisRpcBroker.withSsl(nodeSSlconfig, address, adminAddress, brokerSslOptions!!, securityManager, maxMessageSize, jmxEnabled, baseDirectory, false)</ID>
    <ID>MaxLineLength:ArtemisRpcTests.kt$ArtemisRpcTests$ArtemisRpcBroker.withoutSsl(nodeSSlconfig, address, adminAddress, securityManager, maxMessageSize, jmxEnabled, baseDirectory, false)</ID>
    <ID>MaxLineLength:ArtemisRpcTests.kt$ArtemisRpcTests$InternalRPCMessagingClient(nodeSSlconfig, adminAddress, maxMessageSize, CordaX500Name("MegaCorp", "London", "GB"), RPCServerConfiguration.DEFAULT)</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$( // Basic TCP target details. TransportConstants.HOST_PROP_NAME to hostAndPort.host, TransportConstants.PORT_PROP_NAME to hostAndPort.port, // Turn on AMQP support, which needs the protocol jar on the classpath. // Unfortunately we cannot disable core protocol as artemis only uses AMQP for interop. // It does not use AMQP messages for its own messages e.g. topology and heartbeats. // TODO further investigate how to ensure we use a well defined wire level protocol for Node to Node communications. TransportConstants.PROTOCOLS_PROP_NAME to "CORE,AMQP", TransportConstants.USE_GLOBAL_WORKER_POOL_PROP_NAME to (nodeSerializationEnv != null), TransportConstants.REMOTING_THREADS_PROPNAME to (if (nodeSerializationEnv != null) -1 else 1), // turn off direct delivery in Artemis - this is latency optimisation that can lead to // hick-ups under high load (CORDA-1336) TransportConstants.DIRECT_DELIVER to false)</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun rpcInternalAcceptorTcpTransport(hostAndPort: NetworkHostAndPort, config: SslConfiguration): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun rpcInternalClientTcpTransport(hostAndPort: NetworkHostAndPort, config: SslConfiguration): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$internal val acceptorFactoryClassName = "org.apache.activemq.artemis.core.remoting.impl.netty.NettyAcceptorFactory"</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$options[TransportConstants.HANDSHAKE_TIMEOUT] = 0</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$return TransportConfiguration(acceptorFactoryClassName, defaultArtemisOptions(hostAndPort) + defaultSSLOptions + config.toTransportOptions() + (TransportConstants.HANDSHAKE_TIMEOUT to 0))</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$return TransportConfiguration(connectorFactoryClassName, defaultArtemisOptions(hostAndPort) + defaultSSLOptions + config.toTransportOptions())</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$require(messageSize &lt;= limit) { "Message exceeds maxMessageSize network parameter, maxMessageSize: [$limit], message size: [$messageSize]" }</ID>
    <ID>MaxLineLength:AssociatedList.kt$AssociatedList&lt;K, out A, B&gt; : ReadOnlyBackedObservableMapBase</ID>
    <ID>MaxLineLength:AsyncLoggerContextSelectorNoThreadLocal.kt$AsyncLoggerContextSelectorNoThreadLocal.Companion$return AsyncLoggerContextSelectorNoThreadLocal::class.java.name == PropertiesUtil.getProperties().getStringProperty(Constants.LOG4J_CONTEXT_SELECTOR)</ID>
    <ID>MaxLineLength:Attachment.kt$Attachment$/** * The parties that have correctly signed the whole attachment. * Even though this returns a list of party objects, it is not required that these parties exist on the network, but rather they are a mapping from the signing key to the X.500 name. * * Note: Anyone can sign attachments, not only Corda parties. It's recommended to use [signerKeys]. */ @Deprecated("Use signerKeys. There is no requirement that attachment signers are Corda parties.") val signers: List&lt;Party&gt;</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$AttachmentConstraint$ fun isSatisfiedBy(attachment: Attachment): Boolean</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$AutomaticPlaceholderConstraint : AttachmentConstraint</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$AutomaticPlaceholderConstraint$throw UnsupportedOperationException("Contracts cannot be satisfied by an AutomaticPlaceholderConstraint placeholder.")</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$HashAttachmentConstraint$log.warn("Hash constraint check failed: $attachmentId does not match contract attachment JAR ${attachment.id} or contract attachment JAR is untrusted")</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$NoConstraintPropagation</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$SignatureAttachmentConstraint$log.debug("Checking signature constraints: verifying $key in contract attachment signer keys: ${attachment.signerKeys}")</ID>
    <ID>MaxLineLength:AttachmentContract.kt$AttachmentContract$require(tx.attachments.any { it.id == state.hash }) { "At least one attachment in transaction must match hash ${state.hash}" }</ID>
    <ID>MaxLineLength:AttachmentDemo.kt$require</ID>
    <ID>MaxLineLength:AttachmentDemo.kt$require(connection.contentType == APPLICATION_OCTET_STREAM) { "Content-Type header was ${connection.contentType}" }</ID>
    <ID>MaxLineLength:AttachmentDemo.kt$val bankBParty = rpc.partiesFromName("Bank B", false).firstOrNull() ?: throw IllegalArgumentException("Couldn't find Bank B party")</ID>
    <ID>MaxLineLength:AttachmentDemo.kt$val connection = URL("http://localhost:$webPort/attachments/${state.hash}").openConnection() as HttpURLConnection</ID>
    <ID>MaxLineLength:AttachmentDemo.kt$val notaryParty = rpc.partiesFromName("Notary", false).firstOrNull() ?: throw IllegalArgumentException("Couldn't find notary party")</ID>
    <ID>MaxLineLength:AttachmentDemoTest.kt$AttachmentDemoTest$// run with a 10,000,000 bytes in-memory zip file. In practice, a slightly bigger file will be used (~10,002,000 bytes). @Test fun `attachment demo using a 10MB zip file`()</ID>
    <ID>MaxLineLength:AttachmentDemoTest.kt$AttachmentDemoTest$cordappsForAllNodes = listOf(findCordapp("net.corda.attachmentdemo.contracts"), findCordapp("net.corda.attachmentdemo.workflows"))</ID>
    <ID>MaxLineLength:AttachmentDownloadServlet.kt$AttachmentDownloadServlet$log.warn("404 Not Found whilst trying to handle attachment download request for ${servletContext.contextPath}/$reqPath")</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests$alice.rpc.startFlow(::ConsumeAndBroadcastFlow, stateRef, bob.nodeInfo.singleIdentity()).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests$assertThatThrownBy { alice.rpc.startFlow(::ConsumeAndBroadcastFlow, stateRef, bob.nodeInfo.singleIdentity()).returnValue.getOrThrow() }</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests$assertThatThrownBy { alice.rpc.startFlow(::ConsumeAndBroadcastFlow, stateRef, bob.nodeInfo.singleIdentity()).returnValue.getOrThrow() } // ConsumeAndBroadcastResponderFlow re-throws any non-FlowExceptions with just their class name in the message so that // we can verify here Bob threw the correct exception .hasMessage(TransactionVerificationException.UntrustedAttachmentsException::class.java.name)</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests.Companion$"contaminate the tests. This is a known issue with the driver and we must work around it until it's fixed."</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests.Companion$"isolated module cannot be on the classpath as otherwise it will be pulled into the nodes the driver creates and "</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests.Companion$val issuanceFlowClass: Class&lt;FlowLogic&lt;StateRef&gt;&gt; = uncheckedCast(loadFromIsolated("net.corda.isolated.workflows.IsolatedIssuanceFlow"))</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests.ConsumeAndBroadcastFlow${ val notary = serviceHub.networkMapCache.notaryIdentities[0] val stateAndRef = serviceHub.toStateAndRef&lt;ContractState&gt;(stateRef) val stx = serviceHub.signInitialTransaction( TransactionBuilder(notary) .addInputState(stateAndRef) .addOutputState(ConsumeContract.State()) .addCommand(Command(ConsumeContract.Cmd, ourIdentity.owningKey)) ) stx.verify(serviceHub, checkSufficientSignatures = false) val session = initiateFlow(otherSide) subFlow(FinalityFlow(stx, session)) // It's important we wait on this dummy receive, as otherwise it's possible we miss any errors the other side throws session.receive&lt;String&gt;().unwrap { require(it == "OK") { "Not OK: $it" } } }</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$Attachment</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest$assertEquals("hacked", rebootClientAndGetAttachmentContent(false))</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest$client.hackAttachment(attachmentId, "hacked")</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest$client.internals.disableDBCloseOnStop()</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest$return (client.smm.allStateMachines[0].stateMachine.resultFuture.apply { mockNet.runNetwork() }.getOrThrow() as ClientResult).attachmentContent</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest.&lt;no name provided&gt;$override fun start()</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest.FetchAttachmentLogic$private</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest.OpenAttachmentLogic$private</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest.ServerLogic$private</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$val attachment = session.get&lt;NodeAttachmentService.DBAttachment&gt;(NodeAttachmentService.DBAttachment::class.java, attachmentId.toString())</ID>
    <ID>MaxLineLength:AttachmentStorage.kt$AttachmentStorage$ @Deprecated("More attachment information is required", replaceWith = ReplaceWith("importAttachment(jar, uploader, filename)")) @Throws(FileAlreadyExistsException::class, IOException::class) fun importAttachment(jar: InputStream): AttachmentId</ID>
    <ID>MaxLineLength:AttachmentStorage.kt$AttachmentStorage$ fun getLatestContractAttachments(contractClassName: String, minContractVersion: Int = DEFAULT_CORDAPP_VERSION): List&lt;AttachmentId&gt;</ID>
    <ID>MaxLineLength:AttachmentStorage.kt$AttachmentStorage$@Deprecated("More attachment information is required", replaceWith = ReplaceWith("importAttachment(jar, uploader, filename)"))</ID>
    <ID>MaxLineLength:AttachmentStorageInternal.kt$AttachmentStorageInternal$ fun privilegedImportAttachment(jar: InputStream, uploader: String, filename: String?): AttachmentId</ID>
    <ID>MaxLineLength:AttachmentTests.kt$AttachmentTests$private</ID>
    <ID>MaxLineLength:AttachmentTests.kt$AttachmentTests$val corruptAttachment = NodeAttachmentService.DBAttachment(attId = id.toString(), content = attachment, version = DEFAULT_CORDAPP_VERSION)</ID>
    <ID>MaxLineLength:AttachmentTests.kt$AttachmentTests.InitiatingFetchAttachmentsFlow$@InitiatingFlow private</ID>
    <ID>MaxLineLength:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$logger.error("$msg skipped, network parameters not retrieved, could not determine node base directory due to system property $NODE_BASE_DIR_KEY being not set.")</ID>
    <ID>MaxLineLength:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$logger.info("$msg skipped, network parameters not found in $path, but there are no available attachments to migrate.")</ID>
    <ID>MaxLineLength:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$logger.info("$msg using network parameters from $path, whitelistedContractImplementations: ${networkParameters.whitelistedContractImplementations}.")</ID>
    <ID>MaxLineLength:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$logger.warn("Several versions based on whitelistedContractImplementations position are available: ${versions.toSet()}. $msg")</ID>
    <ID>MaxLineLength:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$val versions = networkParameters?.whitelistedContractImplementations?.values.mapNotNull { it.indexOfFirst { it.toString() == attachmentId } }.filter { it &gt;= 0 }</ID>
    <ID>MaxLineLength:AttachmentWithContext.kt$AttachmentWithContext$"This AttachmentWithContext was not initialised properly. Please ensure all Corda contracts extending existing Corda contracts also implement the Contract base class."</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader : URLClassLoader</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$"Please follow the operational steps outlined in https://docs.corda.net/cordapp-build-systems.html#cordapp-contract-attachments to learn more and continue."</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$(path == "meta-inf/services/net.corda.core.serialization.serializationwhitelist") -&gt; false</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$// This calculates the hash of the current entry because the JarInputStream returns only the current entry. fun entryHash()</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$currentHash == previousFileHash -&gt; log.debug { "Duplicate entry $path has same content hash $currentHash" }</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$if (!isZipOrJar(attachment)) throw TransactionVerificationException.InvalidAttachmentException(sampleTxId, attachment.id)</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$log</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$path.startsWith("meta-inf/services") -&gt; true</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$targetPlatformVersion &lt; 4 &amp;&amp; ignoreDirectories.any { path.startsWith(it) } -&gt; false</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader${ // Make some preliminary checks to ensure that we're not loading invalid attachments. // All attachments need to be valid JAR or ZIP files. for (attachment in attachments) { if (!isZipOrJar(attachment)) throw TransactionVerificationException.InvalidAttachmentException(sampleTxId, attachment.id) } // Until we have a sandbox to run untrusted code we need to make sure that any loaded class file was whitelisted by the node administrator. val untrusted = attachments .filter(::containsClasses) .filterNot(isAttachmentTrusted) .map(Attachment::id) if (untrusted.isNotEmpty()) { log.warn("Cannot verify transaction $sampleTxId as the following attachment IDs are untrusted: $untrusted." + "You will need to manually install the CorDapp to whitelist it for use. " + "Please follow the operational steps outlined in https://docs.corda.net/cordapp-build-systems.html#cordapp-contract-attachments to learn more and continue.") throw TransactionVerificationException.UntrustedAttachmentsException(sampleTxId, untrusted) } // Enforce the no-overlap and package ownership rules. checkAttachments(attachments) }</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader${ val entry = jar.nextJarEntry ?: break if (entry.isDirectory) continue // We already verified that paths are not strange/game playing when we inserted the attachment // into the storage service. So we don't need to repeat it here. // // We forbid files that differ only in case, or path separator to avoid issues for Windows/Mac developers where the // filesystem tries to be case insensitive. This may break developers who attempt to use ProGuard. // // Also convert to Unix path separators as all resource/class lookups will expect this. val path = entry.name.toLowerCase(Locale.US).replace('\\', '/') // Namespace ownership. We only check class files: resources are loaded relative to a JAR anyway. if (path.endsWith(".class")) { // Get the package name from the file name. Inner classes separate their names with $ not / // in file names so they are not a problem. val pkgName = path .dropLast(".class".length) .replace('/', '.') .split('.') .dropLast(1) .joinToString(".") for ((namespace, pubkey) in params.packageOwnership) { // Note that due to the toLowerCase() call above, we'll be comparing against a lowercased // version of the ownership claim. val ns = namespace.toLowerCase(Locale.US) // We need an additional . to avoid matching com.foo.Widget against com.foobar.Zap if (pkgName == ns || pkgName.startsWith("$ns.")) { if (pubkey !in signers) throw PackageOwnershipException(sampleTxId, attachment.id, path, pkgName) } } } // Some files don't need overlap checking because they don't affect the way the code runs. if (!shouldCheckForNoOverlap(path, targetPlatformVersion)) continue // This calculates the hash of the current entry because the JarInputStream returns only the current entry. fun entryHash() = ByteArrayOutputStream().use { jar.copyTo(it) it.toByteArray() }.sha256() // If 2 entries are identical, it means the same file is present in both attachments, so that is ok. val currentHash = entryHash() val previousFileHash = classLoaderEntries[path] when { previousFileHash == null -&gt; { log.debug { "Adding new entry for $path" } classLoaderEntries[path] = currentHash } currentHash == previousFileHash -&gt; log.debug { "Duplicate entry $path has same content hash $currentHash" } else -&gt; { log.debug { "Content hash differs for $path" } throw OverlappingAttachmentsException(sampleTxId, path) } } }</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader.Companion$log.warn("The URLStreamHandlerFactory was already set in the JVM. Please be aware that this is not recommended.")</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$ fun &lt;T&gt; withAttachmentsClassloaderContext( attachments: List&lt;Attachment&gt;, params: NetworkParameters, txId: SecureHash, isAttachmentTrusted: (Attachment) -&gt; Boolean, parent: ClassLoader = ClassLoader.getSystemClassLoader(), block: (ClassLoader) -&gt; T ): T</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$private</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$val serializers = createInstancesOfClassesImplementing(transactionClassLoader, SerializationCustomSerializer::class.java)</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderSerializationTests.kt$AttachmentsClassLoaderSerializationTests$val att2 = storage.importAttachment(fakeAttachment("file2.txt", "some other data").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderSerializationTests.kt$AttachmentsClassLoaderSerializationTests$val state = (contract as DummyContractBackdoor).generateInitial(MEGA_CORP.ref(1), 1, DUMMY_NOTARY).outputStates().first()</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderSerializationTests.kt$AttachmentsClassLoaderSerializationTests.Companion$val ISOLATED_CONTRACTS_JAR_PATH: URL = AttachmentsClassLoaderSerializationTests::class.java.getResource("/isolated.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderStaticContractTests.kt$AttachmentsClassLoaderStaticContractTests$doReturn(it.cordappProvider.getContractAttachmentID(AttachmentDummyContract.ATTACHMENT_PROGRAM_ID)).whenever(attachment).id</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderStaticContractTests.kt$AttachmentsClassLoaderStaticContractTests$return JarScanningCordappLoader.fromJarUrls(listOf(cordappWithPackages(*packages.toTypedArray()).jarFile.toUri().toURL()))</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderStaticContractTests.kt$AttachmentsClassLoaderStaticContractTests$val cordappProviderImpl = CordappProviderImpl(cordappLoaderForPackages(listOf("net.corda.nodeapi.internal")), MockCordappConfigProvider(), MockAttachmentStorage())</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderStaticContractTests.kt$AttachmentsClassLoaderStaticContractTests.AttachmentDummyContract$TransactionBuilder(notary) .withItems(StateAndContract(state, ATTACHMENT_PROGRAM_ID), Command(Commands.Create(), owner.party.owningKey))</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderStaticContractTests.kt$AttachmentsClassLoaderStaticContractTests.AttachmentDummyContract.Companion$const val ATTACHMENT_PROGRAM_ID = "net.corda.nodeapi.internal.AttachmentsClassLoaderStaticContractTests\$AttachmentDummyContract"</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderStaticContractTests.kt$import net.corda.nodeapi.internal.AttachmentsClassLoaderStaticContractTests.AttachmentDummyContract.Companion.ATTACHMENT_PROGRAM_ID</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Allow loading an untrusted contract jar if another attachment exists that was signed by a trusted uploader - intersection of keys match existing attachment`()</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Allow loading an untrusted contract jar if another attachment exists that was signed with the same keys and uploaded by a trusted uploader`()</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Cannot load an untrusted contract jar if no other attachment exists that was signed with the same keys and uploaded by a trusted uploader`()</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$make(arrayOf(trustedResourceJar, untrustedResourceJar, trustedClassJar, untrustedClassJar).map { storage.openAttachment(it)!! })</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att1 = importAttachment(fakeAttachment("/folder1/foldera/file1.txt", "some data").inputStream(), "app", "file1.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att1 = importAttachment(fakeAttachment("file1.txt", "same data", "file2.txt", "same other data").inputStream(), "app", "file1.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att1 = importAttachment(fakeAttachment("meta-inf/services/com.example.something", "some data").inputStream(), "app", "file1.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att1 = importAttachment(fakeAttachment("meta-inf/services/net.corda.core.serialization.SerializationWhitelist", "some data").inputStream(), "app", "file1.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = importAttachment(fakeAttachment("\\folder1\\folderb\\file2.txt", "some other data").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = importAttachment(fakeAttachment("file1.txt", "same data", "file3.txt", "same totally different").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = importAttachment(fakeAttachment("meta-inf/services/com.example.something", "some other data").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = importAttachment(fakeAttachment("meta-inf/services/net.corda.core.serialization.SerializationWhitelist", "some other data").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = importAttachment(fakeAttachment("net/corda/finance/contracts/isolated/AnotherDummyContract\$State.class", "some attackdata").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = storage.importAttachment(fakeAttachment("file1.txt", "some other data").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val isolatedSignedId = importAttachment(signedJar.first.toUri().toURL().openStream(), "app", "isolated-signed.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val trustedClassJar = importAttachment(fakeAttachment("/com/example/something/VirtuousClass.class", "some other data").inputStream(), "app", "file3.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val trustedResourceJar = importAttachment(fakeAttachment("file1.txt", "some data").inputStream(), "app", "file0.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val untrustedClassJar = importAttachment(fakeAttachment("/com/example/something/MaliciousClass.class", "some malicious data").inputStream(), "untrusted", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val untrustedResourceJar = importAttachment(fakeAttachment("file2.txt", "some malicious data").inputStream(), "untrusted", "file1.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests.Companion$val ISOLATED_CONTRACTS_JAR_PATH_V4: URL = AttachmentsClassLoaderTests::class.java.getResource("isolated-4.0.jar")</ID>
    <ID>MaxLineLength:AuditService.kt$AuditEvent</ID>
    <ID>MaxLineLength:AuditService.kt$FlowPermissionAuditEvent : AuditEventFlowAuditInfo</ID>
    <ID>MaxLineLength:AuthDBTests.kt$"bar" to "\$shiro1\$SHA-256$500000\$Q6dmdY1uVMm0LYAWaOHtCA==\$u7NbFaj9tHf2RTW54jedLPiOiGjJv0RVEPIjVquJuYY="</ID>
    <ID>MaxLineLength:AuthDBTests.kt$"foo" to "\$shiro1\$SHA-256$500000\$WSiEVj6q8d02sFcCk1dkoA==\$MBkU/ghdD9ovoDerdzNfkXdP9Bdhmok7tidvVIqGzcA="</ID>
    <ID>MaxLineLength:AuthDBTests.kt$"test" to "\$shiro1\$SHA-256$500000\$F6CWSFDDxGTlzvREwih8Gw==\$DQhyAPoUw3RdvNYJ1aubCnzEIXm+szGQ3HplaG+euz8="</ID>
    <ID>MaxLineLength:AuthDBTests.kt$PasswordEncryption.SHIRO_1_CRYPT -&gt; hashedPasswords[format]!![s] ?: DefaultPasswordService().encryptPassword(s.toCharArray())</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy$/** * Returns the RPC protocol version, which is the same the node's Platform Version. Exists since version 1 so guaranteed * to be present. * * TODO: Why is this logic duplicated vs the actual implementation? */ override val protocolVersion: Int get() = delegate.nodeInfo().platformVersion</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy$internal</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy$override</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy.Companion$return Proxy.newProxyInstance(delegate::class.java.classLoader, arrayOf(InternalCordaRPCOps::class.java), handler) as InternalCordaRPCOps</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy.PermissionsEnforcingInvocationHandler$override fun invoke(proxy: Any, method: Method, arguments: Array&lt;out Any?&gt;?)</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$private fun &lt;RESULT&gt; guard(methodName: String, context: () -&gt; RpcAuthContext, action: () -&gt; RESULT)</ID>
    <ID>MaxLineLength:AutoAcceptable.kt$AutoAcceptable</ID>
    <ID>MaxLineLength:AutoOfferFlow.kt$AutoOfferFlow$ReportToRegulatorFlow : FlowLogic</ID>
    <ID>MaxLineLength:AutoOfferFlow.kt$AutoOfferFlow.Requester$val notary = serviceHub.networkMapCache.notaryIdentities.first() // TODO We should pass the notary as a parameter to the flow, not leave it to random choice.</ID>
    <ID>MaxLineLength:AutoOfferFlow.kt$AutoOfferFlow.Requester$val otherParty = excludeHostNode(serviceHub, groupAbstractPartyByWellKnownParty(serviceHub, dealToBeOffered.participants)).keys.single()</ID>
    <ID>MaxLineLength:AutoOfferFlow.kt$AutoOfferFlow.Requester.Companion$// We vend a progress tracker that already knows there's going to be a TwoPartyTradingFlow involved at some // point: by setting up the tracker in advance, the user can see what's coming in more detail, instead of being // surprised when it appears as a new set of tasks below the current one. fun tracker()</ID>
    <ID>MaxLineLength:AzureBackend.kt$AzureBackend.Companion$azure.resourceGroups().define(resourceGroupName).withRegion(context.extraParams[Constants.REGION_ARG_NAME]).create()</ID>
    <ID>MaxLineLength:AzureBackend.kt$AzureBackend.Companion$val azureInstantiatorFuture = azureNetworkStore.thenCombine(registryLocatorFuture) { azureVolume, registryLocator -&gt; AzureInstantiator(azure, registryLocator.registry, azureVolume, resourceGroup) }</ID>
    <ID>MaxLineLength:AzureBackend.kt$AzureBackend.Companion$val resourceGroupName = context.networkName.replace(Constants.ALPHA_NUMERIC_DOT_AND_UNDERSCORE_ONLY_REGEX, "")</ID>
    <ID>MaxLineLength:AzureInstantiator.kt$AzureInstantiator.&lt;no name provided&gt;$LOG.info("Completed instantiation: $instanceName is running at $fqdn with port(s) $portsToOpen exposed")</ID>
    <ID>MaxLineLength:AzureRegistryLocator.kt$RegistryLocator$LOG.info("Did not find existing container registry - creating new registry with name ${resourceGroup.restFriendlyName()}")</ID>
    <ID>MaxLineLength:AzureRegistryLocator.kt$RegistryLocator$val found = azure.containerRegistries().getByResourceGroup(resourceGroup.name(), resourceGroup.restFriendlyName())</ID>
    <ID>MaxLineLength:AzureSmbVolume.kt$AzureSmbVolume$networkParamsFile.uploadFromByteArray(networkParameters.signWithCert(keyPair.private, networkMapCert).serialize().bytes)</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$certificateStore.query { setPrivateKey(alias, keyPair.private, listOf(cert), certificateStore.entryPassword) }</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$null -&gt; Crypto.doSign(certificateStore.query { getPrivateKey(alias, certificateStore.entryPassword) }, data)</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$return ContentSignerBuilder.build(signatureScheme, privateKey, Crypto.findProvider(signatureScheme.providerName), newSecureRandom())</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$throw CryptoServiceException("Cannot generate key for alias $alias and signature scheme ${scheme.schemeCodeName} (id ${scheme.schemeNumberID})", e)</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$throw CryptoServiceException("Cannot sign using the key with alias $alias. SHA256 of data to be signed: ${data.sha256()}", e)</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService${ // Store a self-signed certificate, as Keystore requires to store certificates instead of public keys. // We could probably add a null cert, but we store a self-signed cert that will be used to retrieve the public key. val cert = X509Utilities.createSelfSignedCACertificate(legalName, keyPair) certificateStore.query { setPrivateKey(alias, keyPair.private, listOf(cert), certificateStore.entryPassword) } }</ID>
    <ID>MaxLineLength:BCCryptoServiceTests.kt$BCCryptoServiceTests$Crypto.supportedSignatureSchemes().filter { it != Crypto.COMPOSITE_KEY }.forEach { generateKeyAndSignForScheme(cryptoService, it) }</ID>
    <ID>MaxLineLength:BCCryptoServiceTests.kt$BCCryptoServiceTests$private</ID>
    <ID>MaxLineLength:BFTNotaryServiceTests.kt$BFTNotaryServiceTests$addOutputState(DummyContract.SingleOwnerState(owner = info.singleIdentity()), DummyContract.PROGRAM_ID, AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:BFTNotaryServiceTests.kt$BFTNotaryServiceTests$private</ID>
    <ID>MaxLineLength:BFTNotaryServiceTests.kt$BFTNotaryServiceTests.Companion$fun startBftClusterAndNode(clusterSize: Int, mockNet: InternalMockNetwork, exposeRaces: Boolean = false): Pair&lt;Party, TestStartedNode&gt;</ID>
    <ID>MaxLineLength:BFTNotaryServiceTests.kt$BFTNotaryServiceTests.Companion$val networkParameters = NetworkParametersCopier(testNetworkParameters(listOf(NotaryInfo(notaryIdentity, false))))</ID>
    <ID>MaxLineLength:BFTNotaryServiceTests.kt$BFTNotaryServiceTests.Companion${ (Paths.get("config") / "currentView").deleteIfExists() // XXX: Make config object warn if this exists? val replicaIds = (0 until clusterSize) val serviceLegalName = CordaX500Name("BFT", "Zurich", "CH") val notaryIdentity = DevIdentityGenerator.generateDistributedNotaryCompositeIdentity( replicaIds.map { mockNet.baseDirectory(mockNet.nextNodeId + it) }, serviceLegalName) val networkParameters = NetworkParametersCopier(testNetworkParameters(listOf(NotaryInfo(notaryIdentity, false)))) val clusterAddresses = replicaIds.map { NetworkHostAndPort("localhost", 11000 + it * 10) } val nodes = replicaIds.map { replicaId -&gt; mockNet.createUnstartedNode(InternalMockNodeParameters(configOverrides = { val notary = NotaryConfig( validating = false, bftSMaRt = BFTSmartConfig(replicaId, clusterAddresses, exposeRaces = exposeRaces), serviceLegalName = serviceLegalName ) doReturn(notary).whenever(it).notary })) } + mockNet.createUnstartedNode() // MockNetwork doesn't support BFT clusters, so we create all the nodes we need unstarted, and then install the // network-parameters in their directories before they're started. val node = nodes.map { node -&gt; networkParameters.install(mockNet.baseDirectory(node.id)) node.start() }.last() return Pair(notaryIdentity, node) }</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart$ClusterResponse</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Client$ private fun buildExtractor(): Extractor</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Client$log.debug { "BFT Client $clientId: number of replicas accepted the commit: ${accepted.size}, rejected: ${rejected.size}" }</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Client$private val sessionTable = (proxy.communicationSystem as NettyClientServerCommunicationSystemClientSide).declaredField&lt;Map&lt;Int, NettyClientServerSession&gt;&gt;("sessionTable").value</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Client${ // TODO: Hopefully we only need to wait for the client's initial connection to the cluster, and this method can be moved to some startup code. // TODO: Investigate ConcurrentModificationException in this method. while (true) { val inactive = sessionTable.entries.mapNotNull { if (it.value.channel.isActive) null else it.key } if (inactive.isEmpty()) break log.info("Client-replica channels not yet active: $clientId to $inactive") Thread.sleep((inactive.size * 100).toLong()) } }</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.CordaServiceReplica$private</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Replica$checkConflict(conflictingStates, references, StateConsumptionDetails.ConsumedStateType.REFERENCE_INPUT_STATE)</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Replica$val (committedStates, requests) = bytes.deserialize&lt;Pair&lt;LinkedHashMap&lt;StateRef, SecureHash&gt;, List&lt;PersistentUniquenessProvider.Request&gt;&gt;&gt;()</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Replica$val criteriaQuery = session.criteriaBuilder.createQuery(PersistentUniquenessProvider.Request::class.java)</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Replica$val deleteQuery = session.criteriaBuilder.createCriteriaDelete(PersistentUniquenessProvider.Request::class.java)</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Replica$val signableData = SignableData(txId, SignatureMetadata(services.myInfo.platformVersion, Crypto.findSignatureScheme(notaryIdentityKey).schemeNumberID))</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Replica.&lt;no name provided&gt;$if (exposeStartupRace) Thread.sleep(20000)</ID>
    <ID>MaxLineLength:BFTSmartConfigInternal.kt$BFTSmartConfigInternal$val systemConfig = String.format(javaClass.getResource("system.config.printf").readText(), n, maxFaultyReplicas(n), if (debug) 1 else 0, (0 until n).joinToString(","))</ID>
    <ID>MaxLineLength:BFTSmartConfigTests.kt$BFTSmartConfigTests$assertThatThrownBy { config(11001, 11000).use {} } .isInstanceOf(IllegalArgumentException::class.java) .hasMessage(portIsClaimedFormat.format("localhost:11001", setOf("localhost:11001", "localhost:11002", "localhost:11000")))</ID>
    <ID>MaxLineLength:BFTSmartConfigTests.kt$BFTSmartConfigTests$fun config(vararg ports: Int)</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService$?:</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService$CommittedState : BaseComittedState</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService$client</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService$override fun createServiceFlow(otherPartySession: FlowSession): FlowLogic&lt;Void?&gt;</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService.&lt;no name provided&gt;$log.warn("A BFT replica may still be initializing, in which case the upcoming consensus change may cause it to spin.")</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService.Replica$val response = verifyAndCommitTx(commitRequest.payload.coreTransaction, commitRequest.callerIdentity, commitRequest.payload.requestSignature)</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService.ServiceFlow$private</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService.ServiceFlow${ // TODO: here we assume that all error will be the same, but there might be invalid onces from mailicious nodes val responseError = response.errors.first().verified() throw NotaryException(responseError, payload.coreTransaction.id) }</ID>
    <ID>MaxLineLength:BackpressureAwareTimedFlow.kt$BackpressureAwareTimedFlow$else -&gt; throw throw IllegalArgumentException("We were expecting a ${ReceiveType::class.java.name} or WaitTimeUpdate but we instead got a ${unwrapped.javaClass.name} ($unwrapped)")</ID>
    <ID>MaxLineLength:BackpressureAwareTimedFlow.kt$BackpressureAwareTimedFlow$is ReceiveType</ID>
    <ID>MaxLineLength:BackpressureAwareTimedFlow.kt$BackpressureAwareTimedFlow$logger.info("Counterparty [${session.counterparty}] is busy - TimedFlow $runId has been asked to wait for an additional ${unwrapped.waitTime} seconds for completion.")</ID>
    <ID>MaxLineLength:BackpressureAwareTimedFlow.kt$BackpressureAwareTimedFlow&lt;ResultType&gt; : FlowLogicTimedFlow</ID>
    <ID>MaxLineLength:BankOfCordaClientApi.kt$BankOfCordaClientApi$ fun requestRPCIssue(rpcAddress: NetworkHostAndPort, params: IssueRequestParams): SignedTransaction</ID>
    <ID>MaxLineLength:BankOfCordaClientApi.kt$BankOfCordaClientApi$ fun requestRPCIssueHA(availableRpcServers: List&lt;NetworkHostAndPort&gt;, params: IssueRequestParams): SignedTransaction</ID>
    <ID>MaxLineLength:BankOfCordaClientApi.kt$BankOfCordaClientApi$return rpc.startFlow(::CashIssueAndPaymentFlow, params.amount, issuerBankPartyRef, issueToParty, anonymous, notaryLegalIdentity) .returnValue.getOrThrow().stx</ID>
    <ID>MaxLineLength:BankOfCordaWebApi.kt$BankOfCordaWebApi$?:</ID>
    <ID>MaxLineLength:BankOfCordaWebApi.kt$BankOfCordaWebApi$rpc.startFlow(::CashIssueAndPaymentFlow, params.amount, issuerBankPartyRef, issueToParty, anonymous, notaryParty).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:BankOfCordaWebApi.kt$BankOfCordaWebApi$rpc.wellKnownPartyFromX500Name(params.issuerBankName) ?: return Response.status(Response.Status.FORBIDDEN).entity("Unable to locate ${params.issuerBankName} in identity service").build()</ID>
    <ID>MaxLineLength:BaseTransaction.kt$BaseTransaction$ fun &lt;T : ContractState&gt; filterOutRefs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:BaseTransaction.kt$BaseTransaction$ fun &lt;T : ContractState&gt; filterOutputs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:BaseTransaction.kt$BaseTransaction$ fun &lt;T : ContractState&gt; outRef(index: Int): StateAndRef&lt;T&gt;</ID>
    <ID>MaxLineLength:BaseTransaction.kt$BaseTransaction$ fun &lt;T : ContractState&gt; outputsOfType(clazz: Class&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:BaseTransaction.kt$BaseTransaction$/** * Helper property to return a list of [ContractState] objects, rather than the often less convenient [TransactionState] */ val outputStates: List&lt;ContractState&gt; get() = outputs.map { it.data }</ID>
    <ID>MaxLineLength:BaseTransactions.kt$CoreTransaction$/** * Hash of the network parameters that were in force when the transaction was notarised. Null means, that the transaction * was created on older version of Corda (before 4), resolution will default to initial parameters. */ abstract val networkParametersHash: SecureHash?</ID>
    <ID>MaxLineLength:BaseTransactions.kt$FullTransaction$"Notary ($notaryParty) specified by the transaction is not on the network parameter whitelist: [${notaryWhitelist.joinToString()}]"</ID>
    <ID>MaxLineLength:BaseTransactions.kt$FullTransaction$/** * Network parameters that were in force when this transaction was created. Resolved from the hash of network parameters on the corresponding * wire transaction. */ abstract val networkParameters: NetworkParameters?</ID>
    <ID>MaxLineLength:BaseTransactions.kt$FullTransaction$// Network parameters will never be null if the transaction is resolved from a CoreTransaction rather than constructed directly. networkParameters?.let { parameters -&gt; val notaryWhitelist = parameters.notaries.map { it.identity } check(notaryParty in notaryWhitelist) { "Notary ($notaryParty) specified by the transaction is not on the network parameter whitelist: [${notaryWhitelist.joinToString()}]" } }</ID>
    <ID>MaxLineLength:BaseTransactions.kt$FullTransaction$check(notaries.single() == notary) { "The specified notary must be the one specified by all inputs and input references" }</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService$"Metadata schemeCodeName: ${sigMetaData.schemeCodeName} is not aligned with the key type: ${sigKey.schemeCodeName}."</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService$// Get [KeyPair] for the input [publicKey]. This is used for fresh keys, in which we have access to the private key material. private fun getSigningKeyPair(publicKey: PublicKey): KeyPair</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService$require(it.private is AliasPrivateKey) { "${this.javaClass.name} supports AliasPrivateKeys only, but ${it.private.algorithm} key was found" }</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService.Companion$fun createKeyMap(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;PublicKey, PrivateKey, PersistentKey, String&gt;</ID>
    <ID>MaxLineLength:BitSetSerializer.kt$BitSetSerializer : Proxy</ID>
    <ID>MaxLineLength:BlobInspector.kt$BlobInspector$?:</ID>
    <ID>MaxLineLength:BlobInspector.kt$BlobInspector$@Option(names = ["--input-format"], paramLabel = "type", description = ["Input format. If the file can't be decoded with the given value it's auto-detected, so you should never normally need to specify this. Possible values: [BINARY, HEX, BASE64]"])</ID>
    <ID>MaxLineLength:BlobInspector.kt$BlobInspector$@Parameters(index = "0", paramLabel = "SOURCE", description = ["URL or file path to the blob"], converter = [SourceConverter::class])</ID>
    <ID>MaxLineLength:BlobInspector.kt$BlobInspector$description = ["Display the owningKey and certPath properties of Party and PartyAndReference objects respectively"]</ID>
    <ID>MaxLineLength:BlobInspector.kt$BlobInspector$val envelope = DeserializationInput.getEnvelope(bytes.sequence(), SerializationDefaults.STORAGE_CONTEXT.encodingWhitelist)</ID>
    <ID>MaxLineLength:BlobInspectorTest.kt$BlobInspectorTest$assertThat(output) .startsWith(SignedDataWithCert::class.java.name) .contains(NetworkParameters::class.java.name) .contains(CordaX500Name("Notary Service", "Zurich", "CH").toString())</ID>
    <ID>MaxLineLength:BootTests.kt$BootTests$assertThatThrownBy { devModeNode.attemptJavaDeserialization() }.isInstanceOf(CordaRuntimeException::class.java)</ID>
    <ID>MaxLineLength:BootTests.kt$BootTests$val alice = startNode(providedName = ALICE_NAME).getOrThrow() val aliceCertDir = alice.baseDirectory / "certificates" (aliceCertDir / "nodekeystore.jks").delete() val cert = CertificateStoreStubs.Signing.withCertificatesDirectory(aliceCertDir).get(true) // Creating a new certificate store does not populate that store with the node certificate path. If the node certificate path is // missing, the node will fail to start but not because the legal identity is missing. To test that a missing legal identity // prevents the node from starting, the node certificate path must be installed. cert.installDevNodeCaCertPath(ALICE_NAME) alice.stop() // The node shouldn't start, and the logs should indicate that the failure is due to a missing identity key assertThatThrownBy { startNode(providedName = ALICE_NAME).getOrThrow() } val logFolder = alice.baseDirectory / NodeStartup.LOGS_DIRECTORY_NAME val logFile = logFolder.list { it.filter { a -&gt; a.isRegularFile() &amp;&amp; a.fileName.toString().startsWith("node") }.findFirst().get() } val lines = logFile.readLines { lines -&gt; lines.filter { "$NODE_IDENTITY_ALIAS_PREFIX-private-key" in it }.toArray() } assertTrue(lines.count() &gt; 0)</ID>
    <ID>MaxLineLength:BootTests.kt$BootTests$val lines = logFile.readLines { lines -&gt; lines.filter { "$NODE_IDENTITY_ALIAS_PREFIX-private-key" in it }.toArray() }</ID>
    <ID>MaxLineLength:BootTests.kt$BootTests$val logFile = logFolder.list { it.filter { a -&gt; a.isRegularFile() &amp;&amp; a.fileName.toString().startsWith("node") }.findFirst().get() }</ID>
    <ID>MaxLineLength:BootTests.kt$BootTests$val numberOfNodesThatLogged = logFile.readLines { it.filter { NodeStartup.LOGS_CAN_BE_FOUND_IN_STRING in it }.count() }</ID>
    <ID>MaxLineLength:BootTests.kt$ObjectInputStreamFlow$val data = ByteArrayOutputStream().apply { ObjectOutputStream(this).use { it.writeObject(object : Serializable {}) } }.toByteArray()</ID>
    <ID>MaxLineLength:BootstrapperView.kt$BootstrapperView$nodeAdder.addNode(context, nodeToAdd, x500ToUse?.let { CordaX500Name.parse(it) })</ID>
    <ID>MaxLineLength:BootstrapperView.kt$BootstrapperView$return Pair(mapOf(Constants.REGION_ARG_NAME to ChoiceDialog&lt;Region&gt;(Region.EUROPE_WEST, Region.values().toList().sortedBy { it.name() }).showAndWait().get().name()), networkName1)</ID>
    <ID>MaxLineLength:BootstrapperView.kt$BootstrapperView.State$var hasNodesOrNotaries = Bindings.size(foundNotaries).greaterThan(0).or(Bindings.size(foundNotaries).greaterThan(0))</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$bridgeManager.deployBridge(controlMessage.bridgeInfo.queueName, controlMessage.bridgeInfo.targets, controlMessage.bridgeInfo.legalNames.toSet())</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$return queueName.startsWith(P2P_PREFIX) &amp;&amp; artemis!!.started!!.session.queueQuery(SimpleString(queueName)).isExists</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$return queueName.startsWith(PEERS_PREFIX) &amp;&amp; artemis!!.started!!.session.queueQuery(SimpleString(queueName)).isExists</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$val startupMessage = BridgeControl.BridgeToNodeSnapshotRequest(bridgeId).serialize(context = SerializationDefaults.P2P_CONTEXT).bytes</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeControl$Create : BridgeControl</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeControl$Delete : BridgeControl</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeControl$NodeToBridgeSnapshot : BridgeControl</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeEntry</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule : BaseBrokerJaasLoginModule</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$CertificateChainCheckPolicy.LeafMustMatch.createCheck(nodeJaasConfig.keyStore, nodeJaasConfig.trustStore).checkCertificateChain(certificates!!)</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$CertificateChainCheckPolicy.RootMustMatch.createCheck(p2pJaasConfig!!.keyStore, p2pJaasConfig!!.trustStore).checkCertificateChain(certificates!!)</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$Pair(username, listOf(RolePrincipal(RPC_ROLE), RolePrincipal("${RPCApi.RPC_CLIENT_QUEUE_NAME_PREFIX}.$username")))</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$fun requireTls(certificates: Array&lt;X509Certificate&gt;?)</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$if (e is IllegalArgumentException &amp;&amp; e.stackTrace.any { it.className == "org.apache.activemq.artemis.protocol.amqp.sasl.PlainSASL" }) { log.trace("SASL Login failed.") } else { log.warn("Login failed: ${e.message}") }</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$private</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule${ // This is a known problem, so we swallow this exception. A peer will attempt to connect without presenting client certificates during SASL if (e is IllegalArgumentException &amp;&amp; e.stackTrace.any { it.className == "org.apache.activemq.artemis.protocol.amqp.sasl.PlainSASL" }) { log.trace("SASL Login failed.") } else { log.warn("Login failed: ${e.message}") } if (e is LoginException) { throw e } else { throw FailedLoginException(e.message) } }</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$RPCJaasConfig$val loginListener: LoginListener</ID>
    <ID>MaxLineLength:BuiltNode.kt$BuiltNode$return PushedNode(configFile, baseDirectory, copiedNodeConfig, copiedNodeDir, nodeConfig, localImageId, remoteImageName)</ID>
    <ID>MaxLineLength:BusinessCalendar.kt$BusinessCalendar$operator fun plus(other: BusinessCalendar): BusinessCalendar</ID>
    <ID>MaxLineLength:BusinessCalendar.kt$BusinessCalendar.Companion$dcbDay == DayCountBasisDay.D30 &amp;&amp; dcbYear == DayCountBasisYear.Y360 -&gt; ((endDate.year - startDate.year) * 360.0 + (endDate.monthValue - startDate.monthValue) * 30.0 + endDate.dayOfMonth - startDate.dayOfMonth).toInt()</ID>
    <ID>MaxLineLength:ByteArrays.kt$ByteSequence$ @Suppress("MemberVisibilityCanBePrivate") fun subSequence(offset: Int, size: Int): ByteSequence</ID>
    <ID>MaxLineLength:ByteArrays.kt$ByteSequence$ fun slice(start: Int = 0, end: Int = size): ByteBuffer</ID>
    <ID>MaxLineLength:ByteArrays.kt$OpaqueBytes$/** * The bytes are always cloned so that this object becomes immutable. This has been done * to prevent tampering with entities such as [net.corda.core.crypto.SecureHash] and [net.corda.core.contracts.PrivacySalt], as well as * preserve the integrity of our hash constants [net.corda.core.crypto.SecureHash.zeroHash] and [net.corda.core.crypto.SecureHash.allOnesHash]. * * Cloning like this may become a performance issue, depending on whether or not the JIT * compiler is ever able to optimise away the clone. In which case we may need to revisit * this later. */ final override val bytes: ByteArray = bytes get() = field.clone()</ID>
    <ID>MaxLineLength:ByteArrays.kt$OpaqueBytesSubSequence : ByteSequence</ID>
    <ID>MaxLineLength:ByteArrays.kt$OpaqueBytesSubSequence$require(offset &gt;= 0 &amp;&amp; offset &lt; bytes.size) { "Offset must be greater than or equal to 0, and less than the size of the backing array" }</ID>
    <ID>MaxLineLength:ByteArrays.kt$OpaqueBytesSubSequence$require(size &gt;= 0 &amp;&amp; offset + size &lt;= bytes.size) { "Sub-sequence size must be greater than or equal to 0, and less than the size of the backing array" }</ID>
    <ID>MaxLineLength:ByteBufferStreams.kt$ByteBufferOutputStream.Companion$private</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", BusinessCalendar.parseDateFromString("2017-03-01"), Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", BusinessCalendar.parseDateFromString("2017-03-01"), Tenor("3M")), 1.5.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", BusinessCalendar.parseDateFromString("2017-03-01"), Tenor("9M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", BusinessCalendar.parseDateFromString("2017-03-01").plusYears(1), Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("3M")), 1.5.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("9M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate.plusYears(1), Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBORx", BusinessCalendar.parseDateFromString("2017-03-01"), Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBORx", tradeDate, Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$val floating = interest(notional, "act/365", fix("LIBOR", start, Tenor("3M")), start, end)</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("6M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("6M")), 1.5.bd))))</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate.plusYears(1), Tenor("6M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBORx", tradeDate, Tenor("6M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$val floating = interest(notional, "act/365", fix("LIBOR", tradeDate, Tenor("6M")), "2016-04-01", "2016-10-01")</ID>
    <ID>MaxLineLength:CarpentryDependencyGraph.kt$CarpentryDependencyGraph$/** * A map of inbound edges by node. * * A [RemoteTypeInformation] map key is a type that requires other types to have been constructed before it can be * constructed. * * Each [RemoteTypeInformation] in the corresponding [Set] map value is one of the types that the key-type depends on. * * No key ever maps to an empty set: types with no dependencies are not included in this map. */ private val dependencies = mutableMapOf&lt;RemoteTypeInformation, MutableSet&lt;RemoteTypeInformation&gt;&gt;()</ID>
    <ID>MaxLineLength:CarpentryDependencyGraph.kt$CarpentryDependencyGraph$if (dependencies.isEmpty()) newlyIndependent.asSequence() else topologicalSort(remaining, newlyIndependent)</ID>
    <ID>MaxLineLength:CarpentryDependencyGraph.kt$CarpentryDependencyGraph${ // Types which still have dependencies. val remaining = dependencies.keys.toSet() // Remove the types which have no dependencies from the dependencies of the remaining types, and identify // those types which have no dependencies left after we've done this. val newlyIndependent = dependencies.asSequence().mapNotNull { (dependent, dependees) -&gt; dependees.removeAll(noDependencies) if (dependees.isEmpty()) dependent else null }.toSet() // If there are still types with dependencies, and we have no dependencies we can remove, then we can't continue. if (newlyIndependent.isEmpty() &amp;&amp; dependencies.isNotEmpty()) { throw NotSerializableException( "Cannot build dependencies for " + dependencies.keys.map { it.typeIdentifier.prettyPrint(false) }) } // Remove the types which have no dependencies remaining, maintaining the invariant that no key maps to an // empty set. dependencies.keys.removeAll(newlyIndependent) // Return the types that had no dependencies, then recurse to process the remainder. return noDependencies.asSequence() + if (dependencies.isEmpty()) newlyIndependent.asSequence() else topologicalSort(remaining, newlyIndependent) }</ID>
    <ID>MaxLineLength:Cash.kt$ @Throws(IllegalArgumentException::class) internal inline fun &lt;reified T : MoveCommand&gt; verifyFlattenedMoveCommand( inputs: List&lt;OwnableState&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt; ): MoveCommand</ID>
    <ID>MaxLineLength:Cash.kt$Cash$"for reference ${issuer.reference} at issuer ${issuer.party} the amounts balance: ${inputAmount.quantity} - ${amountExitingLedger.quantity} != ${outputAmount.quantity}"</ID>
    <ID>MaxLineLength:Cash.kt$Cash$override</ID>
    <ID>MaxLineLength:Cash.kt$Cash$val exitCommand = tx.commands.select&lt;Commands.Exit&gt;(parties = null, signers = exitKeys).singleOrNull { it.value.amount.token == key }</ID>
    <ID>MaxLineLength:Cash.kt$Cash$val inputAmount = inputs.sumCashOrNull() ?: throw IllegalArgumentException("there is at least one cash input for this group")</ID>
    <ID>MaxLineLength:Cash.kt$Cash${ val inputAmount = inputs.sumCashOrNull() ?: throw IllegalArgumentException("there is at least one cash input for this group") val outputAmount = outputs.sumCashOrZero(Issued(issuer, currency)) // If we want to remove cash from the ledger, that must be signed for by the issuer. // A mis-signed or duplicated exit command will just be ignored here and result in the exit amount being zero. val exitKeys: Set&lt;PublicKey&gt; = inputs.flatMap { it.exitKeys }.toSet() val exitCommand = tx.commands.select&lt;Commands.Exit&gt;(parties = null, signers = exitKeys).singleOrNull { it.value.amount.token == key } val amountExitingLedger = exitCommand?.value?.amount ?: Amount(0, Issued(issuer, currency)) requireThat { "there are no zero sized inputs" using inputs.none { it.amount.quantity == 0L } "for reference ${issuer.reference} at issuer ${issuer.party} the amounts balance: ${inputAmount.quantity} - ${amountExitingLedger.quantity} != ${outputAmount.quantity}" using (inputAmount == outputAmount + amountExitingLedger) } verifyFlattenedMoveCommand&lt;Commands.Move&gt;(inputs, tx.commands) }</ID>
    <ID>MaxLineLength:Cash.kt$Cash.State$infix fun issuedBy(deposit: PartyAndReference)</ID>
    <ID>MaxLineLength:Cash.kt$Cash.State$infix fun issuedBy(party: AbstractParty)</ID>
    <ID>MaxLineLength:Cash.kt$Cash.State$infix fun withDeposit(deposit: PartyAndReference): Cash.State</ID>
    <ID>MaxLineLength:Cash.kt$Cash.State$override</ID>
    <ID>MaxLineLength:Cash.kt$internal</ID>
    <ID>MaxLineLength:Cash.kt$internal inline</ID>
    <ID>MaxLineLength:CashConfigDataFlowTest.kt$CashConfigDataFlowTest$additionalCordapps = listOf(FINANCE_WORKFLOWS_CORDAPP.withConfig(mapOf("issuableCurrencies" to listOf("EUR", "USD"))))</ID>
    <ID>MaxLineLength:CashExceptionSerialisationTest.kt$CashExceptionSerialisationTest$val action = { node.rpc.startFlow(CashExceptionSerialisationTest::CashExceptionThrowingFlow).returnValue.getOrThrow() }</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow$AbstractCashSelection .getInstance { serviceHub.jdbcSession().metaData } .unconsumedCashStatesForSpending(serviceHub, amount, setOf(issuer.party), builder.notary, builder.lockId, setOf(issuer.reference))</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow$val changeOwner = exitStates.asSequence().map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amount)</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow$val inputStates = serviceHub.vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(stateRefs = builder.inputStates()), PageSpecification(pageNumber = DEFAULT_PAGE_NUM, pageSize = builder.inputStates().size)).states</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow${ progressTracker.currentStep = GENERATING_TX val builder = TransactionBuilder(notary = null) val issuer = ourIdentity.ref(issuerRef) val exitStates = AbstractCashSelection .getInstance { serviceHub.jdbcSession().metaData } .unconsumedCashStatesForSpending(serviceHub, amount, setOf(issuer.party), builder.notary, builder.lockId, setOf(issuer.reference)) val signers = try { val changeOwner = exitStates.asSequence().map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amount) Cash().generateExit( builder, amount.issuedBy(issuer), exitStates, changeOwner) } catch (e: InsufficientBalanceException) { throw CashException("Exiting more cash than exists", e) } // Work out who the owners of the burnt states were (specify page size so we don't silently drop any if &gt; DEFAULT_PAGE_SIZE) val inputStates = serviceHub.vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(stateRefs = builder.inputStates()), PageSpecification(pageNumber = DEFAULT_PAGE_NUM, pageSize = builder.inputStates().size)).states val participantSessions = inputStates .asSequence() .mapNotNull { serviceHub.identityService.wellKnownPartyFromAnonymous(it.state.data.owner) } .filterNot(serviceHub.myInfo::isLegalIdentity) .distinct() .map(::initiateFlow) .toList() // Sign transaction progressTracker.currentStep = SIGNING_TX val tx = serviceHub.signInitialTransaction(builder, signers) // Commit the transaction progressTracker.currentStep = FINALISING_TX val notarised = finaliseTx(tx, participantSessions, "Unable to notarise exit") return Result(notarised, null) }</ID>
    <ID>MaxLineLength:CashExitFlowTests.kt$CashExitFlowTests$mockNet = MockNetwork(MockNetworkParameters(servicePeerAllocationStrategy = RoundRobin(), cordappsForAllNodes = FINANCE_CORDAPPS))</ID>
    <ID>MaxLineLength:CashIssueAndPaymentFlow.kt$CashIssueAndPaymentFlow$constructor(request: IssueAndPaymentRequest) : this(request.amount, request.issueRef, request.recipient, request.anonymous, request.notary, tracker())</ID>
    <ID>MaxLineLength:CashIssueFlowTests.kt$CashIssueFlowTests$mockNet = MockNetwork(MockNetworkParameters(servicePeerAllocationStrategy = RoundRobin(), cordappsForAllNodes = FINANCE_CORDAPPS))</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$/** A straightforward constructor that constructs spends using cash states of any issuer. */ constructor(amount: Amount&lt;Currency&gt;, recipient: Party, anonymous: Boolean) : this(amount, recipient, anonymous, tracker())</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$constructor(amount: Amount&lt;Currency&gt;, recipient: Party, anonymous: Boolean, notary: Party) : this(amount, recipient, anonymous, tracker(), notary = notary)</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$constructor(request: PaymentRequest) : this(request.amount, request.recipient, request.anonymous, tracker(), request.issuerConstraint, request.notary)</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$val sessionsForFinality = if (serviceHub.myInfo.isLegalIdentity(recipient)) emptyList() else listOf(recipientSession)</ID>
    <ID>MaxLineLength:CashPaymentFlowTests.kt$CashPaymentFlowTests$mockNet = MockNetwork(MockNetworkParameters(servicePeerAllocationStrategy = RoundRobin(), cordappsForAllNodes = FINANCE_CORDAPPS))</ID>
    <ID>MaxLineLength:CashSchemaV1.kt$CashSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:CashSchemaV1.kt$CashSchemaV1.PersistentCashState$@Table(name = "contract_cash_states", indexes = [Index(name = "ccy_code_idx", columnList = "ccy_code"), Index(name = "pennies_idx", columnList = "pennies")])</ID>
    <ID>MaxLineLength:CashSelectionH2Impl.kt$CashSelectionH2Impl$ SELECT vs.transaction_id, vs.output_index, ccs.pennies, SET(@t, ifnull(@t,0)+ccs.pennies) total_pennies, vs.lock_id</ID>
    <ID>MaxLineLength:CashSelectionH2Impl.kt$CashSelectionH2Impl$// We are using an H2 specific means of selecting a minimum set of rows that match a request amount of coins: // 1) There is no standard SQL mechanism of calculating a cumulative total on a field and restricting row selection on the // running total of such an accumulator // 2) H2 uses session variables to perform this accumulator function: // http://www.h2database.com/html/functions.html#set // 3) H2 does not support JOIN's in FOR UPDATE (hence we are forced to execute 2 queries) override fun executeQuery( connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean ): Boolean</ID>
    <ID>MaxLineLength:CashSelectionH2Impl.kt$CashSelectionH2Impl${ connection.createStatement().use { it.execute("CALL SET(@t, CAST(0 AS BIGINT));") } // state_status = 0 -&gt; UNCONSUMED. // is_relevant = 0 -&gt; RELEVANT. val selectJoin = """ SELECT vs.transaction_id, vs.output_index, ccs.pennies, SET(@t, ifnull(@t,0)+ccs.pennies) total_pennies, vs.lock_id FROM vault_states AS vs, contract_cash_states AS ccs WHERE vs.transaction_id = ccs.transaction_id AND vs.output_index = ccs.output_index AND vs.state_status = 0 AND vs.relevancy_status = 0 AND ccs.ccy_code = ? and @t &lt; ? AND (vs.lock_id = ? OR vs.lock_id is null) """ + (if (notary != null) " AND vs.notary_name = ?" else "") + (if (onlyFromIssuerParties.isNotEmpty()) { val repeats = generateSequence { "?" }.take(onlyFromIssuerParties.size).joinToString(",") " AND ccs.issuer_key_hash IN ($repeats)" } else "") + (if (withIssuerRefs.isNotEmpty()) { val repeats = generateSequence { "?" }.take(withIssuerRefs.size).joinToString(",") " AND ccs.issuer_ref IN ($repeats)" } else "") // Use prepared statement for protection against SQL Injection (http://www.h2database.com/html/advanced.html#sql_injection) connection.prepareStatement(selectJoin).use { psSelectJoin -&gt; var pIndex = 0 psSelectJoin.setString(++pIndex, amount.token.currencyCode) psSelectJoin.setLong(++pIndex, amount.quantity) psSelectJoin.setString(++pIndex, lockId.toString()) if (notary != null) psSelectJoin.setString(++pIndex, notary.name.toString()) onlyFromIssuerParties.forEach { psSelectJoin.setString(++pIndex, it.owningKey.toStringShort()) } withIssuerRefs.forEach { psSelectJoin.setBytes(++pIndex, it.bytes) } log.debug { psSelectJoin.toString() } psSelectJoin.executeQuery().use { rs -&gt; return withResultSet(rs) } } }</ID>
    <ID>MaxLineLength:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest$( // Tweak connections to be minimal to make this easier (1 results in a hung node during start up, so use 2 connections). configOverrides = MockNodeConfigOverrides(extraDataSourceProperties = mapOf("maximumPoolSize" to "2")) )</ID>
    <ID>MaxLineLength:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest$private val mockNet = MockNetwork(MockNetworkParameters(threadPerNode = true, cordappsForAllNodes = FINANCE_CORDAPPS))</ID>
    <ID>MaxLineLength:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest$val paymentResult = node.startFlow(CashPaymentFlow(999.POUNDS, node.info.legalIdentities[0], false)).getOrThrow()</ID>
    <ID>MaxLineLength:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest$val request = CashPaymentFlow.PaymentRequest(1.POUNDS, node.info.legalIdentities[0], true, setOf(node.info.legalIdentities[0], mockNet.defaultNotaryIdentity))</ID>
    <ID>MaxLineLength:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest${ val bankA = mockNet.createNode(MockNodeParameters( // Tweak connections to be minimal to make this easier (1 results in a hung node during start up, so use 2 connections). configOverrides = MockNodeConfigOverrides(extraDataSourceProperties = mapOf("maximumPoolSize" to "2")) )) val notary = mockNet.defaultNotaryIdentity // Start more cash spends than we have connections. If spend leaks a connection on retry, we will run out of connections. val flow1 = bankA.startFlow(CashPaymentFlow(amount = 100.DOLLARS, anonymous = false, recipient = notary)) val flow2 = bankA.startFlow(CashPaymentFlow(amount = 100.DOLLARS, anonymous = false, recipient = notary)) val flow3 = bankA.startFlow(CashPaymentFlow(amount = 100.DOLLARS, anonymous = false, recipient = notary)) assertThatThrownBy { flow1.getOrThrow() }.isInstanceOf(CashException::class.java) assertThatThrownBy { flow2.getOrThrow() }.isInstanceOf(CashException::class.java) assertThatThrownBy { flow3.getOrThrow() }.isInstanceOf(CashException::class.java) }</ID>
    <ID>MaxLineLength:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest${ val node = mockNet.createNode() // The amount has to split across at least two states, probably to trigger the H2 accumulator variable during the // spend operation below. // Issuing Integer.MAX_VALUE will not cause an exception since PersistentCashState.pennies is a long nCopies(2, Integer.MAX_VALUE).map { issueAmount -&gt; node.startFlow(CashIssueFlow(issueAmount.POUNDS, OpaqueBytes.of(1), mockNet.defaultNotaryIdentity)) }.transpose().getOrThrow() // The spend must be more than the size of a single cash state to force the accumulator onto the second state. node.startFlow(CashPaymentFlow((Integer.MAX_VALUE + 1L).POUNDS, node.info.legalIdentities[0])).getOrThrow() }</ID>
    <ID>MaxLineLength:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$ coalesce((SUM(ccs.pennies) OVER (PARTITION BY 1 ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING)), 0)</ID>
    <ID>MaxLineLength:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$// This is using PostgreSQL window functions for selecting a minimum set of rows that match a request amount of coins: // 1) This may also be possible with user-defined functions (e.g. using PL/pgSQL) // 2) The window function accumulated column (`total`) does not include the current row (starts from 0) and cannot // appear in the WHERE clause, hence restricting row selection and adjusting the returned total in the outer query. // 3) Currently (version 9.6), FOR UPDATE cannot be specified with window functions override fun executeQuery( connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean ): Boolean</ID>
    <ID>MaxLineLength:CashSelectionTest.kt$CashSelectionTest$AbstractCashSelection .getInstance { node.services.jdbcSession().metaData } .unconsumedCashStatesForSpending(node.services, exitedAmount, setOf(issuer.party), builder.notary, builder.lockId, setOf(issuer.reference))</ID>
    <ID>MaxLineLength:CashSelectionTest.kt$CashSelectionTest$issuance.addOutputState(TransactionState(Cash.State(coin, nodeIdentity), Cash.PROGRAM_ID, mockNet.defaultNotaryIdentity))</ID>
    <ID>MaxLineLength:CashSelectionTest.kt$CashSelectionTest$issuance.addOutputState(TransactionState(Cash.State(it, nodeIdentity), "net.corda.finance.contracts.asset.Cash", mockNet.defaultNotaryIdentity))</ID>
    <ID>MaxLineLength:CashSelectionTest.kt$CashSelectionTest$node.services.startFlow(CashIssueFlow(issuedAmount, issuerRef, mockNet.defaultNotaryIdentity)).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$Cash().generateExit(tx, Amount(amount.quantity, Issued(issuer.ref(depositRef), amount.token)), cashStates, payChangeTo)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$Cash().generateIssue(ptx, 100.DOLLARS `issued by` miniCorp.ref(12, 34), owner = miniCorp.party, notary = dummyNotary.party)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$Cash().generateIssue(this, 100.DOLLARS `issued by` miniCorp.ref(12, 34), owner = AnonymousParty(alice.publicKey), notary = dummyNotary.party)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$CashUtils.generateSpend(ourServices, tx, 80.DOLLARS, ourServices.myInfo.singleIdentityAndCert(), alice.party, setOf(miniCorp.party))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$TransactionState(Cash.State(amount `issued by` issuer.ref(depositRef), ourIdentity), Cash.PROGRAM_ID, dummyNotary.party, constraint = AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$amount = Amount(amount.quantity, token = amount.token.copy(amount.token.issuer.copy(reference = OpaqueBytes.of(ref))))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$assertEquals(vaultState.state.data.copy(owner = miniCorpAnonymised, amount = 10.DOLLARS `issued by` defaultIssuer), wtx.outputs[0].data)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$assertEquals(vaultState0.state.data.copy(owner = miniCorpAnonymised, amount = 500.DOLLARS `issued by` defaultIssuer), wtx.getOutput(0))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$assertEquals(vaultState0.state.data.copy(owner = miniCorpAnonymised, amount = 500.DOLLARS `issued by` defaultIssuer), wtx.outputs[1].data)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$assertNotEquals((fiveThousandDollarsFromMega withDeposit defaultIssuer).amount.token, fiveThousandDollarsFromMega.amount.token)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$assertNotEquals(fiveThousandDollarsFromMega.amount.token, (fiveThousandDollarsFromMega withDeposit defaultIssuer).amount.token)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$makeTestIdentityService(megaCorp.identity, miniCorp.identity, dummyCashIssuer.identity, dummyNotary.identity, myself.identity)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, "MEGA_CORP cash 2", "MEGA_CORP cash".output&lt;Cash.State&gt;().copy(owner = AnonymousParty(alice.publicKey)))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, "MEGA_CORP cash 3", "MEGA_CORP cash".output&lt;Cash.State&gt;().copy(owner = alice.party))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, inState.copy(owner = AnonymousParty(bob.publicKey), amount = 2000.DOLLARS `issued by` defaultIssuer))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, issuerInState.copy(amount = issuerInState.amount - (200.DOLLARS `issued by` defaultIssuer)) issuedBy miniCorp.party)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, issuerInState.copy(amount = issuerInState.amount - (200.DOLLARS `issued by` defaultIssuer)))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, issuerInState.copy(owner = miniCorp.party, amount = issuerInState.amount - (200.DOLLARS `issued by` defaultIssuer)))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$private</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$val expectedChange = cashStates[0].state.data.copy(amount = cashStates[0].state.data.amount.copy(quantity = expectedChangeAmount), owner = actualChange.owner)</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$@Deprecated("Our identity should be specified", replaceWith = ReplaceWith("generateSpend(services, tx, amount, to, ourIdentity, onlyFromParties)"))</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$fun deriveState(txState: TransactionState&lt;Cash.State&gt;, amt: Amount&lt;Issued&lt;Currency&gt;&gt;, owner: AbstractParty): TransactionState&lt;Cash.State&gt;</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$return generateSpend(services, tx, listOf(PartyAndAmount(to, amount)), services.myInfo.legalIdentitiesAndCerts.single(), onlyFromParties)</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$val acceptableCoins = cashSelection.unconsumedCashStatesForSpending(services, totalAmount, onlyFromParties, tx.notary, tx.lockId)</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$val changeIdentity: AbstractParty = if (anonymous) services.keyManagementService.freshKeyAndCert(ourIdentity, revocationEnabled).party.anonymise() else ourIdentity.party</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils${ fun deriveState(txState: TransactionState&lt;Cash.State&gt;, amt: Amount&lt;Issued&lt;Currency&gt;&gt;, owner: AbstractParty): TransactionState&lt;Cash.State&gt; { return txState.copy(data = txState.data.copy(amount = amt, owner = owner)) } // Retrieve unspent and unlocked cash states that meet our spending criteria. val totalAmount = payments.map { it.amount }.sumOrThrow() val cashSelection = AbstractCashSelection.getInstance { services.jdbcSession().metaData } val acceptableCoins = cashSelection.unconsumedCashStatesForSpending(services, totalAmount, onlyFromParties, tx.notary, tx.lockId) val revocationEnabled = false // Revocation is currently unsupported // If anonymous is true, generate a new identity that change will be sent to for confidentiality purposes. This means that a // third party with a copy of the transaction (such as the notary) cannot identify who the change was // sent to val changeIdentity: AbstractParty = if (anonymous) services.keyManagementService.freshKeyAndCert(ourIdentity, revocationEnabled).party.anonymise() else ourIdentity.party return OnLedgerAsset.generateSpend( tx, payments, acceptableCoins, changeIdentity, ::deriveState, Cash()::generateMoveCommand ) }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$"Issuer" to { state, text -&gt; state.resolveIssuer().value?.name?.organisation?.contains(text, true) == true }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$/** * Assemble the Issuer node. */ val treeItem = TreeItem(ViewerNode.IssuerNode(issuer.owningKey.toKnownParty().value ?: issuer, equivSumAmount, memberStates))</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$/** * Next we create subgroups based on currency. [memberStates] here is all states holding currency [currency] issued by [issuer] above. * Note that these states will not be displayed in the TreeTable, but rather in the side pane if the user clicks on the row. */ val currencyNodes = AggregatedList(memberStates, { it.state.data.amount.token.product }) { currency, groupedMemberStates -&gt; /** * We sum the states in the subgroup, to be displayed in the "Local Currency" column */ val amounts = groupedMemberStates.map { it.state.data.amount.withoutIssuer() } val sumAmount = amounts.foldObservable(Amount(0, currency), Amount&lt;Currency&gt;::plus) /** * We exchange the sum to the reporting currency, to be displayed in the "&lt;currency&gt; Equiv" column. */ val equivSumAmount = EasyBind.combine(sumAmount, reportingExchange) { sum, exchange -&gt; exchange.second(sum) } /** * Finally assemble the actual TreeTable Currency node. */ TreeItem(ViewerNode.CurrencyNode(sumAmount, equivSumAmount, groupedMemberStates)) }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$/** * Next we create subgroups based on currency. [memberStates] here is all states holding currency [currency] issued by [issuer] above. * Note that these states will not be displayed in the TreeTable, but rather in the side pane if the user clicks on the row. */ val currencyNodes = AggregatedList(memberStates, { it.state.data.amount.token.product }) { currency, groupedMemberStates -&gt; /** * We sum the states in the subgroup, to be displayed in the "Local Currency" column */ val amounts = groupedMemberStates.map { it.state.data.amount.withoutIssuer() } val sumAmount = amounts.foldObservable(Amount(0, currency), Amount&lt;Currency&gt;::plus) /** * We exchange the sum to the reporting currency, to be displayed in the "&lt;currency&gt; Equiv" column. */ val equivSumAmount = EasyBind.combine(sumAmount, reportingExchange) { sum, exchange -&gt; exchange.second(sum) } /** * Finally assemble the actual TreeTable Currency node. */ TreeItem(ViewerNode.CurrencyNode(sumAmount, equivSumAmount, groupedMemberStates)) } /** * Now that we have all nodes per currency, we sum the exchanged amounts, to be displayed in the * "&lt;currency&gt; Equiv" column, this time on the issuer level. */ val equivAmounts = currencyNodes.map { it.value.equivAmount }.flatten() val equivSumAmount = reportingCurrency.bind { currency -&gt; equivAmounts.foldObservable(Amount(0, currency), Amount&lt;Currency&gt;::plus) } /** * Assemble the Issuer node. */ val treeItem = TreeItem(ViewerNode.IssuerNode(issuer.owningKey.toKnownParty().value ?: issuer, equivSumAmount, memberStates)) /** * Bind the children in the TreeTable structure. * * TODO Perhaps we shouldn't do this here, but rather have a generic way of binding nodes to the treetable once. */ treeItem.isExpanded = true val children: List&lt;TreeItem&lt;out ViewerNode.IssuerNode&gt;&gt; = treeItem.children Bindings.bindContent(children, currencyNodes) treeItem</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$/** * This is where we aggregate the list of cash states into the TreeTable structure. */ val cashViewerIssueNodes: ObservableList&lt;TreeItem&lt;out ViewerNode.IssuerNode&gt;&gt; = /** * First we group the states based on the issuer. [memberStates] is all states holding currency issued by [issuer] */ AggregatedList(searchField.filteredData, { it.state.data.amount.token.issuer.party }) { issuer, memberStates -&gt; /** * Next we create subgroups based on currency. [memberStates] here is all states holding currency [currency] issued by [issuer] above. * Note that these states will not be displayed in the TreeTable, but rather in the side pane if the user clicks on the row. */ val currencyNodes = AggregatedList(memberStates, { it.state.data.amount.token.product }) { currency, groupedMemberStates -&gt; /** * We sum the states in the subgroup, to be displayed in the "Local Currency" column */ val amounts = groupedMemberStates.map { it.state.data.amount.withoutIssuer() } val sumAmount = amounts.foldObservable(Amount(0, currency), Amount&lt;Currency&gt;::plus) /** * We exchange the sum to the reporting currency, to be displayed in the "&lt;currency&gt; Equiv" column. */ val equivSumAmount = EasyBind.combine(sumAmount, reportingExchange) { sum, exchange -&gt; exchange.second(sum) } /** * Finally assemble the actual TreeTable Currency node. */ TreeItem(ViewerNode.CurrencyNode(sumAmount, equivSumAmount, groupedMemberStates)) } /** * Now that we have all nodes per currency, we sum the exchanged amounts, to be displayed in the * "&lt;currency&gt; Equiv" column, this time on the issuer level. */ val equivAmounts = currencyNodes.map { it.value.equivAmount }.flatten() val equivSumAmount = reportingCurrency.bind { currency -&gt; equivAmounts.foldObservable(Amount(0, currency), Amount&lt;Currency&gt;::plus) } /** * Assemble the Issuer node. */ val treeItem = TreeItem(ViewerNode.IssuerNode(issuer.owningKey.toKnownParty().value ?: issuer, equivSumAmount, memberStates)) /** * Bind the children in the TreeTable structure. * * TODO Perhaps we shouldn't do this here, but rather have a generic way of binding nodes to the treetable once. */ treeItem.isExpanded = true val children: List&lt;TreeItem&lt;out ViewerNode.IssuerNode&gt;&gt; = treeItem.children Bindings.bindContent(children, currencyNodes) treeItem }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$/** * We allow filtering by both issuer and currency. We do this by filtering by both at the same time and picking the * one which produces more results, which seems to work, as the set of currency strings don't really overlap with * issuer strings. */ val searchField = SearchField(cashStates, "Currency" to { state, text -&gt; state.state.data.amount.token.product.toString().contains(text, true) }, "Issuer" to { state, text -&gt; state.resolveIssuer().value?.name?.organisation?.contains(text, true) == true } )</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$/** * We exchange the sum to the reporting currency, to be displayed in the "&lt;currency&gt; Equiv" column. */ val equivSumAmount = EasyBind.combine(sumAmount, reportingExchange) { sum, exchange -&gt; exchange.second(sum) }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$AggregatedList</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$is ViewerNode.IssuerNode -&gt; SimpleStringProperty(node.issuer.nameOrNull()?.let { PartyNameFormatter.short.format(it) } ?: "Anonymous")</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$itemsProperty().bind(selectedNode.map { it?.states?.map { StateRow(LocalDateTime.now(), it) } ?: ObservableListWrapper(emptyList()) })</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$setCellValueFactory { val node = it.value.value when (node) { is ViewerNode.IssuerNode -&gt; null.lift() is ViewerNode.CurrencyNode -&gt; node.amount.map { it } } } cellFactory = currencyCellFactory /** * We must set this, otherwise on sort an exception will be thrown, as it will try to compare Amounts of differing currency */ isSortable = false</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer.CashWidget$if (lastTimeStamp != null &amp;&amp; currentTimeStamp - lastTimeStamp.toLong() &lt; 1.seconds.toMillis()) { data.safelyTransition { remove(size - 1, size) } }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer.CashWidget${ // If update arrived in very close succession to the previous one - kill the last point received to eliminate un-necessary noise on the graph. if (lastTimeStamp != null &amp;&amp; currentTimeStamp - lastTimeStamp.toLong() &lt; 1.seconds.toMillis()) { data.safelyTransition { remove(size - 1, size) } } // Add a new data point. data(currentTimeStamp, currAmount) // Limit population of data points to make graph painting faster. data.safelyTransition { if (size &gt; 300) remove(0, 1) } }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer.StateRowGraphic$issuerValueLabel.apply { tooltip(resolvedIssuer.nameOrNull()?.let { PartyNameFormatter.full.format(it) } ?: "Anonymous") }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer.StateRowGraphic$val resolvedIssuer: AbstractParty = stateRow.stateAndRef.resolveIssuer().value ?: stateRow.stateAndRef.state.data.amount.token.issuer.party</ID>
    <ID>MaxLineLength:CertPathSerializer.kt$CertPathSerializer$CustomSerializer.Proxy&lt;CertPath, CertPathSerializer.CertPathProxy&gt;(CertPath::class.java, CertPathProxy::class.java, factory)</ID>
    <ID>MaxLineLength:CertRole.kt$CertRole : ASN1Encodable</ID>
    <ID>MaxLineLength:CertRole.kt$CertRole$enum</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$assertFalse { confidentialCertRole.isValidParent(doormanCertRole) }</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$assertFalse { confidentialCertRole.isValidParent(nodeCACertRole) }</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$assertFalse { legalIDCertFromDoormanRole.isValidParent(tlsCertFromDoormanRole) }</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$assertFalse { tlsCertFromNodeCARole.isValidParent(legalIDCertFromNodeCARole) }</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$assertTrue { confidentialCertRole.isValidParent(legalIDCertFromNodeCARole) }</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$assertTrue { doormanCertRole.isValidParent(intermediateRootCertRole) }</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$assertTrue { legalIDCertFromDoormanRole.isValidParent(doormanCertRole) }</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val confidentialCert = X509Utilities.createCertificate(CertificateType.CONFIDENTIAL_LEGAL_IDENTITY, legalIDCertFromNodeCA, legalIDKeyPairFromNodeCA, nodeSubject, confidentialKeyPair.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val doormanCert = X509Utilities.createCertificate(CertificateType.INTERMEDIATE_CA, intermediateRootCert, intermediateRootKeyPair, doormanSubject, doormanKeyPair.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val intermediateRootCert = X509Utilities.createCertificate(CertificateType.ROOT_CA, rootCert, rootKeyPair, intermediateRootSubject, intermediateRootKeyPair.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val legalIDCertFromDoorman = X509Utilities.createCertificate(CertificateType.LEGAL_IDENTITY, doormanCert, doormanKeyPair, nodeSubject, legalIDKeyPairFromDoorman.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val legalIDCertFromNodeCA = X509Utilities.createCertificate(CertificateType.LEGAL_IDENTITY, nodeCACert, nodeCAKeyPair, nodeSubject, legalIDKeyPairFromNodeCA.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val nodeCACert = X509Utilities.createCertificate(CertificateType.NODE_CA, doormanCert, doormanKeyPair, nodeSubject, nodeCAKeyPair.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val tlsCertFromDoorman = X509Utilities.createCertificate(CertificateType.TLS, doormanCert, doormanKeyPair, nodeSubject, tlsKeyPairFromDoorman.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val tlsCertFromNodeCA = X509Utilities.createCertificate(CertificateType.TLS, nodeCACert, nodeCAKeyPair, nodeSubject, tlsKeyPairFromNodeCA.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests${ // Testing for various certificate hierarchies (with or without NodeCA). // ROOT -&gt; Intermediate Root -&gt; Doorman -&gt; NodeCA -&gt; Legal Identity cert -&gt; Confidential key cert // -&gt; NodeCA -&gt; TLS // -&gt; Legal Identity cert -&gt; Confidential key cert // -&gt; TLS val rootSubject = X500Principal("CN=Root,O=R3 Ltd,L=London,C=GB") val intermediateRootSubject = X500Principal("CN=Intermediate Root,O=R3 Ltd,L=London,C=GB") val doormanSubject = X500Principal("CN=Doorman,O=R3 Ltd,L=London,C=GB") val nodeSubject = X500Principal("CN=Node,O=R3 Ltd,L=London,C=GB") val rootKeyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val rootCert = X509Utilities.createSelfSignedCACertificate(rootSubject, rootKeyPair) val rootCertRole = CertRole.extract(rootCert) val intermediateRootKeyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) // Note that [CertificateType.ROOT_CA] is used for both root and intermediate root. val intermediateRootCert = X509Utilities.createCertificate(CertificateType.ROOT_CA, rootCert, rootKeyPair, intermediateRootSubject, intermediateRootKeyPair.public) val intermediateRootCertRole = CertRole.extract(intermediateRootCert) val doormanKeyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) // Note that [CertificateType.INTERMEDIATE_CA] has actually role = CertRole.DOORMAN_CA, see [CertificateType] in [X509Utilities]. val doormanCert = X509Utilities.createCertificate(CertificateType.INTERMEDIATE_CA, intermediateRootCert, intermediateRootKeyPair, doormanSubject, doormanKeyPair.public) val doormanCertRole = CertRole.extract(doormanCert)!! val nodeCAKeyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val nodeCACert = X509Utilities.createCertificate(CertificateType.NODE_CA, doormanCert, doormanKeyPair, nodeSubject, nodeCAKeyPair.public) val nodeCACertRole = CertRole.extract(nodeCACert)!! val tlsKeyPairFromNodeCA = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val tlsCertFromNodeCA = X509Utilities.createCertificate(CertificateType.TLS, nodeCACert, nodeCAKeyPair, nodeSubject, tlsKeyPairFromNodeCA.public) val tlsCertFromNodeCARole = CertRole.extract(tlsCertFromNodeCA)!! val tlsKeyPairFromDoorman = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val tlsCertFromDoorman = X509Utilities.createCertificate(CertificateType.TLS, doormanCert, doormanKeyPair, nodeSubject, tlsKeyPairFromDoorman.public) val tlsCertFromDoormanRole = CertRole.extract(tlsCertFromDoorman)!! val legalIDKeyPairFromNodeCA = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val legalIDCertFromNodeCA = X509Utilities.createCertificate(CertificateType.LEGAL_IDENTITY, nodeCACert, nodeCAKeyPair, nodeSubject, legalIDKeyPairFromNodeCA.public) val legalIDCertFromNodeCARole = CertRole.extract(legalIDCertFromNodeCA)!! val legalIDKeyPairFromDoorman = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val legalIDCertFromDoorman = X509Utilities.createCertificate(CertificateType.LEGAL_IDENTITY, doormanCert, doormanKeyPair, nodeSubject, legalIDKeyPairFromDoorman.public) val legalIDCertFromDoormanRole = CertRole.extract(legalIDCertFromDoorman)!! val confidentialKeyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val confidentialCert = X509Utilities.createCertificate(CertificateType.CONFIDENTIAL_LEGAL_IDENTITY, legalIDCertFromNodeCA, legalIDKeyPairFromNodeCA, nodeSubject, confidentialKeyPair.public) val confidentialCertRole = CertRole.extract(confidentialCert)!! assertNull(rootCertRole) assertNull(intermediateRootCertRole) assertEquals(tlsCertFromNodeCARole, tlsCertFromDoormanRole) assertEquals(legalIDCertFromNodeCARole, legalIDCertFromDoormanRole) assertTrue { doormanCertRole.isValidParent(intermediateRootCertRole) } // Doorman is signed by Intermediate Root. assertTrue { nodeCACertRole.isValidParent(doormanCertRole) } // NodeCA is signed by Doorman. assertTrue { tlsCertFromNodeCARole.isValidParent(nodeCACertRole) } // TLS is signed by NodeCA. assertTrue { tlsCertFromDoormanRole.isValidParent(doormanCertRole) } // TLS can also be signed by Doorman. assertTrue { legalIDCertFromNodeCARole.isValidParent(nodeCACertRole) } // Legal Identity is signed by NodeCA. assertTrue { legalIDCertFromDoormanRole.isValidParent(doormanCertRole) } // Legal Identity can also be signed by Doorman. assertTrue { confidentialCertRole.isValidParent(legalIDCertFromNodeCARole) } // Confidential key cert is signed by Legal Identity. assertFalse { legalIDCertFromDoormanRole.isValidParent(tlsCertFromDoormanRole) } // Legal Identity cannot be signed by TLS. assertFalse { tlsCertFromNodeCARole.isValidParent(legalIDCertFromNodeCARole) } // TLS cannot be signed by Legal Identity. assertFalse { confidentialCertRole.isValidParent(nodeCACertRole) } // Confidential key cert cannot be signed by NodeCA. assertFalse { confidentialCertRole.isValidParent(doormanCertRole) } // Confidential key cert cannot be signed by Doorman. }</ID>
    <ID>MaxLineLength:CertificateChainCheckPolicy.kt$CertificateChainCheckPolicy.UsernameMustMatchCommonNameCheck$if (!theirChain.any { certificate -&gt; CordaX500Name.parse(certificate.subjectDN.name).commonName == username }) { throw CertificateException("Client certificate does not match login username.") }</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$Pair(Date(System.currentTimeMillis() - 5.minutes.toMillis()), Date(System.currentTimeMillis() + 10.days.toMillis()))</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val (nodeCert, nodeKeys) = nodeKeyStore.query { getCertificateAndKeyPair(X509Utilities.CORDA_CLIENT_CA, nodeKeyStore.entryPassword) }</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val (tlsCert, tlsKeys) = sslKeyStore.query { getCertificateAndKeyPair(X509Utilities.CORDA_CLIENT_TLS, sslKeyStore.entryPassword) }</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val distPointName = DistributionPointName(GeneralNames(GeneralName(GeneralName.uniformResourceIdentifier, it)))</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val newNodeCert = replaceCrlDistPointCaCertificate(nodeCert, CertificateType.NODE_CA, INTERMEDIATE_CA.keyPair, nodeCaCrlDistPoint)</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val newTlsCert = replaceCrlDistPointCaCertificate(tlsCert, CertificateType.TLS, nodeKeys, tlsCrlDistPoint, X500Name.getInstance(ROOT_CA.certificate.subjectX500Principal.encoded))</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val nodeCert = (signingCertificateStore to p2pSslConfiguration).recreateNodeCaAndTlsCertificates(nodeCrlDistPoint, tlsCrlDistPoint)</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val nodeCertChain = listOf(newNodeCert, INTERMEDIATE_CA.certificate, *nodeKeyStore.query { getCertificateChain(X509Utilities.CORDA_CLIENT_CA) }.drop(2).toTypedArray())</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val sslCertChain = listOf(newTlsCert, newNodeCert, INTERMEDIATE_CA.certificate, *sslKeyStore.query { getCertificateChain(X509Utilities.CORDA_CLIENT_TLS) }.drop(3).toTypedArray())</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.Companion$builder.addCRLEntry(it, Date(System.currentTimeMillis() - 10.minutes.toMillis()), ReasonFlags.certificateHold)</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.Companion$val builder = JcaX509v2CRLBuilder(caCertificate.subjectX500Principal, Date(System.currentTimeMillis() - 1.minutes.toMillis()))</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.Companion$val issuingDistPoint = IssuingDistributionPoint(DistributionPointName(GeneralNames(issuingDistPointName)), indirect, false)</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.Companion$val signer = JcaContentSignerBuilder(signatureAlgorithm).setProvider(Crypto.findProvider("BC")).build(caPrivateKey)</ID>
    <ID>MaxLineLength:CertificateStore.kt$CertificateStore$ operator fun get(alias: String): X509Certificate</ID>
    <ID>MaxLineLength:CertificateStore.kt$CertificateStore.Companion$( storeResourceName: String, password: String, entryPassword: String, classLoader: ClassLoader = Thread.currentThread().contextClassLoader )</ID>
    <ID>MaxLineLength:CertificateStore.kt$CertificateStore.Companion$fun fromFile(storePath: Path, password: String, entryPassword: String, createNew: Boolean): CertificateStore</ID>
    <ID>MaxLineLength:CertificateStore.kt$CertificateStore.Companion$fun fromInputStream(stream: InputStream, password: String, entryPassword: String): CertificateStore</ID>
    <ID>MaxLineLength:CertificateStore.kt$CertificateStore.Companion$fun of(store: X509KeyStore, password: String, entryPassword: String): CertificateStore</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$return withCertificatesDirectory(baseDirectory / certificatesDirectoryName, keyStoreFileName, keyStorePassword, keyPassword, trustStoreFileName, trustStorePassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$val keyStore = FileBasedCertificateStoreSupplier(certificatesDirectory / keyStoreFileName, keyStorePassword, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$val trustStore = FileBasedCertificateStoreSupplier(certificatesDirectory / trustStoreFileName, trustStorePassword, trustStoreKeyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.KeyStore.Companion$return FileBasedCertificateStoreSupplier(baseDirectory / certificatesDirectoryName / certificateStoreFileName, password, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.KeyStore.Companion$return FileBasedCertificateStoreSupplier(certificatesDirectory / certificateStoreFileName, password, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.TrustStore.Companion$return FileBasedCertificateStoreSupplier(baseDirectory / certificatesDirectoryName / certificateStoreFileName, password, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.TrustStore.Companion$return FileBasedCertificateStoreSupplier(certificatesDirectory / certificateStoreFileName, password, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.Signing.Companion$return FileBasedCertificateStoreSupplier(baseDirectory / certificatesDirectoryName / certificateStoreFileName, password, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.Signing.Companion$return FileBasedCertificateStoreSupplier(certificatesDirectory / certificateStoreFileName, password, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreSupplier.kt$FileBasedCertificateStoreSupplier : CertificateStoreSupplier</ID>
    <ID>MaxLineLength:CheatingSecurityProvider.kt$CheatingSecurityProvider : ProviderAutoCloseable</ID>
    <ID>MaxLineLength:CheatingSecurityProvider.kt$CheatingSecurityProvider.CheatingSecureRandomService$Provider.Service(provider, "SecureRandom", "CheatingPRNG", CheatingSecureRandomSpi::javaClass.name, null, null)</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointAgent.Companion$println("Running Checkpoint agent with following arguments: instrumentClassname=$instrumentClassname, instrumentType=$instrumentType, minimumSize=$minimumSize, maximumSize=$maximumSize, graphDepth=$graphDepth, printOnce=$printOnce\n")</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook : ClassFileTransformer</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$builder.append("${statsTree.className} (hash:${statsTree.value?.hashCode()}) (count:${identityInfo.refCount})")</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$if (parameterTypeNames == listOf("com.esotericsoftware.kryo.Kryo", "com.esotericsoftware.kryo.io.Input", "java.lang.Class")) { if (method.isEmpty) continue log.debug { "Instrumenting on read: ${clazz.name}" } method.insertBefore("$hookClassName.${this::readEnter.name}($2, $3);") method.insertAfter("$hookClassName.${this::readExit.name}($2, $3, (java.lang.Object)\$_);") return clazz } else if (parameterTypeNames == listOf("com.esotericsoftware.kryo.io.Input", "java.lang.Object")) { if (method.isEmpty) continue log.debug { "Instrumenting on field read: ${clazz.name}" } method.insertBefore("$hookClassName.${this::readFieldEnter.name}((java.lang.Object)this);") method.insertAfter("$hookClassName.${this::readFieldExit.name}($2, (java.lang.Object)this);") return clazz }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$if (parameterTypeNames == listOf("com.esotericsoftware.kryo.Kryo", "com.esotericsoftware.kryo.io.Output", "java.lang.Object")) { if (method.isEmpty) continue log.debug { "Instrumenting on write: ${clazz.name}" } method.insertBefore("$hookClassName.${this::writeEnter.name}($2, $3);") method.insertAfter("$hookClassName.${this::writeExit.name}($2, $3);") return clazz }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$log.debug { "readFieldExit basic type value: ${that.field.name}:${that.field.type} = ${arrayValue ?: value}" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$log.debug { "writeEnter: adding event for clazz: ${obj.javaClass.name} (strandId: ${Strand.currentStrand().id})" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$log.debug { "writeExit: clazz[${obj.javaClass.name}], strandId[${Strand.currentStrand().id}], eventCount[$count]" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$log.debug { "writeExit: clearing event for clazz: ${obj.javaClass.name} (strandId: ${Strand.currentStrand().id})" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$fun readTree(events: List&lt;StatsEvent&gt;, index: Int, idMap: IdentityHashMap&lt;Any, IdentityInfo&gt; = IdentityHashMap()): Pair&lt;Int, IdentityInfo&gt;</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$fun readTrees(events: List&lt;StatsEvent&gt;, index: Int, idMap: IdentityHashMap&lt;Any, IdentityInfo&gt;): Pair&lt;Int, List&lt;Pair&lt;StatsInfo, IdentityInfo&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$log.debug { "Skipping repeated StatsEvent.Enter: ${exit.value} (hashcode:${exit.value!!.hashCode()}) (count:${idMap[exit.value]?.refCount})" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$log.debug { "Skipping repeated StatsEvent.Exit: ${event.value} (hashcode:${event.value!!.hashCode()}) (count:${idMap[event.value]?.refCount})" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$log.debug { "Skipping repeated StatsEvent.ObjectField: ${event.value} (hashcode:${event.value!!.hashCode()}) (count:${idMap[event.value]?.refCount})" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$trees += StatsInfo(event.fieldName, event.fieldType) to IdentityInfo(StatsTree.BasicType(event.fieldValue), 1)</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper$is WaitForStateConsumption -&gt; SuspendedOn(waitForStateConsumption = (operation as WaitForStateConsumption).stateRefs)</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper$it.secondsSpentWaiting = TimeUnit.MILLISECONDS.toSeconds(Duration.between(suspendedTimestamp, now).toMillis())</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper$serialisedCheckpoint.checkpointDeserialize(context = checkpointSerializationContext)</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper$val file = baseDirectory / NodeStartup.LOGS_DIRECTORY_NAME / "checkpoints_dump-${TIME_FORMATTER.format(now)}.zip"</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper${ // Poke into Quasar's stack and find the object references to the sub-flows so that we can correctly get the current progress // step for each sub-call. val stackObjects = fiber.getQuasarStack() subFlowStack.map { it.toJson(stackObjects) } }</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper.AttachmentSerializer$override fun serialize(value: Attachment, gen: JsonGenerator, serializers: SerializerProvider)</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper.CheckpointDumperBeanModifier$it.type.isTypeOrSubTypeOf(ProgressTracker::class.java) || it.name == "_stateMachine" || it.name == "deprecatedPartySessionMap"</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper.CheckpointDumperBeanModifier${ // Do not serialise node singletons // TODO This will cause the singleton to appear as an empty object. Ideally we don't want it to appear at all but this will // have to do for now. beanProperties.clear() }</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper.FlowLogicMixin$@JsonAutoDetect(getterVisibility = Visibility.NONE, isGetterVisibility = Visibility.NONE, fieldVisibility = Visibility.ANY)</ID>
    <ID>MaxLineLength:CheckpointDumperTest.kt$CheckpointDumperTest$val checkpoint = Checkpoint.create(InvocationContext.shell(), FlowStart.Explicit, logic.javaClass, frozenLogic, myself.identity.party, SubFlowVersion.CoreFlow(version), false) .getOrThrow()</ID>
    <ID>MaxLineLength:CheckpointSerializationAPI.kt$CheckpointSerializationContext$/** * A whitelist that determines (mostly for security purposes) whether a particular encoding may be used when deserializing. */ val encodingWhitelist: EncodingWhitelist</ID>
    <ID>MaxLineLength:CheckpointSerializationScheme.kt$CheckpointSerializationContextImpl$override fun withEncodingWhitelist(encodingWhitelist: EncodingWhitelist)</ID>
    <ID>MaxLineLength:CheckpointSerializationTestHelpers.kt$CheckpointSerializationEnvironmentRule.Companion$Executors.newCachedThreadPool(testThreadFactory(true)) // Close enough to what InVMConnector makes normally.</ID>
    <ID>MaxLineLength:CheckpointSerializationTestHelpers.kt$CheckpointSerializationEnvironmentRule.Companion$InVMConnector::class.staticField&lt;ExecutorService&gt;("threadPoolExecutor").value</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException$SubFlowCoreVersionIncompatibleException : CheckpointIncompatibleException</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.CannotBeDeserialisedException$"Found checkpoint that cannot be deserialised using the current Corda version. Please revert to the previous version of Corda, "</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.CannotBeDeserialisedException$"drain your node (see https://docs.corda.net/upgrading-cordapps.html#flow-drains), and try again. Cause: ${e.message}"</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.CordappNotInstalledException$"Found checkpoint for CorDapp that is no longer installed. Specifically, could not find class $classNotFound. Please install the "</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.CordappNotInstalledException$"missing CorDapp, drain your node (see https://docs.corda.net/upgrading-cordapps.html#flow-drains), and try again."</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.FlowVersionIncompatibleException$"Found checkpoint for flow: $flowClass that is incompatible with the current installed version of ${cordapp.name}. "</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.SubFlowCoreVersionIncompatibleException$"Found checkpoint for flow: $flowClass that is incompatible with the current Corda platform. Please revert to the previous "</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.SubFlowCoreVersionIncompatibleException$"version of Corda (version $oldVersion), drain your node (see https://docs.corda.net/upgrading-cordapps.html#flow-drains), and try again."</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointVerifier$throw CheckpointIncompatibleException.FlowVersionIncompatibleException(subFlow.flowClass, matchingCordapp, subFlowVersion.corDappHash)</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointVerifier$throw CheckpointIncompatibleException.SubFlowCoreVersionIncompatibleException(subFlow.flowClass, subFlowVersion.platformVersion)</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointVerifier${ // If we don't then see if the flow exists in any of the CorDapps so that we can give the user a more useful error message val matchingCordapp = currentCordappsByHash.values.find { subFlow.flowClass in it.allFlows } if (matchingCordapp != null) { throw CheckpointIncompatibleException.FlowVersionIncompatibleException(subFlow.flowClass, matchingCordapp, subFlowVersion.corDappHash) } else { throw CheckpointIncompatibleException.CordappNotInstalledException(subFlow.flowClass.name) } }</ID>
    <ID>MaxLineLength:ChosenList.kt$ChosenList&lt;E&gt; : ObservableListBase</ID>
    <ID>MaxLineLength:ClassCarpenter.kt$ClassCarpenterImpl$/** Returns a snapshot of the currently loaded classes as a map of full class name (package names+dots) -&gt; class object */ val loaded: Map&lt;String, Class&lt;*&gt;&gt; = HashMap(_loaded)</ID>
    <ID>MaxLineLength:ClassCarpenter.kt$ClassCarpenterImpl$if (fieldNameFromItf.isEmpty() &amp;&amp; SimpleFieldAccess::class.java in schema.interfaces) continue@methodLoop</ID>
    <ID>MaxLineLength:ClassCarpenter.kt$ClassCarpenterImpl$visitMethodInsn(INVOKEVIRTUAL, toStringHelper, "add", "(L$jlString;${field.type})L$toStringHelper;", false)</ID>
    <ID>MaxLineLength:ClassCarpenter.kt$InterfaceMismatchMissingAMQPFieldException$"Interface ${clazz.name} requires a field named $field but that isn't found in the schema or any superclass schemas"</ID>
    <ID>MaxLineLength:ClassCarpenterTest.kt$ClassCarpenterTest$ @Test fun `superclasses with double-size primitive constructor parameters`()</ID>
    <ID>MaxLineLength:ClassCarpenterTestUtils.kt$AmqpCarpenterBase$properties = properties.mapValues { (_, property) -&gt; property.copy(type = property.type.rename(from, to)) }</ID>
    <ID>MaxLineLength:ClassCarpenterTestUtils.kt$AmqpCarpenterBase$protected</ID>
    <ID>MaxLineLength:ClassCarpentingTypeLoaderTests.kt$ClassCarpentingTypeLoaderTests$is TypeIdentifier.Unparameterised -&gt; RemoteTypeInformation.Unparameterised(typeIdentifier.prettyPrint(), typeIdentifier)</ID>
    <ID>MaxLineLength:ClassGraphUtils.kt$ fun ClassGraph.pooledScan(): ScanResult</ID>
    <ID>MaxLineLength:ClassLoadingUtils.kt$ @StubOutForDJVM fun &lt;T : Any&gt; createInstancesOfClassesImplementing(classloader: ClassLoader, clazz: Class&lt;T&gt;): Set&lt;T&gt;</ID>
    <ID>MaxLineLength:ClassLoadingUtilsTest.kt$ClassLoadingUtilsTest$val classes = createInstancesOfClassesImplementing(BaseInterface::class.java.classLoader, BaseInterface2::class.java)</ID>
    <ID>MaxLineLength:ClassLoadingUtilsTest.kt$ClassLoadingUtilsTest$val classes = createInstancesOfClassesImplementing(BaseInterface::class.java.classLoader, BaseInterface::class.java)</ID>
    <ID>MaxLineLength:ClassWhitelists.kt$AbstractMutableClassWhitelist${ /** * There are certain delegates like [net.corda.serialization.internal.AllButBlacklisted] * which may throw when asked whether the type is listed. * In such situations - it may be a good idea to ask [delegate] first before making a check against own [whitelist]. */ return delegate.hasListed(type) || (type.name in whitelist) }</ID>
    <ID>MaxLineLength:ClassWhitelists.kt$TransientClassWhiteList : AbstractMutableClassWhitelist</ID>
    <ID>MaxLineLength:ClearNetworkCacheCli.kt$ClearNetworkCacheCli : NodeCliCommand</ID>
    <ID>MaxLineLength:ClientCacheFactory.kt$ClientCacheFactory$override</ID>
    <ID>MaxLineLength:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$assertEquals("Quote by Mark Twain: Clothes make the man. Naked people have little or no influence on society.", clientQuotes.take())</ID>
    <ID>MaxLineLength:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$assertEquals("Quote by Mark Twain: I have never let my schooling interfere with my education.", clientQuotes.take())</ID>
    <ID>MaxLineLength:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$assertEquals("Quote by Oscar Wilde: Always forgive your enemies - nothing annoys them so much.", clientQuotes.take())</ID>
    <ID>MaxLineLength:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$assertThat(clientQuotes.take()).isEqualTo("Quote by Mark Twain: I have never let my schooling interfere with my education.")</ID>
    <ID>MaxLineLength:ClientRelevantException.kt$ClientRelevantException : CordaRuntimeExceptionClientRelevantError</ID>
    <ID>MaxLineLength:ClientRpcSslOptions.kt$ClientRpcSslOptions</ID>
    <ID>MaxLineLength:ClientRpcTutorial.kt$PrintOrVisualise</ID>
    <ID>MaxLineLength:ClientRpcTutorial.kt$driver</ID>
    <ID>MaxLineLength:ClientRpcTutorial.kt$val (transactions: List&lt;SignedTransaction&gt;, futureTransactions: Observable&lt;SignedTransaction&gt;) = proxy.internalVerifiedTransactionsFeed()</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertFalse(NodeSchedulerService.awaitWithDeadline(stoppedClock, stoppedClock.instant()), "Should have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertFalse(NodeSchedulerService.awaitWithDeadline(stoppedClock, stoppedClock.instant(), future), "Should have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertFalse(NodeSchedulerService.awaitWithDeadline(stoppedClock, stoppedClock.instant().minus(1.hours)), "Should have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertFalse(NodeSchedulerService.awaitWithDeadline(stoppedClock, stoppedClock.instant().minus(1.hours), future), "Should have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertFalse(NodeSchedulerService.awaitWithDeadline(testClock, advancedClock.instant()), "Should have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertFalse(NodeSchedulerService.awaitWithDeadline(testClock, advancedClock.instant(), future), "Should have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertTrue(NodeSchedulerService.awaitWithDeadline(stoppedClock, advancedClock.instant(), future), "Should not have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertTrue(NodeSchedulerService.awaitWithDeadline(testClock, advancedClock.instant(), future), "Should not have reached deadline")</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow : FlowLogic</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow$else -&gt; throw IllegalArgumentException("Signatures can only be collected from Party or AnonymousParty, not $destination")</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow$require(it.value.size == 1) { "There are multiple sessions initiated for party key ${it.key.toStringShort()}" }</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow$val wellKnownParty = checkNotNull(keyToSigningParty[it]) { "Could not find a session or wellKnown party for key ${it.toStringShort()}" }</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow${ // setOfAllSessionKeys has already checked for valid destination types so we can safely cast to AnonoymousParty here. // This session was not initiated by a wellKnownParty so must directly exist in the unsigned. (it.destination as AnonymousParty).owningKey in unsigned }</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$SignTransactionFlow${ progressTracker.currentStep = RECEIVING // Receive transaction and resolve dependencies, check sufficient signatures is disabled as we don't have all signatures. val stx = subFlow(ReceiveTransactionFlow(otherSideSession, checkSufficientSignatures = false)) // Receive the signing key that the party requesting the signature expects us to sign with. Having this provided // means we only have to check we own that one key, rather than matching all keys in the transaction against all // keys we own. val signingKeys = otherSideSession.receive&lt;List&lt;PublicKey&gt;&gt;().unwrap { keys -&gt; // TODO: We should have a faster way of verifying we own a single key serviceHub.keyManagementService.filterMyKeys(keys) } progressTracker.currentStep = VERIFYING // Check that the Responder actually needs to sign. checkMySignaturesRequired(stx, signingKeys) // Check the signatures which have already been provided. Usually the Initiators and possibly an Oracle's. checkSignatures(stx) stx.tx.toLedgerTransaction(serviceHub).verify() // Perform some custom verification over the transaction. try { checkTransaction(stx) } catch (e: Exception) { if (e is IllegalStateException || e is IllegalArgumentException || e is AssertionError) throw FlowException(e) else throw e } // Sign and send back our signature to the Initiator. progressTracker.currentStep = SIGNING val mySignatures = signingKeys.map { key -&gt; serviceHub.createSignature(stx, key) } otherSideSession.send(mySignatures) // Return the additionally signed transaction. return stx + mySignatures }</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$AnonymousSessionTestFlow$val sessionsToCollectFrom = cis.filter { it.name != ourIdentity.name }.map { initiateFlow(AnonymousParty(it.owningKey)) }</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests$val future = aliceNode.startFlow(MixAndMatchAnonymousSessionTestFlow(owners, keysToLookup.toSet(), keysToKeepAnonymous.toSet())) .resultFuture</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests$val keysToLookup = listOf(bConfidentialIdentity1.owningKey, bConfidentialIdentity2.owningKey, cConfidentialIdentity1.owningKey)</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests$val owners = listOf(aConfidentialIdentity1, bConfidentialIdentity1, bConfidentialIdentity2, cConfidentialIdentity1)</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests.Companion$private val classMockNet = InternalMockNetwork(cordappsForAllNodes = listOf(DUMMY_CONTRACTS_CORDAPP, enclosedCordapp()))</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests.Companion$private val miniCorpServices = MockServices(listOf("net.corda.testing.contracts"), miniCorp, rigorousMock&lt;IdentityService&gt;())</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests.TestFlow$Initiator : FlowLogic</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests.TestFlow.Initiator$val builder = TransactionBuilder(notary).withItems(StateAndContract(state, DummyContract.PROGRAM_ID), command)</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests.TestFlow.Initiator$val sessions = excludeHostNode(serviceHub, groupAbstractPartyByWellKnownParty(serviceHub, state.owners)).map { initiateFlow(it.key) }</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$MixAndMatchAnonymousSessionTestFlow$val resolvedParties = keysToLookUp.map { serviceHub.identityService.wellKnownPartyFromAnonymous(AnonymousParty(it))!! }.toSet()</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer : AMQPSerializer</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer$private val typeNotation: TypeNotation = RestrictedType(AMQPTypeIdentifiers.nameForType(declaredType), null, emptyList(), "list", Descriptor(typeDescriptor), emptyList())</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer.Companion$ fun resolveDeclared(declaredTypeInformation: LocalTypeInformation.ACollection): LocalTypeInformation.ACollection</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer.Companion$fun resolveActual(actualClass: Class&lt;*&gt;, declaredTypeInformation: LocalTypeInformation.ACollection): LocalTypeInformation.ACollection</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer.Companion$is TypeIdentifier.Parameterised -&gt; erasedInformation.withElementType(declaredTypeInformation.elementType)</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer.Companion$private</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer.Companion$private val supportedTypeIdentifiers = supportedTypes.keys.asSequence().map { TypeIdentifier.forClass(it) }.toSet()</ID>
    <ID>MaxLineLength:CommandLineCompatibilityCheckerTest.kt$CommandLineCompatibilityCheckerTest$val breaks = CommandLineCompatibilityChecker().checkBackwardsCompatibility(CommandLine(Dummy()), CommandLine(Dummy2()))</ID>
    <ID>MaxLineLength:CommandLineCompatibilityCheckerTest.kt$CommandLineCompatibilityCheckerTest$val breaks = CommandLineCompatibilityChecker().checkBackwardsCompatibility(CommandLine(value1), CommandLine(value2))</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$?:</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$EnumOptionsChangedError(it.key + " on command ${old.commandName} previously accepted: $oldEnums, and now is missing $toPrint}")</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$PositionalArgumentsChangedError("Positional Parameter [ ${it.parameterName} ] has been removed from subcommand: ${old.commandName}")</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkAllCommandsArePresent(old: List&lt;CommandDescription&gt;, new: List&lt;CommandDescription&gt;): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkAllOptionsArePresent(old: CommandDescription, new: CommandDescription): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkAllParamsAreOfTheSameType(old: CommandDescription, new: CommandDescription): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkAllPositionalCharactersArePresent(old: CommandDescription, new: CommandDescription): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkBackwardsCompatibility(old: CommandLine, new: CommandLine): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkCommandLineIsBackwardsCompatible(commandLineToCheck: Class&lt;*&gt;): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$private</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$return objectMapper.readValue&lt;List&lt;CommandDescription&gt;&gt;(inputStream, object : TypeReference&lt;List&lt;CommandDescription&gt;&gt;() {})</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$val potentiallyChanged = oldAcceptableTypes.filter { newAcceptableTypes[it.key] != null &amp;&amp; newAcceptableTypes[it.key]!!.toSet() != it.value.toSet() }</ID>
    <ID>MaxLineLength:CommandLineInterface.kt$CommandLineInterface$"${instance.reachableAddress} {ssh:${instance.portMapping[Constants.NODE_SSHD_PORT]}, "</ID>
    <ID>MaxLineLength:CommandLineInterface.kt$CommandLineInterface$NetworkBuilder.instance() .withBasedir(baseDir) .withNetworkName(networkName) .onNodeBuild { builtNode -&gt; println("Built node: ${builtNode.name} to image: ${builtNode.localImageId}") }</ID>
    <ID>MaxLineLength:CommandLineInterface.kt$CommandLineInterface$NetworkBuilder.instance() .withBasedir(baseDir) .withNetworkName(networkName) .onNodeBuild { builtNode -&gt; println("Built node: ${builtNode.name} to image: ${builtNode.localImageId}") } .onNodePushed { pushedNode -&gt; println("Pushed node: ${pushedNode.name} to: ${pushedNode.remoteImageName}") }</ID>
    <ID>MaxLineLength:CommandLineInterface.kt$CommandLineInterface$nodeAdder.addNode(context, Constants.ALPHA_NUMERIC_ONLY_REGEX.replace(it.key.toLowerCase(), ""), CordaX500Name.parse(it.value))</ID>
    <ID>MaxLineLength:CommandParsers.kt$CliParser$@Option(names = ["--add"], split = ":", description = ["The node to add. Format is &lt;Name&gt;:&lt;X500&gt;. Eg; \"Node1:O=Bank A, L=New York, C=US, OU=Org Unit, CN=Service Name\""])</ID>
    <ID>MaxLineLength:CommandParsers.kt$CliParser$@Option(names = ["-b", "--backend"], description = ["The backend to use when instantiating nodes. Valid values: LOCAL_DOCKER and AZURE."])</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper : Contract</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper$"the transaction is signed by the owner of the CP" using (input.owner.owningKey in command.signers)</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper$val time = timeWindow?.fromTime ?: throw IllegalArgumentException("Redemptions must have a time-window")</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper.Commands$Issue : TypeOnlyCommandDataCommands</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper.State$// Although kotlin is smart enough not to need these, as we are using the ICommercialPaperState, we need to declare them explicitly for use later, override fun withOwner(newOwner: AbstractParty): ICommercialPaperState</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper.State$override fun toString()</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper.State$override fun withFaceValue(newFaceValue: Amount&lt;Issued&lt;Currency&gt;&gt;): ICommercialPaperState</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper.State$override fun withMaturityDate(newMaturityDate: Instant): ICommercialPaperState</ID>
    <ID>MaxLineLength:CommercialPaperIssueFlow.kt$CommercialPaperIssueFlow$constructor(amount: Amount&lt;Currency&gt;, issueRef: OpaqueBytes, recipient: Party, notary: Party) : this(amount, issueRef, recipient, notary, tracker())</ID>
    <ID>MaxLineLength:CommercialPaperIssueFlow.kt$CommercialPaperIssueFlow$val tx = CommercialPaperUtils.generateIssue(ourIdentity.ref(issueRef), amount `issued by` ourIdentity.ref(issueRef), Instant.now() + 10.days, notary)</ID>
    <ID>MaxLineLength:CommercialPaperSchemaV1.kt$CommercialPaperSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:CommercialPaperSchemaV1.kt$CommercialPaperSchemaV1.PersistentCommercialPaperState$@Table(name = "cp_states", indexes = [Index(name = "ccy_code_index", columnList = "ccy_code"), Index(name = "maturity_index", columnList = "maturity_instant"), Index(name = "face_value_index", columnList = "face_value")])</ID>
    <ID>MaxLineLength:CommercialPaperTests.kt$CommercialPaperTestsGeneric$CashUtils.generateSpend(aliceServices, builder, 9000.DOLLARS, alice.identity, AnonymousParty(megaCorp.publicKey))</ID>
    <ID>MaxLineLength:CommercialPaperTests.kt$CommercialPaperTestsGeneric$CommercialPaperUtils.generateRedeem(builder, moveTX.tx.outRef(1), megaCorpServices, megaCorpServices.myInfo.singleIdentityAndCert())</ID>
    <ID>MaxLineLength:CommercialPaperTests.kt$CommercialPaperTestsGeneric$VaultFiller(aliceServices, dummyNotary).fillWithSomeTestCash(9000.DOLLARS, issuerServices, 1, dummyCashIssuer.ref(1))</ID>
    <ID>MaxLineLength:CommercialPaperTests.kt$CommercialPaperTestsGeneric$VaultFiller(megaCorpServices, dummyNotary).fillWithSomeTestCash(13000.DOLLARS, issuerServices, 1, dummyCashIssuer.ref(1))</ID>
    <ID>MaxLineLength:CommercialPaperTests.kt$CommercialPaperTestsGeneric$aliceServices.recordTransactions(bigCorpCash.states.map { megaCorpServices.validatedTransactions.getTransaction(it.ref.txhash)!! })</ID>
    <ID>MaxLineLength:CommercialPaperTests.kt$CommercialPaperTestsGeneric$megaCorpServices.recordTransactions(aliceCash.states.map { aliceServices.validatedTransactions.getTransaction(it.ref.txhash)!! })</ID>
    <ID>MaxLineLength:CommercialPaperTests.kt$CommercialPaperTestsGeneric$output(thisTest.getContract(), "alice's paper", "paper".output&lt;ICommercialPaperState&gt;().withOwner(alice.party))</ID>
    <ID>MaxLineLength:CommercialPaperTests.kt$CommercialPaperTestsGeneric$val issueBuilder = CommercialPaperUtils.generateIssue(issuance, faceValue, TEST_TX_TIME + 30.days, dummyNotary.party)</ID>
    <ID>MaxLineLength:CommercialPaperTests.kt$CommercialPaperTestsGeneric.&lt;no name provided&gt;$override fun loadState(stateRef: StateRef): TransactionState&lt;*&gt;</ID>
    <ID>MaxLineLength:CommercialPaperUtils.kt$CommercialPaperUtils$CashUtils.generateSpend(services, tx, paper.state.data.faceValue.withoutIssuer(), ourIdentity, paper.state.data.owner)</ID>
    <ID>MaxLineLength:CommonSerializationTestHelpers.kt$fun &lt;T&gt; SerializationEnvironment.asContextEnv(inheritable: Boolean = false, callable: (SerializationEnvironment) -&gt; T): T</ID>
    <ID>MaxLineLength:CompatibilityTest.kt$CompatibilityTest$reserialized.types.firstOrNull { it.name == originalType.name } ?: fail("""Schema mismatch between original and re-serialized data. Could not find reserialized schema matching: $originalType """)</ID>
    <ID>MaxLineLength:CompatibilityTest.kt$CompatibilityTest$val (serializedBytes, schema) = output.serializeAndReturnSchema(transaction, SerializationDefaults.STORAGE_CONTEXT)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$ComponentGroup(SIGNERS_GROUP.ordinal, twoCommandsforKey1.map { it.signers.serialize() }.subList(0, 1))</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$allCommandsNoKey1Ftx.checkCommandVisibility(DUMMY_KEY_1.public)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(1, ftxInputs.filteredComponentGroups.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(1, ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(1, ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(1, ftxOneInput.filteredComponentGroups.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(3, ftxCompatible.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(3, ftxCompatible.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(3, ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(3, ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionA, WireTransaction(componentGroups = shuffledComponentGroupsA, privacySalt = privacySalt))</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionA.accessGroupMerkleRoots()[NOTARY_GROUP.ordinal], wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[NOTARY_GROUP.ordinal])</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionA.accessGroupMerkleRoots()[OUTPUTS_GROUP.ordinal], wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[OUTPUTS_GROUP.ordinal])</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionA.merkleTree.hash, MerkleTree.getMerkleTree(wireTransactionA.accessGroupHashes()).hash)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionCompatibleA.availableComponentGroups, wireTransactionA.availableComponentGroups)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionCompatibleA.componentGroups.map { it.groupIndex }.max()!!, ftxCompatibleNoInputs.groupHashes.size - 1)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionCompatibleA.componentGroups.size - 1, ftxCompatibleNoInputs.filteredComponentGroups.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertFails { ftxConstructor.call(key1CommandsFtx.id, updatedFilteredComponentsNoSignersKey1SamePMT, key1CommandsFtx.groupHashes) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertFailsWith&lt;ComponentVisibilityException&gt; { ftxNoLastCommandAndSigners.checkCommandVisibility(DUMMY_KEY_1.public) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertFailsWith&lt;ComponentVisibilityException&gt; { noCommandsFtx.checkAllComponentsVisible(SIGNERS_GROUP) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertFailsWith&lt;IllegalStateException&gt; { WireTransaction(componentGroups = componentGroupsCompatible, privacySalt = PrivacySalt()) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertFailsWith&lt;IllegalStateException&gt; { WireTransaction(componentGroups = componentGroupsLessSigners, privacySalt = PrivacySalt()) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertNotEquals(wireTransactionA.accessGroupMerkleRoots()[INPUTS_GROUP.ordinal], wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[INPUTS_GROUP.ordinal])</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertNotEquals(wireTransactionCompatibleA, wireTransactionA)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertNotNull(ftxCompatible.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertNotNull(ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertNotNull(ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$is Command&lt;*&gt; -&gt; elem.signers.size == 1</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$key1CommandsFtx.checkAllComponentsVisible(SIGNERS_GROUP)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$key1CommandsFtx.filteredComponentGroups[1].partialMerkleTree</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$oneKey1CommandFtxA.checkAllComponentsVisible(SIGNERS_GROUP)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$oneKey1CommandFtxB.checkAllComponentsVisible(SIGNERS_GROUP)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$private val attachmentGroup by lazy { ComponentGroup(ATTACHMENTS_GROUP.ordinal, attachments.map { it.serialize() }) } // The list is empty.</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$private val newUnknownComponentGroup = ComponentGroup(100, listOf(OpaqueBytes(secureRandomBytes(4)), OpaqueBytes(secureRandomBytes(8))))</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$private val wireTransactionA by lazy { WireTransaction(componentGroups = componentGroupsA, privacySalt = privacySalt) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val alterSignerComponents = signerComponents.subList(0, 2) + signerComponents[1] // Third one is removed and the 2nd command is added twice.</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val alterSignersHashes = wtx.accessAvailableComponentHashes()[ComponentGroupEnum.SIGNERS_GROUP.ordinal]!!.subList(0, 2) + componentHash(key1CommandsFtx.filteredComponentGroups[1].nonces[2], alterSignerComponents[2])</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val attachments = ComponentGroup(ATTACHMENTS_GROUP.ordinal, listOf(paramsHash.serialize())) // Same hash as network parameters</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxAlterSigner = ftxConstructor.call(key1CommandsFtx.id, alterFilteredComponents, key1CommandsFtx.groupHashes)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxAlterSignerB = ftxConstructor.call(key1CommandsFtx.id, alterFilteredComponents, key1CommandsFtx.groupHashes.subList(0, 6) + alterMTree.hash)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxCompatibleAll = wireTransactionCompatibleA.buildFilteredTransaction(Predicate { true }) // All filtered, including the unknown component.</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxNoLastCommandAndSigners = ftxConstructor.call(key1CommandsFtx.id, updatedFilteredComponentsNoLastCommandAndSigners, key1CommandsFtx.groupHashes)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxNoLastSigner = ftxConstructor.call(key2CommandsFtx.id, updatedFilteredComponentsNoSignersKey2SamePMT, key2CommandsFtx.groupHashes)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxNoLastSignerB = ftxConstructor.call(key2CommandsFtx.id, updatedFilteredComponentsNoSignersKey2, key2CommandsFtx.groupHashes)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxOneInput = wireTransactionA.buildFilteredTransaction(Predicate(::filteringOneInput)) // First input only filtered.</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val groups = createComponentGroups(inputs, outputs, commands, attachments, notary, timeWindow, emptyList(), null)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val twoCommandsforKey1 = listOf(dummyCommand(DUMMY_KEY_1.public, DUMMY_KEY_2.public), dummyCommand(DUMMY_KEY_2.public), dummyCommand(DUMMY_KEY_1.public))</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val updatedFilteredComponentsNoSignersKey1SamePMT = listOf(key1CommandsFtx.filteredComponentGroups[0], noLastSignerGroupSamePartialTree)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val updatedFilteredComponentsNoSignersKey2 = listOf(key2CommandsFtx.filteredComponentGroups[0], noLastSignerGroup)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val updatedFilteredComponentsNoSignersKey2SamePMT = listOf(key2CommandsFtx.filteredComponentGroups[0], noLastSignerGroupSamePartialTree)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val wireTransaction1ShuffledInputs = WireTransaction(componentGroups = componentGroupsB, privacySalt = privacySalt)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val wireTransactionOtherPrivacySalt = WireTransaction(componentGroups = componentGroupsA, privacySalt = PrivacySalt())</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests${ // Filter out all of the components. val ftxNothing = wireTransactionA.buildFilteredTransaction(Predicate { false }) // Nothing filtered. // Although nothing filtered, we still receive the group hashes for the top level Merkle tree. // Note that attachments are not sent, but group hashes include the allOnesHash flag for the attachment group hash; that's why we expect +1 group hashes. assertEquals(wireTransactionA.componentGroups.size + 1, ftxNothing.groupHashes.size) ftxNothing.verify() // Include all of the components. val ftxAll = wireTransactionA.buildFilteredTransaction(Predicate { true }) // All filtered. ftxAll.verify() ftxAll.checkAllComponentsVisible(INPUTS_GROUP) ftxAll.checkAllComponentsVisible(OUTPUTS_GROUP) ftxAll.checkAllComponentsVisible(COMMANDS_GROUP) ftxAll.checkAllComponentsVisible(ATTACHMENTS_GROUP) ftxAll.checkAllComponentsVisible(NOTARY_GROUP) ftxAll.checkAllComponentsVisible(TIMEWINDOW_GROUP) ftxAll.checkAllComponentsVisible(SIGNERS_GROUP) ftxAll.checkAllComponentsVisible(PARAMETERS_GROUP) // Filter inputs only. fun filtering(elem: Any): Boolean { return when (elem) { is StateRef -&gt; true else -&gt; false } } val ftxInputs = wireTransactionA.buildFilteredTransaction(Predicate(::filtering)) // Inputs only filtered. ftxInputs.verify() ftxInputs.checkAllComponentsVisible(INPUTS_GROUP) assertEquals(1, ftxInputs.filteredComponentGroups.size) // We only add component groups that are not empty, thus in this case: the inputs only. assertEquals(3, ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size) // All 3 inputs are present. assertEquals(3, ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size) // And their corresponding nonces. assertNotNull(ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree) // And the Merkle tree. // Filter one input only. fun filteringOneInput(elem: Any) = elem == inputs[0] val ftxOneInput = wireTransactionA.buildFilteredTransaction(Predicate(::filteringOneInput)) // First input only filtered. ftxOneInput.verify() assertFailsWith&lt;ComponentVisibilityException&gt; { ftxOneInput.checkAllComponentsVisible(INPUTS_GROUP) } assertEquals(1, ftxOneInput.filteredComponentGroups.size) // We only add component groups that are not empty, thus in this case: the inputs only. assertEquals(1, ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size) // 1 input is present. assertEquals(1, ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size) // And its corresponding nonce. assertNotNull(ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree) // And the Merkle tree. // The old client (receiving more component types than expected) is still compatible. val componentGroupsCompatibleA = listOf( inputGroup, outputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup, newUnknownComponentGroup // A new unknown component with ordinal 100 that we cannot process. ) val wireTransactionCompatibleA = WireTransaction(componentGroupsCompatibleA, privacySalt) val ftxCompatible = wireTransactionCompatibleA.buildFilteredTransaction(Predicate(::filtering)) ftxCompatible.verify() assertEquals(ftxInputs.inputs, ftxCompatible.inputs) assertEquals(wireTransactionCompatibleA.id, ftxCompatible.id) assertEquals(1, ftxCompatible.filteredComponentGroups.size) assertEquals(3, ftxCompatible.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size) assertEquals(3, ftxCompatible.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size) assertNotNull(ftxCompatible.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree) assertNull(wireTransactionCompatibleA.networkParametersHash) assertNull(ftxCompatible.networkParametersHash) // Now, let's allow everything, including the new component type that we cannot process. val ftxCompatibleAll = wireTransactionCompatibleA.buildFilteredTransaction(Predicate { true }) // All filtered, including the unknown component. ftxCompatibleAll.verify() assertEquals(wireTransactionCompatibleA.id, ftxCompatibleAll.id) // Check we received the last element that we cannot process (backwards compatibility). assertEquals(wireTransactionCompatibleA.componentGroups.size, ftxCompatibleAll.filteredComponentGroups.size) // Hide one component group only. // Filter inputs only. fun filterOutInputs(elem: Any): Boolean { return when (elem) { is StateRef -&gt; false else -&gt; true } } val ftxCompatibleNoInputs = wireTransactionCompatibleA.buildFilteredTransaction(Predicate(::filterOutInputs)) ftxCompatibleNoInputs.verify() assertFailsWith&lt;ComponentVisibilityException&gt; { ftxCompatibleNoInputs.checkAllComponentsVisible(INPUTS_GROUP) } assertEquals(wireTransactionCompatibleA.componentGroups.size - 1, ftxCompatibleNoInputs.filteredComponentGroups.size) assertEquals(wireTransactionCompatibleA.componentGroups.map { it.groupIndex }.max()!!, ftxCompatibleNoInputs.groupHashes.size - 1) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests${ // Merkle tree computation is deterministic if the same salt and ordering are used. val wireTransactionB = WireTransaction(componentGroups = componentGroupsA, privacySalt = privacySalt) assertEquals(wireTransactionA, wireTransactionB) // Merkle tree computation will change if privacy salt changes. val wireTransactionOtherPrivacySalt = WireTransaction(componentGroups = componentGroupsA, privacySalt = PrivacySalt()) assertNotEquals(wireTransactionA, wireTransactionOtherPrivacySalt) // Full Merkle root is computed from the list of Merkle roots of each component group. assertEquals(wireTransactionA.merkleTree.hash, MerkleTree.getMerkleTree(wireTransactionA.accessGroupHashes()).hash) // Trying to add an empty component group (not allowed), e.g. the empty attachmentGroup. val componentGroupsEmptyAttachment = listOf( inputGroup, outputGroup, commandGroup, attachmentGroup, notaryGroup, timeWindowGroup, signersGroup ) assertFails { WireTransaction(componentGroups = componentGroupsEmptyAttachment, privacySalt = privacySalt) } // Ordering inside a component group matters. val inputsShuffled = listOf(stateRef2, stateRef1, stateRef3) val inputShuffledGroup = ComponentGroup(INPUTS_GROUP.ordinal, inputsShuffled.map { it -&gt; it.serialize() }) val componentGroupsB = listOf( inputShuffledGroup, outputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup ) val wireTransaction1ShuffledInputs = WireTransaction(componentGroups = componentGroupsB, privacySalt = privacySalt) // The ID has changed due to change of the internal ordering in inputs. assertNotEquals(wireTransaction1ShuffledInputs, wireTransactionA) // Inputs group Merkle roots are not equal. assertNotEquals(wireTransactionA.accessGroupMerkleRoots()[INPUTS_GROUP.ordinal], wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[INPUTS_GROUP.ordinal]) // But outputs group Merkle leaf (and the rest) remained the same. assertEquals(wireTransactionA.accessGroupMerkleRoots()[OUTPUTS_GROUP.ordinal], wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[OUTPUTS_GROUP.ordinal]) assertEquals(wireTransactionA.accessGroupMerkleRoots()[NOTARY_GROUP.ordinal], wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[NOTARY_GROUP.ordinal]) assertNull(wireTransactionA.accessGroupMerkleRoots()[ATTACHMENTS_GROUP.ordinal]) assertNull(wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[ATTACHMENTS_GROUP.ordinal]) // Group leaves (components) ordering does not affect the id. In this case, we added outputs group before inputs. val shuffledComponentGroupsA = listOf( outputGroup, inputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup ) assertEquals(wireTransactionA, WireTransaction(componentGroups = shuffledComponentGroupsA, privacySalt = privacySalt)) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests${ // Required to call the private constructor. val ftxConstructor = FilteredTransaction::class.constructors.first() // 1st and 3rd commands require a signature from KEY_1. val twoCommandsforKey1 = listOf(dummyCommand(DUMMY_KEY_1.public, DUMMY_KEY_2.public), dummyCommand(DUMMY_KEY_2.public), dummyCommand(DUMMY_KEY_1.public)) val componentGroups = listOf( inputGroup, outputGroup, ComponentGroup(COMMANDS_GROUP.ordinal, twoCommandsforKey1.map { it.value.serialize() }), notaryGroup, timeWindowGroup, ComponentGroup(SIGNERS_GROUP.ordinal, twoCommandsforKey1.map { it.signers.serialize() }) ) val wtx = WireTransaction(componentGroups = componentGroups, privacySalt = PrivacySalt()) // Filter KEY_1 commands (commands 1 and 3). fun filterKEY1Commands(elem: Any): Boolean { return when (elem) { is Command&lt;*&gt; -&gt; DUMMY_KEY_1.public in elem.signers else -&gt; false } } // Filter KEY_2 commands (commands 1 and 2). fun filterKEY2Commands(elem: Any): Boolean { return when (elem) { is Command&lt;*&gt; -&gt; DUMMY_KEY_2.public in elem.signers else -&gt; false } } val key1CommandsFtx = wtx.buildFilteredTransaction(Predicate(::filterKEY1Commands)) val key2CommandsFtx = wtx.buildFilteredTransaction(Predicate(::filterKEY2Commands)) // val commandDataComponents = key1CommandsFtx.filteredComponentGroups[0].components val commandDataHashes = wtx.accessAvailableComponentHashes()[ComponentGroupEnum.COMMANDS_GROUP.ordinal]!! val noLastCommandDataPMT = PartialMerkleTree.build( MerkleTree.getMerkleTree(commandDataHashes), commandDataHashes.subList(0, 1) ) val noLastCommandDataComponents = key1CommandsFtx.filteredComponentGroups[0].components.subList(0, 1) val noLastCommandDataNonces = key1CommandsFtx.filteredComponentGroups[0].nonces.subList(0, 1) val noLastCommandDataGroup = FilteredComponentGroup( COMMANDS_GROUP.ordinal, noLastCommandDataComponents, noLastCommandDataNonces, noLastCommandDataPMT ) val signerComponents = key1CommandsFtx.filteredComponentGroups[1].components val signerHashes = wtx.accessAvailableComponentHashes()[ComponentGroupEnum.SIGNERS_GROUP.ordinal]!! val noLastSignerPMT = PartialMerkleTree.build( MerkleTree.getMerkleTree(signerHashes), signerHashes.subList(0, 2) ) val noLastSignerComponents = key1CommandsFtx.filteredComponentGroups[1].components.subList(0, 2) val noLastSignerNonces = key1CommandsFtx.filteredComponentGroups[1].nonces.subList(0, 2) val noLastSignerGroup = FilteredComponentGroup( SIGNERS_GROUP.ordinal, noLastSignerComponents, noLastSignerNonces, noLastSignerPMT ) val noLastSignerGroupSamePartialTree = FilteredComponentGroup( SIGNERS_GROUP.ordinal, noLastSignerComponents, noLastSignerNonces, key1CommandsFtx.filteredComponentGroups[1].partialMerkleTree) // We don't update that, so we can catch the index mismatch. val updatedFilteredComponentsNoSignersKey2 = listOf(key2CommandsFtx.filteredComponentGroups[0], noLastSignerGroup) val updatedFilteredComponentsNoSignersKey2SamePMT = listOf(key2CommandsFtx.filteredComponentGroups[0], noLastSignerGroupSamePartialTree) // There are only two components in key1CommandsFtx (commandData and signers). assertEquals(2, key1CommandsFtx.componentGroups.size) // Remove last signer for which there is a pointer from a visible commandData. This is the case of Key1. // This will result to an invalid transaction. // A command with no corresponding signer detected // because the pointer of CommandData (3rd leaf) cannot find a corresponding (3rd) signer. val updatedFilteredComponentsNoSignersKey1SamePMT = listOf(key1CommandsFtx.filteredComponentGroups[0], noLastSignerGroupSamePartialTree) assertFails { ftxConstructor.call(key1CommandsFtx.id, updatedFilteredComponentsNoSignersKey1SamePMT, key1CommandsFtx.groupHashes) } // Remove both last signer (KEY1) and related command. // Update partial Merkle tree for signers. val updatedFilteredComponentsNoLastCommandAndSigners = listOf(noLastCommandDataGroup, noLastSignerGroup) val ftxNoLastCommandAndSigners = ftxConstructor.call(key1CommandsFtx.id, updatedFilteredComponentsNoLastCommandAndSigners, key1CommandsFtx.groupHashes) // verify() will pass as the transaction is well-formed. ftxNoLastCommandAndSigners.verify() // checkCommandVisibility() will not pass, because checkAllComponentsVisible(ComponentGroupEnum.SIGNERS_GROUP) will fail. assertFailsWith&lt;ComponentVisibilityException&gt; { ftxNoLastCommandAndSigners.checkCommandVisibility(DUMMY_KEY_1.public) } // Remove last signer for which there is no pointer from a visible commandData. This is the case of Key2. // Do not change partial Merkle tree for signers. // This time the object can be constructed as there is no pointer mismatch. val ftxNoLastSigner = ftxConstructor.call(key2CommandsFtx.id, updatedFilteredComponentsNoSignersKey2SamePMT, key2CommandsFtx.groupHashes) // verify() will fail as we didn't change the partial Merkle tree. assertFailsWith&lt;FilteredTransactionVerificationException&gt; { ftxNoLastSigner.verify() } // checkCommandVisibility() will not pass. assertFailsWith&lt;ComponentVisibilityException&gt; { ftxNoLastSigner.checkCommandVisibility(DUMMY_KEY_2.public) } // Remove last signer for which there is no pointer from a visible commandData. This is the case of Key2. // Update partial Merkle tree for signers. val ftxNoLastSignerB = ftxConstructor.call(key2CommandsFtx.id, updatedFilteredComponentsNoSignersKey2, key2CommandsFtx.groupHashes) // verify() will pass, the transaction is well-formed. ftxNoLastSignerB.verify() // But, checkAllComponentsVisible() will not pass. assertFailsWith&lt;ComponentVisibilityException&gt; { ftxNoLastSignerB.checkCommandVisibility(DUMMY_KEY_2.public) } // Modify last signer (we have a pointer from commandData). // Update partial Merkle tree for signers. val alterSignerComponents = signerComponents.subList(0, 2) + signerComponents[1] // Third one is removed and the 2nd command is added twice. val alterSignersHashes = wtx.accessAvailableComponentHashes()[ComponentGroupEnum.SIGNERS_GROUP.ordinal]!!.subList(0, 2) + componentHash(key1CommandsFtx.filteredComponentGroups[1].nonces[2], alterSignerComponents[2]) val alterMTree = MerkleTree.getMerkleTree(alterSignersHashes) val alterSignerPMTK = PartialMerkleTree.build( alterMTree, alterSignersHashes ) val alterSignerGroup = FilteredComponentGroup( SIGNERS_GROUP.ordinal, alterSignerComponents, key1CommandsFtx.filteredComponentGroups[1].nonces, alterSignerPMTK ) val alterFilteredComponents = listOf(key1CommandsFtx.filteredComponentGroups[0], alterSignerGroup) // Do not update groupHashes. val ftxAlterSigner = ftxConstructor.call(key1CommandsFtx.id, alterFilteredComponents, key1CommandsFtx.groupHashes) // Visible components in signers group cannot be verified against their partial Merkle tree. assertFailsWith&lt;FilteredTransactionVerificationException&gt; { ftxAlterSigner.verify() } // Also, checkAllComponentsVisible() will not pass (groupHash matching will fail). assertFailsWith&lt;ComponentVisibilityException&gt; { ftxAlterSigner.checkCommandVisibility(DUMMY_KEY_1.public) } // Update groupHashes. val ftxAlterSignerB = ftxConstructor.call(key1CommandsFtx.id, alterFilteredComponents, key1CommandsFtx.groupHashes.subList(0, 6) + alterMTree.hash) // Visible components in signers group cannot be verified against their partial Merkle tree. assertFailsWith&lt;FilteredTransactionVerificationException&gt; { ftxAlterSignerB.verify() } // Also, checkAllComponentsVisible() will not pass (top level Merkle tree cannot be verified against transaction's id). assertFailsWith&lt;ComponentVisibilityException&gt; { ftxAlterSignerB.checkCommandVisibility(DUMMY_KEY_1.public) } }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests${ val groups = createComponentGroups(inputs, outputs, commands, attachments, notary, timeWindow, emptyList(), null) val wireTransactionOldConstructor = WireTransaction(groups, privacySalt) assertEquals(wireTransactionA, wireTransactionOldConstructor) // Malformed tx - attachments is not List&lt;SecureHash&gt;. For this example, we mistakenly added input-state (StateRef) serialised objects with ATTACHMENTS_GROUP.ordinal. val componentGroupsB = listOf( inputGroup, outputGroup, commandGroup, ComponentGroup(ATTACHMENTS_GROUP.ordinal, inputGroup.components), notaryGroup, timeWindowGroup, signersGroup ) assertFails { WireTransaction(componentGroupsB, privacySalt).attachments.toList() } // Malformed tx - duplicated component group detected. val componentGroupsDuplicatedCommands = listOf( inputGroup, outputGroup, commandGroup, // First commandsGroup. commandGroup, // Second commandsGroup. notaryGroup, timeWindowGroup, signersGroup ) assertFails { WireTransaction(componentGroupsDuplicatedCommands, privacySalt) } // Malformed tx - inputs is not a serialised object at all. val componentGroupsC = listOf( ComponentGroup(INPUTS_GROUP.ordinal, listOf(OpaqueBytes(ByteArray(8)))), outputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup ) assertFails { WireTransaction(componentGroupsC, privacySalt) } val componentGroupsCompatibleA = listOf( inputGroup, outputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup, newUnknownComponentGroup // A new unknown component with ordinal 100 that we cannot process. ) // The old client (receiving more component types than expected) is still compatible. val wireTransactionCompatibleA = WireTransaction(componentGroupsCompatibleA, privacySalt) assertEquals(wireTransactionCompatibleA.availableComponentGroups, wireTransactionA.availableComponentGroups) // The known components are the same. assertNotEquals(wireTransactionCompatibleA, wireTransactionA) // But obviously, its Merkle root has changed Vs wireTransactionA (which doesn't include this extra component). // The old client will throw if receiving an empty component (even if this is unknown). val componentGroupsCompatibleEmptyNew = listOf( inputGroup, outputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup, newUnknownComponentEmptyGroup // A new unknown component with ordinal 101 that we cannot process. ) assertFails { WireTransaction(componentGroupsCompatibleEmptyNew, privacySalt) } }</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$ComposableTypePropertySerializer.Companion$ fun make(name: String, propertyInformation: LocalPropertyInformation, factory: LocalSerializerFactory): PropertySerializer</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$ComposableTypePropertySerializer.Companion$ fun makeForEvolution(name: String, isCalculated: Boolean, typeIdentifier: TypeIdentifier, type: Type): PropertySerializer</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$ComposableTypePropertySerializer.Companion$PropertyReadStrategy.make(name, propertyInformation.type.typeIdentifier, propertyInformation.type.observedType)</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$DescribedTypeReadStrategy : PropertyReadStrategy</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$PropertyReader</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$PropertyReader.Companion$is LocalPropertyInformation.PrivateConstructorPairedProperty -&gt; FieldReader(propertyInformation.observedField)</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$PropertyWriteStrategy.Companion$ fun make(name: String, propertyInformation: LocalPropertyInformation, factory: LocalSerializerFactory): PropertyWriteStrategy</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey$ fun isFulfilledBy(keysToCheck: Iterable&lt;PublicKey&gt;): Boolean</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey$return SubjectPublicKeyInfo(AlgorithmIdentifier(CordaObjectIdentifier.COMPOSITE_KEY), DERSequence(keyVector)).encoded</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey.Builder$ fun build(threshold: Int? = null): PublicKey</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey.Builder$require(threshold == null || threshold == children.first().weight) { "Trying to build invalid CompositeKey, threshold value different than weight of single child node." }</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey.Builder$require(threshold == null || threshold &gt; 0) { "Threshold must not be specified or its value must be greater than zero" }</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey.Builder${ require(threshold == null || threshold == children.first().weight) { "Trying to build invalid CompositeKey, threshold value different than weight of single child node." } // Returning the only child node which is [PublicKey] itself. We need to avoid single-key [CompositeKey] instances, // as there are scenarios where developers expected the underlying key and its composite versions to be equivalent. children.first().node }</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey.NodeAndWeight$if (weight == other.weight) // TODO: this might be expensive, consider a faster deterministic compareTo implementation when weights are equal. node.encoded.sequence().compareTo(other.node.encoded.sequence()) else weight.compareTo(other.weight)</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$// By lazy is required so that the serialisers are configured before vals initialisation takes place (they internally invoke serialise). private val aliceSignature by lazy { aliceKey.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(alicePublicKey).schemeNumberID))) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$@Test() fun `composite key validation with graph cycle detection`()</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$assertFalse { engine.verify(CompositeSignaturesWithKeys(listOf(aliceSignature, brokenBobSignature)).serialize().bytes) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$assertTrue { engine.verify(CompositeSignaturesWithKeys(listOf(aliceSignature, bobSignature)).serialize().bytes) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$assertTrue { engine.verify(CompositeSignaturesWithKeys(listOf(aliceSignature, bobSignature, charlieSignature)).serialize().bytes) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$assertTrue { engine.verify(CompositeSignaturesWithKeys(listOf(aliceSignature, charlieSignature)).serialize().bytes) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$assertTrue { engine.verify(CompositeSignaturesWithKeys(listOf(bobSignature, charlieSignature)).serialize().bytes) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$private</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$private val bobSignature by lazy { bobKey.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(bobPublicKey).schemeNumberID))) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$private val charlieSignature by lazy { charlieKey.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(charliePublicKey).schemeNumberID))) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val EdSignature = keyPairEd.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairEd.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val K1Signature = keyPairK1.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairK1.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val R1Signature = keyPairR1.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairR1.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val RSASignature = keyPairRSA.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairRSA.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val SPSignature = keyPairSP.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairSP.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val brokenBobSignature = TransactionSignature(aliceSignature.bytes, bobSignature.by, SignatureMetadata(1, Crypto.findSignatureScheme(bobSignature.by).schemeNumberID))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val composite1 = CompositeKey.Builder().addKeys(pub1, pub2, pub3, pub4, pub5, pub6, pub7).build() as CompositeKey</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val composite2 = CompositeKey.Builder().addKeys(pub7, pub6, pub5, pub4, pub3, pub2, pub1).build() as CompositeKey</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val compositeKey = CompositeKey.Builder().addKeys(keyPairRSA.public, keyPairK1.public, keyPairR1.public, keyPairEd.public, keyPairSP.public).build() as CompositeKey</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val compositeKeyCert = X509Utilities.createCertificate(CertificateType.LEGAL_IDENTITY, ca, caKeyPair, caName, compositeKey)</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val twoOfThree = CompositeKey.Builder().addKeys(alicePublicKey, bobPublicKey, charliePublicKey).build(threshold = 2)</ID>
    <ID>MaxLineLength:CompositeMemberCompositeSchemaToClassCarpenterTests.kt$CompositeMembers$val mangledMap = envelope.typeInformation.values.find { it.typeIdentifier.name == "java.util.Map" }!!.mangle&lt;C&gt;()</ID>
    <ID>MaxLineLength:CompositeSignature.kt$CompositeSignature$throw InvalidKeyException("Composite signatures must be assembled independently from signatures provided by the component private keys")</ID>
    <ID>MaxLineLength:CompositeSignature.kt$CompositeSignature$throw SignatureException("Composite signatures must be assembled independently from signatures provided by the component private keys")</ID>
    <ID>MaxLineLength:CompositeSignature.kt$CompositeSignature.Companion$@JvmStatic fun getService(provider: Provider)</ID>
    <ID>MaxLineLength:CompositeSignaturesWithKeys.kt$CompositeSignaturesWithKeys</ID>
    <ID>MaxLineLength:ConcatenatedList.kt$ConcatenatedList$val permutedOffset = (if (permutedListIndex == 0) 0 else newSubNestedIndexOffsets[permutedListIndex - 1])</ID>
    <ID>MaxLineLength:ConcatenatedList.kt$ConcatenatedList${ // If a nested element is updated we simply propagate the update by offsetting the nested element index // by the startingOffsetOf the nested list. val listIndex = indexMap[wrapped]!!.first val startingOffset = startingOffsetOf(listIndex) for (i in change.from until change.to) { nextUpdate(startingOffset + i) } }</ID>
    <ID>MaxLineLength:ConcatenatedList.kt$ConcatenatedList&lt;A&gt; : TransformationList</ID>
    <ID>MaxLineLength:ConcatenatedListTest.kt$ConcatenatedListTest$sourceList = FXCollections.observableArrayList&lt;ObservableList&lt;String&gt;&gt;(FXCollections.observableArrayList("hello"))</ID>
    <ID>MaxLineLength:ConcurrencyUtils.kt$ fun &lt;V, W&gt; firstOf(vararg futures: CordaFuture&lt;out V&gt;, handler: (CordaFuture&lt;out V&gt;) -&gt; W)</ID>
    <ID>MaxLineLength:ConcurrencyUtils.kt$internal</ID>
    <ID>MaxLineLength:ConfigExporter.kt$ConfigExporter$fileWriter.write(configToWrite.root().render(ConfigRenderOptions.concise().setFormatted(true).setJson(false)))</ID>
    <ID>MaxLineLength:ConfigExporter.kt$ConfigExporter$ourParsedConfig = ourParsedConfig.withValue("keyStorePassword", testNetParsedConfig.getValue("keyStorePassword"))</ID>
    <ID>MaxLineLength:ConfigExporter.kt$ConfigExporter$ourParsedConfig = ourParsedConfig.withValue("trustStorePassword", testNetParsedConfig.getValue("trustStorePassword"))</ID>
    <ID>MaxLineLength:ConfigParsingTest.kt$ConfigParsingTest$assertThatThrownBy { configuration.parseAs&lt;TypedConfiguration&gt;() }</ID>
    <ID>MaxLineLength:ConfigParsingTest.kt$ConfigParsingTest$testPropertyType&lt;InstantData, InstantListData, Instant&gt;(Instant.now(), Instant.now().plusMillis(100), valuesToString = true)</ID>
    <ID>MaxLineLength:ConfigParsingTest.kt$ConfigParsingTest$testPropertyType&lt;LocalDateData, LocalDateListData, LocalDate&gt;(LocalDate.now(), LocalDate.now().plusDays(1), valuesToString = true)</ID>
    <ID>MaxLineLength:ConfigParsingTest.kt$ConfigParsingTest$testPropertyType&lt;URLData, URLListData, URL&gt;(URL("http://localhost:1234"), URL("http://localhost:1235"), valuesToString = true)</ID>
    <ID>MaxLineLength:ConfigParsingTest.kt$ConfigParsingTest$testPropertyType&lt;X500PrincipalData, X500PrincipalListData, X500Principal&gt;(X500Principal("C=US, L=New York, CN=Corda Root CA, OU=Corda, O=R3 HoldCo LLC"), X500Principal("O=Bank A,L=London,C=GB"), valuesToString = true)</ID>
    <ID>MaxLineLength:ConfigSections.kt$BFTSmartConfigSpec$return valid(BFTSmartConfig(configuration[replicaId], configuration[clusterAddresses], configuration[debug], configuration[exposeRaces]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$CertChainPolicyConfigSpec$@Suppress("DEPRECATION") internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$CertChainPolicyConfigSpec$return valid(CertChainPolicyConfig(configuration[role], configuration[policy], configuration[trustedAliases].toSet()))</ID>
    <ID>MaxLineLength:ConfigSections.kt$DatabaseConfigSpec$private val exportHibernateJMXStatistics by boolean().optional().withDefaultValue(DatabaseConfig.Defaults.exportHibernateJMXStatistics)</ID>
    <ID>MaxLineLength:ConfigSections.kt$DatabaseConfigSpec$private val initialiseAppSchema by enum(SchemaInitializationType::class).optional().withDefaultValue(DatabaseConfig.Defaults.initialiseAppSchema)</ID>
    <ID>MaxLineLength:ConfigSections.kt$DatabaseConfigSpec$private val mappedSchemaCacheSize by long().optional().withDefaultValue(DatabaseConfig.Defaults.mappedSchemaCacheSize)</ID>
    <ID>MaxLineLength:ConfigSections.kt$DatabaseConfigSpec$private val transactionIsolationLevel by enum(TransactionIsolationLevel::class).optional().withDefaultValue(DatabaseConfig.Defaults.transactionIsolationLevel)</ID>
    <ID>MaxLineLength:ConfigSections.kt$DatabaseConfigSpec$return valid(DatabaseConfig(configuration[initialiseSchema], configuration[initialiseAppSchema], configuration[transactionIsolationLevel], configuration[exportHibernateJMXStatistics], configuration[mappedSchemaCacheSize]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$DevModeOptionsSpec$private val allowCompatibilityZone by boolean().optional().withDefaultValue(DevModeOptions.Defaults.allowCompatibilityZone)</ID>
    <ID>MaxLineLength:ConfigSections.kt$DevModeOptionsSpec$private val disableCheckpointChecker by boolean().optional().withDefaultValue(DevModeOptions.Defaults.disableCheckpointChecker)</ID>
    <ID>MaxLineLength:ConfigSections.kt$FlowTimeoutConfigurationSpec$internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$FlowTimeoutConfigurationSpec$return valid(FlowTimeoutConfiguration(configuration[timeout], configuration[maxRestartCount], configuration[backoffBase]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$NetworkServicesConfigSpec$internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$NetworkServicesConfigSpec$return valid(NetworkServicesConfig(configuration[doormanURL], configuration[networkMapURL], configuration[pnm], configuration[inferred]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$NodeRpcSettingsSpec$return valid(NodeRpcSettings(configuration[address], configuration[adminAddress], configuration[standAloneBroker], configuration[useSsl], configuration[ssl]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$NotaryConfigSpec$private val etaMessageThresholdSeconds by int().optional().withDefaultValue(NotaryServiceFlow.defaultEstimatedWaitTime.seconds.toInt())</ID>
    <ID>MaxLineLength:ConfigSections.kt$NotaryConfigSpec$return valid(NotaryConfig(configuration[validating], configuration[serviceLegalName], configuration[className], configuration[etaMessageThresholdSeconds], configuration[extraConfig], configuration[raft], configuration[bftSMaRt]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$SSHDConfigurationSpec$override fun parseValid(configuration: Config): Valid&lt;SSHDConfiguration&gt;</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec$internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec$dataSource.type == AuthDataSourceType.INMEMORY &amp;&amp; options?.cache != null -&gt; badValue("no cache supported for \"INMEMORY\" data provider")</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.DataSourceSpec$else -&gt; valid(SecurityConfiguration.AuthService.DataSource(type, passwordEncryption, connection, users))</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.DataSourceSpec$private</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.DataSourceSpec$private val passwordEncryption by enum(PasswordEncryption::class).optional().withDefaultValue(SecurityConfiguration.AuthService.DataSource.Defaults.passwordEncryption)</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.DataSourceSpec$type == AuthDataSourceType.DB &amp;&amp; (users != null || connection == null) -&gt; badValue("\"DB\" data source type requires \"connection\" and cannot specify \"users\"")</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.DataSourceSpec$type == AuthDataSourceType.INMEMORY &amp;&amp; (users == null || connection != null) -&gt; badValue("\"INMEMORY\" data source type requires \"users\" and cannot specify \"connection\"")</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.OptionsSpec.CacheSpec$private</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.OptionsSpec.CacheSpec$private val expireAfterSecs by long().mapValid { value -&gt; if (value &gt;= 0) validValue(value) else badValue("cannot be less than 0'") }</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.OptionsSpec.CacheSpec$private val maxEntries by long().mapValid { value -&gt; if (value &gt;= 0) validValue(value) else badValue("cannot be less than 0'") }</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.OptionsSpec.CacheSpec$return valid(SecurityConfiguration.AuthService.Options.Cache(configuration[expireAfterSecs], configuration[maxEntries]))</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ // TODO Move this to KeyStoreConfigHelpers. fun NodeConfiguration.configureWithDevSSLCertificate(cryptoService: CryptoService? = null)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$// Problems: // - Forces you to have a primary constructor with all fields of name and type matching the configuration file structure. // - Encourages weak bean-like types. // - Cannot support a many-to-one relationship between configuration file structures and configuration domain type. This is essential for versioning of the configuration files. // - It's complicated and based on reflection, meaning problems with it are typically found at runtime. // - It doesn't support validation errors in a structured way. If something goes wrong, it throws exceptions, which doesn't support good usability practices like displaying all the errors at once. fun &lt;T : Any&gt; Config.parseAs( clazz: KClass&lt;T&gt;, onUnknownKeys: ((Set&lt;String&gt;, logger: Logger) -&gt; Unit) = UnknownConfigKeysPolicy.FAIL::handle, nestedPath: String? = null, baseDirectory: Path? = null ): T</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ConfigHelper$configOf( // Add substitution values here "baseDirectory" to baseDirectory.toString()) .withFallback(configOverrides) .withFallback(systemOverrides) .withFallback(environmentOverrides) .withFallback(appConfig) .withFallback(devModeConfig)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ConfigHelper$return ConfigFactory.parseMap(toProperties().filterKeys { (it as String).startsWith(CORDA_PROPERTY_PREFIX) }.mapKeys { (it.key as String).removePrefix(CORDA_PROPERTY_PREFIX) })</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ConfigHelper$val smartDevMode = CordaSystemUtils.isOsMac() || (CordaSystemUtils.isOsWindows() &amp;&amp; !CordaSystemUtils.getOsName().toLowerCase().contains("server"))</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ConfigHelper${ val parseOptions = ConfigParseOptions.defaults() val defaultConfig = ConfigFactory.parseResources("reference.conf", parseOptions.setAllowMissing(false)) val appConfig = ConfigFactory.parseFile(configFile.toFile(), parseOptions.setAllowMissing(allowMissingConfig)) // Detect the underlying OS. If mac or windows non-server then we assume we're running in devMode. Unless specified otherwise. val smartDevMode = CordaSystemUtils.isOsMac() || (CordaSystemUtils.isOsWindows() &amp;&amp; !CordaSystemUtils.getOsName().toLowerCase().contains("server")) val devModeConfig = ConfigFactory.parseMap(mapOf("devMode" to smartDevMode)) val systemOverrides = ConfigFactory.systemProperties().cordaEntriesOnly() val environmentOverrides = ConfigFactory.systemEnvironment().cordaEntriesOnly() val finalConfig = configOf( // Add substitution values here "baseDirectory" to baseDirectory.toString()) .withFallback(configOverrides) .withFallback(systemOverrides) .withFallback(environmentOverrides) .withFallback(appConfig) .withFallback(devModeConfig) // this needs to be after the appConfig, so it doesn't override the configured devMode .withFallback(defaultConfig) .resolve() val entrySet = finalConfig.entrySet().filter { entry -&gt; entry.key.contains("\"") } for ((key) in entrySet) { log.error("Config files should not contain \" in property names. Please fix: $key") } return finalConfig }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$UnknownConfigurationKeysException : IllegalArgumentException</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$UnknownConfigurationKeysException$require(unknownKeys.isNotEmpty()) { "Absence of unknown keys should not raise UnknownConfigurationKeysException." }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$UnknownConfigurationKeysException.Companion$fun of(offendingKeys: Set&lt;String&gt;): UnknownConfigurationKeysException</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$UnknownConfigurationKeysException.Companion$private fun message(offendingKeys: Set&lt;String&gt;)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$fun Any?.toConfigValue(): ConfigValue</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$getConfig(path).parseAs(typeClass, onUnknownKeys, nestedPath?.let { "$it.$path" } ?: path, baseDirectory = baseDirectory)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$private fun parseEnum(enumType: Class&lt;*&gt;, name: String): Enum&lt;*&gt;</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$require(clazz.isData) { "Only Kotlin data classes or class annotated with CustomConfigParser can be parsed. Offending: ${clazz.qualifiedName}" }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$return getValueInternal(metadata.name, metadata.returnType, UnknownConfigKeysPolicy.IGNORE::handle, nestedPath = null, baseDirectory = null)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$return uncheckedCast(if (type.arguments.isEmpty()) getSingleValue(path, type, onUnknownKeys, nestedPath, baseDirectory) else getCollectionValue(path, type, onUnknownKeys, nestedPath, baseDirectory))</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$setPrivateKey(it, serviceKeystore.getPrivateKey(it, DEV_CA_KEY_STORE_PASS), serviceKeystore.getCertificateChain(it), signingKeyStore.entryPassword)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$val elementClass = type.arguments[0].type?.jvmErasure ?: throw IllegalArgumentException("Cannot work with star projection: $type")</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$val signingKeyStore = FileBasedCertificateStoreSupplier(signingCertificateStore.path, signingCertificateStore.storePassword, signingCertificateStore.entryPassword).get(true) .also { it.installDevNodeCaCertPath(myLegalName) }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt${ // These types are supported by Config as use as is value }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt${ // These types make sense to be represented as Strings and the exact inverse parsing function for use in parseAs value.toString() }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt${ // if baseDirectory been specified try resolving path against it. Note if `pathFromConfig` is an absolute path - this instruction has no effect. baseDirectory.resolve(path) }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt${ val signingKeyStore = FileBasedCertificateStoreSupplier(signingCertificateStore.path, signingCertificateStore.storePassword, signingCertificateStore.entryPassword).get(true) .also { it.installDevNodeCaCertPath(myLegalName) } // Move distributed service composite key (generated by IdentityGenerator.generateToDisk) to keystore if exists. val distributedServiceKeystore = certificatesDirectory / "distributedService.jks" if (distributedServiceKeystore.exists()) { val serviceKeystore = X509KeyStore.fromFile(distributedServiceKeystore, DEV_CA_KEY_STORE_PASS) signingKeyStore.update { serviceKeystore.aliases().forEach { if (serviceKeystore.internal.isKeyEntry(it)) { setPrivateKey(it, serviceKeystore.getPrivateKey(it, DEV_CA_KEY_STORE_PASS), serviceKeystore.getCertificateChain(it), signingKeyStore.entryPassword) } else { setCertificate(it, serviceKeystore.getCertificate(it)) } } } } }</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Describer</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Schema : ValidatorDescriber</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Specification&lt;VALUE&gt; : SchemaParser</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Validator : Validator</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property$Definition&lt;TYPE&gt; : MetadataValidatorExtractorDescriberParser</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property$Metadata</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition$Single&lt;TYPE&gt; : Definition</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition$override</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun &lt;ENUM : Enum&lt;ENUM&gt;&gt; enum(key: String, enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean = false): Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun boolean(key: String, sensitive: Boolean = false): Standard&lt;Boolean&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun double(key: String, sensitive: Boolean = false): Standard&lt;Double&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun duration(key: String, sensitive: Boolean = false): Standard&lt;Duration&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun float(key: String, sensitive: Boolean = false): Standard&lt;Float&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun int(key: String, sensitive: Boolean = false): Standard&lt;Int&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun nestedObject(key: String, schema: Schema? = null, sensitive: Boolean = false): Standard&lt;ConfigObject&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun string(key: String, sensitive: Boolean = false): Standard&lt;String&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$invalid&lt;Float, Configuration.Validation.Error&gt;(Configuration.Validation.Error.BadValue.of(key, Float::class.javaObjectType.simpleName, "Provided value exceeds Float range."))</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$invalid&lt;Int, Configuration.Validation.Error&gt;(Configuration.Validation.Error.BadValue.of("Provided value exceeds Integer range [${Int.MIN_VALUE}, ${Int.MAX_VALUE}].", key, Int::class.javaObjectType.simpleName))</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.RequiredList$ fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; MAPPED): Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Standard$ fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (TYPE) -&gt; MAPPED): Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Standard$ fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (TYPE) -&gt; Validated&lt;MAPPED, Validation.Error&gt;): Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Schema.Companion$ fun withProperties( name: String? = null, builder: Property.Definition.Companion.() -&gt; Iterable&lt;Property.Definition&lt;*&gt;&gt; ): Schema</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Schema.Companion$ fun withProperties(name: String? = null, properties: Iterable&lt;Property.Definition&lt;*&gt;&gt;): Schema</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Schema.Companion$ fun withProperties(vararg properties: Property.Definition&lt;*&gt;, name: String? = null): Schema</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun &lt;ENUM : Enum&lt;ENUM&gt;&gt; enum(enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean = false): PropertyDelegate.Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun &lt;ENUM : Enum&lt;ENUM&gt;&gt; enum(key: String? = null, enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean = false): PropertyDelegate.Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun boolean(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Boolean&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun double(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Double&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun duration(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Duration&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun float(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Float&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun int(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Int&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun long(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Long&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun nestedObject(schema: Schema? = null, key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;ConfigObject&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun string(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;String&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ protected abstract fun parseValid(configuration: Config): Valid&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$abstract</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$final override fun parse(configuration: Config, options: Configuration.Validation.Options): Valid&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$BadValue : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$MissingValue : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$Unknown : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$UnsupportedVersion : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$WrongType : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$internal fun withContainingPathPrefix(vararg containingPath: String): Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadPath$override fun with(keyName: String, typeName: String): BadPath</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadPath$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadPath.Companion$( message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList() )</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadValue$override fun with(keyName: String, typeName: String): BadValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadValue$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadValue.Companion$( message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList() )</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MalformedStructure$override fun with(keyName: String, typeName: String): MalformedStructure</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MalformedStructure$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MalformedStructure.Companion$( message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList() )</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MissingValue$override fun with(keyName: String, typeName: String): MissingValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MissingValue$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MissingValue.Companion$( message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList() )</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MissingValue.Companion$fun forKey(keyName: String): MissingValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.Unknown$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.Unknown.Companion$fun of(keyName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): Unknown</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.UnsupportedVersion$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.WrongType$override fun with(keyName: String, typeName: String): WrongType</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.WrongType$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.WrongType.Companion$( message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList() )</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.WrongType.Companion$fun forKey(keyName: String, expectedTypeName: String, actualTypeName: String): WrongType</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value$Parser&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value.Extractor$ @Throws(ConfigException.Missing::class, ConfigException.WrongType::class, ConfigException.BadValue::class) fun valueIn(configuration: Config): TYPE</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value.Extractor$ @Throws(ConfigException.WrongType::class, ConfigException.BadValue::class) fun valueInOrNull(configuration: Config): TYPE?</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value.Parser$ fun parse( configuration: Config, options: Configuration.Validation.Options = Configuration.Validation.Options.defaults ): Valid&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Version.Extractor.Companion$ fun fromPath(versionPath: String, versionDefaultValue: Int = DEFAULT_VERSION_VALUE): Configuration.Version.Extractor</ID>
    <ID>MaxLineLength:ConnectionChange.kt$ConnectionChange$return "ConnectionChange remoteAddress: $remoteAddress connected state: $connected cert subject: ${remoteCert?.subjectDN} cert ok: ${!badCert}"</ID>
    <ID>MaxLineLength:ConnectionStateMachine.kt$ConnectionStateMachine$logDebugWithMDC { "Put tag ${javax.xml.bind.DatatypeConverter.printHexBinary(delivery.tag)} on wire uuid: ${nextMessage.applicationProperties["_AMQ_DUPL_ID"]}" }</ID>
    <ID>MaxLineLength:ConnectionStateMachine.kt$ConnectionStateMachine$logDebugWithMDC { "Sender delivery confirmed tag ${javax.xml.bind.DatatypeConverter.printHexBinary(delivery.tag)}" }</ID>
    <ID>MaxLineLength:ConnectionStateMachine.kt$ConnectionStateMachine$sender.send(messageBuf.array(), messageBuf.arrayOffset() + messageBuf.readerIndex(), messageBuf.readableBytes())</ID>
    <ID>MaxLineLength:ConnectionStateMachine.kt$ConnectionStateMachine$val pending = transport.pending() // Note this drives frame generation, which the susbsequent writes push to the socket</ID>
    <ID>MaxLineLength:Constants.kt$/** * constants in this file are generated by gradle * to change this file, edit src/main/template/kotlin/net/corda/common/logging/Constants.kt * the generated file does not need to be committed to source control (originally added to source control for ease of use) */ internal const val CURRENT_MAJOR_RELEASE = "4.3-SNAPSHOT"</ID>
    <ID>MaxLineLength:Constants.kt$/** * constants in this file are generated by gradle * to change this file, edit src/main/template/kotlin/net/corda/common/logging/Constants.kt * the generated file does not need to be committed to source control (originally added to source control for ease of use) */ internal const val CURRENT_MAJOR_RELEASE = "@corda_release_version@"</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Fail early in the TransactionBuilder when attempting to change the hash of the HashConstraint on the spending transaction`()</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `On contract annotated with NoConstraintPropagation there is no platform check for propagation, but the transaction builder can't use the AutomaticPlaceholderConstraint`()</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Switching from the WhitelistConstraint to the Signature Constraint fails if the signature constraint does not inherit all jar signatures`()</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Switching from the WhitelistConstraint to the Signature Constraint is possible if the attachment satisfies both constraints, and the signature constraint inherits all jar signatures`()</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `When the constraint of the output state is a valid transition from the input state, transaction validation works`()</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$SignableData(wireTransaction.id, SignatureMetadata(4, Crypto.findSignatureScheme(nodeKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFailsWith&lt;IllegalArgumentException&gt; { AutomaticPlaceholderConstraint.canBeTransitionedFrom(AutomaticPlaceholderConstraint, attachment) }</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(AlwaysAcceptAttachmentConstraint.canBeTransitionedFrom(HashAttachmentConstraint(SecureHash.randomSHA256()), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(AlwaysAcceptAttachmentConstraint.canBeTransitionedFrom(SignatureAttachmentConstraint(ALICE_PUBKEY), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(AlwaysAcceptAttachmentConstraint.canBeTransitionedFrom(WhitelistedByZoneAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(HashAttachmentConstraint(SecureHash.randomSHA256()).canBeTransitionedFrom(AlwaysAcceptAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(HashAttachmentConstraint(SecureHash.randomSHA256()).canBeTransitionedFrom(HashAttachmentConstraint(SecureHash.randomSHA256()), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(SignatureAttachmentConstraint(ALICE_PUBKEY).canBeTransitionedFrom(AlwaysAcceptAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(SignatureAttachmentConstraint(ALICE_PUBKEY).canBeTransitionedFrom(HashAttachmentConstraint(SecureHash.randomSHA256()), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(SignatureAttachmentConstraint(ALICE_PUBKEY).canBeTransitionedFrom(HashAttachmentConstraint(allOnesHash), attachmentSigned))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(SignatureAttachmentConstraint(BOB_PUBKEY).canBeTransitionedFrom(SignatureAttachmentConstraint(ALICE_PUBKEY), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(SignatureAttachmentConstraint(BOB_PUBKEY).canBeTransitionedFrom(WhitelistedByZoneAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(WhitelistedByZoneAttachmentConstraint.canBeTransitionedFrom(AlwaysAcceptAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(WhitelistedByZoneAttachmentConstraint.canBeTransitionedFrom(HashAttachmentConstraint(SecureHash.randomSHA256()), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(WhitelistedByZoneAttachmentConstraint.canBeTransitionedFrom(SignatureAttachmentConstraint(ALICE_PUBKEY), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertTrue(HashAttachmentConstraint(SecureHash.randomSHA256()).canBeTransitionedFrom(SignatureAttachmentConstraint(ALICE_PUBKEY), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertTrue(HashAttachmentConstraint(SecureHash.randomSHA256()).canBeTransitionedFrom(WhitelistedByZoneAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertTrue(SignatureAttachmentConstraint(ALICE_PUBKEY).canBeTransitionedFrom(SignatureAttachmentConstraint(ALICE_PUBKEY), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertTrue(SignatureAttachmentConstraint(ALICE_PUBKEY).canBeTransitionedFrom(WhitelistedByZoneAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertTrue(WhitelistedByZoneAttachmentConstraint.canBeTransitionedFrom(WhitelistedByZoneAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.allOnesHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "1"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.allOnesHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "2"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.allOnesHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "3"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.zeroHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "1"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.zeroHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "2"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.zeroHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "3"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$ledgerServices.attachments.importContractAttachment(cordapp.contractClassNames, "rpc", signedJarStream, null, listOf(jarAndSigner.second))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$ledgerServices.attachments.importContractAttachment(cordapp.contractClassNames, "rpc", unsignedJarStream, null)</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c1", DUMMY_NOTARY, null, HashAttachmentConstraint(allOnesHash), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c1", DUMMY_NOTARY, null, HashAttachmentConstraint(unsignedAttachmentId), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c1", DUMMY_NOTARY, null, HashAttachmentConstraint(zeroHash), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c1", DUMMY_NOTARY, null, SignatureAttachmentConstraint(hashToSignatureConstraintsKey), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c1", DUMMY_NOTARY, null, WhitelistedByZoneAttachmentConstraint, Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c2", DUMMY_NOTARY, null, HashAttachmentConstraint(allOnesHash), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c2", DUMMY_NOTARY, null, HashAttachmentConstraint(zeroHash), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c2", DUMMY_NOTARY, null, SignatureAttachmentConstraint(hashToSignatureConstraintsKey), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c2", DUMMY_NOTARY, null, SignatureAttachmentConstraint(hashToSignatureConstraintsKey), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c2", DUMMY_NOTARY, null, WhitelistedByZoneAttachmentConstraint, Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c3", DUMMY_NOTARY, null, SignatureAttachmentConstraint(ALICE_PUBKEY), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c3", DUMMY_NOTARY, null, SignatureAttachmentConstraint(hashToSignatureConstraintsKey), Cash.State(2000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c4", DUMMY_NOTARY, null, AlwaysAcceptAttachmentConstraint, Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "w1", DUMMY_NOTARY, null, WhitelistedByZoneAttachmentConstraint, Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "w2", DUMMY_NOTARY, null, SignatureAttachmentConstraint(ALICE_PUBKEY), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "w2", DUMMY_NOTARY, null, SignatureAttachmentConstraint(hashToSignatureConstraintsKey), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(noPropagationContractClassName, "c1", DUMMY_NOTARY, null, HashAttachmentConstraint(zeroHash), NoPropagationContractState())</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(noPropagationContractClassName, "c2", DUMMY_NOTARY, null, WhitelistedByZoneAttachmentConstraint, NoPropagationContractState())</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(noPropagationContractClassName, "c3", DUMMY_NOTARY, null, AutomaticPlaceholderConstraint, NoPropagationContractState())</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$val jarAndSigner = ContractJarTestUtils.signContractJar(cordapp.jarPath, copyFirst = true, keyStoreDir = keyStoreDir.path)</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests.&lt;no name provided&gt;$override fun loadContractAttachment(stateRef: StateRef)</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests.Companion$hashToSignatureConstraintsKey = keyStoreDir.path.generateKey("testAlias", "testPassword", ALICE_NAME.toString())</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$ fun AttachmentConstraint.canBeTransitionedFrom(input: AttachmentConstraint, attachment: ContractAttachment): Boolean</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$ internal fun ContractClassName.contractHasAutomaticConstraintPropagation(classLoader: ClassLoader? = null): Boolean</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$HashAttachmentConstraint.disableHashConstraints &amp;&amp; input is HashAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; true</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$input is AutomaticHashConstraint || output is AutomaticHashConstraint -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticHashConstraint.")</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$input is AutomaticPlaceholderConstraint || output is AutomaticPlaceholderConstraint -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticPlaceholderConstraint.")</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$log.warnOnce("Found state ${state.contract} that is constrained by the insecure: AlwaysAcceptAttachmentConstraint.")</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$require(state.constraint::class in validConstraints) { "Found state ${state.contract} with an illegal constraint: ${state.constraint}" }</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$val Attachment.contractVersion: Version get() = if (this is ContractAttachment) version else CordappImpl.DEFAULT_CORDAPP_VERSION</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$when { // These branches should not happen, as this has been already checked. input is AutomaticPlaceholderConstraint || output is AutomaticPlaceholderConstraint -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticPlaceholderConstraint.") input is AutomaticHashConstraint || output is AutomaticHashConstraint -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticHashConstraint.") // Transition to the same constraint. input == output -&gt; true // You can't transition from the AlwaysAcceptAttachmentConstraint to anything else, as it could hide something illegal. input is AlwaysAcceptAttachmentConstraint &amp;&amp; output !is AlwaysAcceptAttachmentConstraint -&gt; false // Nothing can be migrated from the HashConstraint except a HashConstraint with the same Hash. (This check is redundant, but added for clarity) input is HashAttachmentConstraint &amp;&amp; output is HashAttachmentConstraint -&gt; input == output // Anything (except the AlwaysAcceptAttachmentConstraint) can be transformed to a HashAttachmentConstraint. input !is HashAttachmentConstraint &amp;&amp; output is HashAttachmentConstraint -&gt; true // The SignatureAttachmentConstraint allows migration from a Signature constraint with the same key. // TODO - we don't support currently third party signers. When we do, the output key will have to be stronger then the input key. input is SignatureAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; input.key == output.key // HashAttachmentConstraint can be transformed to a SignatureAttachmentConstraint when hash constraint verification checking disabled. HashAttachmentConstraint.disableHashConstraints &amp;&amp; input is HashAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; true // You can transition from the WhitelistConstraint to the SignatureConstraint only if all signers of the JAR are required to sign in the future. input is WhitelistedByZoneAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; attachment.signerKeys.isNotEmpty() &amp;&amp; output.key.keys.containsAll(attachment.signerKeys) else -&gt; false }</ID>
    <ID>MaxLineLength:ContractAttachment.kt$ContractAttachment : Attachment</ID>
    <ID>MaxLineLength:ContractAttachment.kt$ContractAttachment$return "ContractAttachment(attachment=${attachment.id}, contracts='$allContracts', uploader='$uploader', signed='$isSigned', version='$version')"</ID>
    <ID>MaxLineLength:ContractAttachmentSerializer.kt$ContractAttachmentSerializer$return ContractAttachment.create(proxy.attachment, proxy.contract, proxy.contracts, proxy.uploader, proxy.signers, proxy.version)</ID>
    <ID>MaxLineLength:ContractAttachmentSerializer.kt$ContractAttachmentSerializer$return ContractAttachmentProxy(GeneratedAttachment(bytes, obj.uploader), obj.contract, obj.additionalContracts, obj.uploader, obj.signerKeys, obj.version)</ID>
    <ID>MaxLineLength:ContractAttachmentSerializerTest.kt$ContractAttachmentSerializerTest$val contractAttachment = ContractAttachment(GeneratedAttachment(EMPTY_BYTE_ARRAY, "test"), DummyContract.PROGRAM_ID)</ID>
    <ID>MaxLineLength:ContractFunctions.kt$swap(partyA, BigDecimal(notional * strike), domesticCurrency, partyB, BigDecimal(notional), foreignCurrency)</ID>
    <ID>MaxLineLength:ContractHierarchyTest.kt$ContractHierarchyTest$aliceNode.services.startFlow(PrepareTransaction(bob, notary, IndirectContract.State())).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ContractHierarchyTest.kt$ContractHierarchyTest$mockNet = InternalMockNetwork(networkSendManuallyPumped = false, threadPerNode = true, cordappsForAllNodes = listOf(enclosedCordapp()))</ID>
    <ID>MaxLineLength:ContractHierarchyTest.kt$ContractHierarchyTest.PrepareTransaction$val command = Command(IndirectContract.Create(), listOf(serviceHub.myInfo.singleIdentity().owningKey, otherSide.owningKey))</ID>
    <ID>MaxLineLength:ContractHierarchyTest.kt$ContractHierarchyTest.PrepareTransaction$val txB = TransactionBuilder(notary = notary, outputs = mutableListOf(txState), commands = mutableListOf(command))</ID>
    <ID>MaxLineLength:ContractJarTestUtils.kt$ContractJarTestUtils$@JvmOverloads fun makeTestSignedContractJar(workingDir: Path, contractName: String, version: Int = 1, versionSeed: Int = 0): Pair&lt;Path, PublicKey&gt;</ID>
    <ID>MaxLineLength:ContractJarTestUtils.kt$ContractJarTestUtils$private</ID>
    <ID>MaxLineLength:ContractJarTestUtils.kt$ContractJarTestUtils$val outFile = fileManager.getFileForInput(StandardLocation.CLASS_OUTPUT, packages.joinToString("."), "$className.class")</ID>
    <ID>MaxLineLength:ContractJarTestUtils.kt$ContractJarTestUtils$val source = object : SimpleJavaFileObject(URI.create("string:///${packages.joinToString("/")}/$className.java"), JavaFileObject.Kind.SOURCE) { override fun getCharContent(ignoreEncodingErrors: Boolean): CharSequence { return newClass } }</ID>
    <ID>MaxLineLength:ContractStateModel.kt$ContractStateModel$val cashStates: ObservableList&lt;StateAndRef&lt;Cash.State&gt;&gt; = cashStatesDiff.fold(FXCollections.observableArrayList()) { list: MutableList&lt;StateAndRef&lt;Cash.State&gt;&gt;, (added, removed) -&gt; list.removeIf { it in removed } list.addAll(added) }.distinctBy { it.ref }</ID>
    <ID>MaxLineLength:ContractUpgradeFlow.kt$ContractUpgradeFlow$Authorise : FlowLogic</ID>
    <ID>MaxLineLength:ContractUpgradeFlow.kt$ContractUpgradeFlow.Initiate$( originalState: StateAndRef&lt;OldState&gt;, newContractClass: Class&lt;out UpgradedContract&lt;OldState, NewState&gt;&gt; )</ID>
    <ID>MaxLineLength:ContractUpgradeFlow.kt$ContractUpgradeFlow.Initiate$val signableData = SignableData(tx.id, SignatureMetadata(serviceHub.myInfo.platformVersion, Crypto.findSignatureScheme(myKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ContractUpgradeFlowRPCTest.kt$ContractUpgradeFlowRPCTest$has&lt;ContractUpgradeLedgerTransaction, Any&gt;("input data", { it.inputs.single().state.data }, isA&lt;T&gt;(anything))</ID>
    <ID>MaxLineLength:ContractUpgradeFlowRPCTest.kt$ContractUpgradeFlowRPCTest.Companion$private val classMockNet = InternalMockNetwork(cordappsForAllNodes = listOf(DUMMY_CONTRACTS_CORDAPP, enclosedCordapp()))</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest$and</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest$has&lt;ContractUpgradeLedgerTransaction, Any&gt;("input data", { it.inputs.single().state.data }, isA&lt;T&gt;(anything))</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest${ // Create dummy contract. val signedByA = aliceNode.signDummyContract(alice.ref(1), 0, bob.ref(1)) val stx = bobNode.addSignatureTo(signedByA) aliceNode.finalise(stx, bob) val aliceTx = aliceNode.getValidatedTransaction(stx) val bobTx = bobNode.getValidatedTransaction(stx) // The request is expected to be rejected because party B hasn't authorised the upgrade yet. assertThat( aliceNode.initiateContractUpgrade(aliceTx, DummyContractV2::class), willThrow&lt;UnexpectedFlowEndException&gt;()) // Party B authorises the contract state upgrade, and immediately de-authorises the same. assertThat(bobNode.authoriseContractUpgrade(bobTx, DummyContractV2::class), willReturn()) assertThat(bobNode.deauthoriseContractUpgrade(bobTx), willReturn()) // The request is expected to be rejected because party B has subsequently de-authorised a previously authorised upgrade. assertThat( aliceNode.initiateContractUpgrade(aliceTx, DummyContractV2::class), willThrow&lt;UnexpectedFlowEndException&gt;()) // Party B authorises the contract state upgrade. assertThat(bobNode.authoriseContractUpgrade(bobTx, DummyContractV2::class), willReturn()) // Party A initiates contract upgrade flow, expected to succeed this time. assertThat( aliceNode.initiateContractUpgrade(aliceTx, DummyContractV2::class), willReturn( aliceNode.hasContractUpgradeTransaction&lt;DummyContract.State, DummyContractV2.State&gt;() and bobNode.hasContractUpgradeTransaction&lt;DummyContract.State, DummyContractV2.State&gt;())) val upgradedState = aliceNode.getStateFromVault(DummyContractV2.State::class) // We now test that the upgraded state can be upgraded further, to V3. // Party B authorises the contract state upgrade. assertThat(bobNode.authoriseContractUpgrade(upgradedState, DummyContractV3::class), willReturn()) // Party A initiates contract upgrade flow which is expected to succeed. assertThat( aliceNode.initiateContractUpgrade(upgradedState, DummyContractV3::class), willReturn( aliceNode.hasContractUpgradeTransaction&lt;DummyContractV2.State, DummyContractV3.State&gt;() and bobNode.hasContractUpgradeTransaction&lt;DummyContractV2.State, DummyContractV3.State&gt;())) }</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest.CashV2.State$@BelongsToContract(CashV2::class) data</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest.CashV2.State$override fun withNewOwner(newOwner: AbstractParty)</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest.CashV2.State$override fun withNewOwnerAndAmount(newAmount: Amount&lt;Issued&lt;Currency&gt;&gt;, newOwner: AbstractParty)</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest.Companion$private val classMockNet = InternalMockNetwork(cordappsForAllNodes = listOf(FINANCE_CONTRACTS_CORDAPP, DUMMY_CONTRACTS_CORDAPP, enclosedCordapp()))</ID>
    <ID>MaxLineLength:ContractUpgradeServiceImpl.kt$ContractUpgradeServiceImpl : ContractUpgradeServiceSingletonSerializeAsToken</ID>
    <ID>MaxLineLength:ContractUpgradeServiceImpl.kt$ContractUpgradeServiceImpl$override</ID>
    <ID>MaxLineLength:ContractUpgradeServiceImpl.kt$ContractUpgradeServiceImpl.Companion$fun createContractUpgradesMap(cacheFactory: NamedCacheFactory): PersistentMap&lt;String, String, DBContractUpgrade, String&gt;</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeFilteredTransaction : CoreTransaction</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt; = this.inputs, notary: Party = this.notary, legacyContractAttachment: Attachment = this.legacyContractAttachment, upgradedContractClassName: ContractClassName = this.upgradedContract::class.java.name, upgradedContractAttachment: Attachment = this.upgradedContractAttachment, id: SecureHash = this.id, privacySalt: PrivacySalt = this.privacySalt, sigs: List&lt;TransactionSignature&gt; = this.sigs, networkParameters: NetworkParameters = this.networkParameters )</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, notary: Party, legacyContractAttachment: Attachment, upgradedContractClassName: ContractClassName, upgradedContractAttachment: Attachment, id: SecureHash, privacySalt: PrivacySalt, sigs: List&lt;TransactionSignature&gt;, networkParameters: NetworkParameters )</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$?:</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$@Deprecated("ContractUpgradeLedgerTransaction should not be created directly, use ContractUpgradeWireTransaction.resolve instead.")</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$override</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$override fun equals(other: Any?): Boolean</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$return "ContractUpgradeLedgerTransaction(inputs=$inputs, notary=$notary, legacyContractAttachment=$legacyContractAttachment, upgradedContractAttachment=$upgradedContractAttachment, id=$id, privacySalt=$privacySalt, sigs=$sigs, networkParameters=$networkParameters, upgradedContract=$upgradedContract, references=$references, legacyContractClassName='$legacyContractClassName', outputs=$outputs)"</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction.Companion$@CordaInternal internal</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction.Companion$return ContractUpgradeLedgerTransaction(inputs, notary, legacyContractAttachment, upgradedContractAttachment, id, privacySalt, sigs, networkParameters, upgradedContract)</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction.Companion$val cordappLoader = services.cordappProvider::class.java.getMethod("getCordappLoader").invoke(services.cordappProvider)</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$ @CordaInternal internal fun resolveOutputComponent(services: ServicesForResolution, stateRef: StateRef, params: NetworkParameters): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$ fun buildFilteredTransaction(): ContractUpgradeFilteredTransaction</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$@CordaInternal internal</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$PARAMETERS_HASH.ordinal to FilteredComponent(serializedComponents[PARAMETERS_HASH.ordinal], nonces[PARAMETERS_HASH.ordinal])</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$classLoader.loadClass(className).asSubclass(UpgradedContract::class.java).newInstance() as UpgradedContract&lt;ContractState, ContractState&gt;</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$private</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val binaryInput: SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt; = resolveStateRefBinaryComponent(inputs[stateRef.index], services)!!</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val legacyContractAttachmentId: SecureHash by lazy { serializedComponents[LEGACY_ATTACHMENT.ordinal].deserialize&lt;SecureHash&gt;() }</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val resolvedNetworkParameters = services.networkParametersService.lookup(hashToResolve) ?: throw TransactionResolutionException(id)</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val upgradedContractAttachmentId: SecureHash by lazy { serializedComponents[UPGRADED_ATTACHMENT.ordinal].deserialize&lt;SecureHash&gt;() }</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val upgradedContractClassName: ContractClassName by lazy { serializedComponents[UPGRADED_CONTRACT.ordinal].deserialize&lt;ContractClassName&gt;() }</ID>
    <ID>MaxLineLength:ContractsDSL.kt$inline</ID>
    <ID>MaxLineLength:ContractsDSL.kt$mapNotNull { if (klass.isInstance(it.value)) uncheckedCast&lt;CommandWithParties&lt;CommandData&gt;, CommandWithParties&lt;C&gt;&gt;(it) else null }.filter { if (signer == null) true else signer in it.signers }.filter { if (party == null) true else party in it.signingParties }.map { CommandWithParties(it.signers, it.signingParties, it.value) }</ID>
    <ID>MaxLineLength:ContractsDSL.kt$mapNotNull { if (klass.isInstance(it.value)) uncheckedCast&lt;CommandWithParties&lt;CommandData&gt;, CommandWithParties&lt;C&gt;&gt;(it) else null }.filter { if (signers == null) true else it.signers.containsAll(signers) }.filter { if (parties == null) true else it.signingParties.containsAll(parties) }.map { CommandWithParties(it.signers, it.signingParties, it.value) }</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$RequireSingleCommandTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt; -&gt; commands.requireSingleCommand(TestCommands::class.java) }, "Interop version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$RequireSingleCommandTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt; -&gt; commands.requireSingleCommand&lt;TestCommands&gt;() }, "Inline version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithMultipleInputsTests$private val testFunction: (Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;, Collection&lt;PublicKey&gt;?, Collection&lt;Party&gt;?) -&gt; Iterable&lt;CommandWithParties&lt;CommandData&gt;&gt;</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithMultipleInputsTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;, signers: Collection&lt;PublicKey&gt;?, party: Collection&lt;Party&gt;? -&gt; commands.select(TestCommands::class.java, signers, party) }, "Interop version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithMultipleInputsTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;, signers: Collection&lt;PublicKey&gt;?, party: Collection&lt;Party&gt;? -&gt; commands.select&lt;TestCommands&gt;(signers, party) }, "Inline version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithSingleInputsTests$private val testFunction: (Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;, PublicKey?, AbstractParty?) -&gt; Iterable&lt;CommandWithParties&lt;CommandData&gt;&gt;</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithSingleInputsTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;, signer: PublicKey?, party: AbstractParty? -&gt; commands.select(TestCommands::class.java, signer, party) }, "Interop version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithSingleInputsTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;, signer: PublicKey?, party: AbstractParty? -&gt; commands.select&lt;TestCommands&gt;(signer, party) }, "Inline version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$val validCommandOne = CommandWithParties(listOf(megaCorp.publicKey, miniCorp.publicKey), listOf(megaCorp.party, miniCorp.party), TestCommands.CommandOne())</ID>
    <ID>MaxLineLength:ContractsScanning.kt$// When scanning of the CorDapp Jar is performed without "corda-core.jar" being in the classpath, there is no way to appreciate // relationships between those interfaces, therefore they have to be listed explicitly. val coreContractClasses = setOf(Contract::class, UpgradedContractWithLegacyConstraint::class, UpgradedContract::class)</ID>
    <ID>MaxLineLength:Converters.kt$CordaConverterProvider$override</ID>
    <ID>MaxLineLength:CopiedNode.kt$CopiedNode$return BuiltNode(this.configFile, this.baseDirectory, this.copiedNodeConfig, this.copiedNodeDir, nodeConfig, localImageId)</ID>
    <ID>MaxLineLength:CorDappInfoServlet.kt$CorDappInfoServlet$private</ID>
    <ID>MaxLineLength:CordaAuthenticationPlugin.kt$CordaAuthenticationPlugin : CRaSHPluginAuthenticationPlugin</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver$// We don't allow the annotation for classes in attachments for now. The class will be on the main classpath if we have the CorDapp installed. // We also do not allow extension of KryoSerializable for annotated classes, or combination with @DefaultSerializer for custom serialisation. // TODO: Later we can support annotations on attachment classes and spin up a proxy via bytecode that we know is harmless. private fun checkForAnnotation(type: Class&lt;*&gt;): Boolean</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver$if (type.isPrimitive || type == Any::class.java || type == String::class.java || (!type.isEnum &amp;&amp; isAbstract(type.modifiers))) return null</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver$kotlin.jvm.internal.Lambda::class.java.isAssignableFrom(targetType)</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver$throw KryoException("Class ${Util.className(type)} is not annotated or on the whitelist, so cannot be used in serialization")</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver${ // If call path has disabled whitelisting (see [CordaKryo.register]), just return without checking. if (!whitelistEnabled) return null // If array, recurse on element type if (type.isArray) return checkClass(type.componentType) // Specialised enum entry, so just resolve the parent Enum type since cannot annotate the specialised entry. if (!type.isEnum &amp;&amp; Enum::class.java.isAssignableFrom(type)) return checkClass(type.superclass) // Allow primitives, abstracts and interfaces. Note that we can also create abstract Enum types, // but we don't want to whitelist those here. if (type.isPrimitive || type == Any::class.java || type == String::class.java || (!type.isEnum &amp;&amp; isAbstract(type.modifiers))) return null // It's safe to have the Class already, since Kryo loads it with initialisation off. // If we use a whitelist with blacklisting capabilities, whitelist.hasListed(type) may throw an IllegalStateException if input class is blacklisted. // Thus, blacklisting precedes annotation checking. if (!whitelist.hasListed(type) &amp;&amp; !checkForAnnotation(type)) { throw KryoException("Class ${Util.className(type)} is not annotated or on the whitelist, so cannot be used in serialization") } return null }</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver${ val targetType = typeForSerializationOf(type) val objectInstance = targetType.kotlinObjectInstance // We have to set reference to true, since the flag influences how String fields are treated and we want it to be consistent. val references = kryo.references try { kryo.references = true val serializer = when { objectInstance != null -&gt; KotlinObjectSerializer(objectInstance) kotlin.jvm.internal.Lambda::class.java.isAssignableFrom(targetType) -&gt; // Kotlin lambdas extend this class and any captured variables are stored in synthetic fields FieldSerializer&lt;Any&gt;(kryo, targetType).apply { setIgnoreSyntheticFields(false) } Throwable::class.java.isAssignableFrom(targetType) -&gt; ThrowableSerializer(kryo, targetType) else -&gt; kryo.getDefaultSerializer(targetType) } return register(Registration(targetType, serializer, NAME.toInt())) } finally { kryo.references = references } }</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$expectedEx.expectMessage("The superclass java.util.HashSet of net.corda.serialization.internal.CordaClassResolverTests\$CordaSerializableHashSet is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$expectedEx.expectMessage("The superclass java.util.HashSet of net.corda.serialization.internal.CordaClassResolverTests\$SubHashSet is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$expectedEx.expectMessage("The superclass java.util.HashSet of net.corda.serialization.internal.CordaClassResolverTests\$SubSubHashSet is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$expectedEx.expectMessage("The superinterface java.sql.Connection of net.corda.serialization.internal.CordaClassResolverTests\$ConnectionImpl is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$expectedEx.expectMessage("The superinterface java.sql.Connection of net.corda.serialization.internal.CordaClassResolverTests\$SubConnectionImpl is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$private fun importJar(storage: AttachmentStorage, uploader: String = DEPLOYED_CORDAPP_UPLOADER)</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$private val allButBlacklistedContext: CheckpointSerializationContext = CheckpointSerializationContextImpl(this.javaClass.classLoader, AllButBlacklisted, emptyMap(), true, null)</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$private val emptyWhitelistContext: CheckpointSerializationContext = CheckpointSerializationContextImpl(this.javaClass.classLoader, EmptyWhitelist, emptyMap(), true, null)</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$val classLoader = AttachmentsClassLoader(arrayOf(attachmentHash).map { storage.openAttachment(it)!! }, testNetworkParameters(), SecureHash.zeroHash, { isAttachmentTrusted(it, storage) })</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$CliWrapperBase$// Override this function with the actual method to be run once all the arguments have been parsed. The return number // is the exit code to be returned abstract fun runProgram(): Int</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$CliWrapperBase$// Raw args are provided for use in logging - this is a lateinit var rather than a constructor parameter as the class // needs to be parameterless for autocomplete to work. lateinit var args: Array&lt;String&gt;</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$CliWrapperBase$// This needs to be called before loggers (See: NodeStartup.kt:51 logger called by lazy, initLogging happens before). // Node's logging is more rich. In corda configurations two properties, defaultLoggingLevel and consoleLogLevel, are usually used. open fun initLogging(): Boolean</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$CliWrapperBase$@Option(names = ["-v", "--verbose", "--log-to-console"], description = ["If set, prints logging to the console as well as to a file."])</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$CliWrapperBase$System.setProperty("defaultLogLevel", specifiedLogLevel)</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$CordaCliWrapper : CliWrapperBase</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$DefaultExceptionHandler&lt;List&lt;Any&gt;&gt;().useErr(System.err).useAnsi(defaultAnsiMode).andExit(ExitCodes.FAILURE)</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$Validated</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt${ val defaultAnsiMode = if (CordaSystemUtils.isOsWindows()) { Help.Ansi.ON } else { Help.Ansi.AUTO } val results = cmd.parseWithHandlers(RunLast().useOut(System.out).useAnsi(defaultAnsiMode), DefaultExceptionHandler&lt;List&lt;Any&gt;&gt;().useErr(System.err).useAnsi(defaultAnsiMode).andExit(ExitCodes.FAILURE), *args) // If an error code has been returned, use this and exit results?.firstOrNull()?.let { if (it is Int) { exitProcess(it) } else { exitProcess(ExitCodes.FAILURE) } } // If no results returned, picocli ran something without invoking the main program, e.g. --help or --version, so exit successfully exitProcess(ExitCodes.SUCCESS) }</ID>
    <ID>MaxLineLength:CordaClock.kt$CordaClock$@Deprecated("Do not use this. Instead seek to use ZonedDateTime methods.", level = DeprecationLevel.ERROR) override</ID>
    <ID>MaxLineLength:CordaClock.kt$MutableClock$ protected fun notifyMutationObservers()</ID>
    <ID>MaxLineLength:CordaClosureSerializer.kt$CordaClosureSerializer$const val ERROR_MESSAGE = "Unable to serialize Java Lambda expression, unless explicitly declared e.g., Runnable r = (Runnable &amp; Serializable) () -&gt; System.out.println(\"Hello world!\");"</ID>
    <ID>MaxLineLength:CordaException.kt$CordaException$if (originalMessage == null) "$originalExceptionClassName" else "$originalExceptionClassName: $originalMessage"</ID>
    <ID>MaxLineLength:CordaException.kt$CordaRuntimeException$if (originalMessage == null) "$originalExceptionClassName" else "$originalExceptionClassName: $originalMessage"</ID>
    <ID>MaxLineLength:CordaExceptionTest.kt$CordaExceptionTest$val ex = assertFailsWith&lt;ConflictingAttachmentsRejection&gt; { throw ConflictingAttachmentsRejection(TX_ID, CONTRACT_CLASS) }</ID>
    <ID>MaxLineLength:CordaExceptionTest.kt$CordaExceptionTest$val ex = assertFailsWith&lt;NotaryChangeInWrongTransactionType&gt; { throw NotaryChangeInWrongTransactionType(TX_ID, ALICE, BOB) }</ID>
    <ID>MaxLineLength:CordaFuture.kt$CordaFuture&lt;V&gt; : Future</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$ fun &lt;ELEMENT&gt; CordaFuture&lt;out ELEMENT&gt;.mapError(transform: (Throwable) -&gt; Throwable): CordaFuture&lt;ELEMENT&gt;</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$ fun &lt;RESULT&gt; CordaFuture&lt;out RESULT&gt;.doOnError(accept: (Throwable) -&gt; Unit): CordaFuture&lt;RESULT&gt;</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$ fun &lt;V, W, X&gt; CordaFuture&lt;out V&gt;.thenMatch(success: (V) -&gt; W, failure: (Throwable) -&gt; X)</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$ fun &lt;V, W&gt; CordaFuture&lt;out V&gt;.flatMap(transform: (V) -&gt; CordaFuture&lt;out W&gt;): CordaFuture&lt;W&gt;</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$CordaFutureImpl$@VisibleForTesting internal</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$internal fun &lt;V&gt; Future&lt;V&gt;.get(timeout: Duration? = null): V</ID>
    <ID>MaxLineLength:CordaInternal.kt$CordaInternal</ID>
    <ID>MaxLineLength:CordaMigration.kt$CordaMigration : CustomTaskChange</ID>
    <ID>MaxLineLength:CordaMigration.kt$CordaMigration$_servicesForResolution = MigrationServicesForResolution(identityService, attachmentsService, dbTransactions, cordaDB, cacheFactory)</ID>
    <ID>MaxLineLength:CordaMigration.kt$CordaMigration$return CordaPersistence(configDefaults, schema, jdbcUrl, cacheFactory, attributeConverters, closeConnection = false)</ID>
    <ID>MaxLineLength:CordaMigration.kt$CordaMigration${ val configDefaults = DatabaseConfig() val attributeConverters = listOf( PublicKeyToTextConverter(), AbstractPartyToX500NameAsStringConverter( identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous) ) // Liquibase handles closing the database connection when migrations are finished. If the connection is closed here, then further // migrations may fail. return CordaPersistence(configDefaults, schema, jdbcUrl, cacheFactory, attributeConverters, closeConnection = false) }</ID>
    <ID>MaxLineLength:CordaModule.kt$CordaModule${ super.setupModule(context) // For classes which are annotated with CordaSerializable we want to use the same set of properties as the Corda serilasation scheme. // To do that we use CordaSerializableClassIntrospector to first turn on field visibility for these classes (the Jackson default is // private fields are not included) and then we use CordaSerializableBeanSerializerModifier to remove any extra properties that Jackson // might pick up. context.setClassIntrospector(CordaSerializableClassIntrospector(context)) context.addBeanSerializerModifier(CordaSerializableBeanSerializerModifier()) context.addBeanDeserializerModifier(AmountBeanDeserializerModifier()) context.setMixInAnnotations(PartyAndCertificate::class.java, PartyAndCertificateMixin::class.java) context.setMixInAnnotations(NetworkHostAndPort::class.java, NetworkHostAndPortMixin::class.java) context.setMixInAnnotations(CordaX500Name::class.java, CordaX500NameMixin::class.java) context.setMixInAnnotations(Amount::class.java, AmountMixin::class.java) context.setMixInAnnotations(AbstractParty::class.java, AbstractPartyMixin::class.java) context.setMixInAnnotations(AnonymousParty::class.java, AnonymousPartyMixin::class.java) context.setMixInAnnotations(Party::class.java, PartyMixin::class.java) context.setMixInAnnotations(PublicKey::class.java, PublicKeyMixin::class.java) context.setMixInAnnotations(ByteSequence::class.java, ByteSequenceMixin::class.java) context.setMixInAnnotations(SecureHash.SHA256::class.java, SecureHashSHA256Mixin::class.java) context.setMixInAnnotations(SecureHash::class.java, SecureHashSHA256Mixin::class.java) context.setMixInAnnotations(SerializedBytes::class.java, SerializedBytesMixin::class.java) context.setMixInAnnotations(DigitalSignature.WithKey::class.java, ByteSequenceWithPropertiesMixin::class.java) context.setMixInAnnotations(DigitalSignatureWithCert::class.java, ByteSequenceWithPropertiesMixin::class.java) context.setMixInAnnotations(TransactionSignature::class.java, ByteSequenceWithPropertiesMixin::class.java) context.setMixInAnnotations(SignedTransaction::class.java, SignedTransactionMixin::class.java) context.setMixInAnnotations(WireTransaction::class.java, WireTransactionMixin::class.java) context.setMixInAnnotations(TransactionState::class.java, TransactionStateMixin::class.java) context.setMixInAnnotations(Command::class.java, CommandMixin::class.java) context.setMixInAnnotations(TimeWindow::class.java, TimeWindowMixin::class.java) context.setMixInAnnotations(PrivacySalt::class.java, PrivacySaltMixin::class.java) context.setMixInAnnotations(SignatureScheme::class.java, SignatureSchemeMixin::class.java) context.setMixInAnnotations(SignatureMetadata::class.java, SignatureMetadataMixin::class.java) context.setMixInAnnotations(PartialTree::class.java, PartialTreeMixin::class.java) context.setMixInAnnotations(NodeInfo::class.java, NodeInfoMixin::class.java) context.setMixInAnnotations(StateMachineRunId::class.java, StateMachineRunIdMixin::class.java) }</ID>
    <ID>MaxLineLength:CordaModule.kt$CordaSerializableBeanSerializerModifier$// We need to pass in a SerializerFactory when scanning for properties, but don't actually do any serialisation so any will do. private val serializerFactory = SerializerFactoryBuilder.build(AllWhitelist, javaClass.classLoader)</ID>
    <ID>MaxLineLength:CordaModule.kt$CordaSerializableBeanSerializerModifier$val propertyNames = typeInformation.propertiesOrEmptyMap.mapNotNull { if (it.value.isCalculated) null else it.key }</ID>
    <ID>MaxLineLength:CordaModule.kt$CordaSerializableClassIntrospector$context.configOverride(type.rawClass).visibility = Value.defaultVisibility().withFieldVisibility(Visibility.ANY)</ID>
    <ID>MaxLineLength:CordaModule.kt$NetworkHostAndPortDeserializer : SimpleDeserializer</ID>
    <ID>MaxLineLength:CordaModule.kt$SignatureSchemeDeserializer$signatureSchemesByNumberID[parser.intValue] ?: throw JsonParseException(parser, "Unable to find SignatureScheme ${parser.text}")</ID>
    <ID>MaxLineLength:CordaModule.kt$SignedTransactionDeserializer$val core = wrapper.run { wire ?: filtered ?: notaryChangeWire ?: contractUpgradeWire ?: contractUpgradeFiltered!! }</ID>
    <ID>MaxLineLength:CordaModule.kt$StxJson$val count = Booleans.countTrue(wire != null, filtered != null, notaryChangeWire != null, contractUpgradeWire != null, contractUpgradeFiltered != null)</ID>
    <ID>MaxLineLength:CordaPersistence.kt$// Add the subscriber to the wrapping subscriber, which will invoke the original subscribers together inside a database transaction. wrappingSubscriber.delegates.add(toBeWrappedInDbTx) // If we are the first subscriber, return the shared subscriber, otherwise return a subscriber that does nothing. if (wrappingSubscriber.delegates.size == 1) wrappingSubscriber else NoOpSubscriber(toBeWrappedInDbTx) // Clean up the shared list of subscribers when they unsubscribe.</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$ fun &lt;T&gt; transaction( isolationLevel: TransactionIsolationLevel, recoverableFailureTolerance: Int, recoverAnyNestedSQLException: Boolean, statement: DatabaseTransaction.() -&gt; T ): T</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$ fun &lt;T&gt; transaction(recoverableFailureTolerance: Int, statement: DatabaseTransaction.() -&gt; T): T</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$HibernateConfiguration(schemas, databaseConfig, attributeConverters, jdbcUrl, cacheFactory, customClassLoader)</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$error("Was not expecting to find existing database transaction on current strand when setting database: ${Strand.currentStrand()}, $it")</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$is SchemaManagementException -&gt; throw HibernateSchemaChangeException("Incompatible schema change detected. Please run the node with database.initialiseSchema=true. Reason: ${e.message}", e)</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$val connectionBag: ConcurrentBag&lt;ConcurrentBag.IConcurrentBagEntry&gt; = connectionBagField.get(pool) as ConcurrentBag&lt;ConcurrentBag.IConcurrentBagEntry&gt;</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$val transaction = contextDatabase.currentOrNew(isolationLevel) // XXX: Does this code really support statement changing the contextDatabase?</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence${ // DataSource doesn't implement AutoCloseable so we just have to hope that the implementation does so that we can close it (_dataSource as? AutoCloseable)?.close() }</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence${ // We need to set the database for the current [Thread] or [Fiber] here as some tests share threads across databases. _contextDatabase.set(this) currentDBSession().flush() return contextTransaction.connection }</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence${ // We need to set the database for the current [Thread] or [Fiber] here as some tests share threads across databases. _contextDatabase.set(this) return currentOrNew(isolationLevel) }</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CouldNotCreateDataSourceException : Exception</ID>
    <ID>MaxLineLength:CordaPersistence.kt$currentTx.boundary.filter { !it.success }.subscribe { this.onError(DatabaseTransactionRolledBackException(it.txId)) }</ID>
    <ID>MaxLineLength:CordaPersistence.kt$return _contextDatabase.get() ?: error("Was expecting to find CordaPersistence set on current thread: ${Strand.currentStrand()}")</ID>
    <ID>MaxLineLength:CordaPersistence.kt${ var wrappingSubscriber = DatabaseTransactionWrappingSubscriber&lt;T&gt;(db) // Use lift to add subscribers to a special subscriber that wraps a database transaction around observations. // Each subscriber will be passed to this lambda when they subscribe, at which point we add them to wrapping subscriber. return this.lift { toBeWrappedInDbTx: Subscriber&lt;in T&gt; -&gt; // Add the subscriber to the wrapping subscriber, which will invoke the original subscribers together inside a database transaction. wrappingSubscriber.delegates.add(toBeWrappedInDbTx) // If we are the first subscriber, return the shared subscriber, otherwise return a subscriber that does nothing. if (wrappingSubscriber.delegates.size == 1) wrappingSubscriber else NoOpSubscriber(toBeWrappedInDbTx) // Clean up the shared list of subscribers when they unsubscribe. }.doOnUnsubscribe { wrappingSubscriber.cleanUp() // If cleanup removed the last subscriber reset the system, as future subscribers might need the stream again if (wrappingSubscriber.delegates.isEmpty()) { wrappingSubscriber = DatabaseTransactionWrappingSubscriber(db) } } }</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$ @JvmOverloads fun start( username: String, password: String, externalTrace: Trace?, impersonatedActor: Actor?, gracefulReconnect: Boolean = false ): CordaRPCConnection</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$ @JvmOverloads fun start( username: String, password: String, externalTrace: Trace?, impersonatedActor: Actor?, targetLegalIdentity: CordaX500Name?, gracefulReconnect: Boolean = false ): CordaRPCConnection</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$ @JvmOverloads fun start( username: String, password: String, targetLegalIdentity: CordaX500Name, gracefulReconnect: Boolean = false ): CordaRPCConnection</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$ @JvmOverloads fun start(username: String, password: String, gracefulReconnect: Boolean = false): CordaRPCConnection</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$( haAddressPool: List&lt;NetworkHostAndPort&gt;, configuration: CordaRPCClientConfiguration = CordaRPCClientConfiguration.DEFAULT, sslConfiguration: ClientRpcSslOptions? = null, classLoader: ClassLoader? = null )</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$( hostAndPort: NetworkHostAndPort, configuration: CordaRPCClientConfiguration, sslConfiguration: ClientRpcSslOptions?, classLoader: ClassLoader? = null )</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$( hostAndPort: NetworkHostAndPort, sslConfiguration: ClientRpcSslOptions? = null, classLoader: ClassLoader? = null )</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$AMQPClientSerializationScheme.initialiseSerialization(serializationClassLoader, customSerializers, serializationWhitelists, cache)</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$CordaRPCConnection(getRpcClient().start(InternalCordaRPCOps::class.java, username, password, externalTrace, impersonatedActor, targetLegalIdentity))</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$if (classLoader != null) AMQP_RPC_CLIENT_CONTEXT.withClassLoader(classLoader) else AMQP_RPC_CLIENT_CONTEXT</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$val cache = Caffeine.newBuilder().maximumSize(128).build&lt;SerializationFactoryCacheKey, SerializerFactory&gt;().asMap()</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$val customSerializers = createInstancesOfClassesImplementing(serializationClassLoader, SerializationCustomSerializer::class.java)</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$val serializationWhitelists = ServiceLoader.load(SerializationWhitelist::class.java, serializationClassLoader).toSet()</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient${ val cache = Caffeine.newBuilder().maximumSize(128).build&lt;SerializationFactoryCacheKey, SerializerFactory&gt;().asMap() // If the client has explicitly provided a classloader use this one to scan for custom serializers, otherwise use the current one. val serializationClassLoader = this.classLoader ?: this.javaClass.classLoader val customSerializers = createInstancesOfClassesImplementing(serializationClassLoader, SerializationCustomSerializer::class.java) val serializationWhitelists = ServiceLoader.load(SerializationWhitelist::class.java, serializationClassLoader).toSet() AMQPClientSerializationScheme.initialiseSerialization(serializationClassLoader, customSerializers, serializationWhitelists, cache) }</ID>
    <ID>MaxLineLength:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$(client.start(rpcUser.username, rpcUser.password, gracefulReconnect = true).proxy as ReconnectingCordaRPCOps)</ID>
    <ID>MaxLineLength:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$driver</ID>
    <ID>MaxLineLength:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$rpcOps.startTrackedFlow(::CashIssueFlow, 10.DOLLARS, OpaqueBytes.of(0), defaultNotaryIdentity).returnValue.get()</ID>
    <ID>MaxLineLength:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$val addresses = listOf(NetworkHostAndPort("localhost", portAllocator.nextPort()), NetworkHostAndPort("localhost", portAllocator.nextPort()))</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest$// WireTransaction stores its components as blobs which are deserialised in its constructor. This test makes sure // the extra class loader given to the CordaRPCClient is used in this deserialisation, as otherwise any WireTransaction // containing Cash.State objects are not receivable by the client. // // We run the client in a separate process, without the finance module on its system classpath to ensure that the // additional class loader that we give it is used. Cash.State objects are used as they can't be synthesised fully // by the carpenter, and thus avoiding any false-positive results. @Test fun `additional class loader used by WireTransaction when it deserialises its components`()</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest$checkRpcNotification(update.stateMachineInfo, rpcUser.username, historicalIds, externalTrace, impersonatedActor)</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest$node.services.startFlow(CashIssueFlow(100.POUNDS, OpaqueBytes.of(1), identity), InvocationContext.shell()).flatMap { it.resultFuture }.getOrThrow()</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest$node.services.startFlow(CashIssueFlow(2000.DOLLARS, OpaqueBytes.of(0), identity), InvocationContext.shell()).flatMap { it.resultFuture }.getOrThrow()</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest$poll(scheduler, pollName = "node's started state", check = { if (node.node.started == null) true else null })</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest$proxy.startFlowDynamic(CashIssueFlow::class.java, 1000.DOLLARS, OpaqueBytes.of(0), identity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest.CloseableExecutor$private</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$ @Deprecated("For automated upgrades, consider using the `gracefulShutdown` command in an SSH session instead.") fun CordaRPCOps.pendingFlowsCount(): DataFeed&lt;Int, Pair&lt;Int, Int&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ // DOCSTART VaultQueryByAPI @RPCReturnsObservables fun &lt;T : ContractState&gt; vaultQueryBy( criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt; ): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ // DOCSTART VaultTrackByAPI @RPCReturnsObservables fun &lt;T : ContractState&gt; vaultTrackBy( criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt; ): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ // TODO This operation should be restricted to just node admins. @RPCReturnsObservables fun networkParametersFeed(): DataFeed&lt;ParametersUpdateInfo?, ParametersUpdateInfo&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ // TODO This operation should be restricted to just node admins. fun acceptNewNetworkParameters(parametersHash: SecureHash)</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ @CordaInternal @Deprecated("This method is intended only for internal use and will be removed from the public API soon.") fun internalFindVerifiedTransaction(txnId: SecureHash): SignedTransaction?</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ @Deprecated("This method is intended only for internal use and will be removed from the public API soon.") @RPCReturnsObservables fun internalVerifiedTransactionsFeed(): DataFeed&lt;List&lt;SignedTransaction&gt;, SignedTransaction&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ @Deprecated("This method is intended only for internal use and will be removed from the public API soon.") fun internalVerifiedTransactionsSnapshot(): List&lt;SignedTransaction&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ @RPCReturnsObservables fun stateMachineRecordedTransactionMappingFeed(): DataFeed&lt;List&lt;StateMachineTransactionMapping&gt;, StateMachineTransactionMapping&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun clearNetworkMapCache()</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun killFlow(id: StateMachineRunId): Boolean</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun nodeDiagnosticInfo(): NodeDiagnosticInfo</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun nodeInfoFromParty(party: AbstractParty): NodeInfo?</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun notaryIdentities(): List&lt;Party&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun refreshNetworkMapCache()</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun setFlowsDrainingModeEnabled(enabled: Boolean)</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun terminate(drainPendingFlows: Boolean = false)</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultQueryByCriteria(criteria: QueryCriteria, contractStateType: Class&lt;out T&gt;): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultTrackByCriteria(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$ParametersUpdateInfo</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$StateMachineInfo$return copy(id = id, flowLogicClassName = flowLogicClassName, initiator = initiator, progressTrackerStepAndUpdates = progressTrackerStepAndUpdates, invocationContext = invocationContext)</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$/** * Returns the RPC protocol version, which is the same the node's platform Version. Exists since version 1 so guaranteed * to be present. */ override val protocolVersion: Int get() = nodeInfo().platformVersion</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$?:</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$hash.serialize().sign { services.keyManagementService.sign(it.bytes, services.myInfo.legalIdentities[0].owningKey) }</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$is ConnectException -&gt; throw CordaRuntimeException("There is connection problem to network map. The possible causes are incorrect configuration or network map service being down")</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$is InvocationOrigin.Scheduled -&gt; FlowInitiator.Scheduled((origin as InvocationOrigin.Scheduled).scheduledState)</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$override</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$override fun internalFindVerifiedTransaction(txnId: SecureHash): SignedTransaction?</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$override fun killFlow(id: StateMachineRunId): Boolean</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$override fun registeredFlows(): List&lt;String&gt;</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$override fun setFlowsDrainingModeEnabled(enabled: Boolean)</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$pendingFlowsCount() .updates .doOnNext { (completed, total) -&gt; logger.info("Pending flows progress before shutdown: $completed / $total.") }</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$progress = stateMachine.logic.track()?.updates?.filter { !it.startsWith(STRUCTURAL_STEP_PREFIX) } ?: Observable.empty()</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$return StateMachineInfo(flowLogic.runId, flowLogic.javaClass.name, flowLogic.stateMachine.context.toFlowInitiator(), flowLogic.track(), flowLogic.stateMachine.context)</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$return vaultQueryBy(QueryCriteria.VaultQueryCriteria(), PageSpecification(), Sort(emptySet()), contractStateType)</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$return vaultTrackBy(QueryCriteria.VaultQueryCriteria(), PageSpecification(), Sort(emptySet()), contractStateType)</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$val wellKnownParty = services.identityService.wellKnownPartyFromX500Name((origin as InvocationOrigin.Peer).party)</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl${ error -&gt; logger.error("Error while waiting for pending flows to drain in preparation for shutdown. Cause was: ${error.message}", error) }</ID>
    <ID>MaxLineLength:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$CURRENT_RPC_CONTEXT.set(RpcAuthContext(InvocationContext.rpc(testActor()), buildSubject("TEST_USER", emptySet())))</ID>
    <ID>MaxLineLength:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$assertThatCode { rpc.startFlow(::SoftLock, cash.ref, Duration.ofSeconds(1)).returnValue.getOrThrow() }.doesNotThrowAnyException()</ID>
    <ID>MaxLineLength:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$require(aliceNode.services.keyManagementService.filterMyKeys(signaturePubKeys).toList().isNotEmpty())</ID>
    <ID>MaxLineLength:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$val cash = rpc.startFlow(::CashIssueFlow, 10.DOLLARS, issuerRef, notary).returnValue.getOrThrow().stx.tx.outRefsOfType&lt;Cash.State&gt;().single()</ID>
    <ID>MaxLineLength:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$withPermissions</ID>
    <ID>MaxLineLength:CordaService.kt$CordaService</ID>
    <ID>MaxLineLength:CordaServiceTest.kt$CordaServiceTest$CordaServiceThatRequiresThreadContextClassLoader : SingletonSerializeAsToken</ID>
    <ID>MaxLineLength:CordaServiceTest.kt$CordaServiceTest$mockNet = MockNetwork(MockNetworkParameters(threadPerNode = true, cordappsForAllNodes = listOf(FINANCE_CONTRACTS_CORDAPP, enclosedCordapp())))</ID>
    <ID>MaxLineLength:CordaServiceTest.kt$CordaServiceTest.CordaServiceThatRequiresThreadContextClassLoader$assertNotNull(Thread.currentThread().contextClassLoader, "thread context classloader should not be null during service initialisation")</ID>
    <ID>MaxLineLength:CordaUtils.kt$ @DeleteForDJVM fun TransactionBuilder.toLedgerTransaction(services: ServicesForResolution, serializationContext: SerializationContext): LedgerTransaction</ID>
    <ID>MaxLineLength:CordaUtils.kt$ @DeleteForDJVM fun TransactionBuilder.toWireTransaction(services: ServicesForResolution, serializationContext: SerializationContext): WireTransaction</ID>
    <ID>MaxLineLength:CordaUtils.kt$ private fun owns(packageName: String, fullClassName: String): Boolean</ID>
    <ID>MaxLineLength:CordaUtils.kt$"$requiredMinPlatformVersion. The current zone is only enforcing a minimum platform version of "</ID>
    <ID>MaxLineLength:CordaUtils.kt$AttachmentSort(listOf(AttachmentSort.AttachmentSortColumn(AttachmentSort.AttachmentSortAttribute.VERSION, Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:CordaUtils.kt$Character.isJavaIdentifierStart(token[0]) &amp;&amp; token.toCharArray().drop(1).all { Character.isJavaIdentifierPart(it) }</ID>
    <ID>MaxLineLength:CordaUtils.kt$private</ID>
    <ID>MaxLineLength:CordaVersion.kt$CordaVersion$arrayOf("Version: $releaseVersion", "Revision: $revision", "Platform Version: $platformVersion", "Vendor: $vendor")</ID>
    <ID>MaxLineLength:CordaVersion.kt$CordaVersion.Companion$internal val semanticVersion: String by lazy { if (releaseVersion == UNKNOWN) CURRENT_MAJOR_RELEASE else releaseVersion }</ID>
    <ID>MaxLineLength:CordaVersionProvider.kt$CordaVersionProvider : IVersionProvider</ID>
    <ID>MaxLineLength:CordaViewModel.kt$CordaView : View</ID>
    <ID>MaxLineLength:CordaX500Name.kt$CordaX500Name$/** * @param organisation name of the organisation. * @param locality locality of the organisation, typically nearest major city. * @param country country the organisation is in, as an ISO 3166-1 2-letter country code. */ constructor(organisation: String, locality: String, country: String) : this(null, null, organisation, locality, null, country)</ID>
    <ID>MaxLineLength:CordaX500Name.kt$CordaX500Name$require(locality.length &lt; MAX_LENGTH_LOCALITY) { "Locality attribute (L) must contain less then $MAX_LENGTH_LOCALITY characters." }</ID>
    <ID>MaxLineLength:CordaX500Name.kt$CordaX500Name$state?.let { require(it.length &lt; MAX_LENGTH_STATE) { "State attribute (ST) must contain less then $MAX_LENGTH_STATE characters." } }</ID>
    <ID>MaxLineLength:CordaX500Name.kt$CordaX500Name$this(commonName = commonName, organisationUnit = null, organisation = organisation, locality = locality, state = null, country = country)</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp$Info</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info$ContractAndWorkflow : Info</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info$Workflow : Info</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info.Contract$override fun toString()</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info.Workflow$override fun toString()</ID>
    <ID>MaxLineLength:CordappConfigFileProviderTests.kt$CordappConfigFileProviderTests$private</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$assertThat(aliceQuery.statesMetadata[0].constraintInfo!!.type()).isEqualTo(Vault.ConstraintInfo.Type.SIGNATURE)</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$assertThat(allStates[0].state.constraint).isInstanceOfAny(HashAttachmentConstraint::class.java, SignatureAttachmentConstraint::class.java)</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$assertThat(bobQuery.statesMetadata[0].constraintInfo!!.type()).isEqualTo(Vault.ConstraintInfo.Type.SIGNATURE)</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val aliceQuery = alice.rpc.vaultQueryBy&lt;Cash.State&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.CONSUMED))</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val aliceQuery = restartedAlice.rpc.vaultQueryBy&lt;Cash.State&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.CONSUMED))</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val issueTx = alice.rpc.startFlow(::CashIssueFlow, 1000.DOLLARS, OpaqueBytes.of(1), defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val issueTx = alice.rpc.startFlow(::CashIssueFlow, expected, ref, defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val issueTx2 = restartedNode.rpc.startFlow(::CashIssueFlow, expected, ref, defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val parameters = NetworkParametersReader(DEV_ROOT_CA.certificate, null, notary.baseDirectory).read().networkParameters</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val transferTx = alice.rpc.startFlow(::CashPaymentFlow, 1000.DOLLARS, bobParty, true, defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val transferTxn = restartedAlice.rpc.startFlow(::CashPaymentFlow, 1000.DOLLARS, bobParty, true, defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val vaultUpdatesBob = bob.rpc.vaultTrackByCriteria(Cash.State::class.java, QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).updates</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val vaultUpdatesBob = restartedBob.rpc.vaultTrackByCriteria(Cash.State::class.java, QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).updates</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.Companion$@CordaInternal fun create(cordapp: Cordapp, attachmentId: SecureHash?, classLoader: ClassLoader, config: CordappConfig): CordappContext</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun get(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getBoolean(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getDouble(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getFloat(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getInt(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getLong(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getNumber(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getString(path: String)</ID>
    <ID>MaxLineLength:CordappImpl.kt$CordappImpl$val classList = rpcFlows + initiatedFlows + services + serializationWhitelists.flatMap { it.whitelist } + notaryService</ID>
    <ID>MaxLineLength:CordappProvider.kt$CordappProvider$ fun getAppContext(): CordappContext</ID>
    <ID>MaxLineLength:CordappResolver.kt$CordappResolver$ @Synchronized @VisibleForTesting fun &lt;T&gt; withCordapp(minimumPlatformVersion: Int = 1, targetPlatformVersion: Int = PLATFORM_VERSION, block: () -&gt; T): T</ID>
    <ID>MaxLineLength:CordappResolver.kt$CordappResolver$CordappImpl.TEST_INSTANCE.copy(minimumPlatformVersion = minimumPlatformVersion, targetPlatformVersion = targetPlatformVersion)</ID>
    <ID>MaxLineLength:CordappResolver.kt$CordappResolver$Exception().stackTrace .mapNotNull { cordappClasses[it.className] } // in case there are multiple classes matched, we select the first one having a single CorDapp registered against it. .firstOrNull { it.size == 1 }</ID>
    <ID>MaxLineLength:CordappResolverTest.kt$CordappResolverTest$@Test fun `when the same cordapp is registered for the same class multiple times, the resolver deduplicates and returns it as the current one`()</ID>
    <ID>MaxLineLength:CordappSmokeTest.kt$CordappSmokeTest$(additionalNodeInfoDir / "nodeInfo-41408E093F95EAD51F6892C34DEB65AE1A3569A4B0E5744769A1B485AF8E04B5").write(signedNodeInfo.serialize().bytes)</ID>
    <ID>MaxLineLength:CordappSmokeTest.kt$CordappSmokeTest$val future = connectionToAlice.proxy.startFlow(CordappSmokeTest::GatherContextsFlow, aliceIdentity).returnValue</ID>
    <ID>MaxLineLength:CordappSmokeTest.kt$CordappSmokeTest$val nodeInfo = createNodeInfoWithSingleIdentity(CordaX500Name(organisation = "Bob Corp", locality = "Madrid", country = "ES"), dummyKeyPair, dummyKeyPair.public)</ID>
    <ID>MaxLineLength:CordappSmokeTest.kt$CordappSmokeTest${ val baseDir = factory.baseDirectory(aliceConfig) val cordappsDir = (baseDir / CORDAPPS_DIR_NAME).createDirectories() // Find the jar file for the smoke tests of this module val selfCordapp = Paths.get("build", "libs").list { it.filter { "-smokeTests" in it.toString() }.toList().single() } selfCordapp.copyToDirectory(cordappsDir) // The `nodeReadyFuture` in the persistent network map cache will not complete unless there is at least one other // node in the network. We work around this limitation by putting another node info file in the additional-node-info // folder. // TODO clean this up after we refactor the persistent network map cache / network map updater val additionalNodeInfoDir = (baseDir / "additional-node-infos").createDirectories() createDummyNodeInfo(additionalNodeInfoDir) factory.create(aliceConfig).use { alice -&gt; alice.connect(superUser).use { connectionToAlice -&gt; val aliceIdentity = connectionToAlice.proxy.nodeInfo().legalIdentitiesAndCerts.first().party val future = connectionToAlice.proxy.startFlow(CordappSmokeTest::GatherContextsFlow, aliceIdentity).returnValue val (sessionInitContext, sessionConfirmContext) = future.getOrThrow() val selfCordappName = selfCordapp.fileName.toString().removeSuffix(".jar") assertThat(sessionInitContext.appName).isEqualTo(selfCordappName) assertThat(sessionConfirmContext.appName).isEqualTo(selfCordappName) } } }</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler : Acceptor</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler$"The instigator is one of the participants" using (initiatingSession.counterparty in oldStateAndRef.state.data.participants)</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler$"The proposed upgrade ${proposal.modification.javaClass} is a trusted upgrade path" using (proposal.modification.name == authorisedUpgrade)</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler$val authorisedUpgrade = checkNotNull(serviceHub.contractUpgradeService.getAuthorisedContractUpgrade(oldStateAndRef.ref)) { "Contract state upgrade is unauthorised. State hash : ${oldStateAndRef.ref}" }</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler$val expectedTx = ContractUpgradeUtils.assembleUpgradeTx(oldStateAndRef, proposal.modification, proposedTx.privacySalt, serviceHub)</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler${ // Retrieve signed transaction from our side, we will apply the upgrade logic to the transaction on our side, and // verify outputs matches the proposed upgrade. val ourSTX = requireNotNull(serviceHub.validatedTransactions.getTransaction(proposal.stateRef.txhash)) { "We don't have a copy of the referenced state" } val oldStateAndRef = ourSTX.resolveBaseTransaction(serviceHub).outRef&lt;ContractState&gt;(proposal.stateRef.index) val authorisedUpgrade = checkNotNull(serviceHub.contractUpgradeService.getAuthorisedContractUpgrade(oldStateAndRef.ref)) { "Contract state upgrade is unauthorised. State hash : ${oldStateAndRef.ref}" } val proposedTx = stx.coreTransaction as ContractUpgradeWireTransaction val expectedTx = ContractUpgradeUtils.assembleUpgradeTx(oldStateAndRef, proposal.modification, proposedTx.privacySalt, serviceHub) requireThat { "The instigator is one of the participants" using (initiatingSession.counterparty in oldStateAndRef.state.data.participants) "The proposed upgrade ${proposal.modification.javaClass} is a trusted upgrade path" using (proposal.modification.name == authorisedUpgrade) "The proposed tx matches the expected tx for this upgrade" using (proposedTx == expectedTx) } proposedTx.resolve(serviceHub, stx.sigs) }</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$FinalityHandler$logger.warnOnce("Insecure API to record finalised transaction was used by ${sender.counterparty} (${sender.getCounterpartyFlowInfo()})")</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$NotaryChangeHandler : Acceptor</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$NotaryChangeHandler${ val state = proposal.stateRef val proposedTx = stx.resolveNotaryChangeTransaction(serviceHub) // TODO: Right now all nodes will automatically approve the notary change. We need to figure out if stricter controls are necessary. if (state !in proposedTx.inputs.map { it.ref }) { throw StateReplacementException("The proposed state $state is not in the proposed transaction inputs") } val newNotary = proposal.modification val isNotary = serviceHub.networkMapCache.isNotary(newNotary) if (!isNotary) { throw StateReplacementException("The proposed node $newNotary does not run a Notary service") } }</ID>
    <ID>MaxLineLength:CouldNotStartFlowException.kt$CouldNotStartFlowException : RPCException</ID>
    <ID>MaxLineLength:CrossCashTest.kt$"Divergence detected, the remote state doesn't match any of our possible predictions."</ID>
    <ID>MaxLineLength:CrossCashTest.kt$is IssueAndPaymentRequest -&gt; command.node.proxy.startFlow(::CashIssueAndPaymentFlow, request).returnValue</ID>
    <ID>MaxLineLength:CrossCashTest.kt$it.value.toDouble() / 1000 to generateMove(it.value, USD, node.mainIdentity, possibleRecipients)</ID>
    <ID>MaxLineLength:CrossCashTest.kt$listOf(1.0 to generateIssue(10000, USD, notaryIdentity, possibleRecipients)) + moves + exits</ID>
    <ID>MaxLineLength:CrossCashTest.kt$val minimumMatches = matches.fold&lt;Map&lt;AbstractParty, Int&gt;, HashMap&lt;AbstractParty, Int&gt;?&gt;(null) { minimum, next -&gt; if (minimum == null) { HashMap(next) } else { next.forEach { minimum.merge(it.key, it.value, Math::min) } minimum } }!!</ID>
    <ID>MaxLineLength:CrossCashTest.kt${ log.warn( "Divergence detected, the remote state doesn't match any of our possible predictions." + "\nPredicted state/queues:\n$previousState" + "\nActual gathered state:\n${CrossCashState(currentNodeVaults, mapOf())}" ) // TODO We should terminate here with an exception, we cannot carry on as we have an inconsistent model. We carry on currently because we always diverge due to notarisation failures return@LoadTest CrossCashState(currentNodeVaults, mapOf()) }</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @DeleteForDJVM @JvmOverloads @JvmStatic fun generateKeyPair(signatureScheme: SignatureScheme = DEFAULT_SIGNATURE_SCHEME): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @DeleteForDJVM @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doSign(privateKey: PrivateKey, clearData: ByteArray): ByteArray</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @DeleteForDJVM @JvmStatic fun generateKeyPair(schemeCodeName: String): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(schemeCodeName: String, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(signatureScheme: SignatureScheme, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(txId: SecureHash, transactionSignature: TransactionSignature): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeySpecException::class) fun decodePrivateKey(schemeCodeName: String, encodedKey: ByteArray): PrivateKey</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeySpecException::class) fun decodePublicKey(schemeCodeName: String, encodedKey: ByteArray): PublicKey</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(SignatureException::class) fun isValid(publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(SignatureException::class) fun isValid(signatureScheme: SignatureScheme, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(SignatureException::class) fun isValid(txId: SecureHash, transactionSignature: TransactionSignature): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun deriveKeyPair(privateKey: PrivateKey, seed: ByteArray): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun deriveKeyPair(signatureScheme: SignatureScheme, privateKey: PrivateKey, seed: ByteArray): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun deriveKeyPairFromEntropy(entropy: BigInteger): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun deriveKeyPairFromEntropy(signatureScheme: SignatureScheme, entropy: BigInteger): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun findSignatureScheme(schemeCodeName: String): SignatureScheme</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun publicKeyOnCurve(signatureScheme: SignatureScheme, publicKey: PublicKey): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$"Metadata schemeCodeName: ${sigMetaData.schemeCodeName} is not aligned with the key type: ${sigKey.schemeCodeName}."</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$// Check if a public key satisfies algorithm specs (for ECC: key should lie on the curve and not being point-at-infinity). private fun validatePublicKey(signatureScheme: SignatureScheme, key: PublicKey): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$AlgorithmIdentifier(BCObjectIdentifiers.sphincs256_with_SHA512, DLSequence(arrayOf(ASN1Integer(0), SHA512_256)))</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ECDSA_SECP256R1_SHA256, ECDSA_SECP256K1_SHA256 -&gt; deriveKeyPairECDSA(signatureScheme.algSpec as ECParameterSpec, privateKey, seed)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$else -&gt; throw InvalidKeyException("Key type ${privateKey.algorithm} is not supported for deterministic key derivation")</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$else -&gt; throw UnsupportedOperationException("Although supported for signing, deterministic key derivation is " + "not currently implemented for ${signatureScheme.schemeCodeName}")</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$is BCECPublicKey -&gt; publicKey.parameters == signatureScheme.algSpec &amp;&amp; !publicKey.q.isInfinity &amp;&amp; publicKey.q.isValid</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$is BCRSAPrivateKey, is BCSphincs256PrivateKey -&gt; true</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$is BCRSAPublicKey -&gt; key.modulus.bitLength() &gt;= 2048</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$is EdDSAPublicKey -&gt; publicKey.params == signatureScheme.algSpec &amp;&amp; !isEdDSAPointAtInfinity(publicKey) &amp;&amp; publicKey.a.isOnCurve</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$listOf(AlgorithmIdentifier(BCObjectIdentifiers.sphincs256, DLSequence(arrayOf(ASN1Integer(0), SHA512_256))))</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$private</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$require(txId.sha256() in usedHashes) { "Transaction with id:$txId is not a leaf in the provided partial Merkle tree" }</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$return publicKey.a.toP3() == (EDDSA_ED25519_SHA512.algSpec as EdDSANamedCurveSpec).curve.getZero(GroupElement.Representation.P3)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$throw InvalidKeySpecException("This private key cannot be decoded, please ensure it is PKCS8 encoded and that " + "it corresponds to the input scheme's code name.", ikse)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$throw throw InvalidKeySpecException("This public key cannot be decoded, please ensure it is X509 encoded and " + "that it corresponds to the input scheme's code name.", ikse)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$val bytes = entropy.toByteArray().copyOf(params.curve.field.getb() / 8) // Need to pad the entropy to the valid seed length.</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$val keyPairGenerator = KeyPairGenerator.getInstance(signatureScheme.algorithmName, providerMap[signatureScheme.providerName])</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$val signableData = SignableData(originalSignedHash(txId, transactionSignature.partialMerkleTree), transactionSignature.signatureMetadata)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$val signature = Instances.getSignatureInstance(signatureScheme.signatureName, providerMap[signatureScheme.providerName])</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto${ // Compute HMAC(privateKey, seed). val macBytes = deriveHMAC(privateKey, seed) // Get the first EC curve fieldSized-bytes from macBytes. // According to recommendations from the deterministic ECDSA rfc, see https://tools.ietf.org/html/rfc6979 // performing a simple modular reduction would induce biases that would be detrimental to security. // Thus, the result is not reduced modulo q and similarly to BIP32, EC curve fieldSized-bytes are utilised. val fieldSizeMacBytes = macBytes.copyOf(parameterSpec.curve.fieldSize / 8) // Calculate value d for private key. val deterministicD = BigInteger(1, fieldSizeMacBytes) // Key generation checks follow the BC logic found in // https://github.com/bcgit/bc-java/blob/master/core/src/main/java/org/bouncycastle/crypto/generators/ECKeyPairGenerator.java // There is also an extra check to align with the BIP32 protocol, according to which // if deterministicD &gt;= order_of_the_curve the resulted key is invalid and we should proceed with another seed. // TODO: We currently use SHA256(seed) when retrying, but BIP32 just skips a counter (i) that results to an invalid key. // Although our hashing approach seems reasonable, we should check if there are alternatives, // especially if we use counters as well. if (deterministicD &lt; ECConstants.TWO || WNafUtil.getNafWeight(deterministicD) &lt; parameterSpec.n.bitLength().ushr(2) || deterministicD &gt;= parameterSpec.n) { // Instead of throwing an exception, we retry with SHA256(seed). return deriveKeyPairECDSA(parameterSpec, privateKey, seed.sha256().bytes) } val privateKeySpec = ECPrivateKeySpec(deterministicD, parameterSpec) val privateKeyD = BCECPrivateKey(privateKey.algorithm, privateKeySpec, BouncyCastleProvider.CONFIGURATION) // Compute the public key by scalar multiplication. // Note that BIP32 uses masterKey + mac_derived_key as the final private key and it consequently // requires an extra point addition: master_public + mac_derived_public for the public part. // In our model, the mac_derived_output, deterministicD, is not currently added to the masterKey and it // it forms, by itself, the new private key, which in turn is used to compute the new public key. val pointQ = FixedPointCombMultiplier().multiply(parameterSpec.g, deterministicD) // This is unlikely to happen, but we should check for point at infinity. if (pointQ.isInfinity) { // Instead of throwing an exception, we retry with SHA256(seed). return deriveKeyPairECDSA(parameterSpec, privateKey, seed.sha256().bytes) } val publicKeySpec = ECPublicKeySpec(pointQ, parameterSpec) val publicKeyD = BCECPublicKey(privateKey.algorithm, publicKeySpec, BouncyCastleProvider.CONFIGURATION) return KeyPair(publicKeyD, privateKeyD) }</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto${ val sigKey: SignatureScheme = Crypto.findSignatureScheme(keyPair.private) val sigMetaData: SignatureScheme = Crypto.findSignatureScheme(signableData.signatureMetadata.schemeNumberID) // Special handling if the advertised SignatureScheme is CompositeKey. // TODO fix notaries that advertise [CompositeKey] in their signature Metadata. Currently, clustered notary nodes // mention Crypto.COMPOSITE_KEY in their SignatureMetadata, but they are actually signing with a leaf-key // (and if they refer to it as a Composite key, then we lose info about the actual type of their signing key). // In short, their metadata should be the leaf key-type, until we support CompositeKey signatures. require(sigKey == sigMetaData || sigMetaData == Crypto.COMPOSITE_KEY) { "Metadata schemeCodeName: ${sigMetaData.schemeCodeName} is not aligned with the key type: ${sigKey.schemeCodeName}." } val signatureBytes = doSign(sigKey.schemeCodeName, keyPair.private, signableData.serialize().bytes) return TransactionSignature(signatureBytes, keyPair.public, signableData.signatureMetadata) }</ID>
    <ID>MaxLineLength:CryptoService.kt$SignOnlyCryptoService$ fun defaultIdentitySignatureScheme(): SignatureScheme</ID>
    <ID>MaxLineLength:CryptoService.kt$SignOnlyCryptoService$ fun defaultTLSSignatureScheme(): SignatureScheme</ID>
    <ID>MaxLineLength:CryptoServiceFactory.kt$CryptoServiceFactory.Companion$throw IllegalArgumentException("Currently only BouncyCastle is used as a crypto service. A valid signing certificate store is required.")</ID>
    <ID>MaxLineLength:CryptoSignUtils.kt$CryptoSignUtils</ID>
    <ID>MaxLineLength:CryptoSignUtils.kt$CryptoSignUtils$"Metadata schemeCodeName: ${sigMetaData.schemeCodeName} is not aligned with the key type: ${sigKey.schemeCodeName}."</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ // TODO: SignatureException should be used only for a damaged signature, as per `java.security.Signature.verify()`. @Throws(SignatureException::class, InvalidKeyException::class) fun PublicKey.verify(content: ByteArray, signature: DigitalSignature)</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @DeleteForDJVM @Throws(NoSuchAlgorithmException::class) fun newSecureRandom(): SecureRandom</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @DeleteForDJVM @Throws(NoSuchAlgorithmException::class) fun secureRandomBytes(numOfBytes: Int): ByteArray</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @DeleteForDJVM fun random63BitValue(): Long</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @Throws(InvalidKeyException::class, SignatureException::class) fun KeyPair.verify(signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @Throws(InvalidKeyException::class, SignatureException::class) fun PublicKey.verify(signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @Throws(SignatureException::class, InvalidKeyException::class) fun PublicKey.isValid(content: ByteArray, signature: DigitalSignature): Boolean</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun &lt;T : Any&gt; serializedHash(x: T): SecureHash</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun PublicKey.isFulfilledBy(otherKeys: Iterable&lt;PublicKey&gt;): Boolean</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun componentHash(nonce: SecureHash, opaqueBytes: OpaqueBytes): SecureHash</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun componentHash(opaqueBytes: OpaqueBytes, privacySalt: PrivacySalt, componentGroupIndex: Int, internalIndex: Int): SecureHash</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun computeNonce(privacySalt: PrivacySalt, groupIndex: Int, internalIndex: Int)</ID>
    <ID>MaxLineLength:CryptoUtils.kt$throw IllegalStateException("Verification of CompositeKey signatures currently not supported.")</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$assertEquals("DL9yJfiNGqteRrKPjGUkRQkeqzuQ4kwcYQWMCi5YKuUHrk", keyPairBiggerThan256bitsV2.public.toStringShort())</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$assertEquals("DLANmjhGSVdLyghxcPHrn3KuGatscf6LtvqifUDxw7SGU8", keyPairBiggerThan256bitsV2.public.toStringShort())</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$assertEquals("DLB9K1UiBrWonn481z6NzkqoWHjMBXpfDeaet3wiwRNWSU", keyPairBiggerThan256bitsV2.public.toStringShort())</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val expectedAlgSet = setOf("RSA_SHA256", "ECDSA_SECP256K1_SHA256", "ECDSA_SECP256R1_SHA256", "EDDSA_ED25519_SHA512", "SPHINCS-256_SHA512", "COMPOSITE")</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(258).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(258).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bits = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(258).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(258).minus(BigInteger("50")))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(258).minus(BigInteger("50")))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(258).minus(BigInteger("50")))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan258bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(259).plus(BigInteger.ONE))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan258bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(259).plus(BigInteger.ONE))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan258bits = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(259).plus(BigInteger.ONE))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan512bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(514).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan512bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(514).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan512bits = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(514).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val pubKeySpec = EdDSAPublicKeySpec((EDDSA_ED25519_SHA512.algSpec as EdDSANamedCurveSpec).curve.getZero(GroupElement.Representation.P3), EDDSA_ED25519_SHA512.algSpec as EdDSANamedCurveSpec)</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest${ val keyPairPositive = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("10")) assertEquals("DL6pYKUgH17az8MLdonvvUtUPN8TqwpCGcdgLr7vg3skCU", keyPairPositive.public.toStringShort()) // The underlying implementation uses the hash of entropy if it is out of range 2 &lt;= entropy &lt; N, where N the order of the group. val keyPairNegative = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("-10")) assertEquals("DLnpXhxece69Nyqgm3pPt3yV7ESQYDJKoYxs1hKgfBAEu", keyPairNegative.public.toStringShort()) val keyPairZero = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("0")) assertEquals("DLBC28e18T6KsYwjTFfUWJfhvHjvYVapyVf6antnqUkbgd", keyPairZero.public.toStringShort()) // BigIntenger.Zero is out or range, so 1 and hash(1.toByteArray) would have the same impact. val zeroHashed = BigInteger(1, BigInteger("0").toByteArray().sha256().bytes) // Check oneHashed &lt; N (order of the group), otherwise we would need an extra hash. assertEquals(-1, zeroHashed.compareTo((ECDSA_SECP256K1_SHA256.algSpec as ECNamedCurveParameterSpec).n)) val keyPairZeroHashed = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, zeroHashed) assertEquals("DLBC28e18T6KsYwjTFfUWJfhvHjvYVapyVf6antnqUkbgd", keyPairZeroHashed.public.toStringShort()) val keyPairOne = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("1")) assertEquals("DLBimRXdEQhJUTpL6f9ri9woNdsze6mwkRrhsML13Eh7ET", keyPairOne.public.toStringShort()) // BigIntenger.ONE is out or range, so 1 and hash(1.toByteArray) would have the same impact. val oneHashed = BigInteger(1, BigInteger("1").toByteArray().sha256().bytes) // Check oneHashed &lt; N (order of the group), otherwise we would need an extra hash. assertEquals(-1, oneHashed.compareTo((ECDSA_SECP256K1_SHA256.algSpec as ECNamedCurveParameterSpec).n)) val keyPairOneHashed = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, oneHashed) assertEquals("DLBimRXdEQhJUTpL6f9ri9woNdsze6mwkRrhsML13Eh7ET", keyPairOneHashed.public.toStringShort()) // 2 is in the range. val keyPairTwo = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2")) assertEquals("DLG32UWaevGw9YY7w1Rf9mmK88biavgpDnJA9bG4GapVPs", keyPairTwo.public.toStringShort()) // Try big numbers that are out of range. val keyPairBiggerThan256bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(258).minus(BigInteger.TEN)) assertEquals("DLGHsdv2xeAuM7n3sBc6mFfiphXe6VSf3YxqvviKDU6Vbd", keyPairBiggerThan256bits.public.toStringShort()) val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(258).minus(BigInteger("50"))) assertEquals("DL9yJfiNGqteRrKPjGUkRQkeqzuQ4kwcYQWMCi5YKuUHrk", keyPairBiggerThan256bitsV2.public.toStringShort()) val keyPairBiggerThan512bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(514).minus(BigInteger.TEN)) assertEquals("DL3Wr5EQGrMTaKBy5XMvG8rvSfKX1AYZLCRU8kixGbxt1E", keyPairBiggerThan512bits.public.toStringShort()) val keyPairBiggerThan258bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(259).plus(BigInteger.ONE)) assertEquals("DL7NbssqvuuJ4cqFkkaVYu9j1MsVswESGgCfbqBS9ULwuM", keyPairBiggerThan258bits.public.toStringShort()) }</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest${ val keyPairPositive = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("10")) assertEquals("DLHDcxuSt9J3cbjd2Dsx4rAgYYA7BAP7A8VLrFiq1tH9yy", keyPairPositive.public.toStringShort()) // The underlying implementation uses the hash of entropy if it is out of range 2 &lt; entropy &lt; N, where N the order of the group. val keyPairNegative = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("-10")) assertEquals("DLBASmjiMZuu1g3EtdHJxfSueXE8PRoUWbkdU61Qcnpamt", keyPairNegative.public.toStringShort()) val keyPairZero = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("0")) assertEquals("DLH2FEHEnsT3MpCJt2gfyNjpqRqcBxeupK4YRPXvDsVEkb", keyPairZero.public.toStringShort()) // BigIntenger.Zero is out or range, so 1 and hash(1.toByteArray) would have the same impact. val zeroHashed = BigInteger(1, BigInteger("0").toByteArray().sha256().bytes) // Check oneHashed &lt; N (order of the group), otherwise we would need an extra hash. assertEquals(-1, zeroHashed.compareTo((ECDSA_SECP256R1_SHA256.algSpec as ECNamedCurveParameterSpec).n)) val keyPairZeroHashed = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, zeroHashed) assertEquals("DLH2FEHEnsT3MpCJt2gfyNjpqRqcBxeupK4YRPXvDsVEkb", keyPairZeroHashed.public.toStringShort()) val keyPairOne = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("1")) assertEquals("DLHrtKwjv6onq9HcrQDJPs8Cgtai5mZU5ZU6sb1ivJjx3z", keyPairOne.public.toStringShort()) // BigIntenger.ONE is out or range, so 1 and hash(1.toByteArray) would have the same impact. val oneHashed = BigInteger(1, BigInteger("1").toByteArray().sha256().bytes) // Check oneHashed &lt; N (order of the group), otherwise we would need an extra hash. assertEquals(-1, oneHashed.compareTo((ECDSA_SECP256R1_SHA256.algSpec as ECNamedCurveParameterSpec).n)) val keyPairOneHashed = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, oneHashed) assertEquals("DLHrtKwjv6onq9HcrQDJPs8Cgtai5mZU5ZU6sb1ivJjx3z", keyPairOneHashed.public.toStringShort()) // 2 is in the range. val keyPairTwo = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2")) assertEquals("DLFoz6txJ3vHcKNSM1vFxHJUoEQ69PorBwW64dHsAnEoZB", keyPairTwo.public.toStringShort()) // Try big numbers that are out of range. val keyPairBiggerThan256bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(258).minus(BigInteger.TEN)) assertEquals("DLBv6fZqaCTbE4L7sgjbt19biXHMgU9CzR5s8g8XBJjZ11", keyPairBiggerThan256bits.public.toStringShort()) val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(258).minus(BigInteger("50"))) assertEquals("DLANmjhGSVdLyghxcPHrn3KuGatscf6LtvqifUDxw7SGU8", keyPairBiggerThan256bitsV2.public.toStringShort()) val keyPairBiggerThan512bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(514).minus(BigInteger.TEN)) assertEquals("DL9sKwMExBTD3MnJN6LWGqo496Erkebs9fxZtXLVJUBY9Z", keyPairBiggerThan512bits.public.toStringShort()) val keyPairBiggerThan258bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(259).plus(BigInteger.ONE)) assertEquals("DLBwjWwPJSF9E7b1NWaSbEJ4oK8CF7RDGWd648TiBhZoL1", keyPairBiggerThan258bits.public.toStringShort()) }</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest${ val keyPairPositive = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("10")) assertEquals("DLBL3iHCp9uRReWhhCGfCsrxZZpfAm9h9GLbfN8ijqXTq", keyPairPositive.public.toStringShort()) val keyPairNegative = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("-10")) assertEquals("DLC5HXnYsJAFqmM9hgPj5G8whQ4TpyE9WMBssqCayLBwA2", keyPairNegative.public.toStringShort()) val keyPairZero = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("0")) assertEquals("DL4UVhGh4tqu1G86UVoGNaDDNCMsBtNHzE6BSZuNNJN7W2", keyPairZero.public.toStringShort()) val keyPairOne = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("1")) assertEquals("DL8EZUdHixovcCynKMQzrMWBnXQAcbVDHi6ArPphqwJVzq", keyPairOne.public.toStringShort()) val keyPairBiggerThan256bits = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(258).minus(BigInteger.TEN)) assertEquals("DLB9K1UiBrWonn481z6NzkqoWHjMBXpfDeaet3wiwRNWSU", keyPairBiggerThan256bits.public.toStringShort()) // The underlying implementation uses the first 256 bytes of the entropy. Thus, 2^258-10 and 2^258-50 and 2^514-10 have the same impact. val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(258).minus(BigInteger("50"))) assertEquals("DLB9K1UiBrWonn481z6NzkqoWHjMBXpfDeaet3wiwRNWSU", keyPairBiggerThan256bitsV2.public.toStringShort()) val keyPairBiggerThan512bits = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(514).minus(BigInteger.TEN)) assertEquals("DLB9K1UiBrWonn481z6NzkqoWHjMBXpfDeaet3wiwRNWSU", keyPairBiggerThan512bits.public.toStringShort()) // Try another big number. val keyPairBiggerThan258bits = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(259).plus(BigInteger.ONE)) assertEquals("DL5tEFVMXMGrzwjfCAW34JjkhsRkPfFyJ38iEnmpB6L2Z9", keyPairBiggerThan258bits.public.toStringShort()) }</ID>
    <ID>MaxLineLength:Currencies.kt$infix fun Amount&lt;Currency&gt;.issuedBy(deposit: PartyAndReference)</ID>
    <ID>MaxLineLength:CurrencyParameterSensitivitiesSerializer.kt$CurrencyParameterSensitivitiesSerializer$override fun fromProxy(proxy: Proxy): CurrencyParameterSensitivities</ID>
    <ID>MaxLineLength:CurrencyParameterSensitivitySerialiser.kt$CurrencyParameterSensitivitySerializer$override fun toProxy(obj: CurrencyParameterSensitivity)</ID>
    <ID>MaxLineLength:CustomCordapp.kt$CustomCordapp : TestCordappInternal</ID>
    <ID>MaxLineLength:CustomCordapp.kt$CustomCordapp$jos.addEntry(testEntry(JarFile.MANIFEST_NAME)) { createTestManifest(name, versionId, targetPlatformVersion).write(jos) } // The same resource may be found in different locations (this will happen when running from gradle) so just // pick the first one found. scanResult.allResources.asMap().forEach { path, resourceList -&gt; jos.addEntry(testEntry(path), resourceList[0].open()) }</ID>
    <ID>MaxLineLength:CustomCordapp.kt$CustomCordapp$return ZipEntry(name).setCreationTime(epochFileTime).setLastAccessTime(epochFileTime).setLastModifiedTime(epochFileTime)</ID>
    <ID>MaxLineLength:CustomCordapp.kt$CustomCordapp.Companion$val filename = it.run { "${name.replace(whitespace, "-")}_${versionId}_${targetPlatformVersion}_${UUID.randomUUID()}.jar" }</ID>
    <ID>MaxLineLength:CustomCordappTest.kt$CustomCordappTest$val cordapp = cordappWithPackages("net.corda.testing.node.internal").copy(targetPlatformVersion = 123, name = "CustomCordappTest")</ID>
    <ID>MaxLineLength:CustomNotaryTest.kt$CustomNotaryTest$CustomNotaryService : NotaryService</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer$/** * This exists purely for documentation and cross-platform purposes. It is not used by our serialization / deserialization * code path. */ abstract val schemaForDocumentation: Schema</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer$Implements&lt;T : Any&gt; : CustomSerializerImp</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer$Proxy&lt;T : Any, P : Any&gt; : CustomSerializerImp</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer$SubClass&lt;T : Any&gt; : CustomSerializer</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer.CustomSerializerImp$abstract</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer.CustomSerializerImp$override fun isSerializerFor(clazz: Class&lt;*&gt;): Boolean</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer.Proxy$override fun isSerializerFor(clazz: Class&lt;*&gt;): Boolean</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer.Proxy$private val proxySerializer: ObjectSerializer by lazy { ObjectSerializer.make(factory.getTypeInformation(proxyClass), factory) }</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer.ToString$listOf</ID>
    <ID>MaxLineLength:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$constructor(descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry) : this(descriptorBasedSerializerRegistry, emptySet())</ID>
    <ID>MaxLineLength:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$logger.warn("Duplicate custom serializers detected for $clazz: ${declaredSerializers.map { it::class.qualifiedName }}")</ID>
    <ID>MaxLineLength:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$logger.warn("Illegal custom serializer detected for $clazz: ${declaredSerializers.first()::class.qualifiedName}")</ID>
    <ID>MaxLineLength:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$private val customSerializersCache: MutableMap&lt;CustomSerializerIdentifier, CustomSerializerLookupResult&gt; = DefaultCacheProvider.createCache()</ID>
    <ID>MaxLineLength:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry.CustomSerializerLookupResult$CustomSerializerFound : CustomSerializerLookupResult</ID>
    <ID>MaxLineLength:CustomSerializerRegistry.kt$DuplicateCustomSerializerException : Exception</ID>
    <ID>MaxLineLength:CustomSerializerRegistryTests.kt$CustomSerializerRegistryTests$TestCustomSerializer : CustomSerializer</ID>
    <ID>MaxLineLength:CustomSerializerRegistryTests.kt$CustomSerializerRegistryTests$private fun CustomSerializerRegistry.find(clazz: Class&lt;*&gt;): AMQPSerializer&lt;Any&gt;</ID>
    <ID>MaxLineLength:CustomVaultQuery.kt$TopupIssuerFlow.TopupIssuanceRequester$return initiateFlow(issuerBankParty).sendAndReceive&lt;List&lt;AbstractCashFlow.Result&gt;&gt;(topupRequest).unwrap { it }</ID>
    <ID>MaxLineLength:CustomVaultQuery.kt$TopupIssuerFlow.TopupIssuer$val txn = issueCashTo(amount, topupRequest.issueToParty, topupRequest.issuerPartyRef, topupRequest.notaryParty)</ID>
    <ID>MaxLineLength:CustomVaultQuery.kt$TopupIssuerFlow.TopupIssuer${ // invoke Cash subflow to issue Asset progressTracker.currentStep = ISSUING val issueCashFlow = CashIssueFlow(amount, issuerPartyRef, notaryParty) val issueTx = subFlow(issueCashFlow) // NOTE: issueCashFlow performs a Broadcast (which stores a local copy of the txn to the ledger) // short-circuit when issuing to self if (serviceHub.myInfo.isLegalIdentity(issueTo)) return issueTx // now invoke Cash subflow to Move issued assetType to issue requester progressTracker.currentStep = TRANSFERRING val moveCashFlow = CashPaymentFlow(amount, issueTo, anonymous = false) // NOTE: CashFlow PayCash calls FinalityFlow which performs a Broadcast (which stores a local copy of the txn to the ledger) return subFlow(moveCashFlow) }</ID>
    <ID>MaxLineLength:CustomVaultQueryTest.kt$CustomVaultQueryTest$mockNet = MockNetwork(threadPerNode = true, cordappPackages = listOf("net.corda.finance", IOUFlow::class.packageName, javaClass.packageName, "com.template"))</ID>
    <ID>MaxLineLength:DBCheckpointStorageTests.kt$DBCheckpointStorageTests$CheckpointVerifier.verifyCheckpointsCompatible(checkpointStorage, emptyList(), 1, mockServices, emptyList())</ID>
    <ID>MaxLineLength:DBCheckpointStorageTests.kt$DBCheckpointStorageTests$val checkpoint = Checkpoint.create(InvocationContext.shell(), FlowStart.Explicit, logic.javaClass, frozenLogic, ALICE, SubFlowVersion.CoreFlow(version), false) .getOrThrow()</ID>
    <ID>MaxLineLength:DBNetworkParametersStorage.kt$DBNetworkParametersStorage$log.warn("Tried to download historical network parameters with hash $parametersHash, but network map url isn't configured")</ID>
    <ID>MaxLineLength:DBNetworkParametersStorage.kt$DBNetworkParametersStorage.Companion$PersistentNetworkParameters</ID>
    <ID>MaxLineLength:DBNetworkParametersStorage.kt$DBNetworkParametersStorage.Companion$fun createParametersMap(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;SecureHash, SignedDataWithCert&lt;NetworkParameters&gt;, PersistentNetworkParameters, String&gt;</ID>
    <ID>MaxLineLength:DBNetworkParametersStorage.kt$DBNetworkParametersStorage.PersistentNetworkParameters$( @Id @Column(name = "hash", length = MAX_HASH_HEX_SIZE, nullable = false) val hash: String = "", @Column(name = "epoch", nullable = false) val epoch: Int = 0, // Stored as serialized bytes because network parameters structure evolves over time. @Lob @Column(name = "parameters_bytes", nullable = false) val networkParametersBytes: ByteArray = ArrayUtils.EMPTY_BYTE_ARRAY, @Lob @Column(name = "signature_bytes", nullable = false) private val signature: ByteArray = ArrayUtils.EMPTY_BYTE_ARRAY, // First certificate in the certificate chain. @Lob @Column(name = "cert", nullable = false) private val certificate: ByteArray = ArrayUtils.EMPTY_BYTE_ARRAY, // Parent certificate path (the first one is stored separately), so node is agnostic to certificate hierarchy. @Lob @Column(name = "parent_cert_path", nullable = false) private val certPath: ByteArray = ArrayUtils.EMPTY_BYTE_ARRAY )</ID>
    <ID>MaxLineLength:DBNetworkParametersStorage.kt$DBNetworkParametersStorage.PersistentNetworkParameters$val signWithCert = DigitalSignatureWithCert(X509CertificateFactory().generateCertificate(certificate.inputStream()), certChain, signature)</ID>
    <ID>MaxLineLength:DBNetworkParametersStorageTest.kt$DBNetworkParametersStorageTest$incorrectParams = createDevNetworkMapCa(DEV_INTERMEDIATE_CA).sign(testNetworkParameters(minimumPlatformVersion = 3))</ID>
    <ID>MaxLineLength:DBNetworkParametersStorageTest.kt$DBNetworkParametersStorageTest$it.contains("Caused by: java.security.cert.CertPathValidatorException: subject/issuer name chaining check failed")</ID>
    <ID>MaxLineLength:DBNetworkParametersStorageTest.kt$DBNetworkParametersStorageTest$networkParametersService</ID>
    <ID>MaxLineLength:DBRunnerExtension.kt$DBRunnerExtension : ExtensionBeforeAllCallbackAfterAllCallbackBeforeEachCallbackAfterEachCallback</ID>
    <ID>MaxLineLength:DBRunnerExtension.kt$DBRunnerExtension$if (annotationClass.isAssignableFrom(annotation::class.java)) sequenceOf(annotationClass.cast(annotation)) else annotation.annotationClass.java.findAnnotations(annotationClass)</ID>
    <ID>MaxLineLength:DBRunnerExtension.kt$DBRunnerExtension$private</ID>
    <ID>MaxLineLength:DBRunnerExtension.kt$DBRunnerExtension$private val AnnotatedElement.requiredSql: List&lt;String&gt; get() = findAnnotations(RequiresSql::class.java).map { it.name }.toList()</ID>
    <ID>MaxLineLength:DBRunnerExtension.kt$DBRunnerExtension$val store = rootContext.getStore(ExtensionContext.Namespace.create(DBRunnerExtension::class.java.simpleName, groupName))</ID>
    <ID>MaxLineLength:DBTransactionMappingStorage.kt$DBTransactionMappingStorage : StateMachineRecordedTransactionMappingStorage</ID>
    <ID>MaxLineLength:DBTransactionMappingStorage.kt$DBTransactionMappingStorage$cq.multiselect(from.get&lt;String&gt;(DBTransactionStorage.DBTransaction::stateMachineRunId.name), from.get&lt;String&gt;(DBTransactionStorage.DBTransaction::txId.name))</ID>
    <ID>MaxLineLength:DBTransactionMappingStorage.kt$DBTransactionMappingStorage$override</ID>
    <ID>MaxLineLength:DBTransactionMappingStorage.kt$DBTransactionMappingStorage$val flowIds = session.createQuery(cq).resultList.map { StateMachineTransactionMapping(StateMachineRunId(UUID.fromString(it[0] as String)), SecureHash.parse(it[1] as String)) }</ID>
    <ID>MaxLineLength:DBTransactionStorage.kt$DBTransactionStorage : WritableTransactionStorageSingletonSerializeAsToken</ID>
    <ID>MaxLineLength:DBTransactionStorage.kt$DBTransactionStorage$criteriaBuilder.equal(updateRoot.get&lt;TransactionStatus&gt;(DBTransaction::status.name), TransactionStatus.UNVERIFIED)</ID>
    <ID>MaxLineLength:DBTransactionStorage.kt$DBTransactionStorage$logger.debug { "Transaction ${transaction.id} is already recorded as verified, so no need to re-record" }</ID>
    <ID>MaxLineLength:DBTransactionStorage.kt$DBTransactionStorage.Companion$return if (effectiveSerializationEnv.serializationFactory.currentContext?.useCase == SerializationContext.UseCase.Storage) { effectiveSerializationEnv.serializationFactory.currentContext!! } else { SerializationDefaults.STORAGE_CONTEXT }</ID>
    <ID>MaxLineLength:DBTransactionStorage.kt$DBTransactionStorage.Companion$transaction = value.toSignedTx().serialize(context = contextToUse().withEncoding(SNAPPY)).bytes</ID>
    <ID>MaxLineLength:DBTransactionStorage.kt$DBTransactionStorage.TransactionStatus$UnexpectedStatusValueException : Exception</ID>
    <ID>MaxLineLength:DBTransactionStorageTests.kt$DBTransactionStorageTests$listOf(TransactionSignature(ByteArray(1), ALICE_PUBKEY, SignatureMetadata(1, Crypto.findSignatureScheme(ALICE_PUBKEY).schemeNumberID)))</ID>
    <ID>MaxLineLength:DataSourceFactory.kt$DataSourceFactory$fun createDataSource(hikariProperties: Properties, pool: Boolean = true, metricRegistry: MetricRegistry? = null): DataSource</ID>
    <ID>MaxLineLength:DatabaseTransaction.kt$get() = contextTransactionOrNull ?: error("Was expecting to find transaction set on current strand: ${Strand.currentStrand()}")</ID>
    <ID>MaxLineLength:DatabaseTransaction.kt$get() = if (_prohibitDatabaseAccess.get() == true) throw IllegalAccessException("Database access is disabled in this context.") else _contextTransaction.get()</ID>
    <ID>MaxLineLength:DbExceptionHandler.kt$DbExceptionHandler : UncaughtExceptionHandler</ID>
    <ID>MaxLineLength:DbExceptionHandler.kt$DbExceptionHandler$errorAndTerminate("Thread ${t!!.name} failed due to database connection error. This is unrecoverable, terminating node.", e)</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$// First clean up any remains from previous test runs persistence.transaction { session.createNativeQuery("delete from locktestobjects").executeUpdate() session.createNativeQuery("delete from otherlockobjects").executeUpdate() } // Prepare a few rows for reading in table 1 val prepMap = AppendOnlyPersistentMap&lt;TestKey, Int, MyPersistenceClass, Int&gt;( cacheFactory, "myTestCache", { k -&gt; k.value }, { e -&gt; Pair(TestKey(e.key), e.value) }, { k, v -&gt; MyPersistenceClass(k.value, v) }, MyPersistenceClass::class.java ) persistence.transaction { prepMap.set(TestKey(1), 1) prepMap.set(TestKey(2), 2) prepMap.set(TestKey(10), 10) } // the map that will read from the prepared table val testMap = AppendOnlyPersistentMap&lt;TestKey, Int, MyPersistenceClass, Int&gt;( cacheFactory, "myTestCache", { k -&gt; k.value }, { e -&gt; Pair(TestKey(e.key), e.value) }, { k, v -&gt; MyPersistenceClass(k.value, v) }, MyPersistenceClass::class.java ) // a second map that writes to another (unrelated table) val otherMap = AppendOnlyPersistentMap&lt;TestKey, Int, SecondPersistenceClass, Int&gt;( cacheFactory, "myTestCache", { k -&gt; k.value }, { e -&gt; Pair(TestKey(e.key), e.value) }, { k, v -&gt; SecondPersistenceClass(k.value, v) }, SecondPersistenceClass::class.java ) val latch1 = CyclicBarrier(2) val latch2 = CountDownLatch(1) val latch3 = CyclicBarrier(2) val otherThreadException = AtomicReference&lt;Exception?&gt;(null) // This thread will wait for the main thread to do a few things. Then it will starting to read key 2, and write a key to // the second table. This read will be buffered (not flushed) at first. The subsequent access to read value 10 fromt the // first table will cause the previous write to flush. As the row this will be writing to should be locked from the main // thread, it will wait for the main thread's db transaction to commit or rollback before proceeding with the read. val otherThread = thread(name = "testThread2") { try { log.info("Thread2 waiting") latch1.await() latch2.await() log.info("Thread2 starting transaction") persistence.transaction { log.info("Thread2 getting key 2") testMap.get(TestKey(2)) log.info("Thread2 set other value 100") otherMap.set(TestKey(100), 100) latch3.await() log.info("Thread2 getting value 10") val v = testMap.get(TestKey(10)) assertEquals(10, v) } log.info("Thread2 done") } catch (e: Exception) { log.info("Thread2 threw") // Don't log the exception though, since we expect it and check in the assertions what it is. otherThreadException.set(e) } } log.info("MainThread waiting for Thread2 to start waiting") latch1.await() // The main thread will write to the same key in the second table, and then read key 1 from the read table. As it will do that // before triggering the run on thread 2, it will get the row lock in the second table when flushing before the read, then // read and carry on. log.info("MainThread starting transaction") persistence.transaction { log.info("MainThread getting key 2") testMap.get(TestKey(2)) log.info("MainThread set other key 100") otherMap.set(TestKey(100), 100) log.info("MainThread getting key 1") testMap.get(TestKey(1)) // Then it will trigger the start of the second thread (see above) and then sleep for a bit to make sure the other // thread actually runs and beats this thread to the get(10). The test will still pass if it doesn't. log.info("MainThread signal") latch2.countDown() log.info("MainThread wait for Thread2 to be getting the same key") latch3.await() log.info("MainThread sleep for 2 seconds so ideally Thread2 reaches the get first") sleep(2000) // finally it will try to get the same value from the read table that the other thread is trying to read. // If access to reading this value from the DB is guarded by a lock, the other thread will be holding this lock // which means the threads are now deadlocked. log.info("MainThread get value 10") try { assertEquals(10, testMap.get(TestKey(10))) } catch (e: Exception) { checkException(e) } } log.info("MainThread joining with Thread2") otherThread.join() assertNotNull(otherThreadException.get()) checkException(otherThreadException.get()) log.info("MainThread done")</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$// We have to catch any exception thrown and check what they are - primary key constraint violations are fine, we are trying // to insert the same key twice after all. Any deadlock time outs or similar are completely not fine and should be a test failure. private fun checkException(exception: Exception?)</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$createCordaPersistence(dbConfig, { null }, { null }, schemaService, hikariProperties, cacheFactory, null)</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$it.setProperty("dataSource.url", "jdbc:h2:file:${temporaryFolder.root}/persistence;DB_CLOSE_ON_EXIT=FALSE;WRITE_DELAY=0;LOCK_TIMEOUT=10000")</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$log.info("MainThread getting key 2") testMap.get(TestKey(2)) log.info("MainThread set other key 100") otherMap.set(TestKey(100), 100) log.info("MainThread getting key 1") testMap.get(TestKey(1)) // Then it will trigger the start of the second thread (see above) and then sleep for a bit to make sure the other // thread actually runs and beats this thread to the get(10). The test will still pass if it doesn't. log.info("MainThread signal") latch2.countDown() log.info("MainThread wait for Thread2 to be getting the same key") latch3.await() log.info("MainThread sleep for 2 seconds so ideally Thread2 reaches the get first") sleep(2000) // finally it will try to get the same value from the read table that the other thread is trying to read. // If access to reading this value from the DB is guarded by a lock, the other thread will be holding this lock // which means the threads are now deadlocked. log.info("MainThread get value 10") try { assertEquals(10, testMap.get(TestKey(10))) } catch (e: Exception) { checkException(e) }</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$log.info("Thread2 threw")</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$startHikariPool(hikariProperties, dbConfig, schemaService.schemaOptions.keys, ourName = TestIdentity(ALICE_NAME, 70).name)</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$val dbConfig = DatabaseConfig(initialiseSchema = true, transactionIsolationLevel = TransactionIsolationLevel.READ_COMMITTED)</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$LockDbSchemaV2 : MappedSchema</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver$TopologicalSort</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver$logger.debug { "Downloaded ${sortedDependencies?.size} dependencies from remote peer for transactions ${flow.txHashes}" }</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver$val (existingTxIds, downloadedTxs) = fetchRequiredTransactions(Collections.singleton(nextRequests.first())) // Fetch first item only</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver$val nextRequests = LinkedHashSet&lt;SecureHash&gt;(flow.txHashes) // Keep things unique but ordered, for unit test stability.</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver${ // Don't re-download the same tx when we haven't verified it yet but it's referenced multiple times in the // graph we're traversing. nextRequests.removeAll(topologicalSort.transactionIds) if (nextRequests.isEmpty()) { // Done early. break } // Request the standalone transaction data (which may refer to things we don't yet have). val (existingTxIds, downloadedTxs) = fetchRequiredTransactions(Collections.singleton(nextRequests.first())) // Fetch first item only for (tx in downloadedTxs) { val dependencies = tx.dependencies topologicalSort.add(tx.id, dependencies) } var suspended = true for (downloaded in downloadedTxs) { suspended = false val dependencies = downloaded.dependencies // Do not keep in memory as this bloats the checkpoint. Write each item to the database. transactionStorage.addUnverifiedTransaction(downloaded) // The write locks are only released over a suspend, so need to keep track of whether the flow has been suspended to ensure // that locks are not held beyond each while loop iteration (as doing this would result in a deadlock due to claiming locks // in the wrong order) val suspendedViaAttachments = flow.fetchMissingAttachments(downloaded) val suspendedViaParams = flow.fetchMissingNetworkParameters(downloaded) suspended = suspended || suspendedViaAttachments || suspendedViaParams // Add all input states and reference input states to the work queue. nextRequests.addAll(dependencies) } // If the flow did not suspend on the last iteration of the downloaded loop above, perform a suspend here to ensure no write // locks are held going into the next while loop iteration. if (!suspended) { FlowLogic.sleep(0.seconds) } // It's possible that the node has a transaction in storage already. Dependencies should also be present for this transaction, // so just remove these IDs from the set of next requests. nextRequests.removeAll(existingTxIds) }</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver${ suspended = false val dependencies = downloaded.dependencies // Do not keep in memory as this bloats the checkpoint. Write each item to the database. transactionStorage.addUnverifiedTransaction(downloaded) // The write locks are only released over a suspend, so need to keep track of whether the flow has been suspended to ensure // that locks are not held beyond each while loop iteration (as doing this would result in a deadlock due to claiming locks // in the wrong order) val suspendedViaAttachments = flow.fetchMissingAttachments(downloaded) val suspendedViaParams = flow.fetchMissingNetworkParameters(downloaded) suspended = suspended || suspendedViaAttachments || suspendedViaParams // Add all input states and reference input states to the work queue. nextRequests.addAll(dependencies) }</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver.TopologicalSort$// Note that we use a LinkedHashSet here to make the traversal deterministic (as long as the input list is). val deDupeIt = dedupe(it) forwardGraph.computeIfAbsent(deDupeIt) { LinkedHashSet() }.add(txId)</ID>
    <ID>MaxLineLength:DeduplicationId.kt$SenderDeduplicationId</ID>
    <ID>MaxLineLength:DefaultKryoCustomizer.kt$DefaultKryoCustomizer$// Store a little schema of field names in the stream the first time a class is used which increases tolerance // for change to a class. setDefaultSerializer(CompatibleFieldSerializer::class.java) // Take the safest route here and allow subclasses to have fields named the same as super classes. fieldSerializerConfig.cachedFieldNameStrategy = FieldSerializer.CachedFieldNameStrategy.EXTENDED instantiatorStrategy = CustomInstantiatorStrategy() // Required for HashCheckingStream (de)serialization. // Note that return type should be specifically set to InputStream, otherwise it may not work, i.e. val aStream : InputStream = HashCheckingStream(...). addDefaultSerializer(InputStream::class.java, InputStreamSerializer) addDefaultSerializer(SerializeAsToken::class.java, SerializeAsTokenSerializer&lt;SerializeAsToken&gt;()) addDefaultSerializer(Logger::class.java, LoggerSerializer) addDefaultSerializer(X509Certificate::class.java, X509CertificateSerializer) // WARNING: reordering the registrations here will cause a change in the serialized form, since classes // with custom serializers get written as registration ids. This will break backwards-compatibility. // Please add any new registrations to the end. // TODO: re-organise registrations into logical groups before v1.0 register(Arrays.asList("").javaClass, ArraysAsListSerializer()) register(LazyMappedList::class.java, LazyMappedListSerializer) register(SignedTransaction::class.java, SignedTransactionSerializer) register(WireTransaction::class.java, WireTransactionSerializer) register(SerializedBytes::class.java, SerializedBytesSerializer) UnmodifiableCollectionsSerializer.registerSerializers(this) ImmutableListSerializer.registerSerializers(this) ImmutableSetSerializer.registerSerializers(this) ImmutableSortedSetSerializer.registerSerializers(this) ImmutableMapSerializer.registerSerializers(this) ImmutableMultimapSerializer.registerSerializers(this) // InputStream subclasses whitelisting, required for attachments. register(BufferedInputStream::class.java, InputStreamSerializer) register(Class.forName("sun.net.www.protocol.jar.JarURLConnection\$JarURLInputStream"), InputStreamSerializer) noReferencesWithin&lt;WireTransaction&gt;() register(ECPublicKeyImpl::class.java, publicKeySerializer) register(EdDSAPublicKey::class.java, publicKeySerializer) register(EdDSAPrivateKey::class.java, PrivateKeySerializer) register(CompositeKey::class.java, publicKeySerializer) // Using a custom serializer for compactness // Exceptions. We don't bother sending the stack traces as the client will fill in its own anyway. register(Array&lt;StackTraceElement&gt;::class, read = { _, _ -&gt; emptyArray() }, write = { _, _, _ -&gt; }) // This ensures a NonEmptySetSerializer is constructed with an initial value. register(NonEmptySet::class.java, NonEmptySetSerializer) register(BitSet::class.java, BitSetSerializer()) register(Class::class.java, ClassSerializer) register(FileInputStream::class.java, InputStreamSerializer) register(CertPath::class.java, CertPathSerializer) register(X509CertPath::class.java, CertPathSerializer) register(BCECPrivateKey::class.java, PrivateKeySerializer) register(BCECPublicKey::class.java, publicKeySerializer) register(BCRSAPrivateCrtKey::class.java, PrivateKeySerializer) register(BCRSAPublicKey::class.java, publicKeySerializer) register(BCSphincs256PrivateKey::class.java, PrivateKeySerializer) register(BCSphincs256PublicKey::class.java, publicKeySerializer) register(NotaryChangeWireTransaction::class.java, NotaryChangeWireTransactionSerializer) register(PartyAndCertificate::class.java, PartyAndCertificateSerializer) // Don't deserialize PrivacySalt via its default constructor. register(PrivacySalt::class.java, PrivacySaltSerializer) // Used by the remote verifier, and will possibly be removed in future. register(ContractAttachment::class.java, ContractAttachmentSerializer) register(java.lang.invoke.SerializedLambda::class.java) register(ClosureSerializer.Closure::class.java, CordaClosureBlacklistSerializer) register(ContractUpgradeWireTransaction::class.java, ContractUpgradeWireTransactionSerializer) register(ContractUpgradeFilteredTransaction::class.java, ContractUpgradeFilteredTransactionSerializer) for (whitelistProvider in serializationWhitelists) { val types = whitelistProvider.whitelist require(types.toSet().size == types.size) { val duplicates = types.toMutableList() types.toSet().forEach { duplicates -= it } "Cannot add duplicate classes to the whitelist ($duplicates)." } for (type in types) { ((kryo.classResolver as? CordaClassResolver)?.whitelist as? MutableClassWhitelist)?.add(type) } }</ID>
    <ID>MaxLineLength:DefaultKryoCustomizer.kt$DefaultKryoCustomizer$register(Class.forName("sun.net.www.protocol.jar.JarURLConnection\$JarURLInputStream"), InputStreamSerializer)</ID>
    <ID>MaxLineLength:DefaultKryoCustomizer.kt$DefaultKryoCustomizer.ContractAttachmentSerializer$return ContractAttachment.create(lazyAttachment, contract, additionalContracts, uploader, signers, version)</ID>
    <ID>MaxLineLength:DefaultKryoCustomizer.kt$DefaultKryoCustomizer.CustomInstantiatorStrategy$val strat = if (type.name.startsWith("java.") &amp;&amp; !isPublic(type.modifiers)) fallbackStrategy else defaultStrategy</ID>
    <ID>MaxLineLength:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$Action.SendExisting(initiatedSession.peerParty, existingMessage, SenderDeduplicationId(deduplicationId, startingState.senderUUID))</ID>
    <ID>MaxLineLength:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$is FlowException -&gt; DeclaredField&lt;Party?&gt;(FlowException::class.java, "peer", exception).value = sessionState.peerParty</ID>
    <ID>MaxLineLength:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$pendingDeduplicationHandlers = currentState.pendingDeduplicationHandlers + event.deduplicationHandler</ID>
    <ID>MaxLineLength:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$sessions = checkpoint.sessions + (sessionId to sessionState.copy(rejectionError = flowError))</ID>
    <ID>MaxLineLength:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$sessions = currentState.checkpoint.sessions + (event.sessionMessage.recipientSessionId to initiatedSession)</ID>
    <ID>MaxLineLength:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$sessions = startingState.checkpoint.sessions + (event.sessionMessage.recipientSessionId to newSessionState)</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput$"Existing reference type mismatch. Expected: '$type', found: '${objectRetrieved::class.java}' "</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput$@VisibleForTesting @Throws(AMQPNoTypeNotSerializableException::class) fun getEnvelope(byteSequence: ByteSequence, context: SerializationContext)</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput$clazz</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput$if (type != TypeIdentifier.UnknownType.getLocalType() &amp;&amp; serializer.type != type &amp;&amp; with(serializer.type) { !isSubClassOf(type) &amp;&amp; !materiallyEquivalentTo(type) } ) { throw AMQPNotSerializableException( type, "Described type with descriptor ${obj.descriptor} was " + "expected to be of type $type but was ${serializer.type}") }</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput$throw NotSerializableException("Internal deserialization failure: ${e.javaClass.name}: ${e.message}").apply { initCause(e) }</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput${ // It must be a reference to an instance that has already been read, cheaply and quickly returning it by reference. val objectIndex = (obj.described as UnsignedInteger).toInt() if (objectIndex &gt;= objectHistory.size) throw AMQPNotSerializableException( type, "Retrieval of existing reference failed. Requested index $objectIndex " + "is outside of the bounds for the list of size: ${objectHistory.size}") val objectRetrieved = objectHistory[objectIndex] if (!objectRetrieved::class.java.isSubClassOf(type.asClass())) { throw AMQPNotSerializableException( type, "Existing reference type mismatch. Expected: '$type', found: '${objectRetrieved::class.java}' " + "@ $objectIndex") } objectRetrieved }</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput.Companion$@Throws(AMQPNoTypeNotSerializableException::class) fun getEnvelope(byteSequence: ByteSequence, encodingWhitelist: EncodingWhitelist = NullEncodingWhitelist): Envelope</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput.Companion$throw AMQPNoTypeNotSerializableException(encodingNotPermittedFormat.format(encoding))</ID>
    <ID>MaxLineLength:DeserializeAndReturnEnvelopeTests.kt$DeserializeAndReturnEnvelopeTests$assertEquals(null, obj.envelope.schema.types.find { it.name == "java.lang.Comparable&lt;${classTestName("Foo")}&gt;" })</ID>
    <ID>MaxLineLength:DeserializeMapTests.kt$DeserializeMapTests$Assertions.assertThatThrownBy { TestSerializationOutput(VERBOSE, sf).serialize(c) } .isInstanceOf(IllegalArgumentException::class.java)</ID>
    <ID>MaxLineLength:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$val classInstance = outerClass.constructors.first().newInstance(nestedClass.constructors.first().newInstance("name"))</ID>
    <ID>MaxLineLength:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests${ val testVal = 10 val clazz = ClassCarpenterImpl(whitelist = AllWhitelist).build(ClassSchema(testName(), mapOf("a" to NonNullableField(Int::class.java)))) val classInstance = clazz.constructors[0].newInstance(testVal) val serialisedBytes = TestSerializationOutput(VERBOSE, sf1).serialize(classInstance) val deserializedObj1 = DeserializationInput(sf1).deserialize(serialisedBytes) assertEquals(clazz, deserializedObj1::class.java) assertEquals(testVal, deserializedObj1::class.java.getMethod("getA").invoke(deserializedObj1)) val deserializedObj2 = DeserializationInput(sf1).deserialize(serialisedBytes) assertEquals(clazz, deserializedObj2::class.java) assertEquals(deserializedObj1::class.java, deserializedObj2::class.java) assertEquals(testVal, deserializedObj2::class.java.getMethod("getA").invoke(deserializedObj2)) val deserializedObj3 = DeserializationInput(sf2).deserializeWithoutAndWithCarpenter(serialisedBytes) assertNotEquals(clazz, deserializedObj3::class.java) assertNotEquals(deserializedObj1::class.java, deserializedObj3::class.java) assertNotEquals(deserializedObj2::class.java, deserializedObj3::class.java) assertEquals(testVal, deserializedObj3::class.java.getMethod("getA").invoke(deserializedObj3)) // NOTE: There is no point attempting this without the carepenter a second time as having carpented things up once // it will, of course, just succeed even with the carpenter disabled val deserializedObj4 = DeserializationInput(sf2).deserialize(serialisedBytes) assertNotEquals(clazz, deserializedObj4::class.java) assertNotEquals(deserializedObj1::class.java, deserializedObj4::class.java) assertNotEquals(deserializedObj2::class.java, deserializedObj4::class.java) assertEquals(deserializedObj3::class.java, deserializedObj4::class.java) assertEquals(testVal, deserializedObj4::class.java.getMethod("getA").invoke(deserializedObj4)) }</ID>
    <ID>MaxLineLength:DeserializeQueryableStateTest.kt$DeserializeQueryableStateTest$val clientContext = AMQP_RPC_CLIENT_CONTEXT.copy(whitelist = AllWhitelist, deserializationClassLoader = ClassLoaderWithoutTestState(ClassLoader.getSystemClassLoader()))</ID>
    <ID>MaxLineLength:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$garbo [class </ID>
    <ID>MaxLineLength:DevCertificatesTest.kt$DevCertificatesTest$val oldNodeCaKeyStore = loadKeyStore(javaClass.classLoader.getResourceAsStream("regression-test/$OLD_NODE_DEV_KEYSTORE_FILE_NAME"), OLD_DEV_KEYSTORE_PASS)</ID>
    <ID>MaxLineLength:DevIdentityGenerator.kt$DevIdentityGenerator$ fun generateDistributedNotaryCompositeIdentity(dirs: List&lt;Path&gt;, notaryName: CordaX500Name, threshold: Int = 1): Party</ID>
    <ID>MaxLineLength:DevIdentityGenerator.kt$DevIdentityGenerator$DEV_CA_KEY_STORE_PASS</ID>
    <ID>MaxLineLength:DevIdentityGenerator.kt$DevIdentityGenerator$val p2pKeyStore = FileBasedCertificateStoreSupplier(certificatesDirectory / "sslkeystore.jks", DEV_CA_KEY_STORE_PASS, DEV_CA_KEY_STORE_PASS)</ID>
    <ID>MaxLineLength:DevIdentityGenerator.kt$DevIdentityGenerator$val p2pTrustStore = FileBasedCertificateStoreSupplier(certificatesDirectory / "truststore.jks", DEV_CA_TRUST_STORE_PASS, DEV_CA_TRUST_STORE_PRIVATE_KEY_PASS)</ID>
    <ID>MaxLineLength:DevIdentityGenerator.kt$DevIdentityGenerator$val signingCertStore = FileBasedCertificateStoreSupplier(certificatesDirectory / "nodekeystore.jks", DEV_CA_KEY_STORE_PASS, DEV_CA_KEY_STORE_PASS)</ID>
    <ID>MaxLineLength:DigitalSignatureWithCert.kt$DigitalSignatureWithCert : DigitalSignature</ID>
    <ID>MaxLineLength:DigitalSignatureWithCert.kt$DigitalSignatureWithCert$val parameters = PKIXParameters(setOf(TrustAnchor(parentCertsChain.last(), null))).apply { isRevocationEnabled = false }</ID>
    <ID>MaxLineLength:DigitalSignatureWithCert.kt$SignedDataWithCert&lt;T : Any&gt; : NamedByHash</ID>
    <ID>MaxLineLength:DigitalSignatureWithCert.kt$net.corda.core.internal.DigitalSignatureWithCert.kt</ID>
    <ID>MaxLineLength:Disruption.kt$connection.runShellCommandGetOutput("sudo rm ${connection.remoteNode.nodeDirectory}/persistence.mv.db").getResultOrThrow()</ID>
    <ID>MaxLineLength:Disruption.kt$val shell = "for c in {1..$parallelism} ; do openssl enc -aes-128-cbc -in /dev/urandom -pass pass: -e &gt; /dev/null &amp; done &amp;&amp; JOBS=\$(jobs -p) &amp;&amp; (sleep $durationSeconds &amp;&amp; kill \$JOBS) &amp; wait"</ID>
    <ID>MaxLineLength:DistributedServiceTests.kt$DistributedServiceTests$// TODO Use a dummy distributed service rather than a Raft Notary Service as this test is only about Artemis' ability // to handle distributed services @Test fun `requests are distributed evenly amongst the nodes`()</ID>
    <ID>MaxLineLength:DistributedServiceTests.kt$DistributedServiceTests$assertThat(notaryNodes.flatMap { it.nodeInfo.legalIdentities - raftNotaryIdentity }.toSet()).hasSameSizeAs(notaryNodes)</ID>
    <ID>MaxLineLength:DistributedServiceTests.kt$DistributedServiceTests$proxy.stateMachinesFeed().updates.map { Pair(proxy.nodeInfo().legalIdentitiesAndCerts.first().party, it) }</ID>
    <ID>MaxLineLength:DockerContainerPusher.kt$DockerContainerPusher$override</ID>
    <ID>MaxLineLength:DockerUtils.kt$DockerUtils$private</ID>
    <ID>MaxLineLength:Driver.kt$ fun &lt;A&gt; driver(defaultParameters: DriverParameters = DriverParameters(), dsl: DriverDSL.() -&gt; A): A</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$@Deprecated("extraCordappPackagesToScan does not preserve the original CorDapp's versioning and metadata, which may lead to " + "misleading results in tests. Use cordappsForAllNodes instead.")</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$@Deprecated("extraCordappPackagesToScan does not preserve the original CorDapp's versioning and metadata, which may lead to " + "misleading results in tests. Use withCordappsForAllNodes instead.")</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$@Deprecated("extraCordappPackagesToScan does not preserve the original CorDapp's versioning and metadata, which may lead to " + "misleading results in tests. Use withCordappsForAllNodes instead.") fun withExtraCordappPackagesToScan(extraCordappPackagesToScan: List&lt;String&gt;): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$constructor(cordappsForAllNodes: Collection&lt;TestCordapp&gt;) : this(isDebug = false, cordappsForAllNodes = cordappsForAllNodes)</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withCordappsForAllNodes(cordappsForAllNodes: Collection&lt;TestCordapp&gt;?): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withDebugPortAllocation(debugPortAllocation: PortAllocation): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withNetworkParameters(networkParameters: NetworkParameters): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withNotaryCustomOverrides(notaryCustomOverrides: Map&lt;String, Any?&gt;): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withStartNodesInProcess(startNodesInProcess: Boolean): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withSystemProperties(systemProperties: Map&lt;String, String&gt;): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withWaitForAllNodesToFinish(waitForAllNodesToFinish: Boolean): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$InProcess$ fun &lt;T&gt; startFlow(logic: FlowLogic&lt;T&gt;): CordaFuture&lt;T&gt;</ID>
    <ID>MaxLineLength:Driver.kt$JmxPolicy</ID>
    <ID>MaxLineLength:Driver.kt$JmxPolicy$@Deprecated("The default constructor does not turn on monitoring. Simply leave the jmxPolicy parameter unspecified if you wish to not " + "have monitoring turned on.")</ID>
    <ID>MaxLineLength:Driver.kt$PortAllocation.Incremental$@Deprecated("This has been superseded by net.corda.testing.driver.SharedMemoryIncremental.INSTANCE", ReplaceWith("SharedMemoryIncremental.INSTANCE"))</ID>
    <ID>MaxLineLength:Driver.kt$PortAllocation.Incremental$@Deprecated("This has been superseded by net.corda.testing.driver.SharedMemoryIncremental.INSTANCE", ReplaceWith("net.corda.testing.driver.DriverDSL.nextPort()"))</ID>
    <ID>MaxLineLength:DriverDSL.kt$DriverDSL$ @Suppress("DEPRECATION") fun startWebserver(handle: NodeHandle): CordaFuture&lt;WebserverHandle&gt;</ID>
    <ID>MaxLineLength:DriverDSL.kt$DriverDSL$ fun startNode( defaultParameters: NodeParameters = NodeParameters(), providedName: CordaX500Name? = defaultParameters.providedName, rpcUsers: List&lt;User&gt; = defaultParameters.rpcUsers, verifierType: VerifierType = defaultParameters.verifierType, customOverrides: Map&lt;String, Any?&gt; = defaultParameters.customOverrides, startInSameProcess: Boolean? = defaultParameters.startInSameProcess, maximumHeapSize: String = defaultParameters.maximumHeapSize ): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>MaxLineLength:DriverDSL.kt$DriverDSL$ fun startNode( defaultParameters: NodeParameters = NodeParameters(), providedName: CordaX500Name? = defaultParameters.providedName, rpcUsers: List&lt;User&gt; = defaultParameters.rpcUsers, verifierType: VerifierType = defaultParameters.verifierType, customOverrides: Map&lt;String, Any?&gt; = defaultParameters.customOverrides, startInSameProcess: Boolean? = defaultParameters.startInSameProcess, maximumHeapSize: String = defaultParameters.maximumHeapSize, logLevelOverride: String? = defaultParameters.logLevelOverride ): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$CompatibilityZoneParams</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$ private fun startOutOfProcessMiniNode(config: NodeConfig, vararg extraCmdLineFlag: String): CordaFuture&lt;Unit&gt;</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$/** * Future which completes when the network map infrastructure is available, whether a local one or one from the CZ. * This future acts as a gate to prevent nodes from starting too early. The value of the future is a [LocalNetworkMap] * object, which is null if the network map is being provided by the CZ. */ private lateinit var networkMapAvailability: CordaFuture&lt;LocalNetworkMap?&gt;</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$LocalNetworkMap</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$NodeConfig</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$NodeConfiguration::rpcUsers.name to if (users.isEmpty()) defaultRpcUserList else users.map { it.toConfig().root().unwrapped() }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$NodeParameters(rpcUsers = spec.rpcUsers, verifierType = spec.verifierType, customOverrides = notaryConfig + customOverrides, maximumHeapSize = spec.maximumHeapSize)</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$NodeParameters(rpcUsers = spec.rpcUsers, verifierType = spec.verifierType, customOverrides = notaryConfig(clusterAddress))</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$NodeParameters(rpcUsers = spec.rpcUsers, verifierType = spec.verifierType, customOverrides = notaryConfig(nodeAddress, clusterAddress))</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$OutOfProcessImpl(rpc.nodeInfo(), rpc, config.corda, webAddress, useHTTPS, debugPort, process, onNodeExit)</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$_executorService = Executors.newScheduledThreadPool(2, ThreadFactoryBuilder().setNameFormat("driver-pool-thread-%d").build())</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$_notaries.map { notary -&gt; notary.map { handle -&gt; handle.nodeHandles } }.getOrThrow(notaryHandleTimeout).forEach { future -&gt; future.getOrThrow(notaryHandleTimeout) }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$fun notaryConfig(nodeAddress: NetworkHostAndPort, clusterAddress: NetworkHostAndPort? = null): Map&lt;String, Any&gt;</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$override</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$paths.filter { it.fileName.toString().startsWith(NodeInfoFilesCopier.NODE_INFO_FILE_NAME_PREFIX) }.findFirst().get()</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$private</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$return (0 until spec.cluster!!.clusterSize).map { spec.name.copy(organisation = "${spec.name.organisation}-$it") }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$startNodeRegistration(name, compatibilityZone.rootCert, compatibilityZone.config(), parameters.customOverrides)</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val client = OkHttpClient.Builder().connectTimeout(5, TimeUnit.SECONDS).readTimeout(60, TimeUnit.SECONDS).build()</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val flowOverrideConfig = FlowOverrideConfig(parameters.flowOverrides.map { FlowOverride(it.key.canonicalName, it.value.canonicalName) })</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val jdbcUrl = "jdbc:h2:mem:persistence${inMemoryCounter.getAndIncrement()};DB_CLOSE_ON_EXIT=FALSE;LOCK_TIMEOUT=10000;WRITE_DELAY=100"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val name = parameters.providedName ?: CordaX500Name("${oneOf(names).organisation}-${p2pAddress.port}", "London", "GB")</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val nodeInfo = Node(config.corda, MOCK_VERSION_INFO, initialiseSerialization = false).generateAndSaveNodeInfo()</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val process = startOutOfProcessNode(config, quasarJarPath, debugPort, systemProperties, parameters.maximumHeapSize, parameters.logLevelOverride)</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val processDeathFuture = poll(executorService, "process death while waiting for RPC (${config.corda.myLegalName})") { if (process.isAlive) null else process }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl${ // If no CZ is specified then the driver does the generation of the network parameters and the copying of the // node info files. startNotaryIdentityGeneration().map { notaryInfos -&gt; Pair(notaryInfos, LocalNetworkMap(notaryInfos)) } }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl${ // In this case we're dealing with the the RPCDriver or one of it's cousins which are internal and we don't care about them emptyList() }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl${ // Otherwise it's the CZ's job to distribute thse via the HTTP network map, as that is what the nodes will be expecting. val notaryInfosFuture = if (compatibilityZone.rootCert == null) { // No root cert specified so we use the dev root cert to generate the notary identities. startNotaryIdentityGeneration() } else { // With a root cert specified we delegate generation of the notary identities to the CZ. startAllNotaryRegistrations(compatibilityZone.rootCert, compatibilityZone) } notaryInfosFuture.map { notaryInfos -&gt; compatibilityZone.publishNotaries(notaryInfos) Pair(notaryInfos, null) } }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$ private fun Map&lt;String, Any&gt;.removeResolvedClasspath(): Map&lt;String, Any&gt;</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$"com.fasterxml**;com.google**;com.ibm**;com.intellij**;com.jcabi**;com.nhaarman**;com.opengamma**;"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$"com.lmax**;picocli**;liquibase**;com.github.benmanes**;org.json**;org.postgresql**;nonapi.io.github.classgraph**;)"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$"com.typesafe**;com.zaxxer**;de.javakaffee**;groovy**;groovyjarjarantlr**;groovyjarjarasm**;io.atomix**;"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$"io.github**;io.netty**;jdk**;joptsimple**;junit**;kotlin**;net.bytebuddy**;net.i2p**;org.apache**;"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$"org.assertj**;org.bouncycastle**;org.codehaus**;org.crsh**;org.dom4j**;org.fusesource**;org.h2**;"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$"org.hamcrest**;org.hibernate**;org.jboss**;org.jcp**;org.joda**;org.junit**;org.mockito**;org.objectweb**;"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$/** * A sub-set of permissions that grant most of the essential operations used in the unit/integration tests as well as * in demo application like NodeExplorer. */ @Suppress("DEPRECATION") private val DRIVER_REQUIRED_PERMISSIONS = setOf( Permissions.invokeRpc(CordaRPCOps::nodeInfo), Permissions.invokeRpc(CordaRPCOps::networkMapFeed), Permissions.invokeRpc(CordaRPCOps::networkMapSnapshot), Permissions.invokeRpc(CordaRPCOps::notaryIdentities), Permissions.invokeRpc(CordaRPCOps::stateMachinesFeed), Permissions.invokeRpc(CordaRPCOps::stateMachineRecordedTransactionMappingFeed), Permissions.invokeRpc(CordaRPCOps::nodeInfoFromParty), Permissions.invokeRpc(CordaRPCOps::internalVerifiedTransactionsFeed), Permissions.invokeRpc(CordaRPCOps::internalFindVerifiedTransaction), Permissions.invokeRpc("vaultQueryBy"), Permissions.invokeRpc("vaultTrackBy"), Permissions.invokeRpc(CordaRPCOps::registeredFlows), Permissions.invokeRpc(CordaRPCOps::killFlow) )</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$exclude.any { token -&gt; cpEntry.contains("${File.separatorChar}$token") } || cpEntry.endsWith("-tests.jar")</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$log.info("Starting out-of-process Node ${config.corda.myLegalName.organisation}, debug port is " + (debugPort ?: "not enabled"))</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$private operator fun Config.plus(property: Pair&lt;String, Any&gt;)</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$private val defaultRpcUserList = listOf(InternalUser("default", "default", setOf("ALL")).toConfig().root().unwrapped())</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$throw IllegalStateException("No quasar agent: -javaagent:lib/quasar.jar and working directory project root might fix")</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$val excludePattern = "x(antlr**;bftsmart**;ch**;co.paralleluniverse**;com.codahale**;com.esotericsoftware**;" + "com.fasterxml**;com.google**;com.ibm**;com.intellij**;com.jcabi**;com.nhaarman**;com.opengamma**;" + "com.typesafe**;com.zaxxer**;de.javakaffee**;groovy**;groovyjarjarantlr**;groovyjarjarasm**;io.atomix**;" + "io.github**;io.netty**;jdk**;joptsimple**;junit**;kotlin**;net.bytebuddy**;net.i2p**;org.apache**;" + "org.assertj**;org.bouncycastle**;org.codehaus**;org.crsh**;org.dom4j**;org.fusesource**;org.h2**;" + "org.hamcrest**;org.hibernate**;org.jboss**;org.jcp**;org.joda**;org.junit**;org.mockito**;org.objectweb**;" + "org.objenesis**;org.slf4j**;org.w3c**;org.xml**;org.yaml**;reflectasm**;rx**;org.jolokia**;" + "com.lmax**;picocli**;liquibase**;com.github.benmanes**;org.json**;org.postgresql**;nonapi.io.github.classgraph**;)"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion${ log.info("Starting out-of-process Node ${config.corda.myLegalName.organisation}, debug port is " + (debugPort ?: "not enabled")) // Write node.conf writeConfig(config.corda.baseDirectory, "node.conf", config.typesafe.toNodeOnly()) val systemProperties = mutableMapOf( "name" to config.corda.myLegalName, "visualvm.display.name" to "corda-${config.corda.myLegalName}" ) debugPort?.let { systemProperties += "log4j2.level" to "debug" systemProperties += "log4j2.debug" to "true" } systemProperties += inheritFromParentProcess() systemProperties += overriddenSystemProperties // See experimental/quasar-hook/README.md for how to generate. val excludePattern = "x(antlr**;bftsmart**;ch**;co.paralleluniverse**;com.codahale**;com.esotericsoftware**;" + "com.fasterxml**;com.google**;com.ibm**;com.intellij**;com.jcabi**;com.nhaarman**;com.opengamma**;" + "com.typesafe**;com.zaxxer**;de.javakaffee**;groovy**;groovyjarjarantlr**;groovyjarjarasm**;io.atomix**;" + "io.github**;io.netty**;jdk**;joptsimple**;junit**;kotlin**;net.bytebuddy**;net.i2p**;org.apache**;" + "org.assertj**;org.bouncycastle**;org.codehaus**;org.crsh**;org.dom4j**;org.fusesource**;org.h2**;" + "org.hamcrest**;org.hibernate**;org.jboss**;org.jcp**;org.joda**;org.junit**;org.mockito**;org.objectweb**;" + "org.objenesis**;org.slf4j**;org.w3c**;org.xml**;org.yaml**;reflectasm**;rx**;org.jolokia**;" + "com.lmax**;picocli**;liquibase**;com.github.benmanes**;org.json**;org.postgresql**;nonapi.io.github.classgraph**;)" val extraJvmArguments = systemProperties.removeResolvedClasspath().map { "-D${it.key}=${it.value}" } + "-javaagent:$quasarJarPath=$excludePattern" val loggingLevel = when { logLevelOverride != null -&gt; logLevelOverride debugPort == null -&gt; "INFO" else -&gt; "DEBUG" } val arguments = mutableListOf( "--base-directory=${config.corda.baseDirectory}", "--logging-level=$loggingLevel", "--no-local-shell").also { it += extraCmdLineFlag }.toList() // The following dependencies are excluded from the classpath of the created JVM, so that the environment resembles a real one as close as possible. // These are either classes that will be added as attachments to the node (i.e. samples, finance, opengamma etc.) or irrelevant testing libraries (test, corda-mock etc.). // TODO: There is pending work to fix this issue without custom blacklisting. See: https://r3-cev.atlassian.net/browse/CORDA-2164. val exclude = listOf("samples", "finance", "integrationTest", "test", "corda-mock", "com.opengamma.strata") val cp = ProcessUtilities.defaultClassPath.filterNot { cpEntry -&gt; exclude.any { token -&gt; cpEntry.contains("${File.separatorChar}$token") } || cpEntry.endsWith("-tests.jar") } return ProcessUtilities.startJavaProcess( className = "net.corda.node.Corda", // cannot directly get class for this, so just use string arguments = arguments, jdwpPort = debugPort, extraJvmArguments = extraJvmArguments, workingDirectory = config.corda.baseDirectory, maximumHeapSize = maximumHeapSize, classPath = cp ) }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.LocalNetworkMap$// TODO: this object will copy NodeInfo files from started nodes to other nodes additional-node-infos/ // This uses the FileSystem and adds a delay (~5 seconds) given by the time we wait before polling the file system. // Investigate whether we can avoid that. val nodeInfosCopier = NodeInfoFilesCopier().also { shutdownManager.registerShutdown(it::close) }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$fun DriverDSL.startNode(providedName: CordaX500Name, devMode: Boolean, parameters: NodeParameters = NodeParameters()): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>MaxLineLength:DriverInternal.kt$NodeHandleInternal$override val jmxAddress: NetworkHostAndPort? get() = configuration.jmxMonitoringHttpPort?.let { NetworkHostAndPort("localhost", it) }</ID>
    <ID>MaxLineLength:DriverTests.kt$DriverTests$driver</ID>
    <ID>MaxLineLength:DriverTests.kt$DriverTests$newNode(CordaX500Name(commonName = "Notary", organisation = "R3CEV", locality = "New York", country = "US"))().getOrThrow()</ID>
    <ID>MaxLineLength:DriverTests.kt$DriverTests$newNode(CordaX500Name(commonName = "Regulator", organisation = "R3CEV", locality = "New York", country = "US"))().getOrThrow()</ID>
    <ID>MaxLineLength:DriverTests.kt$DriverTests$val logFile = (baseDirectory / NodeStartup.LOGS_DIRECTORY_NAME).list { it.filter { a -&gt; a.isRegularFile() &amp;&amp; a.fileName.toString().startsWith("node") }.findFirst().get() }</ID>
    <ID>MaxLineLength:DriverTests.kt$DriverTests${ // Based on local testing, running this 3 times gives us a high confidence that we'll spot if the feature is not working repeat(3) { driver(DriverParameters(startNodesInProcess = true)) { val bob = startNode(providedName = BOB_NAME).getOrThrow() assertThat(bob.rpc.networkMapSnapshot().flatMap { it.legalIdentities }).contains(defaultNotaryIdentity) } } }</ID>
    <ID>MaxLineLength:DummyContract.kt$DummyContract.Companion$StateAndContract(SingleOwnerState(magicNumber, owners.first().party), PROGRAM_ID)</ID>
    <ID>MaxLineLength:DummyContract.kt$DummyContract.Companion$TransactionBuilder(notary).withItems(StateAndContract(state, PROGRAM_ID), Command(Commands.Create(), owners.map { it.party.owningKey }))</ID>
    <ID>MaxLineLength:DummyContract.kt$DummyContract.Companion$val items = arrayOf(StateAndContract(SingleOwnerState(magicNumber, owners.first().party), PROGRAM_ID), Command(Commands.Create(), owners.first().party.owningKey), StateAndContract(SingleOwnerState(magicNumber, owners.first().party), PROGRAM_ID), Command(Commands.Create(), owners.first().party.owningKey))</ID>
    <ID>MaxLineLength:DummyContract.kt$DummyContract.SingleOwnerState$data</ID>
    <ID>MaxLineLength:DummyDealStateSchemaV1.kt$DummyDealStateSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:DummyDealStateSchemaV1.kt$DummyDealStateSchemaV1.PersistentDummyDealState$@CollectionTable(name = "dummy_deal_states_parts", joinColumns = [(JoinColumn(name = "output_index", referencedColumnName = "output_index")), (JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id"))])</ID>
    <ID>MaxLineLength:DummyFungibleContract.kt$DummyFungibleContract$"for reference ${issuer.reference} at issuer ${issuer.party} the amounts balance: ${inputAmount.quantity} - ${amountExitingLedger.quantity} != ${outputAmount.quantity}"</ID>
    <ID>MaxLineLength:DummyFungibleContract.kt$DummyFungibleContract$override</ID>
    <ID>MaxLineLength:DummyFungibleContract.kt$DummyFungibleContract$val exitCommand = tx.commands.select&lt;Commands.Exit&gt;(parties = null, signers = exitKeys).singleOrNull { it.value.amount.token == key }</ID>
    <ID>MaxLineLength:DummyFungibleContract.kt$DummyFungibleContract$val inputAmount = inputs.sumCashOrNull() ?: throw IllegalArgumentException("there is at least one input for this group")</ID>
    <ID>MaxLineLength:DummyFungibleContract.kt$DummyFungibleContract.State$override</ID>
    <ID>MaxLineLength:DummyIssueAndMove.kt$DummyIssueAndMove : FlowLogic</ID>
    <ID>MaxLineLength:DummyLinearContract.kt$DummyLinearContract.State$override fun supportedSchemas(): Iterable&lt;MappedSchema&gt;</ID>
    <ID>MaxLineLength:DummyLinearStateSchemaV1.kt$DummyLinearStateSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:DummyLinearStateSchemaV1.kt$DummyLinearStateSchemaV1.PersistentDummyLinearState$@Table(name = "dummy_linear_states", indexes = [Index(name = "external_id_idx", columnList = "external_id"), Index(name = "uuid_idx", columnList = "uuid")])</ID>
    <ID>MaxLineLength:DummyLinearStateSchemaV2.kt$DummyLinearStateSchemaV2.PersistentDummyLinearState$@CollectionTable(name = "dummy_linear_states_v2_parts", joinColumns = [(JoinColumn(name = "output_index", referencedColumnName = "output_index")), (JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id"))])</ID>
    <ID>MaxLineLength:DumpHistoryOnErrorInterceptor.kt$DumpHistoryOnErrorInterceptor$val (continuation, nextState) = delegate.executeTransition(fiber, previousState, event, transition, actionExecutor)</ID>
    <ID>MaxLineLength:DumpHistoryOnErrorInterceptor.kt$DumpHistoryOnErrorInterceptor$val transitionRecord = TransitionDiagnosticRecord(Instant.now(), fiber.id, previousState, nextState, event, transition, continuation)</ID>
    <ID>MaxLineLength:DumpHistoryOnErrorInterceptor.kt$DumpHistoryOnErrorInterceptor${ val (continuation, nextState) = delegate.executeTransition(fiber, previousState, event, transition, actionExecutor) val transitionRecord = TransitionDiagnosticRecord(Instant.now(), fiber.id, previousState, nextState, event, transition, continuation) val record = records.compute(fiber.id) { _, record -&gt; (record ?: ArrayList()).apply { add(transitionRecord) } } // Just if we decide to propagate, and not if just on the way to the hospital. Only log at debug level here - the flow transition // information is often unhelpful in the logs, and the actual cause of the problem will be logged elsewhere. if (nextState.checkpoint.errorState is ErrorState.Errored &amp;&amp; nextState.checkpoint.errorState.propagating) { log.warn("Flow ${fiber.id} errored, dumping all transitions:\n${record!!.joinToString("\n")}") for (error in nextState.checkpoint.errorState.errors) { log.warn("Flow ${fiber.id} error", error.exception) } } if (nextState.isRemoved) { records.remove(fiber.id) } return Pair(continuation, nextState) }</ID>
    <ID>MaxLineLength:DurationSerializer.kt$DurationSerializer : Proxy</ID>
    <ID>MaxLineLength:E2ETestKeyManagementService.kt$E2ETestKeyManagementService$getPrivateKey((privateKey as AliasPrivateKey).alias, cryptoService.certificateStore.entryPassword)</ID>
    <ID>MaxLineLength:E2ETestKeyManagementService.kt$E2ETestKeyManagementService$throw UnsupportedOperationException("This operation is only supported by persistent key management service variants.")</ID>
    <ID>MaxLineLength:EdDSATests.kt$EdDSATests$// Required to implement a custom doSign function, because Corda's Crypto.doSign does not allow empty messages (testVector1). private fun doSign(privateKey: PrivateKey, clearData: ByteArray): ByteArray</ID>
    <ID>MaxLineLength:EdDSATests.kt$EdDSATests$assertEquals(it.signatureOutputHex, doSign(privateKey, it.messageToSignHex.hexToByteArray()).toHex().toLowerCase())</ID>
    <ID>MaxLineLength:EdDSATests.kt$EdDSATests$assertNotEquals(testVectorEd25519ctx.signatureOutputHex, doSign(privateKey, testVectorEd25519ctx.messageToSignHex.hexToByteArray()).toHex().toLowerCase())</ID>
    <ID>MaxLineLength:EdDSATests.kt$EdDSATests$val privateKey = EdDSAPrivateKey(EdDSAPrivateKeySpec(testVectorEd25519ctx.privateKeyHex.hexToByteArray(), edParams))</ID>
    <ID>MaxLineLength:EncodingUtils.kt$ fun parsePublicKeyBase58(base58String: String): PublicKey</ID>
    <ID>MaxLineLength:EncodingUtils.kt$net.corda.core.utilities.EncodingUtils.kt</ID>
    <ID>MaxLineLength:EnumEvolutionSerializer.kt$EnumEvolutionSerializer$val converted = conversions[enumName] ?: throw AMQPNotSerializableException(type, "No rule to evolve enum constant $type::$enumName")</ID>
    <ID>MaxLineLength:EnumEvolutionSerializer.kt$EnumEvolutionSerializer$val ordinal = ordinals[converted] ?: throw AMQPNotSerializableException(type, "Ordinal not found for enum value $type::$converted")</ID>
    <ID>MaxLineLength:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$assertThatThrownBy { SerializationOutput(sf).serialize(C(RejectMultipleRenameFrom.A)) }.isInstanceOf(NotSerializableException::class.java) .hasToString("Unable to serialize/deserialize net.corda.serialization.internal.amqp.EnumEvolvabilityTests\$RejectMultipleRenameFrom: " + "There are multiple transformations from D, which is not allowed")</ID>
    <ID>MaxLineLength:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$assertTrue(envelope.transformsSchema.types[WithUnknownTest::class.java.name]!!.containsKey(TransformTypes.Unknown))</ID>
    <ID>MaxLineLength:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$val envelope = DeserializationInput(sf).deserializeAndReturnEnvelope(SerializedBytes&lt;WrapsUnknown&gt;(sb1)).envelope</ID>
    <ID>MaxLineLength:EnumSerializer.kt$EnumSerializer : AMQPSerializer</ID>
    <ID>MaxLineLength:EnumSetSerializer.kt$EnumSetSerializer : Proxy</ID>
    <ID>MaxLineLength:EnumSetSerializer.kt$EnumSetSerializer$EnumSet.complementOf(uncheckedCast&lt;EnumSet&lt;*&gt;, EnumSet&lt;MapSerializer.EnumJustUsedForCasting&gt;&gt;(set)).first().javaClass</ID>
    <ID>MaxLineLength:EnumTransforms.kt$EnumTransforms$ private fun validateNoCycles(constants: Map&lt;String, Int&gt;)</ID>
    <ID>MaxLineLength:EnumTransforms.kt$EnumTransforms$"Rename chain from $chainStart to $chainEnd does not end with a known constant in ${constants.keys}"</ID>
    <ID>MaxLineLength:EnumTransforms.kt$EnumTransforms$throw InvalidEnumTransformsException("Rename from $from to $to would rename existing constant in $constants.keys")</ID>
    <ID>MaxLineLength:EnumTransforms.kt$EnumTransforms${ if (from in constants) { throw InvalidEnumTransformsException("Rename from $from to $to would rename existing constant in $constants.keys") } // If there is an existing chain, starting at the "to" node of this edge, then there is a chain from this edge's // "from" to that chain's end. val newEnd = chainStartsToEnds[to] ?: to // If there is an existing chain, ending at the "from" node of this edge, then there is a chain from that chain's start // to this edge's "to". val newStart = chainEndsToStarts[from] ?: from // If either chain ends where it begins, we have closed a loop, and detected a cycle. if (newEnd == from || newStart == to) { throw InvalidEnumTransformsException("Rename cycle detected in rename map starting from $newStart") } // Either update, or create, the chains in both directions. chainStartsToEnds[newStart] = newEnd chainEndsToStarts[newEnd] = newStart }</ID>
    <ID>MaxLineLength:ErrorCodeLoggingTests.kt$ErrorCodeLoggingTests$val linesWithErrorCode = logFile.useLines { lines -&gt; lines.filter { line -&gt; line.contains("[errorCode=") }.filter { line -&gt; line.contains("moreInformationAt=https://errors.corda.net/") }.toList() }</ID>
    <ID>MaxLineLength:ErrorCodeLoggingTests.kt$fun NodeHandle.logFile(): File</ID>
    <ID>MaxLineLength:ErrorCodeRewritePolicy.kt$ErrorCodeRewritePolicy$@Plugin(name = "ErrorCodeRewritePolicy", category = Core.CATEGORY_NAME, elementType = "rewritePolicy", printObject = false)</ID>
    <ID>MaxLineLength:ErrorFlowTransition.kt$ErrorFlowTransition$val (initiatedSessions, newSessions) = bufferErrorMessagesInInitiatingSessions(startingState.checkpoint.sessions, errorMessages)</ID>
    <ID>MaxLineLength:ErrorMessagesTests.kt$ErrorMessagesTests$"Property '$property' or its getter is non public, this renders class 'class $testname\$C' unserializable -&gt; class $testname\$C"</ID>
    <ID>MaxLineLength:ErrorMessagesTests.kt$ErrorMessagesTests$@Ignore("Current behaviour allows for the serialization of objects with private members, this will be disallowed at some point in the future")</ID>
    <ID>MaxLineLength:Event.kt$Event$GeneratedByExternalEvent</ID>
    <ID>MaxLineLength:Event.kt$Event$RetryFlowFromSafePoint : Event</ID>
    <ID>MaxLineLength:EventGenerator.kt$ErrorFlowsEventGenerator : EventGenerator</ID>
    <ID>MaxLineLength:EventGenerator.kt$ErrorFlowsEventGenerator$private</ID>
    <ID>MaxLineLength:EventGenerator.kt$EventGenerator$open</ID>
    <ID>MaxLineLength:EventGenerator.kt$EventGenerator$protected</ID>
    <ID>MaxLineLength:EventGenerator.kt$EventGenerator$protected val currencyMap: MutableMap&lt;Currency, Long&gt; = mutableMapOf(USD to 0L, GBP to 0L) // Used for estimation of how much money we have in general.</ID>
    <ID>MaxLineLength:EventProcessor.kt$EventProcessor$val status: DeliveryState = if (completer.status == MessageStatus.Acknowledged) Accepted.getInstance() else Rejected()</ID>
    <ID>MaxLineLength:Eventually.kt$ inline fun &lt;R&gt; eventually( duration: Duration = Duration.ofSeconds(5), waitBetween: Duration = Duration.ofMillis(100), waitBefore: Duration = waitBetween, test: () -&gt; R ): R</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory$properties.asSequence().zip(localTypeInformation.properties.values.asSequence())</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory$return EnumEvolutionSerializer(localTypeInformation.observedType, localSerializerFactory, conversions, localOrdinals)</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory$val bestMatchEvolutionConstructor = findEvolverConstructor(localTypeInformation.evolutionConstructors, properties)</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory$val convertedOrdinals = remoteOrdinals.asSequence().map { (member, ord) -&gt; ord to conversions[member]!! }.toMap()</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory$val localOrdinals = localTypeInformation.members.asSequence().mapIndexed { ord, member -&gt; member to ord }.toMap()</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory$val propertyTypes = properties.mapValues { (_, info) -&gt; info.type.typeIdentifier.getLocalType(classLoader).asClass() }</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory${ // The no-op case: although the fingerprints don't match for some reason, we have compatible signatures. // This might happen because of inconsistent type erasure, changes to the behaviour of the fingerprinter, // or changes to the type itself - such as adding an interface - that do not change its serialisation/deserialisation // signature. if (propertyNamesMatch(localTypeInformation)) { // Make sure types are assignment-compatible, and return the local serializer for the type. validateCompatibility(localTypeInformation) return null } // Failing that, we have to create an evolution serializer. val bestMatchEvolutionConstructor = findEvolverConstructor(localTypeInformation.evolutionConstructors, properties) val constructorForEvolution = bestMatchEvolutionConstructor?.constructor ?: localTypeInformation.constructor val evolverProperties = bestMatchEvolutionConstructor?.properties ?: localTypeInformation.properties validateEvolvability(evolverProperties) return buildComposableEvolutionSerializer(localTypeInformation, constructorForEvolution, evolverProperties) }</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$EvolutionSerializerFactory$ fun getEvolutionSerializer( remote: RemoteTypeInformation, local: LocalTypeInformation ): AMQPSerializer&lt;Any&gt;?</ID>
    <ID>MaxLineLength:EvolutionSerializerFactoryTests.kt$EvolutionSerializerFactoryTests$val withNonNullTarget = DeserializationInput(nonStrictFactory).deserialize(SerializedBytes&lt;C&gt;(withoutNullUrl.readBytes()))</ID>
    <ID>MaxLineLength:EvolutionSerializerFactoryTests.kt$EvolutionSerializerFactoryTests$val withNullTarget = DeserializationInput(strictFactory).deserialize(SerializedBytes&lt;C&gt;(withNullUrl.readBytes()))</ID>
    <ID>MaxLineLength:EvolvabilityTests.kt$EvolvabilityTests${ val resource = "EvolvabilityTests.evolutionWithCarpentry" val sf = testDefaultFactory() // Uncomment to recreate // File(URI("$localPath/$resource")).writeBytes(SerializationOutput(sf).serialize(Evolved("dronf", NewEnum.BUCKLE_MY_SHOE)).bytes) val url = EvolvabilityTests::class.java.getResource(resource) val sc2 = url.readBytes() val deserialized = DeserializationInput(sf).deserialize(SerializedBytes&lt;Evolved&gt;(sc2)) assertEquals("dronf", deserialized.fnord) }</ID>
    <ID>MaxLineLength:EvolvabilityTests.kt$EvolvabilityTests${ val resource = "EvolvabilityTests.evolutionWithPrimitives" val sf = testDefaultFactory() // Uncomment to recreate // File(URI("$localPath/$resource")).writeBytes(SerializationOutput(sf).serialize(ParameterizedContainer(Parameterized(10, setOf(20)))).bytes) val url = EvolvabilityTests::class.java.getResource(resource) val sc2 = url.readBytes() val deserialized = DeserializationInput(sf).deserialize(SerializedBytes&lt;ParameterizedContainer&gt;(sc2)) assertEquals(10, deserialized.parameterized?.a) }</ID>
    <ID>MaxLineLength:EvolvabilityTests.kt$EvolvabilityTests${ val sf = testDefaultFactory() val resource = "EvolvabilityTests.removeParameterWithCalculatedParameter" // Original version of the class as it was serialised // data class CC(val a: Int, val b: String, val c: String, val d: Int) { // @get:SerializableCalculatedProperty // val e: String get() = "$b $c" // } // File(URI("$localPath/$resource")).writeBytes(SerializationOutput(sf).serialize(CC(1, "hello", "world", 2)).bytes) data class CC(val b: String, val d: Int) { @get:SerializableCalculatedProperty val e: String get() = "$b sailor" } val url = EvolvabilityTests::class.java.getResource(resource) val sc2 = url.readBytes() val deserializedCC = DeserializationInput(sf).deserialize(SerializedBytes&lt;CC&gt;(sc2)) assertEquals("hello", deserializedCC.b) assertEquals(2, deserializedCC.d) assertEquals("hello sailor", deserializedCC.e) }</ID>
    <ID>MaxLineLength:ExampleConfigTest.kt$ExampleConfigTest$assertThat(ConfigHelper.loadConfig(baseDirectory = baseDirectory, configFile = it).parseAsNodeConfiguration().isValid).isTrue()</ID>
    <ID>MaxLineLength:Examples.kt$Examples$// maybe in the presence of negative interest rates you would want other side of contract to be able to take initiative as well val zero_coupon_bond_2 = arrange { actions { (acmeCorp or highStreetBank) may { "execute".givenThat(after("2017-09-01")) { highStreetBank.owes(acmeCorp, 1.M, USD) } } } }</ID>
    <ID>MaxLineLength:ExceptionMaskingRpcOpsProxy.kt$ExceptionMaskingRpcOpsProxy$internal</ID>
    <ID>MaxLineLength:ExceptionMaskingRpcOpsProxy.kt$ExceptionMaskingRpcOpsProxy.Companion$return newProxyInstance(delegate::class.java.classLoader, arrayOf(InternalCordaRPCOps::class.java), handler) as InternalCordaRPCOps</ID>
    <ID>MaxLineLength:ExceptionMaskingRpcOpsProxy.kt$ExceptionMaskingRpcOpsProxy.ErrorObfuscatingInvocationHandler$val exposed = if (error.isWhitelisted()) error else InternalNodeException((error as? IdentifiableException)?.errorId)</ID>
    <ID>MaxLineLength:ExceptionSerialisingRpcOpsProxy.kt$ExceptionSerialisingRpcOpsProxy$internal</ID>
    <ID>MaxLineLength:ExceptionSerialisingRpcOpsProxy.kt$ExceptionSerialisingRpcOpsProxy.Companion$return newProxyInstance(delegate::class.java.classLoader, arrayOf(InternalCordaRPCOps::class.java), handler) as InternalCordaRPCOps</ID>
    <ID>MaxLineLength:ExceptionSerialisingRpcOpsProxy.kt$ExceptionSerialisingRpcOpsProxy.ErrorSerialisingInvocationHandler$val serialisable = (superclasses(error::class.java) + error::class.java).any { it.isAnnotationPresent(CordaSerializable::class.java) || it.interfaces.any { it.isAnnotationPresent(CordaSerializable::class.java) } }</ID>
    <ID>MaxLineLength:ExceptionsErrorCodeFunctions.kt$cause != null &amp;&amp; !visited.contains(cause) -&gt; Objects.hash(*fields, cause.staticLocationBasedHash(hashedFields, visited + cause))</ID>
    <ID>MaxLineLength:ExceptionsErrorCodeFunctions.kt$error != null &amp;&amp; level.isInRange(Level.FATAL, Level.WARN) -&gt; CompositeMessage("$formattedMessage [errorCode=${error.errorCode()}, moreInformationAt=${error.errorCodeLocationUrl()}]", format, parameters, throwable)</ID>
    <ID>MaxLineLength:ExceptionsErrorCodeFunctions.kt$fun Throwable.errorCodeLocationUrl()</ID>
    <ID>MaxLineLength:ExchangeRateModel.kt$ExchangeRate$ fun exchangeAmount(amount: Amount&lt;Currency&gt;, to: Currency)</ID>
    <ID>MaxLineLength:Expect.kt$ fun &lt;E&gt; parallel(expectations: List&lt;ExpectCompose&lt;E&gt;&gt;): ExpectCompose&lt;E&gt;</ID>
    <ID>MaxLineLength:Expect.kt$ fun &lt;E&gt; parallel(vararg expectations: ExpectCompose&lt;E&gt;): ExpectCompose&lt;E&gt;</ID>
    <ID>MaxLineLength:Expect.kt$ fun &lt;E&gt; sequence(vararg expectations: ExpectCompose&lt;E&gt;): ExpectCompose&lt;E&gt;</ID>
    <ID>MaxLineLength:Expect.kt$/** * Internally we create a "lazy" state automaton. The outgoing edges are state.getExpectedEvents() modulo additional * matching logic. When an event comes we extract the first edge that matches using state.nextState(event), which * returns the next state and the piece of dsl to be run on the event. If nextState() returns null it means the event * didn't match at all, in this case we either fail (if isStrict=true) or carry on with the same state (if isStrict=false) * * TODO Think about pre-compiling the state automaton, possibly introducing regexp constructs. This requires some * thinking, as the [parallel] construct blows up the state space factorially, so we need some clever lazy expansion * of states. */ var state = ExpectComposeState.fromExpectCompose(expectCompose())</ID>
    <ID>MaxLineLength:Expect.kt$/** * This file defines a simple DSL for testing non-deterministic sequence of events arriving on an [Observable]. * * [sequence] is used to impose ordering invariants on the stream, whereas [parallel] allows events to arrive in any order. * * The only restriction on [parallel] is that we should be able to discriminate which branch to take based on the * arrived event's type and optionally custom matching logic. If this is ambiguous the first matching piece of DSL will * be run. * * [sequence]s and [parallel]s can be nested arbitrarily * * Example usage: * * val stream: Observable&lt;SomeEvent&gt; = (..) * stream.expectEvents { * sequence( * expect { event: SomeEvent.A -&gt; require(event.isOk()) }, * parallel( * expect { event.SomeEvent.B -&gt; }, * expect { event.SomeEvent.C -&gt; } * ) * ) * } * * The above will test our expectation that the stream should first emit an A, and then a B and C in unspecified order. */ private val log: Logger = LoggerFactory.getLogger("Expect")</ID>
    <ID>MaxLineLength:Expect.kt$log.info("$event :: ${expectedStates.map { it.simpleName }} -&gt; ${next?.second?.getExpectedEvents()?.map { it.simpleName }}")</ID>
    <ID>MaxLineLength:Explorer.kt$Explorer${ // Make sure that the explorer has cordapps on its class path. This is only necessary because currently apps // require the original class files to deserialise states: Kryo serialisation doesn't let us write generic // tools that work with serialised data structures. But the AMQP serialisation revamp will fix this by // integrating the class carpenter, so, we can eventually get rid of this function. // // Note: does not copy dependencies because we should soon be making all apps fat jars and dependencies implicit. // // TODO: Remove this code when serialisation has been upgraded. val cordappsDir = config.explorerDir / NodeConfig.CORDAPP_DIR_NAME cordappsDir.createDirectories() config.cordappsDir.list { it.forEachOrdered { path -&gt; val destPath = cordappsDir / path.fileName.toString() try { // Try making a symlink to make things faster and use less disk space. Files.createSymbolicLink(destPath, path) } catch (e: UnsupportedOperationException) { // OS doesn't support symbolic links? path.copyTo(destPath, REPLACE_EXISTING) } catch (e: java.nio.file.FileAlreadyExistsException) { // OK, don't care ... } catch (e: IOException) { // Windows 10 might not allow this user to create a symlink log.warn("Failed to create symlink '{}' for '{}': {}", destPath, path, e.message) path.copyTo(destPath, REPLACE_EXISTING) } } } }</ID>
    <ID>MaxLineLength:ExposeJpaToFlowsTests.kt$ExposeJpaToFlowsTests$FooSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:ExternalIdMappingTest.kt$ExternalIdMappingTest$vaultService.queryBy&lt;DummyState&gt;(QueryCriteria.VaultQueryCriteria(externalIds = listOf(UUID.randomUUID()))).states</ID>
    <ID>MaxLineLength:FastThreadLocalTest.kt$FastThreadLocalTest$private</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchAttachmentsFlow${ // This can happen when another transaction will insert the same attachment during this transaction. // The outcome is the same (the attachment is imported), so we can ignore this exception. logger.debug { "Attachment ${attachment.id} already inserted." } }</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchAttachmentsFlow.FetchedAttachment$private</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchAttachmentsFlow.FetchedAttachment.Token$override fun fromToken(context: SerializeAsTokenContext)</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$IllegalTransactionRequest : FlowException</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$MissingNetworkParameters : FlowException</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$if (stx == null) toFetch += txid else // Although the full object is loaded here, only return the id. This prevents the full set of objects already present from // being checkpointed every time a request is made to download an object the node does not yet have. fromDisk += txid</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$logger.debug { "Requesting ${toFetch.size} dependency(s) for verification from ${otherSideSession.counterparty.name}" }</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$maybeItems += otherSideSession.sendAndReceive&lt;List&lt;W&gt;&gt;(Request.Data(NonEmptySet.of(hash), dataType)).unwrap { it }</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow${ // We skip the validation here (with unwrap { it }) because we will do it below in validateFetchResponse. // The only thing checked is the object type. It is a protocol violation to send results out of order. // TODO We need to page here after large messages will work. maybeItems += otherSideSession.sendAndReceive&lt;List&lt;W&gt;&gt;(Request.Data(NonEmptySet.of(hash), dataType)).unwrap { it } }</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow${ logger.debug { "Requesting ${toFetch.size} dependency(s) for verification from ${otherSideSession.counterparty.name}" } // TODO: Support "large message" response streaming so response sizes are not limited by RAM. // We can then switch to requesting items in large batches to minimise the latency penalty. // This is blocked by bugs ARTEMIS-1278 and ARTEMIS-1279. For now we limit attachments and txns to 10mb each // and don't request items in batch, which is a performance loss, but works around the issue. We have // configured Artemis to not fragment messages up to 10mb so we can send 10mb messages without problems. // Above that, we start losing authentication data on the message fragments and take exceptions in the // network layer. val maybeItems = ArrayList&lt;W&gt;(toFetch.size) for (hash in toFetch) { // We skip the validation here (with unwrap { it }) because we will do it below in validateFetchResponse. // The only thing checked is the object type. It is a protocol violation to send results out of order. // TODO We need to page here after large messages will work. maybeItems += otherSideSession.sendAndReceive&lt;List&lt;W&gt;&gt;(Request.Data(NonEmptySet.of(hash), dataType)).unwrap { it } } // Check for a buggy/malicious peer answering with something that we didn't ask for. val downloaded = validateFetchResponse(UntrustworthyData(maybeItems), toFetch) logger.debug { "Fetched ${downloaded.size} elements from ${otherSideSession.counterparty.name}" } maybeWriteToDisk(downloaded) // Re-load items already present before the download procedure. This ensures these objects are not unnecessarily checkpointed. val loadedFromDisk = loadExpected(fromDisk) Result(loadedFromDisk, downloaded) }</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchNetworkParametersFlow : FetchDataFlow</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchNetworkParametersFlow$( requests: Set&lt;SecureHash&gt;, otherSide: FlowSession )</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchTransactionsFlow : FetchDataFlow</ID>
    <ID>MaxLineLength:FiberDeserializationCheckingInterceptor.kt$FiberDeserializationCheckingInterceptor$val (continuation, nextState) = delegate.executeTransition(fiber, previousState, event, transition, actionExecutor)</ID>
    <ID>MaxLineLength:FiberUtils.kt$// TODO: This method uses a built-in Quasar function to make a map of all ThreadLocals. This is probably inefficient, but the only API readily available. fun &lt;V, T&gt; Fiber&lt;V&gt;.swappedOutThreadLocalValue(threadLocal: ThreadLocal&lt;T&gt;): T?</ID>
    <ID>MaxLineLength:FiberUtils.kt$private val fiberThreadLocalsField: Field = Fiber::class.java.getDeclaredField("fiberLocals").apply { this.isAccessible = true }</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow : FlowLogic</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$"${session.counterparty} has finished prematurely and we're trying to send them the finalised transaction. "</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$"Do not provide flow sessions for the local node. FinalityFlow will record the notarised transaction locally."</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$/** * Notarise the given transaction and broadcast it to all the participants. * * @param transaction What to commit. * @param sessions A collection of [FlowSession]s for each non-local participant of the transaction. Sessions to non-participants can * also be provided. */ @JvmOverloads constructor( transaction: SignedTransaction, sessions: Collection&lt;FlowSession&gt;, progressTracker: ProgressTracker = tracker() ) : this(transaction, emptyList(), progressTracker, sessions, true)</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$/** * Notarise the given transaction and broadcast it to all the participants. * * @param transaction What to commit. * @param sessions A collection of [FlowSession]s for each non-local participant. * @param oldParticipants An **optional** collection of parties for participants who are still using the old API. * * You will only need to use this parameter if you have upgraded your CorDapp from the V3 FinalityFlow API but are required to provide * backwards compatibility with participants running V3 nodes. If you're writing a new CorDapp then this does not apply and this * parameter should be ignored. */ @Deprecated(DEPRECATION_MSG) constructor( transaction: SignedTransaction, sessions: Collection&lt;FlowSession&gt;, oldParticipants: Collection&lt;Party&gt;, progressTracker: ProgressTracker ) : this(transaction, oldParticipants, progressTracker, sessions, true)</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$@Deprecated(DEPRECATION_MSG) constructor(transaction: SignedTransaction, extraRecipients: Set&lt;Party&gt;) : this(transaction, extraRecipients, tracker(), emptyList(), false)</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$@Deprecated(DEPRECATION_MSG) constructor(transaction: SignedTransaction, progressTracker: ProgressTracker) : this(transaction, emptySet(), progressTracker, emptyList(), false)</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$if (notary != null) transaction.verifySignaturesExcept(notary.owningKey) else transaction.verifyRequiredSignatures()</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$logger</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$require(it.isEmpty()) { "The following parties are specified both in flow sessions and in the oldParticipants list: $it" }</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$val commandDataTypes = transaction.tx.commands.asSequence().mapNotNull { it.value::class.qualifiedName }.distinct()</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow.Companion$"accept notarised transactions without first checking their relevancy. Instead, use one of the constructors "</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow.Companion$private const</ID>
    <ID>MaxLineLength:FinalityFlow.kt$ReceiveFinalityFlow : FlowLogic</ID>
    <ID>MaxLineLength:FinalityFlow.kt$ReceiveFinalityFlow$return subFlow(object : ReceiveTransactionFlow(otherSideSession, checkSufficientSignatures = true, statesToRecord = statesToRecord) { override fun checkBeforeRecording(stx: SignedTransaction) { require(expectedTxId == null || expectedTxId == stx.id) { "We expected to receive transaction with ID $expectedTxId but instead got ${stx.id}. Transaction was" + "not recorded and nor its states sent to the vault." } } })</ID>
    <ID>MaxLineLength:FinalityFlow.kt$ReceiveFinalityFlow.&lt;no name provided&gt;$"We expected to receive transaction with ID $expectedTxId but instead got ${stx.id}. Transaction was"</ID>
    <ID>MaxLineLength:FinalityFlowMigration.kt$ExistingInitiatingFlow : FlowLogic</ID>
    <ID>MaxLineLength:FinalityFlowMigration.kt$ExistingInitiatingFlow${ // Otherwise they're at least on version 2 and so we can send the finalised transaction on the existing session. subFlow(FinalityFlow(fullySignedTx, session)) }</ID>
    <ID>MaxLineLength:FinalityFlowMigration.kt$ExistingResponderFlow${ // The other side is not using the old CorDapp so call ReceiveFinalityFlow to record the finalised transaction. // If SignTransactionFlow is used then we can verify the tranaction we receive for recording is the same one // that was just signed. subFlow(ReceiveFinalityFlow(otherSide, expectedTxId = txWeJustSigned.id)) }</ID>
    <ID>MaxLineLength:FinalityFlowTests.kt$FinalityFlowTests$override val mockNet = InternalMockNetwork(cordappsForAllNodes = listOf(FINANCE_CONTRACTS_CORDAPP, enclosedCordapp()))</ID>
    <ID>MaxLineLength:FinalityHandlerTest.kt$FinalityHandlerTest$( legalName = BOB_NAME, // The node disables the FinalityHandler completely if there are no old CorDapps loaded, so we need to add // a token old CorDapp to keep the handler running. additionalCordapps = setOf(DUMMY_CONTRACTS_CORDAPP.copy(targetPlatformVersion = 3)) )</ID>
    <ID>MaxLineLength:FinalityHandlerTest.kt$FinalityHandlerTest$val alice = mockNet.createNode(InternalMockNodeParameters(legalName = ALICE_NAME, additionalCordapps = FINANCE_CORDAPPS))</ID>
    <ID>MaxLineLength:FinalityHandlerTest.kt$FinalityHandlerTest${ // Setup a network where only Alice has the finance CorDapp and it sends a cash tx to Bob who doesn't have the // CorDapp. Bob's FinalityHandler will error when validating the tx. val alice = mockNet.createNode(InternalMockNodeParameters(legalName = ALICE_NAME, additionalCordapps = FINANCE_CORDAPPS)) var bob = mockNet.createNode(InternalMockNodeParameters( legalName = BOB_NAME, // The node disables the FinalityHandler completely if there are no old CorDapps loaded, so we need to add // a token old CorDapp to keep the handler running. additionalCordapps = setOf(DUMMY_CONTRACTS_CORDAPP.copy(targetPlatformVersion = 3)) )) val stx = alice.issueCashTo(bob) val finalityHandlerId = bob.trackFinalityHandlerId().run { alice.finaliseWithOldApi(stx) getOrThrow() } bob.assertFlowSentForObservationDueToConstraintError(finalityHandlerId) assertThat(bob.getTransaction(stx.id)).isNull() bob = mockNet.restartNode(bob) // Since we've not done anything to fix the orignal error, we expect the finality handler to be sent to the hospital // again on restart bob.assertFlowSentForObservationDueToConstraintError(finalityHandlerId) assertThat(bob.getTransaction(stx.id)).isNull() }</ID>
    <ID>MaxLineLength:FinanceJSONSupport.kt$CalendarDeserializer$StringArrayDeserializer.instance.deserialize(parser, context).fold(BusinessCalendar.EMPTY) { acc, name -&gt; acc + loadTestCalendar(name) }</ID>
    <ID>MaxLineLength:FinanceJSONSupport.kt$ExpressionSerializer$override fun serialize(expr: Expression, generator: JsonGenerator, provider: SerializerProvider)</ID>
    <ID>MaxLineLength:FinanceTypes.kt$DateRollConvention</ID>
    <ID>MaxLineLength:FinanceTypes.kt$DealState$ fun generateAgreement(notary: Party): TransactionBuilder</ID>
    <ID>MaxLineLength:FinanceTypes.kt$Tenor$return BusinessCalendar.calculateDaysBetween(startDate, adjustedMaturityDate, DayCountBasisYear.Y360, DayCountBasisDay.DActual)</ID>
    <ID>MaxLineLength:FinanceTypes.kt$Tenor$val match = regex.matchEntire(name)?.groupValues ?: throw IllegalArgumentException("Unrecognised tenor name: $name")</ID>
    <ID>MaxLineLength:FinanceTypes.kt$net.corda.finance.contracts.FinanceTypes.kt</ID>
    <ID>MaxLineLength:FinanceTypesTest.kt$FinanceTypesTest$exampleTenors.all { Tenor(it).name.isNotEmpty() }</ID>
    <ID>MaxLineLength:FinanceTypesTest.kt$FinanceTypesTest$val ret = BusinessCalendar.createGenericSchedule(startDate = LocalDate.of(2014, 11, 25), period = Frequency.Monthly, noOfAdditionalPeriods = 3)</ID>
    <ID>MaxLineLength:FinanceWorkflowsUtils.kt$BusinessCalendar(stream.reader().readText().split(",").map { BusinessCalendar.parseDateFromString(it) }.toSortedSet())</ID>
    <ID>MaxLineLength:FinanceWorkflowsUtils.kt$val stream = UnknownCalendar::class.java.getResourceAsStream("/net/corda/finance/workflows/utils/${name}HolidayCalendar.txt") ?: throw UnknownCalendar(name)</ID>
    <ID>MaxLineLength:FingerPrinterTesting.kt$FingerPrinterTestingTests$val customSerializerRegistry: CustomSerializerRegistry = CachingCustomSerializerRegistry(descriptorBasedSerializerRegistry)</ID>
    <ID>MaxLineLength:FingerPrinterTesting.kt$FingerPrinterTestingTests$val typeModel = ConfigurableLocalTypeModel(WhitelistBasedTypeModelConfiguration(AllWhitelist, customSerializerRegistry))</ID>
    <ID>MaxLineLength:FixingFlow.kt$FixingFlow.Fixer$@Suspendable override</ID>
    <ID>MaxLineLength:FixingFlow.kt$FixingFlow.Fixer$override</ID>
    <ID>MaxLineLength:FixingFlow.kt$FixingFlow.Fixer$val addFixing = object : RatesFixFlow(ptx, handshake.payload.oracle, fixOf, BigDecimal.ZERO, BigDecimal.ONE) { @Suspendable override fun beforeSigning(fix: Fix) { newDeal.generateFix(ptx, StateAndRef(txState, handshake.payload.ref), fix) // We set the transaction's time-window: it may be that none of the contracts need this! // But it can't hurt to have one. ptx.setTimeWindow(serviceHub.clock.instant(), 30.seconds) } @Suspendable override fun filtering(elem: Any): Boolean { return when (elem) { // Only expose Fix commands in which the oracle is on the list of requested signers // to the oracle node, to avoid leaking privacy is Command&lt;*&gt; -&gt; handshake.payload.oracle.owningKey in elem.signers &amp;&amp; elem.value is Fix else -&gt; false } } }</ID>
    <ID>MaxLineLength:FixingFlow.kt$FixingFlow.FixingRoleDecider$val counterparty = serviceHub.identityService.wellKnownPartyFromAnonymous(parties[1]) ?: throw IllegalStateException("Cannot resolve floater party")</ID>
    <ID>MaxLineLength:FlattenedList.kt$FlattenedList${ // TODO this assumes that if wasAdded() == true then we are adding elements to the getFrom() position val removeStart = c.from val removeRange = c.removed.size val removeEnd = c.from + removeRange val iterator = indexMap.iterator() for (entry in iterator) { val (wrapped, pair) = entry val (index, listener) = pair if (index &gt;= removeStart) { if (index &lt; removeEnd) { wrapped.observableValue.removeListener(listener) iterator.remove() } else { // Shift indices entry.setValue(Pair(index - removeRange, listener)) } } } nextRemove(removeStart, removed.map { it.value }) }</ID>
    <ID>MaxLineLength:FlattenedList.kt$FlattenedList&lt;A&gt; : TransformationList</ID>
    <ID>MaxLineLength:FlowAsyncOperationTests.kt$FlowAsyncOperationTests.WorkerServiceTask$private</ID>
    <ID>MaxLineLength:FlowCheckpointCordapp.kt$SendMessageFlow : FlowLogic</ID>
    <ID>MaxLineLength:FlowCheckpointCordapp.kt$SendMessageFlow$val txBuilder = TransactionBuilder(notary).withItems(StateAndContract(messageState, MESSAGE_CONTRACT_PROGRAM_ID), txCommand)</ID>
    <ID>MaxLineLength:FlowCheckpointCordapp.kt$SendMessageFlow.Companion$fun tracker()</ID>
    <ID>MaxLineLength:FlowCheckpointVersionNodeStartupCheckTest.kt$FlowCheckpointVersionNodeStartupCheckTest$( // The part of the log message generated by CheckpointIncompatibleException.FlowVersionIncompatibleException "that is incompatible with the current installed version of" )</ID>
    <ID>MaxLineLength:FlowCheckpointVersionNodeStartupCheckTest.kt$FlowCheckpointVersionNodeStartupCheckTest$assertThat(defaultCordapp.jarFile.hash).isNotEqualTo(modifiedCordapp.jarFile.hash)</ID>
    <ID>MaxLineLength:FlowCheckpointVersionNodeStartupCheckTest.kt$FlowCheckpointVersionNodeStartupCheckTest$bob.rpc.stateMachinesFeed().let { it.updates.map { it.id }.startWith(it.snapshot.map { it.id }) }.toBlocking().first()</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow : FlowLogic</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$serviceHub.identityService.partyFromKey(dummyPubKey) ?: throw IllegalArgumentException("Couldn't find counterparty with key: $dummyPubKey in identity service")</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val fullySignedTx: SignedTransaction = subFlow(CollectSignaturesFlow(twiceSignedTx, setOf(counterpartySession, regulatorSession), SIGS_GATHERING.childProgressTracker()))</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val notarisedTx1: SignedTransaction = subFlow(FinalityFlow(fullySignedTx, listOf(counterpartySession), FINALISATION.childProgressTracker()))</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val notarisedTx2: SignedTransaction = subFlow(FinalityFlow(fullySignedTx, partySessions, FINALISATION.childProgressTracker()))</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val otherIdentity2: PartyAndCertificate = serviceHub.keyManagementService.freshKeyAndCert(ourIdentityAndCert, false)</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val otherIdentity: PartyAndCertificate = serviceHub.keyManagementService.freshKeyAndCert(ourIdentityAndCert, false)</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val packet2: UntrustworthyData&lt;Boolean&gt; = counterpartySession.sendAndReceive&lt;Boolean&gt;("You can send and receive any class!")</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val txState: TransactionState&lt;DummyState&gt; = TransactionState(ourOutputState, DummyContract.PROGRAM_ID, specificNotary)</ID>
    <ID>MaxLineLength:FlowCookbook.kt$ResponderFlow${ // The ``ResponderFlow` has all the same APIs available. It looks // up network information, sends and receives data, and constructs // transactions in exactly the same way. /**----------------------------- * SENDING AND RECEIVING DATA * -----------------------------**/ progressTracker.currentStep = RECEIVING_AND_SENDING_DATA // We need to respond to the messages sent by the initiator: // 1. They sent us an ``Any`` instance // 2. They waited to receive an ``Integer`` instance back // 3. They sent a ``String`` instance and waited to receive a // ``Boolean`` instance back // Our side of the flow must mirror these calls. // DOCSTART 08 val any: Any = counterpartySession.receive&lt;Any&gt;().unwrap { data -&gt; data } val string: String = counterpartySession.sendAndReceive&lt;String&gt;(99).unwrap { data -&gt; data } counterpartySession.send(true) // DOCEND 08 /**---------------------------------------- * RESPONDING TO COLLECT_SIGNATURES_FLOW * ----------------------------------------**/ progressTracker.currentStep = SIGNING // The responder will often need to respond to a call to // ``CollectSignaturesFlow``. It does so my invoking its own // ``SignTransactionFlow`` subclass. // DOCSTART 16 val signTransactionFlow: SignTransactionFlow = object : SignTransactionFlow(counterpartySession) { override fun checkTransaction(stx: SignedTransaction) = requireThat { // Any additional checking we see fit... val outputState = stx.tx.outputsOfType&lt;DummyState&gt;().single() require(outputState.magicNumber == 777) } } val idOfTxWeSigned = subFlow(signTransactionFlow).id // DOCEND 16 /**----------------------------- * FINALISING THE TRANSACTION * -----------------------------**/ progressTracker.currentStep = FINALISATION // As the final step the responder waits to receive the notarised transaction from the sending party // Since it knows the ID of the transaction it just signed, the transaction ID is specified to ensure the correct // transaction is received and recorded. // DOCSTART ReceiveFinalityFlow subFlow(ReceiveFinalityFlow(counterpartySession, expectedTxId = idOfTxWeSigned)) // DOCEND ReceiveFinalityFlow }</ID>
    <ID>MaxLineLength:FlowException.kt$FlowException : CordaExceptionIdentifiableException</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$aliceNode = mockNet.createNode(InternalMockNodeParameters(legalName = ALICE_NAME, flowManager = aliceFlowManager))</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$assertEquals(0, charlieNode.internals.checkpointStorage.checkpoints().size, "Checkpoints left after restored flow should have ended")</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$assertEquals(0, node2b.internals.checkpointStorage.checkpoints().size, "Checkpoints left after restored flow should have ended")</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$assertEquals(payload + 1, secondFlow.getOrThrow().receivedPayload2, "Received payload does not match the expected second value on Node 2")</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$assertEquals(payload, secondFlow.getOrThrow().receivedPayload, "Received payload does not match the (restarted) first value on Node 2")</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$assertEquals(payload2 + 1, firstAgain.receivedPayload2, "Received payload does not match the expected second value on Node 3")</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$mockNet.messagingNetwork.sentMessages.toSessionTransfers().filter { it.isPayloadTransfer }.forEach { sentCount++ }</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests${ val payload = random63BitValue() val payload2 = random63BitValue() var sentCount = 0 mockNet.messagingNetwork.sentMessages.toSessionTransfers().filter { it.isPayloadTransfer }.forEach { sentCount++ } val charlieNode = mockNet.createNode(InternalMockNodeParameters(legalName = CHARLIE_NAME)) val secondFlow = charlieNode.registerCordappFlowFactory(PingPongFlow::class) { PingPongFlow(it, payload2) } mockNet.runNetwork() val charlie = charlieNode.info.singleIdentity() // Kick off first send and receive bobNode.services.startFlow(PingPongFlow(charlie, payload)) bobNode.database.transaction { assertEquals(1, bobNode.internals.checkpointStorage.checkpoints().size) } // Make sure the add() has finished initial processing. bobNode.internals.disableDBCloseOnStop() // Restart node and thus reload the checkpoint and resend the message with same UUID bobNode.dispose() bobNode.database.transaction { assertEquals(1, bobNode.internals.checkpointStorage.checkpoints().size) // confirm checkpoint bobNode.services.networkMapCache.clearNetworkMapCache() } val node2b = mockNet.createNode(InternalMockNodeParameters(bobNode.internals.id)) bobNode.internals.manuallyCloseDB() val (firstAgain, fut1) = node2b.getSingleFlow&lt;PingPongFlow&gt;() // Run the network which will also fire up the second flow. First message should get deduped. So message data stays in sync. mockNet.runNetwork() fut1.getOrThrow() val receivedCount = receivedSessionMessages.count { it.isPayloadTransfer } // Check flows completed cleanly and didn't get out of phase assertEquals(4, receivedCount, "Flow should have exchanged 4 unique messages") // Two messages each way // can't give a precise value as every addMessageHandler re-runs the undelivered messages assertTrue(sentCount &gt; receivedCount, "Node restart should have retransmitted messages") node2b.database.transaction { assertEquals(0, node2b.internals.checkpointStorage.checkpoints().size, "Checkpoints left after restored flow should have ended") } charlieNode.database.transaction { assertEquals(0, charlieNode.internals.checkpointStorage.checkpoints().size, "Checkpoints left after restored flow should have ended") } assertEquals(payload2, firstAgain.receivedPayload, "Received payload does not match the first value on Node 3") assertEquals(payload2 + 1, firstAgain.receivedPayload2, "Received payload does not match the expected second value on Node 3") assertEquals(payload, secondFlow.getOrThrow().receivedPayload, "Received payload does not match the (restarted) first value on Node 2") assertEquals(payload + 1, secondFlow.getOrThrow().receivedPayload2, "Received payload does not match the expected second value on Node 2") }</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$CommitReceiverFlow : FlowLogic</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$CommitterFlow : FlowLogic</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$SuspendThrowingActionExecutor : ActionExecutor</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$WaitForLedgerCommitFlow : FlowLogic</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$aliceNode.registerCordappFlowFactory(WaitForLedgerCommitFlow::class) { ExceptionFlow { throw Exception("Error") } }</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$aliceNode.sendSessionMessage(InitialSessionMessage(SessionId(random63BitValue()), 0, "not.a.real.Class", 1, "", null), bob)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$aliceNode.sendSessionMessage(InitialSessionMessage(SessionId(random63BitValue()), 0, String::class.java.name, 1, "", null), bob)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$assertThat((lastMessage.payload as RejectSessionMessage).message).isEqualTo("${String::class.java.name} is not a flow")</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$assertThat(committerStx.getOrThrow()).isEqualTo(waiterStx.getOrThrow()).isEqualTo(commitReceiverStx.getOrThrow())</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$assertThat(receivedSessionMessages).hasSize(1)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$assertThatExceptionOfType(MyFlowException::class.java) .isThrownBy { receivingFiber.resultFuture.getOrThrow() } .withMessage("Nothing useful") .withStackTraceContaining(ReceiveFlow::class.java.name)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$assertThatExceptionOfType(MyPeerFlowException::class.java) .isThrownBy { receivingFiber.resultFuture.getOrThrow() } .has(Condition(Predicate&lt;MyPeerFlowException&gt; { it.peer == alice }, "subclassed peer field has original value"))</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$bobNode.registerCordappFlowFactory(UpgradedFlow::class, initiatedFlowVersion = 1) { InitiatedSendFlow("Old initiated", it) }</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$bobNode.smm.flowHospital.dropSessionInit(sessionInitRecord.id)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$fiber.transientValues = TransientReference(fiber.transientValues!!.value.copy(actionExecutor = throwingActionExecutor))</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$val anonymousBob = bobNode.services.keyManagementService.freshKeyAndCert(bobNode.info.legalIdentitiesAndCerts.single(), false)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$val anonymousBob = bobNode.services.keyManagementService.freshKeyAndCert(bobNode.info.legalIdentitiesAndCerts.single(), false) .party.anonymise()</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$val bobResponderFlow = bobNode.registerCordappFlowFactory(SendAndReceiveFlow::class) { SingleInlinedSubFlow(it) }</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$val result = aliceNode.services.startFlow(SendAndReceiveFlow(anonymousBob.party.anonymise(), "Hello")).resultFuture</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$val throwingActionExecutor = SuspendThrowingActionExecutor(exceptionDuringSuspend, fiber.transientValues!!.value.actionExecutor)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests.ConditionalExceptionFlow$private</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests.IncorrectCustomSendFlow$@InitiatingFlow private</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests.UpgradedFlow$@InitiatingFlow(version = 2) private</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$InitiatedSendFlow$internal open</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$PingPongFlow$constructor(otherPartySession: FlowSession, payload: Long) : this(otherPartySession.counterparty, payload, otherPartySession)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$SendAndReceiveFlow$constructor(otherPartySession: FlowSession, payload: Any) : this(otherPartySession.counterparty, payload, otherPartySession)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$internal</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$internal fun errorMessage(errorResponse: FlowException? = null)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$internal fun sessionConfirm(flowVersion: Int = 1)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$internal infix fun Pair&lt;Int, SessionMessage&gt;.to(node: TestStartedNode): SessionTransfer</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$internal infix fun TestStartedNode.sent(message: SessionMessage): Pair&lt;Int, SessionMessage&gt;</ID>
    <ID>MaxLineLength:FlowFrameworkTripartyTests.kt$FlowFrameworkTripartyTests$charlieNode.registerCordappFlowFactory(ReceiveFlow::class) { ExceptionFlow { MyFlowException("Nothing useful") } }</ID>
    <ID>MaxLineLength:FlowFrameworkTripartyTests.kt$FlowFrameworkTripartyTests$val actualForNode = receivedSessionMessages.filter { it.from == node.internals.id || it.to == node.network.myAddress }</ID>
    <ID>MaxLineLength:FlowHandle.kt$FlowProgressHandle&lt;A&gt; : FlowHandle</ID>
    <ID>MaxLineLength:FlowHandle.kt$FlowProgressHandleImpl$// For API compatibility fun copy(id: StateMachineRunId, returnValue: CordaFuture&lt;A&gt;, progress: Observable&lt;String&gt;): FlowProgressHandleImpl&lt;A&gt;</ID>
    <ID>MaxLineLength:FlowHandle.kt$FlowProgressHandleImpl$return copy(id = id, returnValue = returnValue, progress = progress, stepsTreeFeed = null, stepsTreeIndexFeed = null)</ID>
    <ID>MaxLineLength:FlowInitiator.kt$FlowInitiator : Principal</ID>
    <ID>MaxLineLength:FlowInitiator.kt$FlowInitiator$/** * Returns an [InvocationContext], which is equivalent to this object but expressed using the successor to this * class hierarchy (which is now deprecated). The returned object has less information than it could have, so * prefer to use fetch an invocation context directly if you can (e.g. in [net.corda.core.messaging.StateMachineInfo]) */ val invocationContext: InvocationContext get() { val unknownName = CordaX500Name("UNKNOWN", "UNKNOWN", "GB") var actor: Actor? = null val origin: InvocationOrigin when (this) { is FlowInitiator.RPC -&gt; { actor = Actor(Actor.Id(this.username), AuthServiceId("UNKNOWN"), unknownName) origin = InvocationOrigin.RPC(actor) } is FlowInitiator.Peer -&gt; origin = InvocationOrigin.Peer(this.party.name) is FlowInitiator.Service -&gt; origin = InvocationOrigin.Service(this.serviceClassName, unknownName) FlowInitiator.Shell -&gt; origin = InvocationOrigin.Shell is FlowInitiator.Scheduled -&gt; origin = InvocationOrigin.Scheduled(this.scheduledState) } return InvocationContext.newInstance(origin = origin, actor = actor) }</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Deprecated("Use FlowSession.getCounterpartyFlowInfo()", level = DeprecationLevel.WARNING) @Suspendable fun getFlowInfo(otherParty: Party): FlowInfo</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Deprecated("Use FlowSession.sendAndReceive()", level = DeprecationLevel.WARNING) @Suspendable open fun &lt;R : Any&gt; sendAndReceive(receiveType: Class&lt;R&gt;, otherParty: Party, payload: Any): UntrustworthyData&lt;R&gt;</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Suspendable @JvmOverloads open fun &lt;R : Any&gt; receiveAll( receiveType: Class&lt;R&gt;, sessions: List&lt;FlowSession&gt;, maySkipCheckpoint: Boolean = false ): List&lt;UntrustworthyData&lt;R&gt;&gt;</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Suspendable @JvmOverloads open fun receiveAllMap(sessions: Map&lt;FlowSession, Class&lt;out Any&gt;&gt;, maySkipCheckpoint: Boolean = false): Map&lt;FlowSession, UntrustworthyData&lt;Any&gt;&gt;</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Suspendable fun initiateFlow(destination: Destination): FlowSession</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Suspendable fun waitForStateConsumption(stateRefs: Set&lt;StateRef&gt;)</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Throws(FlowException::class) fun checkFlowPermission(permissionName: String, extraAuditData: Map&lt;String, String&gt;)</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ fun recordAuditEvent(eventType: String, comment: String, extraAuditData: Map&lt;String, String&gt;)</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ fun trackStepsTree(): DataFeed&lt;List&lt;Pair&lt;Int, String&gt;&gt;, List&lt;Pair&lt;Int, String&gt;&gt;&gt;?</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ fun trackStepsTreeIndex(): DataFeed&lt;Int, Int&gt;?</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$/** * @suppress * Internal only. Reference to the [co.paralleluniverse.fibers.Fiber] instance that is the top level controller for * the entire flow. When inside a flow this is equivalent to [co.paralleluniverse.strands.Strand.currentStrand]. This * is public only because it must be accessed across module boundaries. */ var stateMachine: FlowStateMachine&lt;*&gt; @CordaInternal get() = _stateMachine ?: throw IllegalStateException( "You cannot access the flow's state machine until the flow has been started.") @CordaInternal set(value) { _stateMachine = value }</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$/** * Override this to provide a [ProgressTracker]. If one is provided and stepped, the framework will do something * helpful with the progress reports e.g record to the audit service. If this flow is invoked as a subflow of another, * then the tracker will be made a child of the current step in the parent. If it's null, this flow doesn't track * progress. * * Note that this has to return a tracker before the flow is invoked. You can't change your mind half way * through. */ open val progressTracker: ProgressTracker? = DEFAULT_TRACKER()</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$/** * Specifies the identity to use for this flow. This will be one of the multiple identities that belong to this node. * This is the same as calling `ourIdentityAndCert.party`. * @see NodeInfo.legalIdentities * * Note: The current implementation returns the single identity of the node. This will change once multiple identities * is implemented. */ val ourIdentity: Party get() = stateMachine.ourIdentity</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$/** * Specifies the identity, with certificate, to use for this flow. This will be one of the multiple identities that * belong to this node. * @see NodeInfo.legalIdentitiesAndCerts * * Note: The current implementation returns the single identity of the node. This will change once multiple identities * is implemented. */ val ourIdentityAndCert: PartyAndCertificate get() { return serviceHub.myInfo.legalIdentitiesAndCerts.find { it.party == stateMachine.ourIdentity } ?: throw IllegalStateException("Identity specified by ${stateMachine.id} (${stateMachine.ourIdentity}) is not one of ours!") }</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$?:</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$@Suspendable @JvmOverloads open</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$@Suspendable internal</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$private</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic.Companion$throw FlowException("Attempt to sleep for longer than 5 minutes is not supported. Consider using SchedulableState.")</ID>
    <ID>MaxLineLength:FlowLogicRef.kt$FlowLogicRef</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl : SingletonSerializeAsTokenFlowLogicRefFactory</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$forName.asSubclass(FlowLogic::class.java) ?: throw IllegalFlowLogicException(flowClassName, "The class $flowClassName is not a subclass of FlowLogic.")</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$if (ref !is FlowLogicRefImpl) throw IllegalFlowLogicException(ref.javaClass, "FlowLogicRef was not created via correct FlowLogicRefFactory interface")</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$open</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$private</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$protected open</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$return (value is Any &amp;&amp; parameterAssignableFrom(parameter.type.javaType, value)) || parameter.type.isMarkedNullable</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefImpl$@CordaSerializable data</ID>
    <ID>MaxLineLength:FlowManager.kt$FlowManager</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$"${InitiatingFlow::class.java.name}.version not applicable for core flows; their version is the node's platform version"</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$// To verify the integrity of the current state, it is important that the tip of the responders is a unique weight // if there are multiple flows with the same weight as the tip, it means that it is impossible to reliably pick one as the responder private fun validateInvariants(toValidate: List&lt;RegisteredFlowContainer&gt;)</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$@Synchronized override</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$FlowWeightComparator : Comparator</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$log</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$log.warn("Multiple flows are registered for InitiatingFlow: $initiatingFlowClass, currently using: ${listOfFlowsForInitiator.first().initiatedFlowClass}")</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$registerInitiatedCoreFlowFactory(initiatingFlowClass, initiatedFlowClass, InitiatedFlowFactory.Core(flowFactory))</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$throw IllegalArgumentException("$responder must have a constructor accepting a ${FlowSession::class.java.name}")</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$val equalWeightAsCurrentTip = toValidate.map { flowWeightComparator.compare(currentTip, it) to it }.filter { it.first == 0 }.map { it.second }</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$val flowToAdd = RegisteredFlowContainer(initiatingFlowClass, initiatedFlowClass, flowFactory, FlowType.CORDAPP)</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$val message = "Unable to determine which flow to use when responding to: ${currentTip.initiatingFlowClass.canonicalName}. ${equalWeightAsCurrentTip.map { it.initiatedFlowClass!!.canonicalName }} are all registered with equal weight."</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager.FlowWeightComparator$override</ID>
    <ID>MaxLineLength:FlowMessaging.kt$FlowMessagingImpl$val mightDeadlockDrainingTarget = FlowStateMachineImpl.currentStateMachine()?.context?.origin.let { it is InvocationOrigin.Peer &amp;&amp; it.party == target.name }</ID>
    <ID>MaxLineLength:FlowMessaging.kt$FlowMessagingImpl$val networkMessage = serviceHub.networkService.createMessage(sessionTopic, serializeSessionMessage(message).bytes, deduplicationId, message.additionalHeaders(party))</ID>
    <ID>MaxLineLength:FlowMessaging.kt$FlowMessagingImpl$val wellKnown = requireNotNull(serviceHub.identityService.wellKnownPartyFromAnonymous(destination as AnonymousParty)) { "We do not know who $destination belongs to" }</ID>
    <ID>MaxLineLength:FlowMessaging.kt$FlowMessagingImpl${ // Handling Kryo and AMQP serialization problems. Unfortunately the two exception types do not share much of a common exception interface. if ((exception is KryoException || exception is NotSerializableException) &amp;&amp; message is ExistingSessionMessage &amp;&amp; message.payload is ErrorSessionMessage) { val error = message.payload.flowException val rewrappedError = FlowException(error?.message) message.copy(payload = message.payload.copy(flowException = rewrappedError)).serialize() } else { throw exception } }</ID>
    <ID>MaxLineLength:FlowMessaging.kt$FlowMessagingImpl${ // This prevents a "deadlock" in case an initiated flow tries to start a session against a draining node that is also the initiator. // It does not help in case more than 2 nodes are involved in a circle, so the kill switch via RPC should be used in that case. val mightDeadlockDrainingTarget = FlowStateMachineImpl.currentStateMachine()?.context?.origin.let { it is InvocationOrigin.Peer &amp;&amp; it.party == target.name } return when { this !is InitialSessionMessage || mightDeadlockDrainingTarget -&gt; emptyMap() else -&gt; mapOf(P2PMessagingHeaders.Type.KEY to P2PMessagingHeaders.Type.SESSION_INIT_VALUE) } }</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$flow.ioRequest()?.let { request -&gt; warningMessageForFlowWaitingOnIo(request, flow, now) }?.let(logger::info)</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$is FlowIORequest.ExecuteAsyncOperation -&gt; "for asynchronous operation of type ${request.operation::javaClass} to complete"</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$is FlowIORequest.GetFlowInfo -&gt; "to get flow information from parties ${request.sessions.partiesInvolved()}"</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$is FlowIORequest.Send -&gt; "to send a message to parties ${request.sessionToMessage.keys.partiesInvolved()}"</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$is FlowIORequest.SendAndReceive -&gt; "to send and receive messages from parties ${request.sessionToMessage.keys.partiesInvolved()}"</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$is FlowIORequest.Sleep -&gt; "to wake up from sleep ending at ${LocalDateTime.ofInstant(request.wakeUpAfter, ZoneId.systemDefault())}"</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$is FlowIORequest.WaitForLedgerCommit -&gt; "for the ledger to commit transaction with hash ${request.hash}"</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$private</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$private fun FlowStateMachineImpl&lt;*&gt;.ioRequest()</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$scheduler!!.scheduleAtFixedRate({ logFlowsWaitingForParty(suspensionLoggingThreshold) }, 0, monitoringPeriod.toMillis(), TimeUnit.MILLISECONDS)</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$val message = StringBuilder("Flow with id ${flow.id.uuid} has been waiting for ${flow.ongoingDuration(now).toMillis() / 1000} seconds ")</ID>
    <ID>MaxLineLength:FlowOverrideTests.kt$FlowOverrideTests$assertThat(nodeB.rpc.startFlow(::Ping, nodeA.nodeInfo.singleIdentity()).returnValue.getOrThrow(), `is`(Pong.PONG))</ID>
    <ID>MaxLineLength:FlowOverrideTests.kt$FlowOverrideTests$assertThat(nodeB.rpc.startFlow(::Ping, nodeA.nodeInfo.singleIdentity()).returnValue.getOrThrow(), `is`(Pongiest.GORGONZOLA))</ID>
    <ID>MaxLineLength:FlowRetryTest.kt$FlowRetryTest$@Test fun `SQLTransientConnectionExceptions thrown by hikari are retried 3 times and then kept in the checkpoints table`()</ID>
    <ID>MaxLineLength:FlowRetryTest.kt$FlowRetryTest$it.proxy.startFlow(::GeneralExternalFailureFlow, nodeBHandle.nodeInfo.singleIdentity()).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:FlowRetryTest.kt$FlowRetryTest$it.proxy.startFlow(::InitiatorFlow, numSessions, numIterations, nodeBHandle.nodeInfo.singleIdentity()).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:FlowRetryTest.kt$InitiatorFlow : FlowLogic</ID>
    <ID>MaxLineLength:FlowRetryTest.kt$Step</ID>
    <ID>MaxLineLength:FlowRetryTest.kt$WrappedTransientConnectionFailureFlow$throw IllegalStateException("wrapped error message", IllegalStateException("another layer deep", SQLTransientConnectionException("Connection is not available")/*.fillInStackTrace()*/))</ID>
    <ID>MaxLineLength:FlowSession.kt$Destination</ID>
    <ID>MaxLineLength:FlowSession.kt$FlowSession$/** * If the destination on the other side of this session is a [Party] then returns that, otherwise throws [IllegalStateException]. * * Only use this method if it's known the other side is a [Party], otherwise use [destination]. * * @throws IllegalStateException if the other side is not a [Party]. * @see destination */ abstract val counterparty: Party</ID>
    <ID>MaxLineLength:FlowSession.kt$FlowSession$/** * The [Destination] on the other side of this session. In the case of a session created by [FlowLogic.initiateFlow] this is the same * destination as the one passed to that function. */ abstract val destination: Destination</ID>
    <ID>MaxLineLength:FlowSessionImpl.kt$FlowSessionImpl$@Suspendable override</ID>
    <ID>MaxLineLength:FlowSessionImpl.kt$FlowSessionImpl$override fun equals(other: Any?): Boolean</ID>
    <ID>MaxLineLength:FlowSessionImpl.kt$FlowSessionImpl$val responseValues: Map&lt;FlowSession, SerializedBytes&lt;Any&gt;&gt; = flowStateMachine.suspend(request, maySkipCheckpoint)</ID>
    <ID>MaxLineLength:FlowStackSnapshot.kt$FlowStackSnapshotFactoryImpl$if (it != null &amp;&amp; (it is FlowLogic&lt;*&gt; || it is FlowStateMachine&lt;*&gt; || it is Fiber&lt;*&gt; || it is SerializeAsToken)) { StackFrameDataToken(it::class.java.name) } else { it }</ID>
    <ID>MaxLineLength:FlowStackSnapshot.kt$FlowStackSnapshotFactoryImpl$val stackObjects = if (frameObjectsIterator.hasNext() &amp;&amp; (annotation == null || !annotation.methodOptimized)) { frameObjectsIterator.next() } else { emptyList() }</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$"criteria (specifically: extra objects are introduced to the quasar stack by th Jacoco agent). You can however "</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$@Ignore("When running via gradle the Jacoco agent interferes with the quasar instrumentation process and violates tested" + "criteria (specifically: extra objects are introduced to the quasar stack by th Jacoco agent). You can however " + "run these tests via an IDE.")</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$val a = startNode(rpcUsers = listOf(User(Constants.USER, Constants.PASSWORD, setOf(startFlow&lt;MultiplePersistingSideEffectFlow&gt;())))).get()</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$val a = startNode(rpcUsers = listOf(User(Constants.USER, Constants.PASSWORD, setOf(startFlow&lt;NoSideEffectFlow&gt;())))).get()</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$val a = startNode(rpcUsers = listOf(User(Constants.USER, Constants.PASSWORD, setOf(startFlow&lt;PersistingNoSideEffectFlow&gt;())))).get()</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$val a = startNode(rpcUsers = listOf(User(Constants.USER, Constants.PASSWORD, setOf(startFlow&lt;PersistingSideEffectFlow&gt;())))).get()</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$val a = startNode(rpcUsers = listOf(User(Constants.USER, Constants.PASSWORD, setOf(startFlow&lt;SideEffectFlow&gt;())))).get()</ID>
    <ID>MaxLineLength:FlowStateMachine.kt$FlowStateMachine$@Suspendable fun &lt;SUSPENDRETURN : Any&gt; suspend(ioRequest: FlowIORequest&lt;SUSPENDRETURN&gt;, maySkipCheckpoint: Boolean): SUSPENDRETURN</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$"${InitiatingFlow::class.java.name}. See https://docs.corda.net/api-flows.html#flowlogic-annotations."</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$?:</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$"Transaction context is missing. This might happen if a suspendable method is not annotated with @Suspendable annotation."</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$/** * Return the logger for this state machine. The logger name incorporates [id] and so including it in the log message * is not necessary. */ override val logger = log</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$@Suspendable private</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$Thread.currentThread().contextClassLoader = (serviceHub.cordappProvider as CordappProviderImpl).cordappLoader.appClassLoader</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$errorAndTerminate("Caught unrecoverable error from flow. Forcibly terminating the JVM, this might leave resources open, and most likely will.", t)</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$require(continuation == FlowContinuation.ProcessEvents) { "Expected a continuation of type ${FlowContinuation.ProcessEvents}, found $continuation " }</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$require(destination is Party || destination is AnonymousParty) { "Unsupported destination type ${destination.javaClass.name}" }</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$throw FlowPermissionException("User ${context.principal()} not permissioned for $permissionName on flow $id")</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$val (continuation, newState) = transitionExecutor.executeTransition(this, oldState, event, transition, actionExecutor)</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$val permissionGranted = true // TODO define permission control service on ServiceHubInternal and actually check authorization.</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$val serializationContext = TransientReference(getTransientField(TransientValues::checkpointSerializationContext))</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl${ // This sets the Cordapp classloader on the contextClassLoader of the current thread. // Needed because in previous versions of the finance app we used Thread.contextClassLoader to resolve services defined in cordapps. Thread.currentThread().contextClassLoader = (serviceHub.cordappProvider as CordappProviderImpl).cordappLoader.appClassLoader val result = logic.call() suspend(FlowIORequest.WaitForSessionConfirmations, maySkipCheckpoint = true) Try.Success(result) }</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl.Companion$private val SERIALIZER_BLOCKER = Fiber::class.java.getDeclaredField("SERIALIZER_BLOCKER").apply { isAccessible = true }.get(null)</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$if (found != null) throw IllegalArgumentException("${InitiatingFlow::class.java.name} can only be annotated once")</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$ @Suspendable fun &lt;R : Any&gt; FlowLogic&lt;*&gt;.receiveAll(receiveType: Class&lt;R&gt;, session: FlowSession, vararg sessions: FlowSession): List&lt;UntrustworthyData&lt;R&gt;&gt;</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$ @Suspendable fun FlowLogic&lt;*&gt;.receiveAll( session: Pair&lt;FlowSession, Class&lt;out Any&gt;&gt;, vararg sessions: Pair&lt;FlowSession, Class&lt;out Any&gt;&gt; ): Map&lt;FlowSession, UntrustworthyData&lt;Any&gt;&gt;</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$ @Suspendable inline fun &lt;reified R : Any&gt; FlowLogic&lt;*&gt;.receiveAll(session: FlowSession, vararg sessions: FlowSession): List&lt;UntrustworthyData&lt;R&gt;&gt;</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$@Suppress("UNCHECKED_CAST") infix</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$@Suspendable inline</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$return this.internals.registerInitiatedFlowFactory(initiatingFlowClass, initiatedFlowClass, InitiatedFlowFactory.Core(flowFactory), track)</ID>
    <ID>MaxLineLength:FlowWatchPrintingSubscriber.kt$FlowWatchPrintingSubscriber$val header = RowElement(true).add("Id", "Flow name", "Initiator", "Status").style(Decoration.bold.fg(Color.black).bg(Color.white))</ID>
    <ID>MaxLineLength:FlowsDrainingModeContentionTest.kt$FlowsDrainingModeContentionTest$val flow = nodeA.rpc.startFlow(::ProposeTransactionAndWaitForCommit, message, nodeARpcInfo, nodeB.nodeInfo.singleIdentity(), defaultNotaryIdentity)</ID>
    <ID>MaxLineLength:FlowsExecutionModeRpcTest.kt$FlowsExecutionModeRpcTest$val user = User("mark", "dadada", setOf(Permissions.invokeRpc("setFlowsDrainingModeEnabled"), Permissions.invokeRpc("isFlowsDrainingModeEnabled")))</ID>
    <ID>MaxLineLength:FungibleAsset.kt$InsufficientBalanceException : FlowException</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$val sum = it.filter { it.owner.let { it is Party &amp;&amp; serviceHub.myInfo.isLegalIdentity(it) } }.map { it.amount.quantity }.sum()</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$ForeignExchangeRemoteFlow$val ourKey = serviceHub.keyManagementService.filterMyKeys(ourInputState.flatMap { it.state.data.participants }.map { it.owningKey }).single()</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$private</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$val eligibleStates = serviceHub.vaultService.tryLockFungibleStatesForSpending(lockId, fullCriteria, amountRequired.withoutIssuer(), Cash.State::class.java)</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$val logicalExpression = builder { CashSchemaV1.PersistentCashState::currency.equal(amountRequired.token.product.currencyCode) }</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$val ourParties = ourKeys.map { serviceHub.identityService.partyFromKey(it) ?: throw IllegalStateException("Unable to resolve party from key") }</ID>
    <ID>MaxLineLength:GenerateHelpers.kt$return generateAmount(1, max, Generator.pure(Issued(PartyAndReference(issuer, OpaqueBytes.of(0)), currency))).combine( Generator.pickOne(possibleRecipients) ) { amount, recipient -&gt; PaymentRequest(amount.withoutIssuer(), recipient, true, setOf(issuer)) }</ID>
    <ID>MaxLineLength:GenerateNodeInfoCli.kt$GenerateNodeInfoCli : NodeCliCommand</ID>
    <ID>MaxLineLength:GenerateRpcSslCertsCli.kt$GenerateRpcSslCerts$println("You need to distribute this file along with the password in a secure way to all RPC clients.")</ID>
    <ID>MaxLineLength:GenerateRpcSslCertsCli.kt$GenerateRpcSslCertsCli : NodeCliCommand</ID>
    <ID>MaxLineLength:Generator.kt$Generator$product&lt;R&gt;(other1.product(other2.product(other3.product(other4.product(pure({ e -&gt; { d -&gt; { c -&gt; { b -&gt; { a -&gt; function(a, b, c, d, e) } } } } }))))))</ID>
    <ID>MaxLineLength:Generator.kt$Generator$product&lt;R&gt;(other1.product(other2.product(other3.product(pure({ d -&gt; { c -&gt; { b -&gt; { a -&gt; function(a, b, c, d) } } } })))))</ID>
    <ID>MaxLineLength:Generator.kt$Generator.Companion$fun &lt;A&gt; replicatePoisson(meanSize: Double, generator: Generator&lt;A&gt;, atLeastOne: Boolean = false)</ID>
    <ID>MaxLineLength:Generator.kt$Generator&lt;out A&gt;</ID>
    <ID>MaxLineLength:GenericsTests.kt$GenericsTests$val bytes = SerializationOutput(factory).serializeAndReturnSchema(Wrapper(1, G1("hi"), G2("poop"))).apply { printSchema() }</ID>
    <ID>MaxLineLength:GetBalances.kt$CashSchemaV1.PersistentCashState::pennies</ID>
    <ID>MaxLineLength:GetBalances.kt$require(rows.otherResults[1] == currency.currencyCode) { "Currency on rows returned by query does not match expected" }</ID>
    <ID>MaxLineLength:GetBalances.kt$val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:GetBalances.kt${ val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) } val sumCriteria = QueryCriteria.VaultCustomQueryCriteria(sum) val ccyIndex = builder { CashSchemaV1.PersistentCashState::currency.equal(currency.currencyCode) } // This query should only return cash states the calling node is a participant of (meaning they can be modified/spent). val ccyCriteria = QueryCriteria.VaultCustomQueryCriteria(ccyIndex, relevancyStatus = Vault.RelevancyStatus.RELEVANT) return sumCriteria.and(ccyCriteria) }</ID>
    <ID>MaxLineLength:GetBalances.kt${ val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency), orderBy = Sort.Direction.DESC) } // This query should only return cash states the calling node is a participant of (meaning they can be modified/spent). return QueryCriteria.VaultCustomQueryCriteria(sum, relevancyStatus = Vault.RelevancyStatus.RELEVANT) }</ID>
    <ID>MaxLineLength:GroupATests.kt$GroupATests$"forClassGroupATests-setup"</ID>
    <ID>MaxLineLength:GroupBTests.kt$GroupBTests$"forClassGroupBTests-setup"</ID>
    <ID>MaxLineLength:GuiUtilities.kt$ fun &lt;T&gt; stringConverter(fromStringFunction: ((String?) -&gt; T)? = null, toStringFunction: (T) -&gt; String): StringConverter&lt;T&gt;</ID>
    <ID>MaxLineLength:GuiUtilities.kt$// TODO: This is a temporary fix for the UI to show the correct issuer identity, this will break when we start randomizing keys. More work is needed here when the identity work is done. fun StateAndRef&lt;Cash.State&gt;.resolveIssuer(): ObservableValue&lt;Party?&gt;</ID>
    <ID>MaxLineLength:GuiUtilities.kt$fun PublicKey.toKnownParty()</ID>
    <ID>MaxLineLength:H2SecurityTests.kt$H2SecurityTests$driver</ID>
    <ID>MaxLineLength:H2SecurityTests.kt$H2SecurityTests$startNode</ID>
    <ID>MaxLineLength:H2SecurityTests.kt$H2SecurityTests$startNode(customOverrides = mapOf(h2AddressKey to "${InetAddress.getLocalHost().hostAddress}:${getFreePort()}")).getOrThrow()</ID>
    <ID>MaxLineLength:H2SecurityTests.kt$H2SecurityTests$startNode(customOverrides = mapOf(h2AddressKey to "${InetAddress.getLocalHost().hostName}:${getFreePort()}")).getOrThrow()</ID>
    <ID>MaxLineLength:H2SecurityTests.kt$H2SecurityTests$val nodeHandle = startNode(rpcUsers = listOf(user), customOverrides = mapOf(h2AddressKey to "localhost:$port", dbPasswordKey to "x")).getOrThrow()</ID>
    <ID>MaxLineLength:HTTPNetworkRegistrationService.kt$HTTPNetworkRegistrationService$HTTP_UNAUTHORIZED -&gt; throw CertificateRequestException("Certificate signing request has been rejected: ${conn.errorMessage}")</ID>
    <ID>MaxLineLength:HTTPNetworkRegistrationService.kt$HTTPNetworkRegistrationService$else -&gt; throw IOException("Error while connecting to the Doorman. Http response status code was ${conn.responseCode}.")</ID>
    <ID>MaxLineLength:HTTPNetworkRegistrationService.kt$HTTPNetworkRegistrationService$in TRANSIENT_ERROR_STATUS_CODES -&gt; throw ServiceUnavailableException("Could not connect with Doorman. Http response status code was ${conn.responseCode}.")</ID>
    <ID>MaxLineLength:HardRestartTest.kt$HardRestartTest$val rpc = tlRpc.get() ?: CordaRPCClient(a.rpcAddress).start(demoUser.username, demoUser.password).proxy.also { tlRpc.set(it) }</ID>
    <ID>MaxLineLength:HardRestartTest.kt$HardRestartTest$val string = rpc.startFlow(::RecursiveA, b.nodeInfo.singleIdentity(), 10).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:HashLookupCommandTest.kt$HashLookupCommandTest$testCommand(session, command = "hashLookup ${SecureHash.randomSHA256()}", expected = "No matching transaction found")</ID>
    <ID>MaxLineLength:HashLookupCommandTest.kt$HashLookupCommandTest$testCommand(session, command = "hashLookup ${txId.sha256()}", expected = "Found a matching transaction with Id: $txId")</ID>
    <ID>MaxLineLength:HibernateColumnConverterTests.kt$HibernateColumnConverterTests$// AbstractPartyToX500NameAsStringConverter could cause circular flush of Hibernate session because it is invoked during flush, and a // cache miss was doing a flush. This also checks that loading during flush does actually work. @Test fun `issue some cash on a notary that exists only in the database to check cache loading works in our identity column converters during flush of vault update`()</ID>
    <ID>MaxLineLength:HibernateColumnConverterTests.kt$HibernateColumnConverterTests${ val expected = 500.DOLLARS val ref = OpaqueBytes.of(0x01) // Create parallel set of key and identity services so that the values are not cached, forcing the node caches to do a lookup. val identityService = PersistentIdentityService(TestingNamedCacheFactory()) val originalIdentityService: PersistentIdentityService = services.identityService as PersistentIdentityService identityService.database = originalIdentityService.database identityService.start(originalIdentityService.trustRoot) val keyService = E2ETestKeyManagementService(identityService) keyService.start(setOf(myself.keyPair)) // New identity for a notary (doesn't matter that it's for Bank Of Corda... since not going to use it as an actual notary etc). val newKeyAndCert = keyService.freshKeyAndCert(services.myInfo.legalIdentitiesAndCerts[0], false) val randomNotary = Party(myself.name, newKeyAndCert.owningKey) val ourIdentity = services.myInfo.legalIdentities.first() val builder = TransactionBuilder(notary.party) val issuer = services.myInfo.legalIdentities.first().ref(ref) val signers = Cash().generateIssue(builder, expected.issuedBy(issuer), ourIdentity, randomNotary) val tx: SignedTransaction = services.signInitialTransaction(builder, signers) services.recordTransactions(tx) val output = tx.tx.outputsOfType&lt;Cash.State&gt;().single() assertEquals(expected.`issued by`(ourIdentity.ref(ref)), output.amount) }</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$ fun sessionFactoryForSchemas(key: Set&lt;MappedSchema&gt;): SessionFactory</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$// TODO: require mechanism to set schemaOptions (databaseSchema, tablePrefix) which are not global to session schema.mappedTypes.forEach { config.addAnnotatedClass(it) }</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$Configuration(metadataSources).setProperty("hibernate.connection.provider_class", NodeDatabaseConnectionProvider::class.java.name) .setProperty("hibernate.format_sql", "true") .setProperty("hibernate.hbm2ddl.auto", hbm2dll) .setProperty("javax.persistence.validation.mode", "none") .setProperty("hibernate.connection.isolation", databaseConfig.transactionIsolationLevel.jdbcValue.toString())</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$CordaMaterializedBlobType : AbstractSingleColumnStandardBasicType</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$CordaPrimitiveByteArrayTypeDescriptor : PrimitiveByteArrayTypeDescriptor</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$CordaWrapperBinaryType : AbstractSingleColumnStandardBasicType</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$MapBlobToPostgresByteA : AbstractSingleColumnStandardBasicType</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$private val sessionFactories = cacheFactory.buildNamed&lt;Set&lt;MappedSchema&gt;, SessionFactory&gt;(Caffeine.newBuilder(), "HibernateConfiguration_sessionFactories")</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$val config = Configuration(metadataSources).setProperty("hibernate.connection.provider_class", NodeDatabaseConnectionProvider::class.java.name) .setProperty("hibernate.format_sql", "true") .setProperty("hibernate.hbm2ddl.auto", hbm2dll) .setProperty("javax.persistence.validation.mode", "none") .setProperty("hibernate.connection.isolation", databaseConfig.transactionIsolationLevel.jdbcValue.toString())</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration${ "update" }</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration${ logger.info("Creating session factory for schemas: $schemas") val serviceRegistry = BootstrapServiceRegistryBuilder().build() val metadataSources = MetadataSources(serviceRegistry) val hbm2dll: String = if (databaseConfig.initialiseSchema &amp;&amp; databaseConfig.initialiseAppSchema == SchemaInitializationType.UPDATE) { "update" } else if ((!databaseConfig.initialiseSchema &amp;&amp; databaseConfig.initialiseAppSchema == SchemaInitializationType.UPDATE) || databaseConfig.initialiseAppSchema == SchemaInitializationType.VALIDATE) { "validate" } else { "none" } // We set a connection provider as the auto schema generation requires it. The auto schema generation will not // necessarily remain and would likely be replaced by something like Liquibase. For now it is very convenient though. val config = Configuration(metadataSources).setProperty("hibernate.connection.provider_class", NodeDatabaseConnectionProvider::class.java.name) .setProperty("hibernate.format_sql", "true") .setProperty("hibernate.hbm2ddl.auto", hbm2dll) .setProperty("javax.persistence.validation.mode", "none") .setProperty("hibernate.connection.isolation", databaseConfig.transactionIsolationLevel.jdbcValue.toString()) schemas.forEach { schema -&gt; // TODO: require mechanism to set schemaOptions (databaseSchema, tablePrefix) which are not global to session schema.mappedTypes.forEach { config.addAnnotatedClass(it) } } val sessionFactory = buildSessionFactory(config, metadataSources, customClassLoader) logger.info("Created session factory for schemas: $schemas") // export Hibernate JMX statistics if (databaseConfig.exportHibernateJMXStatistics) initStatistics(sessionFactory) return sessionFactory }</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration.Companion$attributeConverters.forEach { applyAttributeConverter(it) } // Register a tweaked version of `org.hibernate.type.MaterializedBlobType` that truncates logged messages. // to avoid OOM when large blobs might get logged. applyBasicType(CordaMaterializedBlobType, CordaMaterializedBlobType.name) applyBasicType(CordaWrapperBinaryType, CordaWrapperBinaryType.name) // Create a custom type that will map a blob to byteA in postgres and as a normal blob for all other dbms. // This is required for the Checkpoints as a workaround for the issue that postgres has on azure. if (jdbcUrl.contains(":postgresql:", ignoreCase = true)) { applyBasicType(MapBlobToPostgresByteA, MapBlobToPostgresByteA.name) } else { applyBasicType(MapBlobToNormalBlob, MapBlobToNormalBlob.name) } return build()</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration.NodeDatabaseConnectionProvider$override fun isUnwrappableAs(unwrapType: Class&lt;*&gt;?): Boolean</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$cashStates = vaultFiller.fillWithSomeTestCash(100.DOLLARS, issuerServices, numStates, issuer.ref(1), rng = Random(0L)).states.toList()</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$criteriaQuery.where(criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultCashStates.get&lt;PersistentStateRef&gt;("stateRef")))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$criteriaQuery.where(criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultLinearStates.get&lt;PersistentStateRef&gt;("stateRef")))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$database = configureDatabase(dataSourceProps, DatabaseConfig(), identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous, schemaService)</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$database = configureDatabase(dataSourceProps, DatabaseConfig(initialiseSchema = initialiseSchema), identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous, schemaService)</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$println("${it.stateRef} with owner ${cashState.owner.owningKey.toBase58String()} and participants ${cashState.participants.map { it.owningKey.toBase58String() }}")</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$println("${vaultState.stateRef} : [${_dummyLinearStates.externalId} ${_dummyLinearStates.uuid}] : [${_vaultLinearStates.externalId} ${_vaultLinearStates.uuid}]")</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$private fun sessionFactoryForSchemas(vararg schemas: MappedSchema)</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andDummyLinearStatesPredicate = criteriaBuilder.and(andDummyLinearStatesPredicate1, criteriaBuilder.and(andDummyLinearStatesPredicate2, andDummyLinearStatesPredicate3))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andDummyLinearStatesPredicate1 = criteriaBuilder.and(criteriaBuilder.equal(dummyLinearStates.get&lt;String&gt;("linearString"), "123"))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andDummyLinearStatesPredicate2 = criteriaBuilder.and(criteriaBuilder.equal(dummyLinearStates.get&lt;Long&gt;("linearNumber"), 123L))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andDummyLinearStatesPredicate3 = criteriaBuilder.and(criteriaBuilder.equal(dummyLinearStates.get&lt;Boolean&gt;("linearBoolean"), true))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andLinearStatesPredicate1 = criteriaBuilder.and(criteriaBuilder.equal(vaultLinearStates.get&lt;String&gt;("externalId"), uniqueID456.externalId))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andLinearStatesPredicate2 = criteriaBuilder.and(criteriaBuilder.equal(vaultLinearStates.get&lt;UUID&gt;("uuid"), uniqueID456.id))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val cashStates = vaultFiller.fillWithSomeTestCash(100.DOLLARS, issuerServices, 2, issuer.ref(1), ALICE, Random(0L)).states</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val cordappPackages = listOf("net.corda.testing.internal.vault", "net.corda.finance.contracts.asset", "net.corda.finance.schemas")</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val joinCashStateToParty = cashStatesSchema.joinSet&lt;SampleCashSchemaV3.PersistentCashState, String&gt;("participants")</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val joinPredicate = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultLinearStates.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val joinPredicate1 = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultLinearStates.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val joinPredicate2 = criteriaBuilder.and(criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), dummyLinearStates.get&lt;PersistentStateRef&gt;("stateRef")))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val joinVaultStatesToCash = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), cashStatesSchema.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val moreCash = vaultFiller.fillWithSomeTestCash(100.DOLLARS, services, 2, identity.ref(0), identity, Random(0L)).states</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val schemaService = NodeSchemaService(extraSchemas = setOf(CashSchemaV1, SampleCashSchemaV1, SampleCashSchemaV2, SampleCashSchemaV3, DummyLinearStateSchemaV1, DummyLinearStateSchemaV2, DummyDealStateSchemaV1))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$vaultFiller.fillWithSomeTestLinearStates(1, externalId = "123", linearString = "123", linearNumber = 123, linearBoolean = true)</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest.&lt;no name provided&gt;$override val vaultService = NodeVaultService(Clock.systemUTC(), keyManagementService, servicesForResolution, database, schemaService, cordappClassloader).apply { start() }</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest.&lt;no name provided&gt;${ for (stx in txs) { (validatedTransactions as WritableTransactionStorage).addTransaction(stx) } // Refactored to use notifyAll() as we have no other unit test for that method with multiple transactions. vaultService.notifyAll(statesToRecord, txs.map { it.tx }) }</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$LIKE_IGNORE_CASE -&gt; criteriaBuilder.like(criteriaBuilder.upper(column), columnPredicate.rightLiteral.toUpperCase())</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$NOT_IN_IGNORE_CASE -&gt; criteriaBuilder.not(criteriaBuilder.upper(column).`in`(literal.map { it.toUpperCase() }))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$NOT_LIKE_IGNORE_CASE -&gt; criteriaBuilder.notLike(criteriaBuilder.upper(column), columnPredicate.rightLiteral.toUpperCase())</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$abstract</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$private</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$AbstractQueryCriteriaParser&lt;AttachmentQueryCriteria, AttachmentsQueryCriteriaParser, AttachmentSort&gt;(), AttachmentsQueryCriteriaParser</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$Sort.Direction.DESC -&gt; orderCriteria.add(criteriaBuilder.desc(root.get&lt;String&gt;(sortAttribute.columnName)))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$val joinDBAttachmentToContractClassNames = root.joinList&lt;NodeAttachmentService.DBAttachment, ContractClassName&gt;("contractClassNames")</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$Sort.Direction.ASC -&gt; criteriaBuilder.asc(criteriaBuilder.literal&lt;Int&gt;(orderByColumnPosition - shiftLeft))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$Sort.Direction.DESC -&gt; criteriaBuilder.desc(criteriaBuilder.literal&lt;Int&gt;(orderByColumnPosition - shiftLeft))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$Triple(VaultSchemaV1.VaultStates::class.java, sortAttribute.attributeParent, sortAttribute.attributeChild)</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates.replace(predicateID, criteriaBuilder.and(vaultStates.get&lt;String&gt;(VaultSchemaV1.VaultStates::contractStateClassName.name).`in`(contractStateTypes.plus(existingTypes))))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates.replace(predicateID, criteriaBuilder.and(vaultStates.get&lt;Vault.ConstraintInfo.Type&gt;(VaultSchemaV1.VaultStates::constraintType.name).`in`(criteria.constraintTypes.plus(existingTypes))))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates.replace(predicateID, criteriaBuilder.equal(vaultStates.get&lt;Vault.RelevancyStatus&gt;(VaultSchemaV1.VaultStates::relevancyStatus.name), criteria.relevancyStatus))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates.replace(predicateID, criteriaBuilder.equal(vaultStates.get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultStates::stateStatus.name), criteria.status))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates[predicateID] = criteriaBuilder.and(vaultStates.get&lt;String&gt;(VaultSchemaV1.VaultStates::contractStateClassName.name).`in`(contractStateTypes))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates[predicateID] = criteriaBuilder.and(vaultStates.get&lt;Vault.ConstraintInfo.Type&gt;(VaultSchemaV1.VaultStates::constraintType.name).`in`(criteria.constraintTypes))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates[predicateID] = criteriaBuilder.equal(vaultStates.get&lt;Vault.RelevancyStatus&gt;(VaultSchemaV1.VaultStates::relevancyStatus.name), criteria.relevancyStatus)</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates[predicateID] = criteriaBuilder.equal(vaultStates.get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultStates::stateStatus.name), criteria.status)</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), entityRoot.get&lt;IndirectStatePersistable&lt;*&gt;&gt;("compositeKey").get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), entityRoot.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$elem</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$if (path is SingularAttributePath) // remove the same columns from different joins to match the single column in 'group by' only (from the last join) aggregateExpressions.removeAll { elem -&gt; if (elem is SingularAttributePath) elem.attribute.javaMember == path.attribute.javaMember else false }</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$is SortAttribute.Custom -&gt; Triple(sortAttribute.entityStateClass, sortAttribute.entityStateColumnName, null)</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$log.warn("Enriching previous attribute [${VaultSchemaV1.VaultStates::constraintType.name}] values [$existingTypes] with [${criteria.constraintTypes}]")</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$log.warn("Enriching previous attribute [${VaultSchemaV1.VaultStates::contractStateClassName.name}] values [$existingTypes] with [$contractStateTypes]")</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$log.warn("Overriding previous attribute [${VaultSchemaV1.VaultStates::relevancyStatus.name}] value $existingStatus with ${criteria.status}")</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$log.warn("Overriding previous attribute [${VaultSchemaV1.VaultStates::stateStatus.name}] value $existingStatus with ${criteria.status}")</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$orderCriteria.add(criteriaBuilder.asc(sortEntityRoot.get&lt;String&gt;(entityStateAttributeParent).get&lt;String&gt;(entityStateAttributeChild)))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$orderCriteria.add(criteriaBuilder.desc(sortEntityRoot.get&lt;String&gt;(entityStateAttributeParent).get&lt;String&gt;(entityStateAttributeChild)))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$predicateSet.add(criteriaBuilder.and(vaultStates.get&lt;String&gt;("lockId").`in`(softLocking.lockIds.map { it.toString() })))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$private</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$private val commonPredicates = mutableMapOf&lt;Pair&lt;String, Operator&gt;, Predicate&gt;() // schema attribute Name, operator -&gt; predicate</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$shiftLeft += columnNumberBeforeRemoval - aggregateExpressions.size</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$sorting.copy(columns = sorting.columns + Sort.SortColumn(SortAttribute.Standard(Sort.CommonStateAttribute.STATE_REF), Sort.Direction.ASC))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val actualSorting = if (sorting.columns.none { it.sortAttribute == SortAttribute.Standard(Sort.CommonStateAttribute.STATE_REF) }) { sorting.copy(columns = sorting.columns + Sort.SortColumn(SortAttribute.Standard(Sort.CommonStateAttribute.STATE_REF), Sort.Direction.ASC)) } else { sorting }</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val combinedPredicates = commonPredicates.values.plus(predicateSet).plus(constraintPredicates).plus(joinPredicates)</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val existingStatus = ((commonPredicates[predicateID] as ComparisonPredicate).rightHandOperand as LiteralExpression).literal</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val existingTypes = (commonPredicates[predicateID]!!.expressions[0] as InPredicate&lt;*&gt;).values.map { (it as LiteralExpression).literal }.toSet()</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val externalIdJoin = criteriaBuilder.equal(vaultStates.get&lt;VaultSchemaV1.VaultStates&gt;("stateRef"), entityRoot.get&lt;VaultSchemaV1.StateToExternalId&gt;("compositeKey").get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val externalIdPredicate = criteriaBuilder.and(entityRoot.get&lt;VaultSchemaV1.StateToExternalId&gt;("externalId").`in`(ids))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val joinPredicate = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), entityRoot.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val joinPredicate = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultFungibleStates.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val joinPredicate = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultLinearStates.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val participantsPredicate = criteriaBuilder.and(entityRoot.get&lt;VaultSchemaV1.PersistentParty&gt;("x500Name").`in`(participants))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val predicateConstraintData = criteriaBuilder.equal(vaultStates.get&lt;Vault.ConstraintInfo&gt;(VaultSchemaV1.VaultStates::constraintData.name), constraint.data())</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val predicateConstraintType = criteriaBuilder.equal(vaultStates.get&lt;Vault.ConstraintInfo&gt;(VaultSchemaV1.VaultStates::constraintType.name), constraint.type())</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val statePartyJoin = criteriaBuilder.equal(vaultStates.get&lt;VaultSchemaV1.VaultStates&gt;("stateRef"), entityRoot.get&lt;VaultSchemaV1.PersistentParty&gt;("compositeKey").get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser${ @Suppress("UNCHECKED_CAST") column as Path&lt;Long?&gt;? val aggregateExpression = when (columnPredicate.type) { AggregateFunctionType.SUM -&gt; criteriaBuilder.sum(column) AggregateFunctionType.AVG -&gt; criteriaBuilder.avg(column) AggregateFunctionType.COUNT -&gt; criteriaBuilder.count(column) AggregateFunctionType.MAX -&gt; criteriaBuilder.max(column) AggregateFunctionType.MIN -&gt; criteriaBuilder.min(column) } // TODO investigate possibility to avoid producing redundant joins in SQL for multiple aggregate functions against the same table aggregateExpressions.add(aggregateExpression) // Some databases may not support aggregate expression in 'group by' clause e.g. 'group by sum(col)', // Hibernate Criteria Builder can't produce alias 'group by col_alias', and the only solution is to use a positional parameter 'group by 1' val orderByColumnPosition = aggregateExpressions.size var shiftLeft = 0 // add optional group by clauses expression.groupByColumns?.let { columns -&gt; val groupByExpressions = columns.map { _column -&gt; val path = root.get&lt;Any?&gt;(getColumnName(_column)) val columnNumberBeforeRemoval = aggregateExpressions.size if (path is SingularAttributePath) // remove the same columns from different joins to match the single column in 'group by' only (from the last join) aggregateExpressions.removeAll { elem -&gt; if (elem is SingularAttributePath) elem.attribute.javaMember == path.attribute.javaMember else false } shiftLeft += columnNumberBeforeRemoval - aggregateExpressions.size // record how many times a duplicated column was removed (from the previous 'parseAggregateFunction' run) aggregateExpressions.add(path) path } criteriaQuery.groupBy(groupByExpressions) } // optionally order by this aggregate function expression.orderBy?.let { val orderCriteria = when (expression.orderBy!!) { // when adding column position of 'group by' shift in case columns were removed Sort.Direction.ASC -&gt; criteriaBuilder.asc(criteriaBuilder.literal&lt;Int&gt;(orderByColumnPosition - shiftLeft)) Sort.Direction.DESC -&gt; criteriaBuilder.desc(criteriaBuilder.literal&lt;Int&gt;(orderByColumnPosition - shiftLeft)) } criteriaQuery.orderBy(orderCriteria) } return aggregateExpression }</ID>
    <ID>MaxLineLength:HospitalisingInterceptor.kt$HospitalisingInterceptor : TransitionExecutor</ID>
    <ID>MaxLineLength:HospitalisingInterceptor.kt$HospitalisingInterceptor$val (continuation, nextState) = delegate.executeTransition(fiber, previousState, event, transition, actionExecutor)</ID>
    <ID>MaxLineLength:HttpUtils.kt$HttpUtils$throw IOException("${request.method()} to ${request.url()} returned a ${response.code()}: ${response.body()?.string()}")</ID>
    <ID>MaxLineLength:IOUFlow.kt$IOUFlow$val fullySignedTx = subFlow(CollectSignaturesFlow(signedTx, listOf(otherPartySession), CollectSignaturesFlow.tracker()))</ID>
    <ID>MaxLineLength:IRS.kt$FixedRatePaymentEvent$"FixedRatePaymentEvent $accrualStartDate -&gt; $accrualEndDate : $dayCountFactor : $days : $date : $notional : $rate : $flow"</ID>
    <ID>MaxLineLength:IRS.kt$FixedRatePaymentEvent$override val flow: Amount&lt;Currency&gt; get() = Amount(dayCountFactor.times(BigDecimal(notional.quantity)).times(rate.ratioUnit!!.value).toLong(), notional.token)</ID>
    <ID>MaxLineLength:IRS.kt$FloatingRatePaymentEvent$( date: LocalDate = this.date, accrualStartDate: LocalDate = this.accrualStartDate, accrualEndDate: LocalDate = this.accrualEndDate, dayCountBasisDay: DayCountBasisDay = this.dayCountBasisDay, dayCountBasisYear: DayCountBasisYear = this.dayCountBasisYear, fixingDate: LocalDate = this.fixingDate, notional: Amount&lt;Currency&gt; = this.notional, rate: Rate = this.rate )</ID>
    <ID>MaxLineLength:IRS.kt$FloatingRatePaymentEvent$override fun asCSV(): String</ID>
    <ID>MaxLineLength:IRS.kt$FloatingRatePaymentEvent$override fun toString(): String</ID>
    <ID>MaxLineLength:IRS.kt$IRS$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:IRS.kt$IRS$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("3M")), 1.5.bd))))</ID>
    <ID>MaxLineLength:IRS.kt$IRS$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("9M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:IRS.kt$IRS$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate.plusYears(1), Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:IRS.kt$IRS$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBORx", tradeDate, Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:IRS.kt$IRS$val nextFloating = interest(notional, "act/365", fix("LIBOR", start, Tenor("3M")), start, end)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap : Contract</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$ private fun getFloatingLegPaymentsDifferences(payments1: Map&lt;LocalDate, Event&gt;, payments2: Map&lt;LocalDate, Event&gt;): List&lt;Pair&lt;LocalDate, Pair&lt;FloatingRatePaymentEvent, FloatingRatePaymentEvent&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"All notionals must be non zero" using (irs.fixedLeg.notional.quantity &gt; 0 &amp;&amp; irs.floatingLeg.notional.quantity &gt; 0)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The changed payments dates are aligned" using (oldFloatingRatePaymentEvent.date == newFixedRatePaymentEvent.date)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The currency of the notionals must be the same" using (irs.fixedLeg.notional.token == irs.floatingLeg.notional.token)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The effective date is before the termination date for the fixed leg" using (irs.fixedLeg.effectiveDate &lt; irs.fixedLeg.terminationDate)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The effective date is before the termination date for the floating leg" using (irs.floatingLeg.effectiveDate &lt; irs.floatingLeg.terminationDate)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The fix payment has the same currency as the notional" using (newFixedRatePaymentEvent.flow.token == irs.floatingLeg.notional.token)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The fixed leg parties are constant" using (irs.fixedLeg.fixedRatePayer == prevIrs.fixedLeg.fixedRatePayer)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The fixed leg payment schedule is constant" using (irs.calculation.fixedLegPaymentSchedule == prevIrs.calculation.fixedLegPaymentSchedule)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The fixing is for the next required date" using (prevIrs.calculation.nextFixingDate() == fixValue.of.forDay)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The new payment has the correct rate" using (newFixedRatePaymentEvent.rate.ratioUnit!!.value == fixValue.value)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"There is at least one difference in the IRS floating leg payment schedules" using !paymentDifferences.isEmpty()</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$Calculation</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$TransactionBuilder(notary) .addCommand(Command(Commands.Agree(), listOf(state.floatingLeg.floatingRatePayer.owningKey, state.fixedLeg.fixedRatePayer.owningKey)))</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$private</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$tx.addCommand(Commands.Refix(fixing), listOf(irs.state.data.floatingLeg.floatingRatePayer.owningKey, irs.state.data.fixedLeg.fixedRatePayer.owningKey))</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$val (oldFloatingRatePaymentEvent, newFixedRatePaymentEvent) = paymentDifferences.single().second // Ignore the date of the changed rate (we checked that earlier).</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$val groups: List&lt;LedgerTransaction.InOutGroup&lt;State, UniqueIdentifier&gt;&gt; = tx.groupStates { state -&gt; state.linearId }</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$val paymentDifferences = getFloatingLegPaymentsDifferences(prevIrs.calculation.floatingLegPaymentSchedule, irs.calculation.floatingLegPaymentSchedule)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.Calculation$return floatingLegPaymentSchedule.filter { it.value.rate is ReferenceRate } // TODO - a better way to determine what fixings remain to be fixed .minBy { it.value.fixingDate.toEpochDay() }?.value?.fixingDate</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.Commands$Mature : TypeOnlyCommandDataCommands</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.Common$val valuationDateDescription: String</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.CommonLeg$"PaymentRule=$paymentRule,PaymentDelay=$paymentDelay,PaymentCalendar=$paymentCalendar,InterestPeriodAdjustment=$interestPeriodAdjustment"</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.CommonLeg$"TerminationDateAdjustment=$terminationDateAdjustment,DayCountBasis=$dayCountBasisDay/$dayCountBasisYear,DayInMonth=$dayInMonth,"</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.CommonLeg$dayCountBasisDay</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.CommonLeg$effectiveDateAdjustment</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.CommonLeg$return "Notional=$notional,PaymentFrequency=$paymentFrequency,EffectiveDate=$effectiveDate,EffectiveDateAdjustment:$effectiveDateAdjustment,TerminatationDate=$terminationDate," + "TerminationDateAdjustment=$terminationDateAdjustment,DayCountBasis=$dayCountBasisDay/$dayCountBasisYear,DayInMonth=$dayInMonth," + "PaymentRule=$paymentRule,PaymentDelay=$paymentDelay,PaymentCalendar=$paymentCalendar,InterestPeriodAdjustment=$interestPeriodAdjustment"</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.FixedLeg$dayCountBasisDay</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.FixedLeg$override</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.FloatingLeg$"FixingPeriondOffset=$fixingPeriodOffset,ResetRule=$resetRule,FixingsPerPayment=$fixingsPerPayment,FixingCalendar=$fixingCalendar,"</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.FloatingLeg$"rollConvention=$rollConvention,FixingRollConvention=$fixingRollConvention,ResetDayInMonth=$resetDayInMonth"</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.FloatingLeg$( var floatingRatePayer: AbstractParty, notional: Amount&lt;Currency&gt;, paymentFrequency: Frequency, effectiveDate: LocalDate, effectiveDateAdjustment: DateRollConvention?, terminationDate: LocalDate, terminationDateAdjustment: DateRollConvention?, dayCountBasisDay: DayCountBasisDay, dayCountBasisYear: DayCountBasisYear, dayInMonth: Int, paymentRule: PaymentRule, paymentDelay: Int, paymentCalendar: BusinessCalendar, interestPeriodAdjustment: AccrualAdjustment, var rollConvention: DateRollConvention, var fixingRollConvention: DateRollConvention, var resetDayInMonth: Int, var fixingPeriodOffset: Int, var resetRule: PaymentRule, var fixingsPerPayment: Frequency, var fixingCalendar: BusinessCalendar, var index: String, var indexSource: String, var indexTenor: Tenor )</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.FloatingLeg$dayCountBasisDay</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.State$InterestRateSwap().generateFix(ptx, StateAndRef(TransactionState(this, IRS_PROGRAM_ID, oldState.state.notary, constraint = AlwaysAcceptAttachmentConstraint), oldState.ref), fix)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.State$override</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.State$return ScheduledActivity(flowLogicRefFactory.create("net.corda.irs.flows.FixingFlow\$FixingRoleDecider", thisStateRef), instant)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.State$val instant = suggestInterestRateAnnouncementTimeWindow(index = nextFixingOf.name, source = floatingLeg.indexSource, date = nextFixingOf.forDay).fromTime!!</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.State${ val nextFixingOf = nextFixingOf() ?: return null // This is perhaps not how we should determine the time point in the business day, but instead expect the schedule to detail some of these aspects val instant = suggestInterestRateAnnouncementTimeWindow(index = nextFixingOf.name, source = floatingLeg.indexSource, date = nextFixingOf.forDay).fromTime!! return ScheduledActivity(flowLogicRefFactory.create("net.corda.irs.flows.FixingFlow\$FixingRoleDecider", thisStateRef), instant) }</ID>
    <ID>MaxLineLength:IRS.kt$PaymentEvent : Event</ID>
    <ID>MaxLineLength:IRS.kt$RatePaymentEvent$// TODO : Fix below (use daycount convention for division, not hardcoded 360 etc) val dayCountFactor: BigDecimal get() = (BigDecimal(days).divide(BigDecimal(360.0), 8, RoundingMode.HALF_UP)).setScale(4, RoundingMode.HALF_UP)</ID>
    <ID>MaxLineLength:IRS.kt$RatePaymentEvent$open fun asCSV()</ID>
    <ID>MaxLineLength:IRS.kt$RatePaymentEvent$val days: Int get() = BusinessCalendar.calculateDaysBetween(accrualStartDate, accrualEndDate, dayCountBasisYear, dayCountBasisDay)</ID>
    <ID>MaxLineLength:IRS.kt$UnknownType</ID>
    <ID>MaxLineLength:IRSDemo.kt$Role.Trade -&gt; IRSDemoClientApi(NetworkHostAndPort("localhost", 10007)).runTrade(value, CordaX500Name.parse("O=Notary Service,L=Zurich,C=CH"))</ID>
    <ID>MaxLineLength:IRSDemoDockerTest.kt$IRSDemoDockerTest.Companion$DockerComposeRule.builder() .files(DockerComposeFiles.from( System.getProperty("CORDAPP_DOCKER_COMPOSE"), System.getProperty("WEB_DOCKER_COMPOSE"))) .waitingForService("web-a", HealthChecks.toRespondOverHttp(8080, { port -&gt; port.inFormat("http://\$HOST:\$EXTERNAL_PORT") }))</ID>
    <ID>MaxLineLength:IRSDemoDockerTest.kt$IRSDemoDockerTest.Companion$throw IllegalStateException("System property $property not set. Please refer to README file for proper setup instructions.")</ID>
    <ID>MaxLineLength:IRSDemoTest.kt$IRSDemoTest$InterestRateSwapStateDeserializer : JsonDeserializer</ID>
    <ID>MaxLineLength:IRSDemoTest.kt$IRSDemoTest$return IOUtils.toString(Thread.currentThread().contextClassLoader.getResourceAsStream(filename), Charsets.UTF_8.name())</ID>
    <ID>MaxLineLength:IRSDemoTest.kt$IRSDemoTest$val (controllerApi, nodeAApi, nodeBApi) = listOf(controller, nodeA, nodeB).zip(listOf(controllerAddr, nodeAAddr, nodeBAddr)).map { val mapper = JacksonSupport.createDefaultMapper(it.first.rpc) registerFinanceJSONMappers(mapper) registerIRSModule(mapper) HttpApi.fromHostAndPort(it.second, "api/irs", mapper = mapper) }</ID>
    <ID>MaxLineLength:IRSDemoTest.kt$IRSDemoTest.InterestRateSwapStateDeserializer$InterestRateSwap.State(fixedLeg = fixedLeg, floatingLeg = floatingLeg, calculation = calculation, common = common, linearId = linearId, oracle = oracle)</ID>
    <ID>MaxLineLength:IRSExport.kt$this.calculation.floatingLegPaymentSchedule.toSortedMap().values.joinToString("\n") { it.asCSV() }</ID>
    <ID>MaxLineLength:IRSState.kt$IRSState$return TransactionBuilder(notary).withItems(StateAndContract(state, IRS_PROGRAM_ID), Command(OGTrade.Commands.Agree(), participants.map { it.owningKey }))</ID>
    <ID>MaxLineLength:IRSTests.kt$"(floatingLeg.notional.pennies * (calculation.fixingSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value))"</ID>
    <ID>MaxLineLength:IRSTests.kt$( // TODO: this seems to fail quite dramatically // expression = "fixedLeg.notional * fixedLeg.fixedRate", // TODO: How I want it to look // expression = "( fixedLeg.notional * (fixedLeg.fixedRate)) - (floatingLeg.notional * (rateSchedule.get(context.getDate('currentDate'))))", // How it's ended up looking, which I think is now broken but it's a WIP. expression = Expression("( fixedLeg.notional.pennies * (fixedLeg.fixedRate.ratioUnit.value)) -" + "(floatingLeg.notional.pennies * (calculation.fixingSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value))"), floatingLegPaymentSchedule = mutableMapOf(), fixedLegPaymentSchedule = mutableMapOf() )</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$ fun tradegroups(): LedgerDSL&lt;TestTransactionDSLInterpreter, TestLedgerDSLInterpreter&gt;</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$( "fixedLeg.notional.quantity", "fixedLeg.fixedRate.ratioUnit", "fixedLeg.fixedRate.ratioUnit.value", "floatingLeg.notional.quantity", "fixedLeg.fixedRate", "currentBusinessDate", "calculation.floatingLegPaymentSchedule.get(currentBusinessDate)", "fixedLeg.notional.token.currencyCode", "fixedLeg.notional.quantity * 10", "fixedLeg.notional.quantity * fixedLeg.fixedRate.ratioUnit.value", "(fixedLeg.notional.token.currencyCode.equals('GBP')) ? 365 : 360 ", "(fixedLeg.notional.quantity * (fixedLeg.fixedRate.ratioUnit.value))" // "calculation.floatingLegPaymentSchedule.get(context.getDate('currentDate')).rate" // "calculation.floatingLegPaymentSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value", // "( fixedLeg.notional.pennies * (fixedLeg.fixedRate.ratioUnit.value)) - (floatingLeg.notional.pennies * (calculation.fixingSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value))", // "( fixedLeg.notional * fixedLeg.fixedRate )" )</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$attachments(IRS_PROGRAM_ID) input(IRS_PROGRAM_ID, oldIRS) // Templated tweak for reference. A corrent fixing applied should be ok tweak { command(ORACLE_PUBKEY, InterestRateSwap.Commands.Refix(Fix(FixOf("ICE LIBOR", ld, Tenor("3M")), bd))) timeWindow(TEST_TX_TIME) output(IRS_PROGRAM_ID, newIRS) this.verifies() } // This test makes sure that verify confirms the fixing was applied and there is a difference in the old and new tweak { command(ORACLE_PUBKEY, InterestRateSwap.Commands.Refix(Fix(FixOf("ICE LIBOR", ld, Tenor("3M")), bd))) timeWindow(TEST_TX_TIME) output(IRS_PROGRAM_ID, oldIRS) this `fails with` "There is at least one difference in the IRS floating leg payment schedules" } // This tests tries to sneak in a change to another fixing (which may or may not be the latest one) tweak { command(ORACLE_PUBKEY, InterestRateSwap.Commands.Refix(Fix(FixOf("ICE LIBOR", ld, Tenor("3M")), bd))) timeWindow(TEST_TX_TIME) val firstResetKey = newIRS.calculation.floatingLegPaymentSchedule.keys.toList()[1] val firstResetValue = newIRS.calculation.floatingLegPaymentSchedule[firstResetKey] val modifiedFirstResetValue = firstResetValue!!.copy(notional = Amount(firstResetValue.notional.quantity, Currency.getInstance("JPY"))) output(IRS_PROGRAM_ID, newIRS.copy( newIRS.fixedLeg, newIRS.floatingLeg, newIRS.calculation.copy(floatingLegPaymentSchedule = newIRS.calculation.floatingLegPaymentSchedule.plus( Pair(firstResetKey, modifiedFirstResetValue))), newIRS.common)) this `fails with` "There is only one change in the IRS floating leg payment schedule" } // This tests modifies the payment currency for the fixing tweak { command(ORACLE_PUBKEY, InterestRateSwap.Commands.Refix(Fix(FixOf("ICE LIBOR", ld, Tenor("3M")), bd))) timeWindow(TEST_TX_TIME) val latestReset = newIRS.calculation.floatingLegPaymentSchedule.filter { it.value.rate is FixedRate }.maxBy { it.key } val modifiedLatestResetValue = latestReset!!.value.copy(notional = Amount(latestReset.value.notional.quantity, Currency.getInstance("JPY"))) output(IRS_PROGRAM_ID, newIRS.copy( newIRS.fixedLeg, newIRS.floatingLeg, newIRS.calculation.copy(floatingLegPaymentSchedule = newIRS.calculation.floatingLegPaymentSchedule.plus( Pair(latestReset.key, modifiedLatestResetValue))), newIRS.common)) this `fails with` "The fix payment has the same currency as the notional" }</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$newIRS.calculation</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$output(IRS_PROGRAM_ID, irs.copy(calculation = irs.calculation.copy(fixedLegPaymentSchedule = emptySchedule)))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$output(IRS_PROGRAM_ID, irs.copy(calculation = irs.calculation.copy(floatingLegPaymentSchedule = emptySchedule)))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$private val notaryServices = MockServices(cordappPackages, dummyNotary, mock(), networkParameters, dummyNotary.keyPair)</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val latestReset = newIRS.calculation.floatingLegPaymentSchedule.filter { it.value.rate is FixedRate }.maxBy { it.key }</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedFirstResetValue = firstResetValue!!.copy(notional = Amount(firstResetValue.notional.quantity, Currency.getInstance("JPY")))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedIRS = irs.copy(fixedLeg = irs.fixedLeg.copy(notional = Amount(irs.fixedLeg.notional.quantity, Currency.getInstance("JPY"))))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedIRS = irs.copy(fixedLeg = irs.fixedLeg.copy(notional = Amount(irs.floatingLeg.notional.quantity + 1, irs.floatingLeg.notional.token)))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedIRS1 = irs.copy(fixedLeg = irs.fixedLeg.copy(terminationDate = irs.fixedLeg.effectiveDate.minusDays(1)))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedIRS2 = irs.copy(floatingLeg = irs.floatingLeg.copy(terminationDate = irs.floatingLeg.effectiveDate.minusDays(1)))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedIRS3 = irs.copy(floatingLeg = irs.floatingLeg.copy(terminationDate = irs.fixedLeg.terminationDate.minusDays(1)))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedIRS4 = irs.copy(floatingLeg = irs.floatingLeg.copy(effectiveDate = irs.fixedLeg.effectiveDate.minusDays(1)))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedLatestResetValue = latestReset!!.value.copy(notional = Amount(latestReset.value.notional.quantity, Currency.getInstance("JPY")))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests${ val dummyIRS = singleIRS() val stuffToPrint: ArrayList&lt;String&gt; = arrayListOf( "fixedLeg.notional.quantity", "fixedLeg.fixedRate.ratioUnit", "fixedLeg.fixedRate.ratioUnit.value", "floatingLeg.notional.quantity", "fixedLeg.fixedRate", "currentBusinessDate", "calculation.floatingLegPaymentSchedule.get(currentBusinessDate)", "fixedLeg.notional.token.currencyCode", "fixedLeg.notional.quantity * 10", "fixedLeg.notional.quantity * fixedLeg.fixedRate.ratioUnit.value", "(fixedLeg.notional.token.currencyCode.equals('GBP')) ? 365 : 360 ", "(fixedLeg.notional.quantity * (fixedLeg.fixedRate.ratioUnit.value))" // "calculation.floatingLegPaymentSchedule.get(context.getDate('currentDate')).rate" // "calculation.floatingLegPaymentSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value", // "( fixedLeg.notional.pennies * (fixedLeg.fixedRate.ratioUnit.value)) - (floatingLeg.notional.pennies * (calculation.fixingSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value))", // "( fixedLeg.notional * fixedLeg.fixedRate )" ) for (i in stuffToPrint) { println(i) val z = dummyIRS.evaluateCalculation(LocalDate.of(2016, 9, 15), Expression(i)) println(z.javaClass) println(z) println("-----------") } // This does not throw an exception in the test itself; it evaluates the above and they will throw if they do not pass. }</ID>
    <ID>MaxLineLength:IRSTests.kt$InterestRateSwap.State(fixedLeg = fixedLeg, floatingLeg = floatingLeg, calculation = calculation, common = common, oracle = DUMMY_PARTY)</ID>
    <ID>MaxLineLength:IRSTests.kt$dailyInterestAmount = Expression("(CashAmount * InterestRate ) / (fixedLeg.notional.currency.currencyCode.equals('GBP')) ? 365 : 360")</ID>
    <ID>MaxLineLength:IRSTests.kt$resolutionTime = "2:00pm London time on the first LocalBusiness Day following the date on which the notice is given "</ID>
    <ID>MaxLineLength:IRSTests.kt$return InterestRateSwap.State(fixedLeg = fixedLeg, floatingLeg = floatingLeg, calculation = calculation, common = common, oracle = DUMMY_PARTY)</ID>
    <ID>MaxLineLength:IRSTests.kt${ // 10y swap, we pay 1.3% fixed 30/360 semi, rec 3m usd libor act/360 Q on 25m notional (mod foll/adj on both sides) // I did a mock up start date 10/03/2015 – 10/03/2025 so you have 5 cashflows on float side that have been preset the rest are unknown val fixedLeg = InterestRateSwap.FixedLeg( fixedRatePayer = MEGA_CORP, notional = 25000000.DOLLARS, paymentFrequency = Frequency.SemiAnnual, effectiveDate = LocalDate.of(2015, 3, 10), effectiveDateAdjustment = null, terminationDate = LocalDate.of(2025, 3, 10), terminationDateAdjustment = null, fixedRate = FixedRate(PercentageRatioUnit("1.3")), dayCountBasisDay = DayCountBasisDay.D30, dayCountBasisYear = DayCountBasisYear.Y360, rollConvention = DateRollConvention.ModifiedFollowing, dayInMonth = 10, paymentRule = PaymentRule.InArrears, paymentDelay = 0, paymentCalendar = BusinessCalendar.EMPTY, interestPeriodAdjustment = AccrualAdjustment.Adjusted ) val floatingLeg = InterestRateSwap.FloatingLeg( floatingRatePayer = MINI_CORP, notional = 25000000.DOLLARS, paymentFrequency = Frequency.Quarterly, effectiveDate = LocalDate.of(2015, 3, 10), effectiveDateAdjustment = null, terminationDate = LocalDate.of(2025, 3, 10), terminationDateAdjustment = null, dayCountBasisDay = DayCountBasisDay.DActual, dayCountBasisYear = DayCountBasisYear.Y360, rollConvention = DateRollConvention.ModifiedFollowing, fixingRollConvention = DateRollConvention.ModifiedFollowing, dayInMonth = 10, resetDayInMonth = 10, paymentRule = PaymentRule.InArrears, paymentDelay = 0, paymentCalendar = BusinessCalendar.EMPTY, interestPeriodAdjustment = AccrualAdjustment.Adjusted, fixingPeriodOffset = 2, resetRule = PaymentRule.InAdvance, fixingsPerPayment = Frequency.Quarterly, fixingCalendar = BusinessCalendar.EMPTY, index = "USD LIBOR", indexSource = "TEL3750", indexTenor = Tenor("3M") ) val calculation = InterestRateSwap.Calculation( // TODO: this seems to fail quite dramatically // expression = "fixedLeg.notional * fixedLeg.fixedRate", // TODO: How I want it to look // expression = "( fixedLeg.notional * (fixedLeg.fixedRate)) - (floatingLeg.notional * (rateSchedule.get(context.getDate('currentDate'))))", // How it's ended up looking, which I think is now broken but it's a WIP. expression = Expression("( fixedLeg.notional.pennies * (fixedLeg.fixedRate.ratioUnit.value)) -" + "(floatingLeg.notional.pennies * (calculation.fixingSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value))"), floatingLegPaymentSchedule = mutableMapOf(), fixedLegPaymentSchedule = mutableMapOf() ) val common = InterestRateSwap.Common( baseCurrency = EUR, eligibleCurrency = EUR, eligibleCreditSupport = "Cash in an Eligible Currency", independentAmounts = Amount(0, EUR), threshold = Amount(0, EUR), minimumTransferAmount = Amount(250000 * 100, EUR), rounding = Amount(10000 * 100, EUR), valuationDateDescription = "Every Local Business Day", notificationTime = "2:00pm London", resolutionTime = "2:00pm London time on the first LocalBusiness Day following the date on which the notice is given ", interestRate = ReferenceRate("T3270", Tenor("6M"), "EONIA"), addressForTransfers = "", exposure = UnknownType(), localBusinessDay = loadTestCalendar("London"), tradeID = "trade2", hashLegalDocs = "put hash here", dailyInterestAmount = Expression("(CashAmount * InterestRate ) / (fixedLeg.notional.currency.currencyCode.equals('GBP')) ? 365 : 360") ) return InterestRateSwap.State(fixedLeg = fixedLeg, floatingLeg = floatingLeg, calculation = calculation, common = common, oracle = DUMMY_PARTY) }</ID>
    <ID>MaxLineLength:IRSTradeFlow.kt$IRSTradeFlow.Requester$val notary = serviceHub.networkMapCache.notaryIdentities.first() // TODO We should pass the notary as a parameter to the flow, not leave it to random choice.</ID>
    <ID>MaxLineLength:IRSUtils.kt$PercentageRatioUnit$open</ID>
    <ID>MaxLineLength:IRSUtils.kt$net.corda.irs.contract.IRSUtils.kt</ID>
    <ID>MaxLineLength:IRSUtils.kt$operator</ID>
    <ID>MaxLineLength:IRSUtils.kt$operator fun kotlin.Int.times(other: FixedRate): Int</ID>
    <ID>MaxLineLength:Id.kt$Id.Companion$ @DeleteForDJVM @JvmStatic fun &lt;V : Any&gt; newInstance(value: V, entityType: String? = null, timestamp: Instant = now())</ID>
    <ID>MaxLineLength:IdempotentFlowTests.kt$IdempotentFlowTests.TimedSubflow$subFlowExecutionCounter.incrementAndGet()</ID>
    <ID>MaxLineLength:IdenticonRenderer.kt$IdenticonRenderer$private val patchFlags = byteArrayOf(PATCH_SYMMETRIC, 0, 0, 0, PATCH_SYMMETRIC, 0, 0, 0, PATCH_SYMMETRIC, 0, 0, 0, 0, 0, 0, (PATCH_SYMMETRIC + PATCH_INVERTED).toByte())</ID>
    <ID>MaxLineLength:IdenticonRenderer.kt$IdenticonRenderer.Patch$return byteArray.map(Byte::toInt).map { it % PATCH_GRIDS * (patchSize / PATCH_CELLS) - patchSize / 2 }.toDoubleArray()</ID>
    <ID>MaxLineLength:IdenticonRenderer.kt$IdenticonRenderer.Patch$return byteArray.map(Byte::toInt).map { it / PATCH_GRIDS * (patchSize / PATCH_CELLS) - patchSize / 2 }.toDoubleArray()</ID>
    <ID>MaxLineLength:IdenticonRenderer.kt$IdenticonRenderer.PatchColor$private</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService$ @Throws(IllegalArgumentException::class) fun registerKeyToParty(key: PublicKey, party: Party)</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService$ fun wellKnownPartyFromX500Name(name: CordaX500Name): Party?</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService$@Deprecated("This method has been deprecated in favour of using a new way to generate and use confidential identities. See the new " + "confidential identities repository.")</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService$@Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class)</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService${ // The original version of this would return the party as-is if it was a Party (rather than AnonymousParty), // however that means that we don't verify that we know who owns the key. As such as now enforce turning the key // into a party, and from there figure out the well known party. log.debug("Attempting to find wellKnownParty for: ${party.owningKey.hash}") val candidate = partyFromKey(party.owningKey) // TODO: This should be done via the network map cache, which is the authoritative source of well known identities return if (candidate != null) { require(party.nameOrNull() == null || party.nameOrNull() == candidate.name) { "Candidate party $candidate does not match expected $party" } wellKnownPartyFromX500Name(candidate.name) } else { null } }</ID>
    <ID>MaxLineLength:IdentityServiceInternal.kt$IdentityServiceInternal$ @Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) fun verifyAndRegisterIdentity( trustAnchor: TrustAnchor, identity: PartyAndCertificate, isNewRandomIdentity: Boolean = false ): PartyAndCertificate?</ID>
    <ID>MaxLineLength:IdentityServiceInternal.kt$IdentityServiceInternal$ @Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) fun verifyAndRegisterIdentity(identity: PartyAndCertificate, isNewRandomIdentity: Boolean): PartyAndCertificate?</ID>
    <ID>MaxLineLength:IdentityServiceInternal.kt$IdentityServiceInternal$ fun justVerifyAndRegisterIdentity(identity: PartyAndCertificate, isNewRandomIdentity: Boolean = false)</ID>
    <ID>MaxLineLength:IdentityServiceInternal.kt$IdentityServiceInternal$@Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class)</ID>
    <ID>MaxLineLength:IdentityServiceInternal.kt$IdentityServiceInternal$log.warn("Certificate validation failed for ${identity.name} against trusted root ${trustAnchor.trustedCert.subjectX500Principal}.")</ID>
    <ID>MaxLineLength:IdentityServiceInternal.kt$IdentityServiceInternal$val components = listOfNotNull(x500name.commonName, x500name.organisationUnit, x500name.organisation, x500name.locality, x500name.state, x500name.country)</ID>
    <ID>MaxLineLength:IdentityServiceInternal.kt$IdentityServiceInternal${ private companion object { val log = contextLogger() } /** This method exists so it can be mocked with doNothing, rather than having to make up a possibly invalid return value. */ fun justVerifyAndRegisterIdentity(identity: PartyAndCertificate, isNewRandomIdentity: Boolean = false) { verifyAndRegisterIdentity(identity, isNewRandomIdentity) } /** * Verify and then store an identity. * * @param identity a party and the certificate path linking them to the network trust root. * @param isNewRandomIdentity true if the identity will not have been registered before (e.g. because it is randomly generated by ourselves). * @return the issuing entity, if known. * @throws IllegalArgumentException if the certificate path is invalid. */ @Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) fun verifyAndRegisterIdentity(identity: PartyAndCertificate, isNewRandomIdentity: Boolean): PartyAndCertificate? // We can imagine this being a query over a lucene index in future. // // Kostas says: When exactMatch = false, we can easily use the Jaro-Winkler distance metric as it is best suited for short // strings such as entity/company names, and to detect small typos. We can also apply it for city // or any keyword related search in lists of records (not raw text - for raw text we need indexing) // and we can return results in hierarchical order (based on normalised String similarity 0.0-1.0). /** Check if [x500name] matches the [query]. */ fun x500Matches(query: String, exactMatch: Boolean, x500name: CordaX500Name): Boolean { val components = listOfNotNull(x500name.commonName, x500name.organisationUnit, x500name.organisation, x500name.locality, x500name.state, x500name.country) return components.any { (exactMatch &amp;&amp; it == query) || (!exactMatch &amp;&amp; it.contains(query, ignoreCase = true)) } } /** * Verifies that an identity is valid. * * @param trustAnchor The trust anchor that will verify the identity's validity * @param identity The identity to verify * @param isNewRandomIdentity true if the identity will not have been registered before (e.g. because it is randomly generated by ourselves). */ @Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) fun verifyAndRegisterIdentity( trustAnchor: TrustAnchor, identity: PartyAndCertificate, isNewRandomIdentity: Boolean = false ): PartyAndCertificate? { // Validate the chain first, before we do anything clever with it val identityCertChain = identity.certPath.x509Certificates try { identity.verify(trustAnchor) } catch (e: CertPathValidatorException) { log.warn("Certificate validation failed for ${identity.name} against trusted root ${trustAnchor.trustedCert.subjectX500Principal}.") log.warn("Certificate path :") identityCertChain.reversed().forEachIndexed { index, certificate -&gt; val space = (0 until index).joinToString("") { " " } log.warn("$space${certificate.subjectX500Principal}") } throw e } // Ensure we record the first identity of the same name, first val wellKnownCert = identityCertChain.single { CertRole.extract(it)?.isWellKnown ?: false } if (wellKnownCert != identity.certificate &amp;&amp; !isNewRandomIdentity) { val idx = identityCertChain.lastIndexOf(wellKnownCert) val firstPath = X509Utilities.buildCertPath(identityCertChain.slice(idx until identityCertChain.size)) verifyAndRegisterIdentity(trustAnchor, PartyAndCertificate(firstPath)) } return registerIdentity(identity, isNewRandomIdentity) } fun registerIdentity(identity: PartyAndCertificate, isNewRandomIdentity: Boolean = false): PartyAndCertificate? }</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$// the only time an identity name does not have a PK_HASH is if there are multiple identities associated with that name Assert.assertThat(groupedByNameIdentities[it]?.size, `is`(greaterThan(1)))</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$Assert.assertThat(nameToHashResultSet.getString(1), `is`(anyOf(groupedByNameIdentities.getValue(it.name).map&lt;PartyAndCertificate, Matcher&lt;String&gt;?&gt; { identity -&gt; CoreMatchers.equalTo(identity.name.toString()) })))</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$val hashToIdentityStatement = database.dataSource.connection.prepareStatement("SELECT ${PersistentIdentityService.PK_HASH_COLUMN_NAME} FROM ${PersistentIdentityService.HASH_TO_IDENTITY_TABLE_NAME} WHERE pk_hash=?")</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$val hashToIdentityStatement = database.dataSource.connection.prepareStatement("SELECT ${PersistentIdentityService.PK_HASH_COLUMN_NAME} FROM ${PersistentIdentityService.HASH_TO_IDENTITY_TABLE_NAME} WHERE pk_hash=?") hashToIdentityStatement.setString(1, it.owningKey.toStringShort()) val hashToIdentityResultSet = hashToIdentityStatement.executeQuery() // check that there is a row for every "new" hash Assert.assertThat(hashToIdentityResultSet.next(), `is`(true)) // check that the pk_hash actually matches what we expect (kinda redundant, but deserializing the whole PartyAndCertificate feels like overkill) Assert.assertThat(hashToIdentityResultSet.getString(1), `is`(it.owningKey.toStringShort())) val nameToHashStatement = connection.prepareStatement("SELECT ${PersistentIdentityService.NAME_COLUMN_NAME} FROM ${PersistentIdentityService.NAME_TO_HASH_TABLE_NAME} WHERE pk_hash=?") nameToHashStatement.setString(1, it.owningKey.toStringShort()) val nameToHashResultSet = nameToHashStatement.executeQuery() // if there is no result for this key, this means its an identity that is not stored in the DB (IE, it's been seen after another identity has already been mapped to it) if (nameToHashResultSet.next()) { Assert.assertThat(nameToHashResultSet.getString(1), `is`(anyOf(groupedByNameIdentities.getValue(it.name).map&lt;PartyAndCertificate, Matcher&lt;String&gt;?&gt; { identity -&gt; CoreMatchers.equalTo(identity.name.toString()) }))) } else { logger.warn("did not find a PK_HASH for ${it.name}") listOfNamesWithoutPkHash.add(it.name) }</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$val nameToHashStatement = connection.prepareStatement("SELECT ${PersistentIdentityService.NAME_COLUMN_NAME} FROM ${PersistentIdentityService.NAME_TO_HASH_TABLE_NAME} WHERE pk_hash=?")</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$val persistentIDs = certs.map { PersistentIdentityService.PersistentPublicKeyHashToCertificate(it.owningKey.hash.toString(), it.certPath.encoded) }</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$val persistentName = PersistentIdentityService.PersistentPartyToPublicKeyHash(name.toString(), certs.first().owningKey.hash.toString())</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Receive$// Store the received confidential identities in the identity service so we have a record of which well known identity they map to. serviceHub.identityService.verifyAndRegisterIdentity(identity)</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Receive$val unknownIdentities = allIdentities.filter { serviceHub.identityService.wellKnownPartyFromAnonymous(it) == null }</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Receive${ progressTracker.currentStep = RECEIVING_IDENTITIES val allIdentities = otherSideSession.receive&lt;List&lt;AbstractParty&gt;&gt;().unwrap { it } val unknownIdentities = allIdentities.filter { serviceHub.identityService.wellKnownPartyFromAnonymous(it) == null } progressTracker.currentStep = RECEIVING_CERTIFICATES val missingIdentities = otherSideSession.sendAndReceive&lt;List&lt;PartyAndCertificate&gt;&gt;(unknownIdentities) // Batch verify the identities we've received, so we know they're all correct before we start storing them in // the identity service missingIdentities.unwrap { identities -&gt; identities.forEach { it.verify(serviceHub.identityService.trustAnchor) } identities }.forEach { identity -&gt; // Store the received confidential identities in the identity service so we have a record of which well known identity they map to. serviceHub.identityService.verifyAndRegisterIdentity(identity) } }</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Send$confidentialIdentities .map { Pair(it, serviceHub.identityService.certificateFromKey(it.owningKey)) } // Filter down to confidential identities of our well known identity // TODO: Consider if this too restrictive - we perhaps should be checking the name on the signing certificate in the certificate path instead .filter { it.second?.name == ourIdentity.name }</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Send$require(req.all { it in identityCertificates.keys }) { "${otherSideSession.counterparty} requested a confidential identity not part of transaction: ${tx.id}" }</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Send$throw IllegalStateException("Counterparty requested a confidential identity for which we do not have the certificate path: ${tx.id}")</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Send$val requestedIdentities: List&lt;AbstractParty&gt; = otherSideSession.sendAndReceive&lt;List&lt;AbstractParty&gt;&gt;(identityCertificates.keys.toList()).unwrap { req -&gt; require(req.all { it in identityCertificates.keys }) { "${otherSideSession.counterparty} requested a confidential identity not part of transaction: ${tx.id}" } req }</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$aliceNode.database.transaction { aliceNode.services.identityService.verifyAndRegisterIdentity(confidentialIdentCert) }</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$assertNotNull(aliceNode.database.transaction { aliceNode.services.identityService.wellKnownPartyFromAnonymous(confidentialIdentity) })</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$assertNull(bobNode.database.transaction { bobNode.services.identityService.wellKnownPartyFromAnonymous(confidentialIdentity) })</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$val confidentialIdentCert = charlieNode.services.identityService.certificateFromKey(confidentialIdentity.owningKey)!!</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$val issueFlow = aliceNode.services.startFlow(CashIssueAndPaymentFlow(1000.DOLLARS, ref, alice, anonymous, notary)).resultFuture</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$val issueFlow = charlieNode.services.startFlow(CashIssueAndPaymentFlow(1000.DOLLARS, ref, charlie, anonymous, notary))</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$val payTx = charlieNode.services.startFlow(CashPaymentFlow(1000.DOLLARS, alice, anonymous)).resultFuture.getOrThrow().stx</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ // Cannot use @JvmOverloads in interface @Throws(IllegalArgumentException::class) fun groupAbstractPartyByWellKnownParty(serviceHub: ServiceHub, parties: Collection&lt;AbstractParty&gt;): Map&lt;Party, List&lt;AbstractParty&gt;&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ // Cannot use @JvmOverloads in interface @Throws(IllegalArgumentException::class) fun groupPublicKeysByWellKnownParty(serviceHub: ServiceHub, publicKeys: Collection&lt;PublicKey&gt;): Map&lt;Party, List&lt;PublicKey&gt;&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ @Throws(IllegalArgumentException::class) fun groupAbstractPartyByWellKnownParty( serviceHub: ServiceHub, parties: Collection&lt;AbstractParty&gt;, ignoreUnrecognisedParties: Boolean ): Map&lt;Party, List&lt;AbstractParty&gt;&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ fun &lt;T&gt; excludeHostNode(serviceHub: ServiceHub, map: Map&lt;Party, T&gt;): Map&lt;Party, T&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$(serviceHub.identityService.wellKnownPartyFromAnonymous(it) ?: if (ignoreUnrecognisedParties) return@mapNotNull null else throw IllegalArgumentException("Could not find Party for $it")) to it</ID>
    <ID>MaxLineLength:IdentityUtils.kt$groupAbstractPartyByWellKnownParty(serviceHub, publicKeys.map { AnonymousParty(it) }, ignoreUnrecognisedParties).mapValues { it.value.map { it.owningKey } }</ID>
    <ID>MaxLineLength:IdentityUtils.kt$val components = listOfNotNull(x500name.commonName, x500name.organisationUnit, x500name.organisation, x500name.locality, x500name.state, x500name.country)</ID>
    <ID>MaxLineLength:InMemoryIdentityService.kt$InMemoryIdentityService$@Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class)</ID>
    <ID>MaxLineLength:InMemoryIdentityService.kt$InMemoryIdentityService$@Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) private</ID>
    <ID>MaxLineLength:InMemoryIdentityService.kt$InMemoryIdentityService$log.warn("Certificate validation failed for ${identity.name} against trusted root ${trustAnchor.trustedCert.subjectX500Principal}.")</ID>
    <ID>MaxLineLength:InMemoryIdentityService.kt$InMemoryIdentityService$override</ID>
    <ID>MaxLineLength:InMemoryIdentityService.kt$InMemoryIdentityService$results += keyToPartyAndCerts[key]?.party ?: throw IllegalArgumentException("Could not find an entry in the database for the public key $key.")</ID>
    <ID>MaxLineLength:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests$ @Test fun `assert ownership`()</ID>
    <ID>MaxLineLength:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests$ @Test fun `get anonymous identity by key`()</ID>
    <ID>MaxLineLength:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests$listOf("Org A", "Org B", "Org C") .map { getTestPartyAndCertificate(CordaX500Name(organisation = it, locality = "London", country = "GB"), generateKeyPair().public) }</ID>
    <ID>MaxLineLength:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests$val alicente = getTestPartyAndCertificate(CordaX500Name(organisation = "Alicente Worldwide", locality = "London", country = "GB"), generateKeyPair().public)</ID>
    <ID>MaxLineLength:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests.Companion$fun createService(vararg identities: PartyAndCertificate)</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork$@Synchronized private</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork$DistributedServiceHandle : MessageRecipientGroup</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork$MessageTransfer</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork$ServicePeerAllocationStrategy</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork$peersMapping[messagingService.myAddress.name] = messagingService.myAddress</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork$private val servicePeerAllocationStrategy: ServicePeerAllocationStrategy = InMemoryMessagingNetwork.ServicePeerAllocationStrategy.Random()</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork.Companion$servicePeerAllocationStrategy: ServicePeerAllocationStrategy = InMemoryMessagingNetwork.ServicePeerAllocationStrategy.Random()</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork.MessageTransfer.Companion$internal</ID>
    <ID>MaxLineLength:InMemoryTransactionVerifierService.kt$InMemoryTransactionVerifierService : SingletonSerializeAsTokenTransactionVerifierServiceTransactionVerifierServiceInternalAutoCloseable</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCache.kt$InfrequentlyMutatedCache$ fun get(key: K, valueGetter: (K) -&gt; V): V</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCache.kt$InfrequentlyMutatedCache$// This protects against the cache purging something that is marked as invalid and thus we "forget" it shouldn't be cached. private val currentlyInvalid = ConcurrentHashMap&lt;K, Wrapper.Invalidated&lt;V&gt;&gt;()</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCache.kt$InfrequentlyMutatedCache&lt;K : Any, V : Any&gt;</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$// This should not get cached, as the transaction that invalidated it in the other thread has completed but we might // not see the new value in our transaction since it started first. val result1 = cache.get("foo") { 1 } assertEquals(1, result1) val result2 = cache.get("foo") { 3 } assertEquals(3, result2) // Now allow other thread to commit transaction phaser.arriveAndAwaitAdvance() // and wait for commit to be complete phaser.arriveAndAwaitAdvance() // This should get cached, as the transaction that invalidated it in the other thread has completed but we might // not see the new value in our transaction since it started first. val result3 = cache.get("foo") { 3 } assertEquals(3, result3) val result4 = cache.get("foo") { 4 } assertEquals(4, result4)</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$// This will cache "2" cache.get("foo") { 2 } invalidateInOtherThread("foo") // This should not get cached, as the transaction that invalidated it in the other thread has completed but we might // not see the new value in our transaction since it started first. val result = cache.get("foo") { 1 } assertEquals(1, result)</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `fourth get outside first transaction from empty cache with invalidate in other thread in the middle returns result of second loader`()</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `fourth get outside first transaction from empty cache with invalidate in the middle returns result of third loader`()</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `fourth get outside first transaction from empty cache with nested invalidate in the middle returns result of third loader`()</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `getIfPresent outside first transaction from empty cache with invalidate in the middle returns result of third loader`()</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `third get outside first transaction from empty cache with invalidate in the middle returns result of third loader`()</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistration$e.logAsUnexpected("Could not delete the marker file that was created for `initial-registration`.", print = logger::warn)</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistration$println("Node was started before with `--initial-registration`, but the registration was not completed.\nResuming registration.")</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistration$println("Successfully registered Corda node with compatibility zone, node identity keys and certificates are stored in '${conf.certificatesDirectory}', it is advised to backup the private keys and certificates.")</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistration$require(networkRootTrustStorePath.exists()) { "Network root trust store path: '$networkRootTrustStorePath' doesn't exist" }</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistration${ // Null checks for [compatibilityZoneURL], [rootTruststorePath] and [rootTruststorePassword] has been done in [CmdLineOptions.loadConfig] attempt { registerWithNetwork(config) }.doOnFailure(Consumer(this::handleRegistrationError)) as Try.Success // At this point the node registration was successful. We can delete the marker file. deleteNodeRegistrationMarker(baseDirectory) }</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistrationCli : CliWrapperBase</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistrationCli$@Option(names = ["-p", "--network-root-truststore-password"], description = ["Network root trust store password obtained from network operator."], required = true)</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistrationCli$@Option(names = ["-t", "--network-root-truststore"], description = ["Network root trust store obtained from network operator."])</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistrationCli$return startup.initialiseAndRun(cmdLineOptions, InitialRegistration(cmdLineOptions.baseDirectory, networkRootTrustStorePath, networkRootTrustStorePassword, startup))</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistrationCli$val networkRootTrustStorePath: Path = networkRootTrustStorePathParameter ?: cmdLineOptions.baseDirectory / "certificates" / "network-root-truststore.jks"</ID>
    <ID>MaxLineLength:InitiatedBy.kt$InitiatedBy</ID>
    <ID>MaxLineLength:InitiatingFlow.kt$InitiatingFlow</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$InstallShellExtensionsParser : CliWrapperBase</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$// If on Windows, Path.toString() returns a path with \ instead of /, but for bash Windows users we want to convert those back to /'s private fun Path.toStringWithDeWindowsfication(): String</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$loggerFor&lt;InstallShellExtensionsParser&gt;().warn("Failed to run command: ${commandAndArgs.joinToString(" ")}; $exception")</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$printWarning("Cannot install shell extension for bash major version earlier than $minSupportedBashVersion. Please upgrade your bash version. Aliases should still work.")</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$println("Installation complete, ${parent.alias} is available in bash, but autocompletion was not installed because of an old version of bash.")</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$println("Restart bash for this to take effect, or run `. ~/.bashrc` in bash or `. ~/.zshrc` in zsh to re-initialise your shell now")</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$private fun jarVersion(alias: String)</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator.SettingsFile$println("Updating settings in ${filePath.fileName} - existing settings file has been backed up to $backupFilePath")</ID>
    <ID>MaxLineLength:Instances.kt$Instances</ID>
    <ID>MaxLineLength:InstantSerializer.kt$InstantSerializer : Proxy</ID>
    <ID>MaxLineLength:InstantSerializer.kt$InstantSerializer$override fun fromProxy(proxy: InstantProxy): Instant</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$ExternalResolver.INSTANCE.addCommand("flow", "Commands to work with flows. Flows are how you can change the ledger.", FlowShellCommand::class.java)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$ExternalResolver.INSTANCE.addCommand("hashLookup", "Checks if a transaction with matching Id hash exists.", HashLookupShellCommand::class.java)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$ExternalResolver.INSTANCE.addCommand("output-format", "Commands to inspect and update the output format.", OutputFormatCommand::class.java)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$ExternalResolver.INSTANCE.addCommand("run", "Runs a method from the CordaRPCOps interface on the node.", RunShellCommand::class.java)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$ReconnectingCordaRPCOps(configuration.hostAndPort, username, password, configuration.ssl, classLoader)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$out.println("Please use the 'flow' command to interact with flows rather than the 'run' command.", Color.yellow)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$private</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$rpcConn.close() // This will only show up in the standalone Shell, because the embedded one is killed as part of a node's shutdown. display { println("...done, quitting the shell now.") } onExit.invoke()</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$shell = ShellLifecycle(configuration.commandsDirectory).start(config, configuration.user, configuration.password)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$val mapElement: (Any?) -&gt; String = { element -&gt; outputMapper.writerWithDefaultPrettyPrinter().writeValueAsString(element) }</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$val stateObservable = runFlowFromString({ clazz, args -&gt; rpcOps.startTrackedFlowDynamic(clazz, *args) }, inputData, flowClazz, inputObjectMapper)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell${ private val log = LoggerFactory.getLogger(javaClass) private lateinit var rpcOps: (username: String, password: String) -&gt; InternalCordaRPCOps private lateinit var ops: InternalCordaRPCOps private lateinit var rpcConn: AutoCloseable private var shell: Shell? = null private var classLoader: ClassLoader? = null private lateinit var shellConfiguration: ShellConfiguration private var onExit: () -&gt; Unit = {} @JvmStatic fun getCordappsClassloader() = classLoader enum class OutputFormat { JSON, YAML } fun startShell(configuration: ShellConfiguration, classLoader: ClassLoader? = null, standalone: Boolean = false) { rpcOps = { username: String, password: String -&gt; if (standalone) { ReconnectingCordaRPCOps(configuration.hostAndPort, username, password, configuration.ssl, classLoader).also { rpcConn = it } } else { val client = CordaRPCClient(hostAndPort = configuration.hostAndPort, configuration = CordaRPCClientConfiguration.DEFAULT.copy( maxReconnectAttempts = 1 ), sslConfiguration = configuration.ssl, classLoader = classLoader) val connection = client.start(username, password) rpcConn = connection connection.proxy as InternalCordaRPCOps } } _startShell(configuration, classLoader) } private fun _startShell(configuration: ShellConfiguration, classLoader: ClassLoader? = null) { shellConfiguration = configuration InteractiveShell.classLoader = classLoader val runSshDaemon = configuration.sshdPort != null val config = Properties() if (runSshDaemon) { // Enable SSH access. Note: these have to be strings, even though raw object assignments also work. config["crash.ssh.port"] = configuration.sshdPort?.toString() config["crash.auth"] = "corda" configuration.sshHostKeyDirectory?.apply { val sshKeysDir = configuration.sshHostKeyDirectory.createDirectories() config["crash.ssh.keypath"] = (sshKeysDir / "hostkey.pem").toString() config["crash.ssh.keygen"] = "true" } } ExternalResolver.INSTANCE.addCommand("output-format", "Commands to inspect and update the output format.", OutputFormatCommand::class.java) ExternalResolver.INSTANCE.addCommand("run", "Runs a method from the CordaRPCOps interface on the node.", RunShellCommand::class.java) ExternalResolver.INSTANCE.addCommand("flow", "Commands to work with flows. Flows are how you can change the ledger.", FlowShellCommand::class.java) ExternalResolver.INSTANCE.addCommand("start", "An alias for 'flow start'", StartShellCommand::class.java) ExternalResolver.INSTANCE.addCommand("hashLookup", "Checks if a transaction with matching Id hash exists.", HashLookupShellCommand::class.java) shell = ShellLifecycle(configuration.commandsDirectory).start(config, configuration.user, configuration.password) } fun runLocalShell(onExit: () -&gt; Unit = {}) { this.onExit = onExit val terminal = TerminalFactory.create() val consoleReader = ConsoleReader("Corda", FileInputStream(FileDescriptor.`in`), System.out, terminal) val jlineProcessor = JLineProcessor(terminal.isAnsiSupported, shell, consoleReader, System.out) InterruptHandler { jlineProcessor.interrupt() }.install() thread(name = "Command line shell processor", isDaemon = true) { Emoji.renderIfSupported { try { jlineProcessor.run() } catch (e: IndexOutOfBoundsException) { log.warn("Cannot parse malformed command.") } } } thread(name = "Command line shell terminator", isDaemon = true) { // Wait for the shell to finish. jlineProcessor.closed() log.info("Command shell has exited") terminal.restore() onExit.invoke() } } class ShellLifecycle(private val shellCommands: Path) : PluginLifeCycle() { fun start(config: Properties, localUserName: String = "", localUserPassword: String = ""): Shell { val classLoader = this.javaClass.classLoader val classpathDriver = ClassPathMountFactory(classLoader) val fileDriver = FileMountFactory(Utils.getCurrentDirectory()) val extraCommandsPath = shellCommands.toAbsolutePath().createDirectories() val commandsFS = FS.Builder() .register("file", fileDriver) .mount("file:$extraCommandsPath") .register("classpath", classpathDriver) .mount("classpath:/net/corda/tools/shell/") .mount("classpath:/crash/commands/") .build() val confFS = FS.Builder() .register("classpath", classpathDriver) .mount("classpath:/crash") .build() val discovery = object : ServiceLoaderDiscovery(classLoader) { override fun getPlugins(): Iterable&lt;CRaSHPlugin&lt;*&gt;&gt; { // Don't use the Java language plugin (we may not have tools.jar available at runtime), this // will cause any commands using JIT Java compilation to be suppressed. In CRaSH upstream that // is only the 'jmx' command. return super.getPlugins().filterNot { it is JavaLanguage } + CordaAuthenticationPlugin(rpcOps) } } val attributes = emptyMap&lt;String, Any&gt;() val context = PluginContext(discovery, attributes, commandsFS, confFS, classLoader) context.refresh() this.config = config start(context) ops = makeRPCOps(rpcOps, localUserName, localUserPassword) return context.getPlugin(ShellFactory::class.java).create(null, CordaSSHAuthInfo(false, ops, StdoutANSIProgressRenderer)) } } fun nodeInfo() = try { ops.nodeInfo() } catch (e: UndeclaredThrowableException) { throw e.cause ?: e } @JvmStatic fun setOutputFormat(outputFormat: OutputFormat) { this.outputFormat = outputFormat } @JvmStatic fun getOutputFormat(): OutputFormat { return outputFormat } fun createYamlInputMapper(rpcOps: CordaRPCOps): ObjectMapper { // Return a standard Corda Jackson object mapper, configured to use YAML by default and with extra // serializers. return JacksonSupport.createDefaultMapper(rpcOps, YAMLFactory(), true).apply { val rpcModule = SimpleModule().apply { addDeserializer(InputStream::class.java, InputStreamDeserializer) addDeserializer(UniqueIdentifier::class.java, UniqueIdentifierDeserializer) } registerModule(rpcModule) } } private fun createOutputMapper(outputFormat: OutputFormat): ObjectMapper { val factory = when (outputFormat) { OutputFormat.JSON -&gt; JsonFactory() OutputFormat.YAML -&gt; YAMLFactory().disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER) } return JacksonSupport.createNonRpcMapper(factory).apply { // Register serializers for stateful objects from libraries that are special to the RPC system and don't // make sense to print out to the screen. For classes we own, annotations can be used instead. val rpcModule = SimpleModule().apply { addSerializer(Observable::class.java, ObservableSerializer) addSerializer(InputStream::class.java, InputStreamSerializer) } registerModule(rpcModule) disable(SerializationFeature.FAIL_ON_EMPTY_BEANS) enable(SerializationFeature.INDENT_OUTPUT) } } // TODO: A default renderer could be used, instead of an object mapper. See: http://www.crashub.org/1.3/reference.html#_renderers private var outputFormat = OutputFormat.YAML @VisibleForTesting lateinit var latch: CountDownLatch private set /** * Called from the 'flow' shell command. Takes a name fragment and finds a matching flow, or prints out * the list of options if the request is ambiguous. Then parses [inputData] as constructor arguments using * the [runFlowFromString] method and starts the requested flow. Ctrl-C can be used to cancel. */ @JvmStatic fun runFlowByNameFragment( nameFragment: String, inputData: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, ansiProgressRenderer: ANSIProgressRenderer, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps) ) { val matches = try { rpcOps.registeredFlows().filter { nameFragment in it } } catch (e: PermissionException) { output.println(e.message ?: "Access denied", Color.red) return } if (matches.isEmpty()) { output.println("No matching flow found, run 'flow list' to see your options.", Color.red) return } else if (matches.size &gt; 1 &amp;&amp; matches.find { it.endsWith(nameFragment) } == null) { output.println("Ambiguous name provided, please be more specific. Your options are:") matches.forEachIndexed { i, s -&gt; output.println("${i + 1}. $s", Color.yellow) } return } val flowName = matches.find { it.endsWith(nameFragment) } ?: matches.single() val flowClazz: Class&lt;FlowLogic&lt;*&gt;&gt; = if (classLoader != null) { uncheckedCast(Class.forName(flowName, true, classLoader)) } else { uncheckedCast(Class.forName(flowName)) } try { // Show the progress tracker on the console until the flow completes or is interrupted with a // Ctrl-C keypress. val stateObservable = runFlowFromString({ clazz, args -&gt; rpcOps.startTrackedFlowDynamic(clazz, *args) }, inputData, flowClazz, inputObjectMapper) latch = CountDownLatch(1) ansiProgressRenderer.render(stateObservable, latch::countDown) // Wait for the flow to end and the progress tracker to notice. By the time the latch is released // the tracker is done with the screen. while (!Thread.currentThread().isInterrupted) { try { latch.await() break } catch (e: InterruptedException) { try { rpcOps.killFlow(stateObservable.id) } finally { Thread.currentThread().interrupt() break } } } output.println("Flow completed with result: ${stateObservable.returnValue.get()}") } catch (e: NoApplicableConstructor) { output.println("No matching constructor found:", Color.red) e.errors.forEach { output.println("- $it", Color.red) } } catch (e: PermissionException) { output.println(e.message ?: "Access denied", Color.red) } catch (e: ExecutionException) { // ignoring it as already logged by the progress handler subscriber } finally { InputStreamDeserializer.closeAll() } } class NoApplicableConstructor(val errors: List&lt;String&gt;) : CordaException(this.toString()) { override fun toString() = (listOf("No applicable constructor for flow. Problems were:") + errors).joinToString(System.lineSeparator()) } /** * Tidies up a possibly generic type name by chopping off the package names of classes in a hard-coded set of * hierarchies that are known to be widely used and recognised, and also not have (m)any ambiguous names in them. * * This is used for printing error messages when something doesn't match. */ private fun maybeAbbreviateGenericType(type: Type, extraRecognisedPackage: String): String { val packagesToAbbreviate = listOf("java.", "net.corda.core.", "kotlin.", extraRecognisedPackage) fun shouldAbbreviate(typeName: String) = packagesToAbbreviate.any { typeName.startsWith(it) } fun abbreviated(typeName: String) = if (shouldAbbreviate(typeName)) typeName.split('.').last() else typeName fun innerLoop(type: Type): String = when (type) { is ParameterizedType -&gt; { val args: List&lt;String&gt; = type.actualTypeArguments.map(::innerLoop) abbreviated(type.rawType.typeName) + '&lt;' + args.joinToString(", ") + '&gt;' } is GenericArrayType -&gt; { innerLoop(type.genericComponentType) + "[]" } is Class&lt;*&gt; -&gt; { if (type.isArray) abbreviated(type.simpleName) else abbreviated(type.name).replace('$', '.') } else -&gt; type.toString() } return innerLoop(type) } @JvmStatic fun killFlowById( id: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps) ) { try { val runId = try { inputObjectMapper.readValue(id, StateMachineRunId::class.java) } catch (e: JsonMappingException) { output.println("Cannot parse flow ID of '$id' - expecting a UUID.", Color.red) log.error("Failed to parse flow ID", e) return } if (rpcOps.killFlow(runId)) { output.println("Killed flow $runId", Color.yellow) } else { output.println("Failed to kill flow $runId", Color.red) } } finally { output.flush() } } // TODO: This utility is generally useful and might be better moved to the node class, or an RPC, if we can commit to making it stable API. /** * Given a [FlowLogic] class and a string in one-line Yaml form, finds an applicable constructor and starts * the flow, returning the created flow logic. Useful for lightweight invocation where text is preferable * to statically typed, compiled code. * * See the [StringToMethodCallParser] class to learn more about limitations and acceptable syntax. * * @throws NoApplicableConstructor if no constructor could be found for the given set of types. */ @Throws(NoApplicableConstructor::class) fun &lt;T&gt; runFlowFromString( invoke: (Class&lt;out FlowLogic&lt;T&gt;&gt;, Array&lt;out Any?&gt;) -&gt; FlowProgressHandle&lt;T&gt;, inputData: String, clazz: Class&lt;out FlowLogic&lt;T&gt;&gt;, om: ObjectMapper ): FlowProgressHandle&lt;T&gt; { val errors = ArrayList&lt;String&gt;() val parser = StringToMethodCallParser(clazz, om) val nameTypeList = getMatchingConstructorParamsAndTypes(parser, inputData, clazz) try { val args = parser.parseArguments(clazz.name, nameTypeList, inputData) return invoke(clazz, args) } catch (e: StringToMethodCallParser.UnparseableCallException.ReflectionDataMissing) { val argTypes = nameTypeList.map { (_, type) -&gt; type } errors.add("$argTypes: &lt;constructor missing parameter reflection data&gt;") } catch (e: StringToMethodCallParser.UnparseableCallException) { val argTypes = nameTypeList.map { (_, type) -&gt; type } errors.add("$argTypes: ${e.message}") } throw NoApplicableConstructor(errors) } private fun &lt;T&gt; getMatchingConstructorParamsAndTypes( parser: StringToMethodCallParser&lt;FlowLogic&lt;T&gt;&gt;, inputData: String, clazz: Class&lt;out FlowLogic&lt;T&gt;&gt; ): List&lt;Pair&lt;String, Type&gt;&gt; { val errors = ArrayList&lt;String&gt;() val classPackage = clazz.packageName lateinit var paramNamesFromConstructor: List&lt;String&gt; for (ctor in clazz.constructors) { // Attempt construction with the given arguments. fun getPrototype(): List&lt;String&gt; { val argTypes = ctor.genericParameterTypes.map { // If the type name is in the net.corda.core or java namespaces, chop off the package name // because these hierarchies don't have (m)any ambiguous names and the extra detail is just noise. maybeAbbreviateGenericType(it, classPackage) } return paramNamesFromConstructor.zip(argTypes).map { (name, type) -&gt; "$name: $type" } } try { paramNamesFromConstructor = parser.paramNamesFromConstructor(ctor) val nameTypeList = paramNamesFromConstructor.zip(ctor.genericParameterTypes) parser.validateIsMatchingCtor(clazz.name, nameTypeList, inputData) return nameTypeList } catch (e: StringToMethodCallParser.UnparseableCallException.MissingParameter) { errors.add("${getPrototype()}: missing parameter ${e.paramName}") } catch (e: StringToMethodCallParser.UnparseableCallException.TooManyParameters) { errors.add("${getPrototype()}: too many parameters") } catch (e: StringToMethodCallParser.UnparseableCallException.ReflectionDataMissing) { val argTypes = ctor.genericParameterTypes.map { it.typeName } errors.add("$argTypes: &lt;constructor missing parameter reflection data&gt;") } catch (e: StringToMethodCallParser.UnparseableCallException) { val argTypes = ctor.genericParameterTypes.map { it.typeName } errors.add("$argTypes: ${e.message}") } } throw NoApplicableConstructor(errors) } // TODO Filtering on error/success when we will have some sort of flow auditing, for now it doesn't make much sense. @JvmStatic fun runStateMachinesView(out: RenderPrintWriter, rpcOps: CordaRPCOps): Any? { val proxy = rpcOps val (stateMachines, stateMachineUpdates) = proxy.stateMachinesFeed() val currentStateMachines = stateMachines.map { StateMachineUpdate.Added(it) } val subscriber = FlowWatchPrintingSubscriber(out) stateMachineUpdates.startWith(currentStateMachines).subscribe(subscriber) var result: Any? = subscriber.future if (result is Future&lt;*&gt;) { if (!result.isDone) { out.cls() out.println("Waiting for completion or Ctrl-C ... ") out.flush() } try { result = result.get() } catch (e: InterruptedException) { Thread.currentThread().interrupt() } catch (e: ExecutionException) { throw e.rootCause } catch (e: InvocationTargetException) { throw e.rootCause } } return result } @JvmStatic fun runRPCFromString( input: List&lt;String&gt;, out: RenderPrintWriter, context: InvocationContext&lt;out Any&gt;, cordaRPCOps: InternalCordaRPCOps, inputObjectMapper: ObjectMapper ): Any? { val cmd = input.joinToString(" ").trim { it &lt;= ' ' } if (cmd.startsWith("startflow", ignoreCase = true)) { // The flow command provides better support and startFlow requires special handling anyway due to // the generic startFlow RPC interface which offers no type information with which to parse the // string form of the command. out.println("Please use the 'flow' command to interact with flows rather than the 'run' command.", Color.yellow) return null } else if (cmd.substringAfter(" ").trim().equals("gracefulShutdown", ignoreCase = true)) { return InteractiveShell.gracefulShutdown(out, cordaRPCOps) } var result: Any? = null try { InputStreamSerializer.invokeContext = context val parser = StringToMethodCallParser(InternalCordaRPCOps::class.java, inputObjectMapper) val call = parser.parse(cordaRPCOps, cmd) result = call.call() if (result != null &amp;&amp; result !== kotlin.Unit &amp;&amp; result !is Void) { result = printAndFollowRPCResponse(result, out, outputFormat) } if (result is Future&lt;*&gt;) { if (!result.isDone) { out.println("Waiting for completion or Ctrl-C ... ") out.flush() } try { result = result.get() } catch (e: InterruptedException) { Thread.currentThread().interrupt() } catch (e: ExecutionException) { throw e.rootCause } catch (e: InvocationTargetException) { throw e.rootCause } } } catch (e: StringToMethodCallParser.UnparseableCallException) { out.println(e.message, Color.red) if (e !is StringToMethodCallParser.UnparseableCallException.NoSuchFile) { out.println("Please try 'man run' to learn what syntax is acceptable") } } catch (e: Exception) { out.println("RPC failed: ${e.rootCause}", Color.red) } finally { InputStreamSerializer.invokeContext = null InputStreamDeserializer.closeAll() } return result } @JvmStatic fun gracefulShutdown(userSessionOut: RenderPrintWriter, cordaRPCOps: CordaRPCOps) { fun display(statements: RenderPrintWriter.() -&gt; Unit) { statements.invoke(userSessionOut) userSessionOut.flush() } var isShuttingDown = false try { display { println("Orchestrating a clean shutdown, press CTRL+C to cancel...") } isShuttingDown = true display { println("...enabling draining mode") println("...waiting for in-flight flows to be completed") } cordaRPCOps.terminate(true) val latch = CountDownLatch(1) cordaRPCOps.pendingFlowsCount().updates.doOnError { error -&gt; log.error(error.message) throw error }.doAfterTerminate(latch::countDown).subscribe( // For each update. { (first, second) -&gt; display { println("...remaining: $first / $second") } }, // On error. { error -&gt; if (!isShuttingDown) { display { println("RPC failed: ${error.rootCause}", Color.red) } } }, // When completed. { rpcConn.close() // This will only show up in the standalone Shell, because the embedded one is killed as part of a node's shutdown. display { println("...done, quitting the shell now.") } onExit.invoke() }) while (!Thread.currentThread().isInterrupted) { try { latch.await() break } catch (e: InterruptedException) { try { cordaRPCOps.setFlowsDrainingModeEnabled(false) display { println("...cancelled clean shutdown.") } } finally { Thread.currentThread().interrupt() break } } } } catch (e: StringToMethodCallParser.UnparseableCallException) { display { println(e.message, Color.red) println("Please try 'man run' to learn what syntax is acceptable") } } catch (e: Exception) { if (!isShuttingDown) { display { println("RPC failed: ${e.rootCause}", Color.red) } } } finally { InputStreamSerializer.invokeContext = null InputStreamDeserializer.closeAll() } } private fun printAndFollowRPCResponse(response: Any?, out: PrintWriter, outputFormat: OutputFormat): CordaFuture&lt;Unit&gt; { val outputMapper = createOutputMapper(outputFormat) val mapElement: (Any?) -&gt; String = { element -&gt; outputMapper.writerWithDefaultPrettyPrinter().writeValueAsString(element) } return maybeFollow(response, mapElement, out) } private class PrintingSubscriber(private val printerFun: (Any?) -&gt; String, private val toStream: PrintWriter) : Subscriber&lt;Any&gt;() { private var count = 0 val future = openFuture&lt;Unit&gt;() init { // The future is public and can be completed by something else to indicate we don't wish to follow // anymore (e.g. the user pressing Ctrl-C). future.then { unsubscribe() } } @Synchronized override fun onCompleted() { toStream.println("Observable has completed") future.set(Unit) } @Synchronized override fun onNext(t: Any?) { count++ toStream.println("Observation $count: " + printerFun(t)) toStream.flush() } @Synchronized override fun onError(e: Throwable) { toStream.println("Observable completed with an error") e.printStackTrace(toStream) future.setException(e) } } private fun maybeFollow(response: Any?, printerFun: (Any?) -&gt; String, out: PrintWriter): CordaFuture&lt;Unit&gt; { // Match on a couple of common patterns for "important" observables. It's tough to do this in a generic // way because observables can be embedded anywhere in the object graph, and can emit other arbitrary // object graphs that contain yet more observables. So we just look for top level responses that follow // the standard "track" pattern, and print them until the user presses Ctrl-C if (response == null) return doneFuture(Unit) if (response is DataFeed&lt;*, *&gt;) { out.println("Snapshot:") out.println(printerFun(response.snapshot)) out.flush() out.println("Updates:") return printNextElements(response.updates, printerFun, out) } if (response is Observable&lt;*&gt;) { return printNextElements(response, printerFun, out) } out.println(printerFun(response)) return doneFuture(Unit) } private fun printNextElements(elements: Observable&lt;*&gt;, printerFun: (Any?) -&gt; String, out: PrintWriter): CordaFuture&lt;Unit&gt; { val subscriber = PrintingSubscriber(printerFun, out) uncheckedCast(elements).subscribe(subscriber) return subscriber.future } }</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell.NoApplicableConstructor$override fun toString()</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell.PrintingSubscriber$private</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell.ShellLifecycle$return context.getPlugin(ShellFactory::class.java).create(null, CordaSSHAuthInfo(false, ops, StdoutANSIProgressRenderer))</ID>
    <ID>MaxLineLength:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$InteractiveShell.runFlowByNameFragment(NoOpFlow::class.java.name, "", output, node.rpc, mockAnsiProgressRenderer())</ID>
    <ID>MaxLineLength:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$InteractiveShell.runRPCFromString(listOf("dumpCheckpoints"), output, mock(), aliceNode.rpc as InternalCordaRPCOps, inputObjectMapper)</ID>
    <ID>MaxLineLength:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$startNode(rpcUsers = listOf(user), customOverrides = brokerSslOptions.useSslRpcOverrides()).getOrThrow()</ID>
    <ID>MaxLineLength:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$val node = startNode(rpcUsers = listOf(user), customOverrides = brokerSslOptions.useSslRpcOverrides()).getOrThrow()</ID>
    <ID>MaxLineLength:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$val zipFile = (aliceNode.baseDirectory / NodeStartup.LOGS_DIRECTORY_NAME).list().first { "checkpoints_dump-" in it.toString() }</ID>
    <ID>MaxLineLength:InteractiveShellTest.kt$FlowA$constructor(amounts: Array&lt;Amount&lt;UserValue&gt;&gt;) : this(amounts.joinToString("++", transform = Amount&lt;UserValue&gt;::toString))</ID>
    <ID>MaxLineLength:InteractiveShellTest.kt$InteractiveShellTest$input = """amounts: [ { "quantity": 10, "token": { "label": "(1)" } }, { "quantity": 200, "token": { "label": "(2)" } } ]"""</ID>
    <ID>MaxLineLength:InteractiveShellTest.kt$InteractiveShellTest$input = "pair: { first: $100.12, second: df489807f81c8c8829e509e1bcb92e6692b9dd9d624b7456435cb2f51dc82587 }"</ID>
    <ID>MaxLineLength:InteractiveShellTest.kt$InteractiveShellTest$val instance = clazz.getConstructor(*args.map { it!!::class.java }.toTypedArray()).newInstance(*args) as FlowA</ID>
    <ID>MaxLineLength:InterestSwapRestAPI.kt$InterestRateSwapAPI</ID>
    <ID>MaxLineLength:InterestSwapRestAPI.kt$InterestRateSwapAPI$val states = vault.filterStatesOfType&lt;InterestRateSwap.State&gt;().filter { it.state.data.linearId.externalId == ref }</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$"You can use MockNetwork.waitQuiescent() to wait for all the nodes to process all the messages on their queues instead."</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$/** * Returns the list of nodes started by the network. Each notary specified when the network is constructed ([notarySpecs] * parameter) maps 1:1 to the notaries returned by this list. */ val notaryNodes: List&lt;TestStartedNode&gt;</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$?:</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$TestCordappInternal.installCordapps(baseDirectory, parameters.additionalCordapps.toSet(), combinedCordappsForAllNodes)</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$configOverrides = { doReturn(NotaryConfig(spec.validating, className = spec.className)).whenever(it).notary }</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$private val serializationEnv = checkNotNull(setDriverSerialization()) { "Using more than one mock network simultaneously is not supported." }</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = defaultParameters.servicePeerAllocationStrategy</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$val messagingNetwork = InMemoryMessagingNetwork.create(networkSendManuallyPumped, servicePeerAllocationStrategy, busyLatch)</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$val node = nodeFactory(MockNodeArgs(config, this, id, parameters.entropyRoot, parameters.version, flowManager = parameters.flowManager))</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode$(network as MockNodeMessagingService).start(mockNet.messagingNetwork, !mockNet.threadPerNode, id, myNotaryIdentity)</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode$open</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode$override</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode$require(cryptoService is BCCryptoService) { "MockNode supports BCCryptoService only, but it is ${cryptoService.javaClass.name}" }</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode${ require(cryptoService is BCCryptoService) { "MockNode supports BCCryptoService only, but it is ${cryptoService.javaClass.name}" } counter = counter.add(BigInteger.ONE) // The StartedMockNode specifically uses EdDSA keys as they are fixed and stored in json files for some tests (e.g IRSSimulation). val keyPair = Crypto.deriveKeyPairFromEntropy(Crypto.EDDSA_ED25519_SHA512, counter) (cryptoService as BCCryptoService).importKey(alias, keyPair) return keyPair.public }</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode.TestStartedNodeImpl$override</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode.TestStartedNodeImpl$return smm.changes.filter { it is StateMachineManager.Change.Add }.map { it.logic }.ofType(initiatedFlowClass)</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$MessagingServiceSpy$val messagingService: MessagingService get() = checkNotNull(_messagingService) { "Spy has not been attached to a node" }</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$MockNodeFlowManager$override</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$TestStartedNode$ fun setMessagingServiceSpy(spy: MessagingServiceSpy)</ID>
    <ID>MaxLineLength:InternalMockNetworkConfigOverrides.kt$return NotaryConfig(validating = this.validating, extraConfig = this.extraConfig, serviceLegalName = this.serviceLegalName, className = this.className)</ID>
    <ID>MaxLineLength:InternalMockNetworkConfigOverrides.kt$this.flowTimeout?.also { fto -&gt; doReturn(FlowTimeoutConfiguration(fto.timeout, fto.maxRestartCount, fto.backoffBase)).whenever(config).flowTimeout }</ID>
    <ID>MaxLineLength:InternalMockNetworkIntegrationTests.kt$InternalMockNetworkIntegrationTests$assertEquals(0, startJavaProcess&lt;InternalMockNetworkIntegrationTests&gt;(emptyList(), extraJvmArguments = listOf("-javaagent:$quasar")).waitFor())</ID>
    <ID>MaxLineLength:InternalMockNetworkTests.kt$InternalMockNetworkTests$node1.network.send(node2.network.createMessage("test.topic", data = bits), rigorousMock&lt;AllPossibleRecipients&gt;())</ID>
    <ID>MaxLineLength:InternalRPCMessagingClient.kt$InternalRPCMessagingClient$fun init(rpcOps: RPCOps, securityManager: RPCSecurityManager, cacheFactory: NamedCacheFactory)</ID>
    <ID>MaxLineLength:InternalRPCMessagingClient.kt$InternalRPCMessagingClient$rpcServer = RPCServer(rpcOps, NODE_RPC_USER, NODE_RPC_USER, locator!!, securityManager, nodeName, rpcServerConfiguration, cacheFactory)</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ // TODO Rename to cordappWithClasses fun cordappForClasses(vararg classes: Class&lt;*&gt;): CustomCordapp</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ fun JarOutputStream.addEntry(entry: ZipEntry, input: InputStream)</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ fun NodeInfo.chooseIdentity(): Party</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ fun addressMustBeBound( executorService: ScheduledExecutorService, hostAndPort: NetworkHostAndPort, listenProcess: Process? = null )</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ fun cordappWithPackages(vararg packageNames: String): CustomCordapp</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ fun createDevNodeCaCertPath( legalName: CordaX500Name, nodeKeyPair: KeyPair = generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME), rootCaName: X500Principal = defaultRootCaName, intermediateCaName: X500Principal = defaultIntermediateCaName ): Triple&lt;CertificateAndKeyPair, CertificateAndKeyPair, CertificateAndKeyPair&gt;</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ fun findCordapp(scanPackage: String): TestCordappImpl</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$/** * *Custom* CorDapp containing the contents of the `net.corda.testing.contracts` package, i.e. the dummy contracts. This is not a real CorDapp * in the way that [FINANCE_CONTRACTS_CORDAPP] and [FINANCE_WORKFLOWS_CORDAPP] are. */ @JvmField val DUMMY_CONTRACTS_CORDAPP: CustomCordapp = cordappWithPackages("net.corda.testing.contracts")</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$/** * Reference to the finance-contracts CorDapp in this repo. The metadata is taken directly from finance/contracts/build.gradle, including the * fact that the jar is signed. If you need an unsigned jar then use `cordappWithPackages("net.corda.finance.contracts")`. * * You will probably need to use [FINANCE_CORDAPPS] instead to get access to the flows as well. */ @JvmField val FINANCE_CONTRACTS_CORDAPP: TestCordappImpl = findCordapp("net.corda.finance.contracts")</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$/** * Reference to the finance-workflows CorDapp in this repo. The metadata is taken directly from finance/workflows/build.gradle, including the * fact that the jar is signed. If you need an unsigned jar then use `cordappWithPackages("net.corda.finance.flows")`. * * You will probably need to use [FINANCE_CORDAPPS] instead to get access to the contract classes as well. */ @JvmField val FINANCE_WORKFLOWS_CORDAPP: TestCordappImpl = findCordapp("net.corda.finance.workflows")</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ListenProcessDeathException$CordaException("The process that was expected to listen on $hostAndPort has died with status: ${listenProcess.exitValue()}")</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$RPCSecurityManagerImpl(SecurityConfiguration.AuthService.fromUsers(users).copy(id = id), TestingNamedCacheFactory())</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$fun &lt;T&gt; StartedNodeServices.startFlow(logic: FlowLogic&lt;T&gt;): FlowStateMachine&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$fun addressMustNotBeBoundFuture(executorService: ScheduledExecutorService, hostAndPort: NetworkHostAndPort): CordaFuture&lt;Unit&gt;</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$manifestAttributes.forEach { manifest[it.key] = it.value }</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$require(classes.isNotEmpty()) { "${receiverClass.name} does not contain any enclosed classes to build a CorDapp out of" }</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$val componentGroups = createComponentGroups(inputs, outputs, commands, attachments, notary, timeWindow, emptyList(), null)</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$val persistence = createCordaPersistence(databaseConfig, wellKnownPartyFromX500Name, wellKnownPartyFromAnonymous, schemaService, hikariProperties, cacheFactory, null)</ID>
    <ID>MaxLineLength:InternalTestUtilsTest.kt$InternalTestUtilsTest$assertThat(simplifyScanPackages(listOf("com.foobar", "com.foo"))).containsExactlyInAnyOrder("com.foobar", "com.foo")</ID>
    <ID>MaxLineLength:InternalTestUtilsTest.kt$InternalTestUtilsTest$assertThat(simplifyScanPackages(listOf("com.foobar", "com.foo.bar"))).containsExactlyInAnyOrder("com.foobar", "com.foo.bar")</ID>
    <ID>MaxLineLength:InternalUtils.kt$ @DeleteForDJVM fun &lt;T&gt; Any.declaredField(clazz: Class&lt;*&gt;, name: String): DeclaredField&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$ @DeleteForDJVM fun &lt;T&gt; Any.declaredField(clazz: KClass&lt;*&gt;, name: String): DeclaredField&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$ @DeleteForDJVM fun &lt;T&gt; Any.declaredField(name: String): DeclaredField&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$ @DeleteForDJVM fun &lt;T&gt; KClass&lt;*&gt;.staticField(name: String): DeclaredField&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$ fun &lt;T, U&gt; List&lt;T&gt;.lazyMapped(transform: (T, Int) -&gt; U): List&lt;U&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$// TODO: Currently the certificate revocation status is not handled here. Nowhere in the code the second parameter is used. Consider adding the support in the future. fun CertPath.validate(trustAnchor: TrustAnchor, checkRevocation: Boolean = false): PKIXCertPathValidatorResult</ID>
    <ID>MaxLineLength:InternalUtils.kt$?:</ID>
    <ID>MaxLineLength:InternalUtils.kt$@DeleteForDJVM fun InputStream.copyTo(target: Path, vararg options: CopyOption): Long</ID>
    <ID>MaxLineLength:InternalUtils.kt$DeclaredField&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$LazyMappedList&lt;T, U&gt; : AbstractList</ID>
    <ID>MaxLineLength:InternalUtils.kt$if (predicate(iterator.next())) throw IllegalArgumentException("Collection contains more than one matching element.")</ID>
    <ID>MaxLineLength:InternalUtils.kt$val Class&lt;*&gt;.packageNameOrNull: String? // This intentionally does not go via `package` as that code path is slow and contended and just ends up doing this. get() { val name = this.getName() val i = name.lastIndexOf('.') if (i != -1) { return name.substring(0, i) } else { return null } }</ID>
    <ID>MaxLineLength:Interpolators.kt$CubicSplineInterpolator : Interpolator</ID>
    <ID>MaxLineLength:Interpolators.kt$Polynomial</ID>
    <ID>MaxLineLength:InvocationContext.kt$Actor.Companion$@JvmStatic fun service(serviceClassName: String, owningLegalIdentity: CordaX500Name): Actor</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun newInstance( origin: InvocationOrigin, trace: Trace = Trace.newInstance(), actor: Actor? = null, externalTrace: Trace? = null, impersonatedActor: Actor? = null )</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun shell(trace: Trace = Trace.newInstance(), externalTrace: Trace? = null): InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$( serviceClassName: String, owningLegalIdentity: CordaX500Name, trace: Trace = Trace.newInstance(), externalTrace: Trace? = null )</ID>
    <ID>MaxLineLength:IrsDemoClientApi.kt$IRSDemoClientApi$val fileContents = IOUtils.toString(Thread.currentThread().contextClassLoader.getResourceAsStream("net/corda/irs/simulation/example.rates.txt"), Charsets.UTF_8.name())</ID>
    <ID>MaxLineLength:IrsDemoClientApi.kt$IRSDemoClientApi$val fileContents = IOUtils.toString(javaClass.classLoader.getResourceAsStream("net/corda/irs/web/simulation/example-irs-trade.json"), Charsets.UTF_8.name())</ID>
    <ID>MaxLineLength:IssueCash.kt$IssueCash$BankOfCordaClientApi.requestWebIssue(NetworkHostAndPort("localhost", BOC_WEB_PORT), createParams(amount, NOTARY_NAME))</ID>
    <ID>MaxLineLength:IssueCash.kt$IssueCash$private</ID>
    <ID>MaxLineLength:IssueCash.kt$IssueCash$return BankOfCordaClientApi.requestRPCIssue(NetworkHostAndPort("localhost", BOC_RPC_PORT), createParams(amount, NOTARY_NAME))</ID>
    <ID>MaxLineLength:IssueCash.kt$IssueCash$val currency = parser.accepts("currency").withOptionalArg().ofType(String::class.java).describedAs("[GBP|USD|CHF|EUR]")</ID>
    <ID>MaxLineLength:IssueCash.kt$IssueCash$val roleArg = parser.accepts("role").withRequiredArg().ofType(Role::class.java).describedAs("[ISSUER|ISSUE_CASH_RPC|ISSUE_CASH_WEB]")</ID>
    <ID>MaxLineLength:IssueCashLoggingTests.kt$IssueCashLoggingTests$nodeA.rpc.startFlow(::CashIssueAndPaymentFlow, amount, ref, recipient, false, defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:IssueCashLoggingTests.kt$IssueCashLoggingTests$val linesWithDuplicateInsertionWarningsInA = nodeA.logFile().useLines { lines -&gt; lines.filter(String::containsDuplicateInsertWarning).toList() }</ID>
    <ID>MaxLineLength:IssueCashLoggingTests.kt$IssueCashLoggingTests$val linesWithDuplicateInsertionWarningsInB = nodeB.logFile().useLines { lines -&gt; lines.filter(String::containsDuplicateInsertWarning).toList() }</ID>
    <ID>MaxLineLength:IssueCashLoggingTests.kt$fun NodeHandle.logFile(): File</ID>
    <ID>MaxLineLength:IssueCashLoggingTests.kt$private fun String.containsDuplicateInsertWarning(): Boolean</ID>
    <ID>MaxLineLength:IssuerModel.kt$IssuerModel$val currencyTypes = ChosenList(cashAppConfiguration.map { it?.issuableCurrencies?.observable() ?: FXCollections.emptyObservableList() }, "currencyTypes")</ID>
    <ID>MaxLineLength:IssuerModel.kt$IssuerModel$val supportedCurrencies = ChosenList(cashAppConfiguration.map { it?.supportedCurrencies?.observable() ?: FXCollections.singletonObservableList(defaultCurrency) }, "supportedCurrencies")</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport$ @JvmStatic @JvmOverloads fun createDefaultMapper( rpc: CordaRPCOps, factory: JsonFactory = JsonFactory(), fuzzyIdentityMatch: Boolean = false, fullParties: Boolean = false ): ObjectMapper</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport$ @JvmStatic @JvmOverloads fun createInMemoryMapper( identityService: IdentityService, factory: JsonFactory = JsonFactory(), fuzzyIdentityMatch: Boolean = false, fullParties: Boolean = false ): ObjectMapper</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport$ @JvmStatic @JvmOverloads fun createNonRpcMapper(factory: JsonFactory = JsonFactory(), fullParties: Boolean = false): ObjectMapper</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport$@CordaInternal @VisibleForTesting internal</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport$@Deprecated("Do not use this as it's not thread safe. Instead get a ObjectMapper instance with one of the create*Mapper methods.")</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.IdentityObjectMapper$override fun wellKnownPartyFromX500Name(name: CordaX500Name): Party?</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.PartyDeserializer$?:</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.PartyDeserializer$mapper.wellKnownPartyFromX500Name(principal) ?: throw JsonParseException(parser, "Could not find a Party with name $principal")</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.PartyDeserializer$throw JsonParseException(parser, "No matching Party found, then tried to directly deserialise ${parser.text} as a PublicKey with no success", e)</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.RpcObjectMapper$@Deprecated("This is an internal class, do not use", replaceWith = ReplaceWith("JacksonSupport.createDefaultMapper"))</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.X509CertificateSerializer$writeObjectField("keyUsage", value.keyUsage?.asList()?.mapIndexedNotNull { i, flag -&gt; if (flag) keyUsages[i] else null })</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.X509CertificateSerializer$writeObjectField("pathLength", value.basicConstraints.let { if (it != Int.MAX_VALUE) it else null })</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$TransactionSignature(ByteArray(1), ALICE_PUBKEY, SignatureMetadata(1, Crypto.findSignatureScheme(ALICE_PUBKEY).schemeNumberID), partialMerkleTree)</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$TransactionSignature(ByteArray(1), BOB_PUBKEY, SignatureMetadata(1, Crypto.findSignatureScheme(BOB_PUBKEY).schemeNumberID))</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$assertThat(json["class"].textValue()).isEqualTo("net.corda.client.jackson.JacksonSupportTest\$ClassNotOnClasspath")</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$assertThat(mapper.convertValue&lt;OpaqueBytes&gt;(BinaryNode(byteArrayOf(1, 2, 3, 4)))).isEqualTo(OpaqueBytes.of(1, 2, 3, 4))</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$assertThat(mapper.convertValue&lt;SerializedBytes&lt;*&gt;&gt;(BinaryNode(serializedBytes.bytes))).isEqualTo(serializedBytes)</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$assertThat(mapper.convertValue&lt;SignatureScheme&gt;(TextNode("EDDSA_ED25519_SHA512"))).isSameAs(Crypto.EDDSA_ED25519_SHA512)</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$assertThat(mapper.valueToTree&lt;TextNode&gt;(Amount.parseCurrency("£25000000")).textValue()).isEqualTo("25000000.00 GBP")</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$fun convertToNodeInfo()</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$val transactionSignature = TransactionSignature(secureRandomBytes(128), BOB_PUBKEY, signatureMetadata, partialMerkleTree)</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$val wtxFields = wtxJson.assertHasOnlyFields("id", "notary", "inputs", "attachments", "outputs", "commands", "timeWindow", "references", "privacySalt", "networkParametersHash")</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest${ val cert: X509Certificate = MINI_CORP.identity.certificate val json = mapper.valueToTree&lt;ObjectNode&gt;(cert) println(mapper.writeValueAsString(json)) assertThat(json["serialNumber"].bigIntegerValue()).isEqualTo(cert.serialNumber) assertThat(json["issuer"].valueAs&lt;X500Principal&gt;(mapper)).isEqualTo(cert.issuerX500Principal) assertThat(json["subject"].valueAs&lt;X500Principal&gt;(mapper)).isEqualTo(cert.subjectX500Principal) // cert.publicKey should be converted to a supported format (this is required because [Certificate] returns keys as SUN EC keys, not BC). assertThat(json["publicKey"].valueAs&lt;PublicKey&gt;(mapper)).isEqualTo(Crypto.toSupportedPublicKey(cert.publicKey)) assertThat(json["notAfter"].valueAs&lt;Date&gt;(mapper)).isEqualTo(cert.notAfter) assertThat(json["notBefore"].valueAs&lt;Date&gt;(mapper)).isEqualTo(cert.notBefore) assertThat(json["encoded"].binaryValue()).isEqualTo(cert.encoded) }</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$CordappLoaderTemplate$"${entry.value.first().first.name}: [ ${entry.value.joinToString { it.second.jarPath.toString() }} ]."</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$CordappLoaderTemplate$throw MultipleCordappsForFlowException("There are multiple CorDapp JARs on the classpath for flow " + "${entry.value.first().first.name}: [ ${entry.value.joinToString { it.second.jarPath.toString() }} ].")</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$"platform version ${it.minimumPlatformVersion} (This node is running version ${versionInfo.platformVersion})."</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$?:</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$RestrictedURL</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$contractInfo != null &amp;&amp; workflowInfo != null -&gt; return Cordapp.Info.ContractAndWorkflow(contractInfo, workflowInfo)</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$it.javaClass.location == cordappJarPath.url &amp;&amp; it.javaClass.name.startsWith(cordappJarPath.qualifiedNamePrefix)</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$logger</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$override val appClassLoader: URLClassLoader = URLClassLoader(cordappJarPaths.stream().map { it.url }.toTypedArray(), javaClass.classLoader)</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$return Modifier.isPublic(modifiers) &amp;&amp; !isLocalClass &amp;&amp; !isAnonymousClass &amp;&amp; (!isMemberClass || Modifier.isStatic(modifiers))</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$return scanResult.getClassesWithAnnotation(FlowLogic::class, StartableByRPC::class).filter { it.isUserInvokable() }</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$throw CordappInvalidVersionException("Target versionId ($versionStr) for attribute $attributeName must not be smaller than 1.")</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$throw CordappInvalidVersionException("Target versionId attribute $attributeName not specified. Please specify a whole number starting from 1.")</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$val blockedCertificates = certificates.filter { it.publicKey.hash.sha256() in signerKeyFingerprintBlacklist }</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$val certificates = it.jarPath.openStream().let(::JarInputStream).use(JarSignatureCollector::collectCertificates)</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$val scanResult = ClassGraph().addClassLoader(appClassLoader).overrideClasspath(cordappJarPath.url).enableAllInfo().pooledScan()</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$val targetPlatformVersion = manifest?.get(CordappImpl.TARGET_PLATFORM_VERSION)?.toIntOrNull() ?: minPlatformVersion</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$versionId = parseVersion(manifest[CordappImpl.CORDAPP_CONTRACT_VERSION], CordappImpl.CORDAPP_CONTRACT_VERSION)</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$versionId = parseVersion(manifest[CordappImpl.CORDAPP_WORKFLOW_VERSION], CordappImpl.CORDAPP_WORKFLOW_VERSION)</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader.RestrictedScanResult$fun &lt;T : Any&gt; getClassesWithAnnotation(type: KClass&lt;T&gt;, annotation: KClass&lt;out Annotation&gt;): List&lt;Class&lt;out T&gt;&gt;</ID>
    <ID>MaxLineLength:JarScanningCordappLoaderTest.kt$JarScanningCordappLoaderTest$@Test fun `cordapp classloader does not load apps when their min platform version is greater than the node platform version`()</ID>
    <ID>MaxLineLength:JarScanningCordappLoaderTest.kt$JarScanningCordappLoaderTest$assertThat(actualCordapp.serializationWhitelists.first().javaClass.name).isEqualTo("net.corda.serialization.internal.DefaultWhitelist")</ID>
    <ID>MaxLineLength:JarScanningCordappLoaderTest.kt$JarScanningCordappLoaderTest$val loader = JarScanningCordappLoader.fromJarUrls(listOf(jar), cordappsSignerKeyFingerprintBlacklist = DEV_PUB_KEY_HASHES)</ID>
    <ID>MaxLineLength:JarScanningCordappLoaderTest.kt$JarScanningCordappLoaderTest$val loader = JarScanningCordappLoader.fromJarUrls(listOf(jar), cordappsSignerKeyFingerprintBlacklist = emptyList())</ID>
    <ID>MaxLineLength:JarScanningCordappLoaderTest.kt$JarScanningCordappLoaderTest$val serializationWhitelistedClasses = actualCordapp.serializationWhitelists.flatMap { it.whitelist }.map { it.name }</ID>
    <ID>MaxLineLength:JarSignatureCollector.kt$JarSignatureCollector$ fun collectCertificates(jar: JarInputStream): List&lt;X509Certificate&gt;</ID>
    <ID>MaxLineLength:JarSignatureCollector.kt$JarSignatureCollector$/** * @see &lt;https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Signed_JAR_File&gt; * Additionally accepting *.EC as its valid for [java.util.jar.JarVerifier] and jarsigner @see https://docs.oracle.com/javase/8/docs/technotes/tools/windows/jarsigner.html, * temporally treating META-INF/INDEX.LIST as unsignable entry because [java.util.jar.JarVerifier] doesn't load its signers. */ private val unsignableEntryName = "META-INF/(?:(?:.*[.](?:SF|DSA|RSA|EC)|SIG-.*)|INDEX\\.LIST)".toRegex()</ID>
    <ID>MaxLineLength:JarSignatureCollectorTest.kt$JarSignatureCollectorTest$// Signing with EC algorithm produces META-INF/*.EC file name not compatible with JAR File Spec however it's compatible with java.util.JarVerifier // and our JarSignatureCollector @Test fun `one signer with EC algorithm`()</ID>
    <ID>MaxLineLength:JarSignatureCollectorTest.kt$JarSignatureCollectorTest$assertEquals(listOf(key), dir.getJarSigners(FILENAME))</ID>
    <ID>MaxLineLength:JarSignatureCollectorTest.kt$JarSignatureCollectorTest${ (dir / "volatile").writeLines(listOf("volatile")) dir.createJar(FILENAME, "volatile") val key1 = signAsAlice() assertEquals(listOf(key1), dir.getJarSigners(FILENAME)) (dir / "volatile").writeLines(listOf("garbage")) dir.updateJar(FILENAME, "volatile", "_signable1") // ALICE's signature on volatile is now bad. signAsBob() // The JDK doesn't care that BOB has correctly signed the whole thing, it won't let us process the entry with ALICE's bad signature: assertFailsWith&lt;SecurityException&gt; { dir.getJarSigners(FILENAME) } }</ID>
    <ID>MaxLineLength:JarSignatureTestUtils.kt$JarSignatureTestUtils$executeProcess("jarsigner", "-keystore", "_teststore", "-storepass", storePassword, "-keypass", keyPassword, fileName, alias)</ID>
    <ID>MaxLineLength:JarSignatureTestUtils.kt$JarSignatureTestUtils$executeProcess("keytool", "-genkeypair", "-keystore", storeName, "-storepass", storePassword, "-keyalg", keyalg, "-alias", alias, "-keypass", keyPassword, "-dname", name)</ID>
    <ID>MaxLineLength:JarSignatureTestUtils.kt$JarSignatureTestUtils$fun Path.signJar(fileName: String, alias: String, storePassword: String, keyPassword: String = storePassword): PublicKey</ID>
    <ID>MaxLineLength:KMSUtils.kt$require(issuerRole == CertRole.LEGAL_IDENTITY) { "Confidential identities can only be issued from well known identities, provided issuer ${issuer.name} has role $issuerRole" }</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun externalIdForPublicKey(publicKey: PublicKey): UUID?</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun freshKey(externalId: UUID): PublicKey</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun freshKeyAndCert(identity: PartyAndCertificate, revocationEnabled: Boolean): PartyAndCertificate</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun freshKeyAndCert(identity: PartyAndCertificate, revocationEnabled: Boolean, externalId: UUID): PartyAndCertificate</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun sign(bytes: ByteArray, publicKey: PublicKey): DigitalSignature.WithKey</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun sign(signableData: SignableData, publicKey: PublicKey): TransactionSignature</ID>
    <ID>MaxLineLength:KeyManagementServiceInternal.kt$KeyManagementServiceInternal$override</ID>
    <ID>MaxLineLength:KeyOwningIdentity.kt$KeyOwningIdentity</ID>
    <ID>MaxLineLength:KeyOwningIdentity.kt$KeyOwningIdentity$MappedIdentity : KeyOwningIdentity</ID>
    <ID>MaxLineLength:KeyOwningIdentity.kt$KeyOwningIdentity$UnmappedIdentity : KeyOwningIdentity</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$"certificates/$DEV_CA_TRUST_STORE_FILE"</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$// A code signing policy is currently under design. // The following interim key represents a self-signed certificate produced using the Java keytool and located in the gradle cordapp plugins resources key store: // https://github.com/corda/corda-gradle-plugins/blob/master/cordapp/src/main/resources/certificates/cordadevcodesign.jks const val DEV_CORDAPP_CODE_SIGNING_STR = "AA59D829F2CA8FDDF5ABEA40D815F937E3E54E572B65B93B5C216AE6594E7D6B"</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$fun CertificateStore.storeLegalIdentity(alias: String, keyPair: KeyPair = Crypto.generateKeyPair()): PartyAndCertificate</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$fun loadDevCaKeyStore(classLoader: ClassLoader = DevCaHelper::class.java.classLoader): CertificateStore</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$fun loadDevCaTrustStore(classLoader: ClassLoader = DevCaHelper::class.java.classLoader): CertificateStore</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$setPrivateKey</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$val DEV_PUB_KEY_HASHES: List&lt;SecureHash.SHA256&gt; get() = listOf(DEV_INTERMEDIATE_CA.certificate, DEV_ROOT_CA.certificate).map { it.publicKey.hash.sha256() } + SecureHash.parse(DEV_CORDAPP_CODE_SIGNING_STR).sha256()</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$val identityCert = X509Utilities.createCertificate(CertificateType.LEGAL_IDENTITY, nodeCaCertAndKeyPair.certificate, nodeCaCertAndKeyPair.keyPair, nodeCaCertAndKeyPair.certificate.subjectX500Principal, keyPair.public)</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$val nameConstraints = NameConstraints(arrayOf(GeneralSubtree(GeneralName(GeneralName.directoryName, legalName.toX500Name()))), arrayOf())</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$val nodeCaCertAndKeyPair = getCertificateAndKeyPair(X509Utilities.CORDA_CLIENT_CA, this@storeLegalIdentity.entryPassword)</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$val tlsCert = X509Utilities.createCertificate(CertificateType.TLS, devNodeCa.certificate, devNodeCa.keyPair, legalName.x500Principal, tlsKeyPair.public)</ID>
    <ID>MaxLineLength:KeyStoreUtilities.kt$ fun KeyStore.addOrReplaceKey(alias: String, key: Key, password: CharArray, chain: Array&lt;out Certificate&gt;)</ID>
    <ID>MaxLineLength:KeyStoreUtilities.kt$ fun KeyStore.getSupportedKey(alias: String, keyPassword: String): PrivateKey</ID>
    <ID>MaxLineLength:KeyStoreUtilities.kt$ fun KeyStore.save(keyStoreFilePath: Path, storePassword: String)</ID>
    <ID>MaxLineLength:KeyStoreUtilities.kt$return certificate as? X509Certificate ?: throw IllegalStateException("Certificate under alias \"$alias\" is not an X.509 certificate: $certificate")</ID>
    <ID>MaxLineLength:KotlinIntegrationTestingTutorial.kt$KotlinIntegrationTestingTutorial$bobProxy.startFlow(::CashPaymentFlow, 1000.DOLLARS, alice.nodeInfo.singleIdentity()).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:KotlinUtilsTest.kt$KotlinUtilsTest$original.checkpointSerialize(context = KRYO_CHECKPOINT_CONTEXT).checkpointDeserialize(context = KRYO_CHECKPOINT_NOWHITELIST_CONTEXT)</ID>
    <ID>MaxLineLength:KotlinUtilsTest.kt$KotlinUtilsTest$val copy = original.checkpointSerialize(context = KRYO_CHECKPOINT_CONTEXT).checkpointDeserialize(context = KRYO_CHECKPOINT_CONTEXT)</ID>
    <ID>MaxLineLength:Kryo.kt$ContractUpgradeFilteredTransactionSerializer$override</ID>
    <ID>MaxLineLength:Kryo.kt$ContractUpgradeFilteredTransactionSerializer$val visibleComponents: Map&lt;Int, ContractUpgradeFilteredTransaction.FilteredComponent&gt; = uncheckedCast(kryo.readClassAndObject(input))</ID>
    <ID>MaxLineLength:Kryo.kt$ContractUpgradeWireTransactionSerializer$override</ID>
    <ID>MaxLineLength:Kryo.kt$ImmutableClassSerializer$throw KryoException("Hashcode mismatch for parameter types for ${klass.qualifiedName}: unsupported type evolution has happened.")</ID>
    <ID>MaxLineLength:Kryo.kt$PublicKeySerializer${ // TODO: Instead of encoding to the default X509 format, we could have a custom per key type (space-efficient) serialiser. output.writeBytesWithLength(obj.encoded) }</ID>
    <ID>MaxLineLength:Kryo.kt$ThrowableSerializer$private val delegate: Serializer&lt;Throwable&gt; = uncheckedCast(ReflectionSerializerFactory.makeSerializer(kryo, FieldSerializer::class.java, type))</ID>
    <ID>MaxLineLength:Kryo.kt$X509CertificateSerializer$return CertificateFactory.getInstance("X.509").generateCertificate(input.readBytesWithLength().inputStream()) as X509Certificate</ID>
    <ID>MaxLineLength:Kryo.kt$fun Kryo.serializationContext(): SerializeAsTokenContext?</ID>
    <ID>MaxLineLength:Kryo.kt$if (elemCount &lt; minLen) throw KryoException("Cannot deserialize list, too little elements. Minimum required: $minLen, got: $elemCount")</ID>
    <ID>MaxLineLength:KryoCheckpointSerializer.kt$AutoCloseableSerialisationDetector$override fun read(kryo: Kryo, input: Input, type: Class&lt;AutoCloseable&gt;)</ID>
    <ID>MaxLineLength:KryoCheckpointSerializer.kt$AutoCloseableSerialisationDetector$val message = "${closeable.javaClass.name}, which is a closeable resource, has been detected during flow checkpointing. " + "Restoring such resources across node restarts is not supported. Make sure code accessing it is " + "confined to a private method or the reference is nulled out."</ID>
    <ID>MaxLineLength:KryoCheckpointSerializer.kt$KryoCheckpointSerializer$context.encodingWhitelist.acceptEncoding(encoding) || throw KryoException(encodingNotPermittedFormat.format(encoding))</ID>
    <ID>MaxLineLength:KryoCheckpointSerializer.kt$KryoCheckpointSerializer$val serializer = Fiber.getFiberSerializer(false) as KryoSerializer val classResolver = CordaClassResolver(context).apply { setKryo(serializer.kryo) } // TODO The ClassResolver can only be set in the Kryo constructor and Quasar doesn't provide us with a way of doing that val field = Kryo::class.java.getDeclaredField("classResolver").apply { isAccessible = true } serializer.kryo.apply { field.set(this, classResolver) // don't allow overriding the public key serializer for checkpointing DefaultKryoCustomizer.customize(this) addDefaultSerializer(AutoCloseable::class.java, AutoCloseableSerialisationDetector) register(ClosureSerializer.Closure::class.java, CordaClosureSerializer) classLoader = it.second }</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$@Test fun `serialised form is stable when the same object instance occurs more than once, and using java serialisation`()</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$assertThat(deserialisedList.checkpointSerialize(noReferencesContext)).isEqualTo(originalList.checkpointSerialize(noReferencesContext))</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$assertThat(listWithSameInstances.checkpointSerialize(noReferencesContext)).isEqualTo(listWithCopies.checkpointSerialize(noReferencesContext))</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$val deserialisedList = originalList.checkpointSerialize(noReferencesContext).checkpointDeserialize(noReferencesContext)</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$val deserialisedMap: Map&lt;Int, Int&gt; = emptyMap&lt;Int, Int&gt;().checkpointSerialize(context).checkpointDeserialize(context)</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$val meta = SignableData(testBytes.sha256(), SignatureMetadata(1, Crypto.findSignatureScheme(ALICE_PUBKEY).schemeNumberID))</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$val readRubbishStream: InputStream = rubbish.inputStream().checkpointSerialize(context).checkpointDeserialize(context)</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$val streams = byteArrays.map { it.inputStream() }.checkpointSerialize(context).checkpointDeserialize(context).iterator()</ID>
    <ID>MaxLineLength:LargeTransactionsTest.kt$LargeTransactionsTest$networkParameters = testNetworkParameters(maxMessageSize = 15.MB.toInt(), maxTransactionSize = 13.MB.toInt())</ID>
    <ID>MaxLineLength:LargeTransactionsTest.kt$LargeTransactionsTest$val (alice, _) = listOf(ALICE_NAME, BOB_NAME).map { startNode(providedName = it, rpcUsers = listOf(rpcUser)) }.transpose().getOrThrow()</ID>
    <ID>MaxLineLength:LazyPool.kt$LazyPool&lt;A&gt;</ID>
    <ID>MaxLineLength:LazyStickyPool.kt$LazyStickyPool&lt;A : Any&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction : FullTransaction</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ @Throws(TransactionVerificationException::class) fun verify()</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : CommandData&gt; commandsOfType(clazz: Class&lt;T&gt;): List&lt;Command&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : CommandData&gt; filterCommands(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;Command&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : CommandData&gt; findCommand(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): Command&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : CommandData&gt; getCommand(index: Int): Command&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; filterInRefs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; filterInputs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; filterReferenceInputRefs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; filterReferenceInputs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; inputsOfType(clazz: Class&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; referenceInputsOfType(clazz: Class&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$"Use WireTransaction.toLedgerTransaction instead. The result of the verify method would not be accurate."</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt, networkParameters: NetworkParameters )</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$/** Random data used to make the transaction hash unpredictable even if the contents can be predicted; needed to avoid some obscure attacks. */ val privacySalt: PrivacySalt</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$/** The notary that the tx uses, this must be the same as the notary of all the inputs, or null if there are no inputs. */ override val notary: Party?</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$// Create a copy of the outer LedgerTransaction which deserializes all fields inside the [transactionClassLoader]. // Only the copy will be used for verification, and the outer shell will be discarded. // This artifice is required to preserve backwards compatibility. Verifier(createLtxForVerification(), transactionClassLoader)</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$inline</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$inline fun &lt;reified T : ContractState&gt; referenceInputRefsOfType(): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$logger</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$return inputs.mapNotNull { if (clazz.isInstance(it.state.data)) uncheckedCast&lt;StateAndRef&lt;ContractState&gt;, StateAndRef&lt;T&gt;&gt;(it) else null }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$return references.mapNotNull { if (clazz.isInstance(it.state.data)) uncheckedCast&lt;StateAndRef&lt;ContractState&gt;, StateAndRef&lt;T&gt;&gt;(it) else null }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$throw UnsupportedOperationException("Cannot verify a LedgerTransaction created using deprecated constructors outside of flow context.")</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$val deserializedOutputs = deserialiseComponentGroup(componentGroups, TransactionState::class, ComponentGroupEnum.OUTPUTS_GROUP, forceDeserialize = true)</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction${ // Switch thread local deserialization context to using a cached attachments classloader. This classloader enforces various rules // like no-overlap, package namespace ownership and (in future) deterministic Java. return AttachmentsClassLoaderBuilder.withAttachmentsClassloaderContext( this.attachments + extraAttachments, getParamsWithGoo(), id, isAttachmentTrusted = isAttachmentTrusted) { transactionClassLoader -&gt; // Create a copy of the outer LedgerTransaction which deserializes all fields inside the [transactionClassLoader]. // Only the copy will be used for verification, and the outer shell will be discarded. // This artifice is required to preserve backwards compatibility. Verifier(createLtxForVerification(), transactionClassLoader) } }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction${ // This path is triggered if someone used old constructors that were accidentally exposed; darn Kotlin's lack of package-private // visibility! We did originally try to maintain verification codepaths that supported lack of network parameters, but, it // got too convoluted and people kept just !! asserting the nullity away because on normal codepaths this is always set. logger.warn("Network parameters on the LedgerTransaction with id: $id are null. Please don't use deprecated constructors of the LedgerTransaction. " + "Use WireTransaction.toLedgerTransaction instead. The result of the verify method would not be accurate.") // Roll the dice - we're probably in flow context if we got here at all, which means we can fish the current params out. try { params = getParamsFromFlowLogic() } catch (e: UnsupportedOperationException) { // Inside DJVM, ignore. } if (params == null) throw UnsupportedOperationException("Cannot verify a LedgerTransaction created using deprecated constructors outside of flow context.") }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction.Companion$return LedgerTransaction(inputs, outputs, commands, attachments, id, notary, timeWindow, privacySalt, networkParameters, references).apply { this.componentGroups = componentGroups this.serializedInputs = serializedInputs this.serializedReferences = serializedReferences this.isAttachmentTrusted = isAttachmentTrusted }</ID>
    <ID>MaxLineLength:LedgerTransactionQueryTests.kt$LedgerTransactionQueryTests$return StateAndRef(TransactionState(dummyState, DummyContract.PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), dummyStateRef)</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator$ fun validateNameAttribute(normalizedNameAttribute: String, validation: Validation)</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator$ fun validateOrganization(normalizedOrganization: String, validation: Validation)</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator$@Deprecated("Use validateOrganization instead", replaceWith = ReplaceWith("validateOrganization(normalizedLegalName)"))</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator.Rule.CapitalLetterRule$require(legalName == capitalizedLegalName) { "Legal name should be capitalized. i.e. '$capitalizedLegalName'" }</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator.Rule.MustHaveAtLeastTwoLettersRule$require(legalName.count { it.isLetter() } &gt;= 2) { "Illegal input legal name '$legalName'. Legal name must have at least two letters" }</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator.Rule.UnicodeNormalizationRule$require(legalName == normalize(legalName)) { "Legal name must be normalized. Please use 'normalize' to normalize the legal name before validation." }</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator.Rule.UnicodeRangeRule$val illegalChars = legalName.toCharArray().filter { Character.UnicodeBlock.of(it) !in supportScriptsSet }.size</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$LegalNameValidator.validateNameAttribute("The quick brown fox jumped over the lazy dog.1234567890", LegalNameValidator.Validation.FULL)</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$LegalNameValidator.validateOrganization("Legal Name With\n\rLine\nBreaks", LegalNameValidator.Validation.FULL)</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$LegalNameValidator.validateOrganization("Legal Name\u2004With\u0009Unicode\u0020Whitespaces", LegalNameValidator.Validation.FULL)</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$LegalNameValidator.validateOrganization("The quick brown fox jumped over the lazy dog.1234567890", LegalNameValidator.Validation.FULL)</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$LegalNameValidator.validateOrganization(LegalNameValidator.normalize("Test Legal Name"), LegalNameValidator.Validation.FULL)</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$LegalNameValidator.validateOrganization(longLegalName.append("A").toString(), LegalNameValidator.Validation.FULL)</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$assertEquals("Legal Name With Unicode Whitespaces", LegalNameValidator.normalize("Legal Name\u2004With\u0009Unicode\u0020Whitespaces"))</ID>
    <ID>MaxLineLength:ListsSerializationTest.kt$ListsSerializationTest$Assertions.assertThatThrownBy { wrongPayloadType.serialize() } .isInstanceOf(NotSerializableException::class.java)</ID>
    <ID>MaxLineLength:ListsSerializationTest.kt$ListsSerializationTest.Companion$val envelope = DeserializationInput(SerializerFactoryBuilder.build(context.whitelist, context.deserializationClassLoader)).getEnvelope(serBytes, context)</ID>
    <ID>MaxLineLength:Literal.kt$ContractBuilder$fun rollOut(startDate: LocalDate, endDate: LocalDate, frequency: Frequency, init: RollOutBuilder&lt;Dummy&gt;.() -&gt; Unit): RollOut</ID>
    <ID>MaxLineLength:Literal.kt$RollOutBuilder&lt;T&gt; : ContractBuilder</ID>
    <ID>MaxLineLength:LoadTest.kt$LoadTest&lt;T, S&gt;</ID>
    <ID>MaxLineLength:LoadTest.kt$RemoteNode(hostname, it.remoteSystemdServiceName, it.sshUser, it.rpcUser, it.rpcPort, it.remoteNodeDirectory)</ID>
    <ID>MaxLineLength:LoadTest.kt$it.legalIdentitiesAndCerts.fold("") { acc, elem -&gt; acc + "\n" + elem.name + ": " + elem.owningKey.toBase58String() }</ID>
    <ID>MaxLineLength:LoadTest.kt$simpleNodes = hostNodeMap.values.filter { it.info.legalIdentitiesAndCerts.size == 1 }</ID>
    <ID>MaxLineLength:LocalDateSerializer.kt$LocalDateSerializer : Proxy</ID>
    <ID>MaxLineLength:LocalDateSerializer.kt$LocalDateSerializer$override fun fromProxy(proxy: LocalDateProxy): LocalDate</ID>
    <ID>MaxLineLength:LocalDateSerializer.kt$LocalDateSerializer$override fun toProxy(obj: LocalDate): LocalDateProxy</ID>
    <ID>MaxLineLength:LocalDateTimeSerializer.kt$LocalDateTimeSerializer : Proxy</ID>
    <ID>MaxLineLength:LocalDateTimeSerializer.kt$LocalDateTimeSerializer$override fun toProxy(obj: LocalDateTime): LocalDateTimeProxy</ID>
    <ID>MaxLineLength:LocalDateTimeSerializer.kt$LocalDateTimeSerializer$override val additionalSerializers: Iterable&lt;CustomSerializer&lt;out Any&gt;&gt; = listOf(LocalDateSerializer(factory), LocalTimeSerializer(factory))</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation$ConstructorPairedProperty : LocalPropertyInformation</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation$GetterSetterProperty : LocalPropertyInformation</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation$PrivateConstructorPairedProperty : LocalPropertyInformation</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation$ReadOnlyProperty : LocalPropertyInformation</ID>
    <ID>MaxLineLength:LocalSerializationRule.kt$LocalSerializationRule.AMQPSerializationScheme$( cordappCustomSerializers: Set&lt;SerializationCustomSerializer&lt;*, *&gt;&gt;, cordappSerializationWhitelists: Set&lt;SerializationWhitelist&gt;, serializerFactoriesForContexts: AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt; )</ID>
    <ID>MaxLineLength:LocalSerializationRule.kt$LocalSerializationRule.AMQPSerializationScheme$override</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory : LocalSerializerFactory</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$clazz.isSynthetic</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$is LocalTypeInformation.ACollection</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$is LocalTypeInformation.AMap</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$private</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$private val serializersByActualAndDeclaredType: MutableMap&lt;ActualAndDeclaredType, AMQPSerializer&lt;Any&gt;&gt; = DefaultCacheProvider.createCache()</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$private val serializersByTypeId: MutableMap&lt;TypeIdentifier, AMQPSerializer&lt;Any&gt;&gt; = DefaultCacheProvider.createCache()</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$val declaredGenericType = if (declaredType !is ParameterizedType &amp;&amp; localTypeInformation.typeIdentifier is Parameterised) { localTypeInformation.typeIdentifier.getLocalType(classLoaderFor(declaredClass)) } else { declaredType }</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$LocalSerializerFactory</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$LocalSerializerFactory$ fun getTypeInformation(typeName: String): LocalTypeInformation?</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$LocalSerializerFactory$/** * The [ClassWhitelist] used by this factory. Classes must be whitelisted for serialization, because they are expected * to be written in a secure manner. */ val whitelist: ClassWhitelist</ID>
    <ID>MaxLineLength:LocalTimeSerializer.kt$LocalTimeSerializer : Proxy</ID>
    <ID>MaxLineLength:LocalTimeSerializer.kt$LocalTimeSerializer$override fun fromProxy(proxy: LocalTimeProxy): LocalTime</ID>
    <ID>MaxLineLength:LocalTimeSerializer.kt$LocalTimeSerializer$override fun toProxy(obj: LocalTime): LocalTimeProxy</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation$ fun prettyPrint(simplifyClassNames: Boolean = true): String</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation$Abstract : LocalTypeInformation</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation$AnArray : LocalTypeInformation</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation$AnInterface : LocalTypeInformation</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.AMap$fun withParameters(keyType: LocalTypeInformation, valueType: LocalTypeInformation): AMap</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.AMap$val reparameterizedType = typeIdentifier.copy(parameters = listOf(keyType.typeIdentifier, valueType.typeIdentifier))</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.AMap$val unerasedType = typeIdentifier.toParameterized(listOf(keyType.typeIdentifier, valueType.typeIdentifier))</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.Atomic$data</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.Companion$ fun forType(type: Type, typeIdentifier: TypeIdentifier, lookup: LocalTypeLookup): LocalTypeInformation</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.Companion$throw IllegalStateException("Should not be attempting to build new type information when populating a cycle")</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformationPrettyPrinter$private</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$ private fun buildNonAtomic( rawType: Class&lt;*&gt;, type: Type, typeIdentifier: TypeIdentifier, typeParameterInformation: List&lt;LocalTypeInformation&gt; ): LocalTypeInformation</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$ private inline fun &lt;T&gt; suppressValidation(block: LocalTypeInformationBuilder.() -&gt; T): T</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$!EnumSet::class.java.isAssignableFrom(type)</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$Map::class.java.isAssignableFrom(type) -&gt; LocalTypeInformation.AMap(type, typeIdentifier, LocalTypeInformation.Unknown, LocalTypeInformation.Unknown)</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$constructorInformation.parameters[index].isMandatory &amp;&amp; index !in indicesAddressedByProperties -&gt; parameter</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$is TypeIdentifier.Parameterised -&gt; buildForParameterised(rawType, type as ParameterizedType, typeIdentifier, isOpaque)</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$it.name ?: throw IllegalStateException("Unnamed parameter in constructor $observedConstructor")</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$name to LocalPropertyInformation.ReadOnlyProperty(descriptor.getter, paramTypeInformation, isMandatory)</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$reason = "Mandatory constructor parameters $missingParameters are missing from the readable properties ${properties.keys}"</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$remedy = "Either annotate a constructor for this type with @ConstructorForDeserialization, or provide a custom serializer for it"</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$remedy = "Either ensure that the properties ${nonComposableProperties.keys} are serializable, or provide a custom serializer for this type"</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$remedy = "Either provide getters or readable fields for $missingParameters, or provide a custom serializer for this type"</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$return LocalTypeInformation.Composable(type, typeIdentifier, constructorInformation, evolutionConstructors, properties, superclassInformation, interfaceInformation, typeParameterInformation)</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$suppressValidation { buildNonAtomic(rawType, type, typeIdentifier, buildTypeParameterInformation(type)) }</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$throw NotSerializableException("Type '${type.typeName} has synthetic fields and is likely a nested inner class.")</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$val constants = type.enumConstants.asSequence().mapIndexed { index, constant -&gt; constant.toString() to index }.toMap()</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$val constructorParameterIndices = constructorInformation.parameters.asSequence().mapIndexed { index, parameter -&gt; parameter.name to index }.toMap()</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$val missingParameters = missingMandatoryConstructorProperties(constructorInformation, properties).map { it.name }</ID>
    <ID>MaxLineLength:LocalTypeModel.kt$ConfigurableLocalTypeModel : LocalTypeModel</ID>
    <ID>MaxLineLength:LocalTypeModel.kt$ConfigurableLocalTypeModel.BuilderLookup$override</ID>
    <ID>MaxLineLength:LocalTypeModel.kt$LocalTypeLookup</ID>
    <ID>MaxLineLength:LocalTypeModel.kt$LocalTypeLookup$ fun findOrBuild(type: Type, typeIdentifier: TypeIdentifier, builder: (Boolean) -&gt; LocalTypeInformation): LocalTypeInformation</ID>
    <ID>MaxLineLength:LocalTypeModel.kt$LocalTypeModel$ fun inspect(type: Type): LocalTypeInformation</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ Concrete(a: Integer[], b: double, c: List&lt;Integer[]&gt;, d: int): Abstract&lt;Integer&gt;, Super&lt;Integer[]&gt;, SuperSuper&lt;Integer[], Double&gt;</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ StringCollectionHolder(list: List&lt;String&gt;, map: Map&lt;String, String&gt;, array: List&lt;String&gt;[]): StringKeyedCollectionHolder&lt;String&gt;, CollectionHolder&lt;String, String&gt;</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ StringKeyedCollectionHolder&lt;Integer&gt;(list: List&lt;Integer&gt;, map: Map&lt;String, Integer&gt;, array: List&lt;Integer&gt;[]): CollectionHolder&lt;String, Integer&gt;</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ c [</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ collectionHolder (optional): StringKeyedCollectionHolder&lt;Integer&gt;(list: List&lt;Integer&gt;, map: Map&lt;String, Integer&gt;, array: List&lt;Integer&gt;[]): CollectionHolder&lt;String, Integer&gt;</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ d [</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ g [</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$"Either annotate a constructor for this type with @ConstructorForDeserialization, or provide a custom serializer for it"</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$"Either ensure that the properties [b, c, d] are serializable, or provide a custom serializer for this type"</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$AliasingOldStylePojoImpl : OldStylePojo</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$StringCollectionHolder : StringKeyedCollectionHolder</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$private val customSerializerRegistry: CustomSerializerRegistry = CachingCustomSerializerRegistry(descriptorBasedSerializerRegistry)</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$private val model = ConfigurableLocalTypeModel(WhitelistBasedTypeModelConfiguration(AllWhitelist, customSerializerRegistry))</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$private val modelWithoutOpacity = ConfigurableLocalTypeModel(WhitelistBasedTypeModelConfiguration(AllWhitelist, emptyCustomSerializerRegistry))</ID>
    <ID>MaxLineLength:LocalVolume.kt$LocalVolume$networkParamsFile.outputStream() .use { networkParameters.signWithCert(Volume.keyPair.private, Volume.networkMapCert).serialize().writeTo(it) }</ID>
    <ID>MaxLineLength:LoginView.kt$LoginView$nodeModel = login(hostTextField.text, portProperty.value, usernameTextField.text, passwordTextField.text)</ID>
    <ID>MaxLineLength:LoginView.kt$LoginView$val button = Alert(Alert.AlertType.CONFIRMATION, "Are you sure you want to exit Corda Explorer?").apply { initOwner(root.scene.window) }.showAndWait().get()</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$attacker.start(ActiveMQDefaultConfiguration.getDefaultClusterUser(), ActiveMQDefaultConfiguration.getDefaultClusterPassword())</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$setPrivateKey(X509Utilities.CORDA_CLIENT_CA, clientKeyPair.private, listOf(clientCACert, DEV_INTERMEDIATE_CA.certificate, DEV_ROOT_CA.certificate), signingCertStore.entryPassword)</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$setPrivateKey(X509Utilities.CORDA_CLIENT_TLS, tlsKeyPair.private, listOf(clientTLSCert, clientCACert, DEV_INTERMEDIATE_CA.certificate, DEV_ROOT_CA.certificate), p2pSslConfig.keyStore.entryPassword)</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$val clientCACert = X509Utilities.createCertificate(CertificateType.INTERMEDIATE_CA, DEV_INTERMEDIATE_CA.certificate, DEV_INTERMEDIATE_CA.keyPair, legalName.x500Principal, clientKeyPair.public, nameConstraints = nameConstraints)</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$val clientTLSCert = X509Utilities.createCertificate(CertificateType.TLS, clientCACert, clientKeyPair, CordaX500Name("MiniCorp", "London", "GB").x500Principal, tlsKeyPair.public)</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$val nameConstraints = NameConstraints(arrayOf(GeneralSubtree(GeneralName(GeneralName.directoryName, legalName.toX500Name()))), arrayOf())</ID>
    <ID>MaxLineLength:Main.kt$ fun main(args: Array&lt;String&gt;)</ID>
    <ID>MaxLineLength:Main.kt$Main$// TODO : This could block the UI thread when number of views increase, maybe we can make this async and display a loading screen. // Stock Views. registerView&lt;Dashboard&gt;() registerView&lt;TransactionViewer&gt;() // CordApps Views. registerView&lt;CashViewer&gt;() // Tools. registerView&lt;Network&gt;() registerView&lt;Settings&gt;() // Default view to Dashboard. selectedView.set(find&lt;Dashboard&gt;())</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$( private val bootstrapper: NetworkBootstrapperWithOverridableParameters = NetworkBootstrapper() )</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--copy-cordapps"], description = ["Whether or not to copy the CorDapp JARs into the nodes' 'cordapps' directory. \${COMPLETION-CANDIDATES}"])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--event-horizon"], description = ["The event horizon to use in the network-parameters. Default is 30 days."])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--max-message-size"], description = ["The maximum message size to use in the network-parameters, in bytes. Current default is $DEFAULT_MAX_MESSAGE_SIZE."])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--max-transaction-size"], description = ["The maximum transaction size to use in the network-parameters, in bytes. Current default is $DEFAULT_MAX_TRANSACTION_SIZE."])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--minimum-platform-version"], description = ["The minimum platform version to use in the network-parameters. Current default is $PLATFORM_VERSION."])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--network-parameter-overrides", "-n"], description = ["Overrides the default network parameters with those in the given file."])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--no-copy"], hidden = true, description = ["""DEPRECATED. Don't copy the CorDapp JARs into the nodes' "cordapps" directories."""])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$description</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$if (networkParametersFile?.exists() != true) throw FileNotFoundException("Unable to find specified network parameters config file at $networkParametersFile")</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$overrides += minimumPlatformVersion?.let { mapOf("minimumPlatformVersion" to minimumPlatformVersion!!) } ?: mutableMapOf()</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$printError("Error${errors.pluralise()} found parsing the network parameter overrides file at $networkParametersFile:")</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$printWarning("The --no-copy parameter has been deprecated and been replaced with the --copy-cordapps parameter.")</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$require(eventHorizon == null || eventHorizon?.isNegative == false) { "The --event-horizon parameter must be a positive value" }</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$require(maxMessageSize == null || maxMessageSize ?: 0 &gt; 0) { "The --max-message-size parameter must be at least 1" }</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$require(maxTransactionSize == null || maxTransactionSize ?: 0 &gt; 0) { "The --max-transaction-size parameter must be at least 1" }</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$require(minimumPlatformVersion == null || minimumPlatformVersion ?: 0 &gt; 0) { "The --minimum-platform-version parameter must be at least 1" }</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$val networkParameterOverrides = getNetworkParametersOverrides().doOnErrors(::reportErrors).optional ?: return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:Main.kt$Node$if (transactions.size == 1) listOf(genesisTx) else transactions.values.reversed().take(10).filter { !isAccepted(it) &amp;&amp; conflicts[it.data]!!.size == 1 }.shuffled(network.rng).take(3)</ID>
    <ID>MaxLineLength:Main.kt$Transaction$return "T(id=${id.toString().take(5)}, data=$data, parents=[${parents.map {it.toString().take(5) }}, chit=$chit, confidence=$confidence)"</ID>
    <ID>MaxLineLength:Main.kt$nodeFilter = isNotary</ID>
    <ID>MaxLineLength:Main.kt$require(acceptance.filter { it }.size &lt; 2) { "More than one transaction of the conflict set of $v got accepted." }</ID>
    <ID>MaxLineLength:Main.kt$val defaultConfig = ConfigFactory.parseResources("loadtest-reference.conf", ConfigParseOptions.defaults().setAllowMissing(false))</ID>
    <ID>MaxLineLength:MainView.kt$MainView$contentDisplayProperty().bind(smallIconProperty.map { if (it) ContentDisplay.TOP else ContentDisplay.LEFT })</ID>
    <ID>MaxLineLength:MainView.kt$MainView$if (selected == it) listOf(menuItemCSS, menuItemSelectedCSS).observable() else listOf(menuItemCSS).observable()</ID>
    <ID>MaxLineLength:MainView.kt$MainView$textAlignmentProperty().bind(smallIconProperty.map { if (it) TextAlignment.CENTER else TextAlignment.LEFT })</ID>
    <ID>MaxLineLength:MapSerializer.kt$MapSerializer : AMQPSerializer</ID>
    <ID>MaxLineLength:MapSerializer.kt$MapSerializer$private val typeNotation: TypeNotation = RestrictedType(AMQPTypeIdentifiers.nameForType(declaredType), null, emptyList(), "map", Descriptor(typeDescriptor), emptyList())</ID>
    <ID>MaxLineLength:MapSerializer.kt$MapSerializer.Companion$fun resolveActual(actualClass: Class&lt;*&gt;, declaredTypeInformation: LocalTypeInformation.AMap): LocalTypeInformation.AMap</ID>
    <ID>MaxLineLength:MapSerializer.kt$MapSerializer.Companion$private</ID>
    <ID>MaxLineLength:MapValuesList.kt$MapValuesList.Companion$val backingList = FXCollections.observableArrayList&lt;Map.Entry&lt;K, A&gt;&gt;(sourceMap.entries.sortedBy { it.key!!.hashCode() })</ID>
    <ID>MaxLineLength:MappedList.kt$MappedList&lt;A, B&gt; : TransformationList</ID>
    <ID>MaxLineLength:MappedSchemasCrossReferenceDetectionTests.kt$MappedSchemasCrossReferenceDetectionTests$BadSchema : MappedSchema</ID>
    <ID>MaxLineLength:MappedSchemasCrossReferenceDetectionTests.kt$MappedSchemasCrossReferenceDetectionTests$GoodSchema : MappedSchema</ID>
    <ID>MaxLineLength:MappedSchemasCrossReferenceDetectionTests.kt$MappedSchemasCrossReferenceDetectionTests$PoliteSchema : MappedSchema</ID>
    <ID>MaxLineLength:MappedSchemasCrossReferenceDetectionTests.kt$MappedSchemasCrossReferenceDetectionTests$TrickySchema : MappedSchema</ID>
    <ID>MaxLineLength:MappedSchemasCrossReferenceDetectionTests.kt$MappedSchemasCrossReferenceDetectionTests.TrickySchema.State$( @Column var id: String, // the field is a cross-reference to other MappedSchema however the field is not persistent (no JPA annotation) var other: GoodSchema.State )</ID>
    <ID>MaxLineLength:MapsSerializationTest.kt$MapsSerializationTest$"Map type class java.util.HashMap is unstable under iteration. Suggested fix: use java.util.LinkedHashMap instead."</ID>
    <ID>MaxLineLength:MapsSerializationTest.kt$MapsSerializationTest$@Test fun `check EmptyMap serialization`()</ID>
    <ID>MaxLineLength:MaxTransactionSizeTests.kt$MaxTransactionSizeTests$assertThatThrownBy { future.getOrThrow() }.hasMessageContaining("Transaction exceeded network's maximum transaction size limit")</ID>
    <ID>MaxLineLength:MaxTransactionSizeTests.kt$MaxTransactionSizeTests${ // These 4 attachments yield a transaction that's got ~ 4mb, which will exceed the 3mb max transaction size limit val bigFile1 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 0, "a") val bigFile2 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 1, "b") val bigFile3 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 2, "c") val bigFile4 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 3, "c") val flow = aliceNode.transaction { val hash1 = aliceNode.importAttachment(bigFile1.inputStream) val hash2 = aliceNode.importAttachment(bigFile2.inputStream) val hash3 = aliceNode.importAttachment(bigFile3.inputStream) val hash4 = aliceNode.importAttachment(bigFile4.inputStream) assertEquals(hash1, bigFile1.sha256) SendLargeTransactionFlow(notary, bob, hash1, hash2, hash3, hash4, verify = false) } val future = aliceNode.startFlow(flow) mockNet.runNetwork() assertThatThrownBy { future.getOrThrow() }.hasMessageContaining("Transaction exceeded network's maximum transaction size limit") }</ID>
    <ID>MaxLineLength:MaxTransactionSizeTests.kt$MaxTransactionSizeTests${ // These 4 attachments yield a transaction that's got ~ 4mb, which will exceed the 3mb max transaction size limit val bigFile1 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 0, "a") val bigFile2 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 1, "b") val bigFile3 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 2, "c") val bigFile4 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 3, "d") val flow = aliceNode.transaction { val hash1 = aliceNode.importAttachment(bigFile1.inputStream) val hash2 = aliceNode.importAttachment(bigFile2.inputStream) val hash3 = aliceNode.importAttachment(bigFile3.inputStream) val hash4 = aliceNode.importAttachment(bigFile4.inputStream) assertEquals(hash1, bigFile1.sha256) SendLargeTransactionFlow(notary, bob, hash1, hash2, hash3, hash4) } val exception = assertFailsWith&lt;IllegalArgumentException&gt; { val future = aliceNode.startFlow(flow) mockNet.runNetwork() future.getOrThrow() } assertThat(exception).hasMessageContaining("Transaction exceeded network's maximum transaction size limit") }</ID>
    <ID>MaxLineLength:Measure.kt$measure(listOf(a, b, c, d), f.reflect()!!) { f(uncheckedCast(it[0]), uncheckedCast(it[1]), uncheckedCast(it[2]), uncheckedCast(it[3])) }</ID>
    <ID>MaxLineLength:Measure.kt$private</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$ComponentVisibilityException : CordaException</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredComponentGroup : ComponentGroup</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction : TraversableTransaction</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$ @Throws(ComponentVisibilityException::class) fun checkAllComponentsVisible(componentGroupEnum: ComponentGroupEnum)</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$ @Throws(ComponentVisibilityException::class) fun checkCommandVisibility(publicKey: PublicKey)</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$ fun checkWithFun(checkingFun: (Any) -&gt; Boolean): Boolean</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$"Did not receive components for group ${componentGroupEnum.ordinal} and cannot verify they didn't exist in the original wire transaction"</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$"Partial Merkle tree root and advertised full Merkle tree root for component group $groupIndex do not match"</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$val groupFullRoot = MerkleTree.getMerkleTree(group.components.mapIndexed { index, component -&gt; componentHash(group.nonces[index], component) }).hash</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$verificationCheck</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$verificationCheck(groupIndex &lt; groupHashes.size) { "There is no matching component group hash for group $groupIndex" }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$visibilityCheck</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$visibilityCheck(group.groupIndex &lt; groupHashes.size) { "There is no matching component group hash for group ${group.groupIndex}" }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$visibilityCheck(groupPartialRoot == groupFullRoot) { "Some components for group ${group.groupIndex} are not visible" }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentGroups.add(FilteredComponentGroup(groupIndex, value, filteredComponentNonces[groupIndex]!!, createPartialMerkleTree(groupIndex)))</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentHashes[componentGroupIndex] = mutableListOf(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex])</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentHashes[componentGroupIndex]!!.add(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex])</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentHashes[signersGroupIndex] = wtx.availableComponentHashes[signersGroupIndex]!!.toMutableList()</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentNonces[componentGroupIndex] = mutableListOf(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex])</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentNonces[componentGroupIndex]!!.add(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex])</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentNonces[signersGroupIndex] = wtx.availableComponentNonces[signersGroupIndex]!!.toMutableList()</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$val filteredComponentHashes: MutableMap&lt;Int, MutableList&lt;SecureHash&gt;&gt; = hashMapOf() // Required for partial Merkle tree generation.</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$val serialisedComponent = wtx.componentGroups.first { it.groupIndex == componentGroupIndex }.components[internalIndex]</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$wtx.attachments.forEachIndexed { internalIndex, it -&gt; filter(it, ATTACHMENTS_GROUP.ordinal, internalIndex) }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$wtx.componentGroups .filter { it.groupIndex &gt;= values().size } .forEach { componentGroup -&gt; componentGroup.components.forEachIndexed { internalIndex, component -&gt; filter(component, componentGroup.groupIndex, internalIndex) } }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$wtx.references.forEachIndexed { internalIndex, it -&gt; filter(ReferenceStateRef(it), REFERENCES_GROUP.ordinal, internalIndex) }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion${ group.add(serialisedComponent) // If the group[componentGroupIndex] existed, then we guarantee that // filteredComponentNonces[componentGroupIndex] and filteredComponentHashes[componentGroupIndex] are not null. filteredComponentNonces[componentGroupIndex]!!.add(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex]) filteredComponentHashes[componentGroupIndex]!!.add(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex]) }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion${ if (!filtering.test(t)) return val group = filteredSerialisedComponents[componentGroupIndex] // Because the filter passed, we know there is a match. We also use first Vs single as the init function // of WireTransaction ensures there are no duplicated groups. val serialisedComponent = wtx.componentGroups.first { it.groupIndex == componentGroupIndex }.components[internalIndex] if (group == null) { // As all of the helper Map structures, like availableComponentNonces, availableComponentHashes // and groupsMerkleRoots, are computed lazily via componentGroups.forEach, there should always be // a match on Map.get ensuring it will never return null. filteredSerialisedComponents[componentGroupIndex] = mutableListOf(serialisedComponent) filteredComponentNonces[componentGroupIndex] = mutableListOf(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex]) filteredComponentHashes[componentGroupIndex] = mutableListOf(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex]) } else { group.add(serialisedComponent) // If the group[componentGroupIndex] existed, then we guarantee that // filteredComponentNonces[componentGroupIndex] and filteredComponentHashes[componentGroupIndex] are not null. filteredComponentNonces[componentGroupIndex]!!.add(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex]) filteredComponentHashes[componentGroupIndex]!!.add(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex]) } // If at least one command is visible, then all command-signers should be visible as well. // This is required for visibility purposes, see FilteredTransaction.checkAllCommandsVisible() for more details. if (componentGroupIndex == COMMANDS_GROUP.ordinal &amp;&amp; !signersIncluded) { signersIncluded = true val signersGroupIndex = SIGNERS_GROUP.ordinal // There exist commands, thus the signers group is not empty. val signersGroupComponents = wtx.componentGroups.first { it.groupIndex == signersGroupIndex } filteredSerialisedComponents[signersGroupIndex] = signersGroupComponents.components.toMutableList() filteredComponentNonces[signersGroupIndex] = wtx.availableComponentNonces[signersGroupIndex]!!.toMutableList() filteredComponentHashes[signersGroupIndex] = wtx.availableComponentHashes[signersGroupIndex]!!.toMutableList() } }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion${ wtx.inputs.forEachIndexed { internalIndex, it -&gt; filter(it, INPUTS_GROUP.ordinal, internalIndex) } wtx.outputs.forEachIndexed { internalIndex, it -&gt; filter(it, OUTPUTS_GROUP.ordinal, internalIndex) } wtx.commands.forEachIndexed { internalIndex, it -&gt; filter(it, COMMANDS_GROUP.ordinal, internalIndex) } wtx.attachments.forEachIndexed { internalIndex, it -&gt; filter(it, ATTACHMENTS_GROUP.ordinal, internalIndex) } if (wtx.notary != null) filter(wtx.notary, NOTARY_GROUP.ordinal, 0) if (wtx.timeWindow != null) filter(wtx.timeWindow, TIMEWINDOW_GROUP.ordinal, 0) // Note that because [inputs] and [references] share the same type [StateRef], we use a wrapper for references [ReferenceStateRef], // when filtering. Thus, to filter-in all [references] based on type, one should use the wrapper type [ReferenceStateRef] and not [StateRef]. // Similar situation is for network parameters hash and attachments, one should use wrapper [NetworkParametersHash] and not [SecureHash]. wtx.references.forEachIndexed { internalIndex, it -&gt; filter(ReferenceStateRef(it), REFERENCES_GROUP.ordinal, internalIndex) } wtx.networkParametersHash?.let { filter(NetworkParametersHash(it), PARAMETERS_GROUP.ordinal, 0) } // It is highlighted that because there is no a signers property in TraversableTransaction, // one cannot specifically filter them in or out. // The above is very important to ensure someone won't filter out the signers component group if at least one // command is included in a FilteredTransaction. // It's sometimes possible that when we receive a WireTransaction for which there is a new or more unknown component groups, // we decide to filter and attach this field to a FilteredTransaction. // An example would be to redact certain contract state types, but otherwise leave a transaction alone, // including the unknown new components. wtx.componentGroups .filter { it.groupIndex &gt;= values().size } .forEach { componentGroup -&gt; componentGroup.components.forEachIndexed { internalIndex, component -&gt; filter(component, componentGroup.groupIndex, internalIndex) } } }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransactionVerificationException : CordaException</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$TraversableTransaction$override</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$TraversableTransaction$override val outputs: List&lt;TransactionState&lt;ContractState&gt;&gt; = deserialiseComponentGroup(componentGroups, TransactionState::class, OUTPUTS_GROUP)</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$TraversableTransaction$val timeWindows: List&lt;TimeWindow&gt; = deserialiseComponentGroup(componentGroups, TimeWindow::class, TIMEWINDOW_GROUP)</ID>
    <ID>MaxLineLength:MerkleTree.kt$MerkleTree$Node : MerkleTree</ID>
    <ID>MaxLineLength:MessageSizeChecksInterceptor.kt$AmqpMessageSizeChecksInterceptor : MessageSizeChecksInterceptorAmqpInterceptor</ID>
    <ID>MaxLineLength:MessageSizeChecksInterceptor.kt$ArtemisMessageSizeChecksInterceptor : MessageSizeChecksInterceptorInterceptor</ID>
    <ID>MaxLineLength:MessageSizeChecksInterceptor.kt$ArtemisMessageSizeChecksInterceptor$is MessagePacket -&gt; (packet.message.persistentSize - packet.message.headersAndPropertiesEncodeSize - 4).toInt()</ID>
    <ID>MaxLineLength:MessageSizeChecksInterceptor.kt$MessageSizeChecksInterceptor$logger</ID>
    <ID>MaxLineLength:Messaging.kt$DeduplicationHandler</ID>
    <ID>MaxLineLength:Messaging.kt$MessagingService$ fun addMessageHandler(topic: String, callback: MessageHandler): MessageHandlerRegistration</ID>
    <ID>MaxLineLength:Messaging.kt$MessagingService$/** * A unique identifier for this sender that changes whenever a node restarts. This is used in conjunction with a sequence * number for message de-duplication at the recipient. */ val ourSenderUUID: String</ID>
    <ID>MaxLineLength:Messaging.kt$MessagingService$deduplicationId: SenderDeduplicationId = SenderDeduplicationId(DeduplicationId.createRandom(newSecureRandom()), ourSenderUUID)</ID>
    <ID>MaxLineLength:Messaging.kt$ReceivedMessage : Message</ID>
    <ID>MaxLineLength:Messaging.kt$deduplicationId: SenderDeduplicationId = SenderDeduplicationId(DeduplicationId.createRandom(newSecureRandom()), ourSenderUUID)</ID>
    <ID>MaxLineLength:MessagingExecutor.kt$MessagingExecutor$putLongProperty(org.apache.activemq.artemis.api.core.Message.HDR_SCHEDULED_DELIVERY_TIME, System.currentTimeMillis() + amqDelayMillis)</ID>
    <ID>MaxLineLength:MessagingExecutor.kt$MessagingExecutor$putStringProperty(P2PMessagingHeaders.cordaVendorProperty, cordaVendor) putStringProperty(P2PMessagingHeaders.releaseVersionProperty, releaseVersion) putIntProperty(P2PMessagingHeaders.platformVersionProperty, versionInfo.platformVersion) putStringProperty(P2PMessagingHeaders.topicProperty, SimpleString(message.topic)) writeBodyBufferBytes(message.data.bytes) // Use the magic deduplication property built into Artemis as our message identity too putStringProperty(org.apache.activemq.artemis.api.core.Message.HDR_DUPLICATE_DETECTION_ID, SimpleString(message.uniqueMessageId.toString)) // If we are the sender (ie. we are not going through recovery of some sort), use sequence number short cut. if (ourSenderUUID == message.senderUUID) { putStringProperty(P2PMessagingHeaders.senderUUID, SimpleString(ourSenderUUID)) putLongProperty(P2PMessagingHeaders.senderSeqNo, ourSenderSeqNo.getAndIncrement()) } // For demo purposes - if set then add a delay to messages in order to demonstrate that the flows are doing as intended if (amqDelayMillis &gt; 0 &amp;&amp; message.topic == FlowMessagingImpl.sessionTopic) { putLongProperty(org.apache.activemq.artemis.api.core.Message.HDR_SCHEDULED_DELIVERY_TIME, System.currentTimeMillis() + amqDelayMillis) } message.additionalHeaders.forEach { key, value -&gt; putStringProperty(key, value) }</ID>
    <ID>MaxLineLength:MessagingExecutor.kt$MessagingExecutor$putStringProperty(org.apache.activemq.artemis.api.core.Message.HDR_DUPLICATE_DETECTION_ID, SimpleString(message.uniqueMessageId.toString))</ID>
    <ID>MaxLineLength:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory : BindableNamedCacheFactorySingletonSerializeAsToken</ID>
    <ID>MaxLineLength:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory$override</ID>
    <ID>MaxLineLength:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory$override fun bindWithConfig(nodeConfiguration: NodeConfiguration)</ID>
    <ID>MaxLineLength:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory$override fun bindWithMetrics(metricRegistry: MetricRegistry)</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution$deserialiseComponentGroup(tx.componentGroups, TransactionState::class, ComponentGroupEnum.OUTPUTS_GROUP, forceDeserialize = true)</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution$else -&gt; throw MigrationException("Unknown transaction type ${baseTx::class.qualifiedName} found when loading a state")</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution$is ContractUpgradeLedgerTransaction -&gt; it.value.map { stateRef -&gt; StateAndRef(baseTx.outputs[stateRef.index], stateRef) }</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution$is NotaryChangeLedgerTransaction -&gt; it.value.map { stateRef -&gt; StateAndRef(baseTx.outputs[stateRef.index], stateRef) }</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution$logger.info("Couldn't find network parameters file: ${e.message}. This is expected if the node is starting for the first time.")</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution$override</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution$private</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution${ // If there is no attachment that allows the state class to be deserialised correctly, then carpent a state class anyway. It // might still be possible to access the participants depending on how the state class was serialised. logger.debug("Could not use attachments to deserialise transaction output states for transaction ${tx.id}") tx.outputs.filterIndexed { index, _ -&gt; stateIndices.contains(index) } }</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution.&lt;no name provided&gt;${ // Note that the parameters in any file shouldn't be put into the database - this will be done by the node on startup. return if (hash == filedParams?.raw?.hash) { filedParams.raw.deserialize() } else { cordaDB.transaction { storage[hash]?.verified() } } }</ID>
    <ID>MaxLineLength:MissingAttachmentsException.kt$MissingAttachmentsException : CordaException</ID>
    <ID>MaxLineLength:MissingContractAttachments.kt$MissingContractAttachments$"${contractsClassName ?: states.map { it.contract }.distinct()}${minimumRequiredContractClassVersion?.let { ", minimum required contract class version $minimumRequiredContractClassVersion"}}. "</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$// This function only covers those possibilities currently used within tests. Each ColumnPredicate type can have multiple operators, // and not all predicate types are covered here. private fun &lt;C&gt; criteriaFilter(metadata: C, predicate: ColumnPredicate&lt;C&gt;?): Boolean</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$ContractAttachment.create(baseAttachment, contractClassNames.first(), contractClassNames.toSet(), uploader, signers, version)</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$fun getAttachmentIdAndBytes(jar: InputStream): Pair&lt;AttachmentId, ByteArray&gt;</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$val attachmentQueryCriteria = AttachmentQueryCriteria.AttachmentsQueryCriteria(contractClassNamesCondition = Builder.equal(listOf(contractClassName)), versionCondition = Builder.greaterThanOrEqual(minContractVersion), uploaderCondition = Builder.`in`(TRUSTED_UPLOADERS))</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$val attachmentSort = AttachmentSort(listOf(AttachmentSort.AttachmentSortColumn(AttachmentSort.AttachmentSortAttribute.VERSION, Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$val contractClassMetadata = ContractAttachmentMetadata(contractClassName, version, signers.isNotEmpty(), signers, uploader)</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$val version = try { Integer.parseInt(baseAttachment.openAsJAR().manifest?.mainAttributes?.getValue(Attributes.Name.IMPLEMENTATION_VERSION)) } catch ( e: Exception ) { DEFAULT_CORDAPP_VERSION }</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$versionCondition = Builder.greaterThanOrEqual(minContractVersion)</ID>
    <ID>MaxLineLength:MockContractAttachment.kt$// A valid zip file with 1 entry. val simpleZip = byteArrayOf(80, 75, 3, 4, 20, 0, 8, 8, 8, 0, 15, 113, 79, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 47, 97, -2, -54, 0, 0, 75, 4, 0, 80, 75, 7, 8, 67, -66, -73, -24, 3, 0, 0, 0, 1, 0, 0, 0, 80, 75, 1, 2, 20, 0, 20, 0, 8, 8, 8, 0, 15, 113, 79, 78, 67, -66, -73, -24, 3, 0, 0, 0, 1, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47, 97, -2, -54, 0, 0, 80, 75, 5, 6, 0, 0, 0, 0, 1, 0, 1, 0, 52, 0, 0, 0, 55, 0, 0, 0, 0, 0)</ID>
    <ID>MaxLineLength:MockCordappProvider.kt$MockCordappProvider$attachments.importContractAttachment(contractClassNames, DEPLOYED_CORDAPP_UPLOADER, data.inputStream(), contractHash, signers)</ID>
    <ID>MaxLineLength:MockCordappProvider.kt$MockCordappProvider$fakeAttachment(contractClass.replace('.', '/') + ".class", "fake class file for $contractClass", manifestAttributes)</ID>
    <ID>MaxLineLength:MockCordappProvider.kt$MockCordappProvider$if (cordappRegistry.none { it.first.contractClassNames.contains(contractClassName) &amp;&amp; it.second == contractHash }) { cordappRegistry.add(Pair( cordapp, findOrImportAttachment( listOf(contractClassName), fakeAttachmentCached(contractClassName, jarManifestAttributesWithObligatoryElement), attachments, contractHash, signers ) )) }</ID>
    <ID>MaxLineLength:MockCordappProvider.kt$MockCordappProvider$private</ID>
    <ID>MaxLineLength:MockCryptoService.kt$MockCryptoService$return ContentSignerBuilder.build(signatureScheme, privateKey, Crypto.findProvider(signatureScheme.providerName), newSecureRandom())</ID>
    <ID>MaxLineLength:MockCryptoService.kt$MockCryptoService$throw CryptoServiceException("Cannot sign using the key with alias $alias. SHA256 of data to be signed: ${data.sha256()}", e)</ID>
    <ID>MaxLineLength:MockKeyManagementService.kt$MockKeyManagementService$override fun filterMyKeys(candidateKeys: Iterable&lt;PublicKey&gt;): Iterable&lt;PublicKey&gt;</ID>
    <ID>MaxLineLength:MockKeyManagementService.kt$MockKeyManagementService$override fun getSigner(publicKey: PublicKey): ContentSigner</ID>
    <ID>MaxLineLength:MockKeyManagementService.kt$MockKeyManagementService$private val keyStore: MutableMap&lt;PublicKey, PrivateKey&gt; = initialKeys.associateByTo(HashMap(), { it.public }, { it.private })</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetwork</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetwork$ fun createPartyNode(legalName: CordaX500Name? = null): StartedMockNode</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetwork$/** In a mock network, nodes have an incrementing integer ID. Real networks do not have this. Returns the next ID that will be used. */ val nextNodeId get(): Int = internalMockNetwork.nextNodeId</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetwork$val servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = defaultParameters.servicePeerAllocationStrategy</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$( networkSendManuallyPumped: Boolean, threadPerNode: Boolean, servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy, notarySpecs: List&lt;MockNetworkNotarySpec&gt;, networkParameters: NetworkParameters )</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$constructor(cordappsForAllNodes: Collection&lt;TestCordapp&gt;) : this(threadPerNode = false, cordappsForAllNodes = cordappsForAllNodes)</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$fun withCordappsForAllNodes(cordappsForAllNodes: Collection&lt;TestCordapp&gt;): MockNetworkParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$fun withNetworkParameters(networkParameters: NetworkParameters): MockNetworkParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$fun withNetworkSendManuallyPumped(networkSendManuallyPumped: Boolean): MockNetworkParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$fun withNotarySpecs(notarySpecs: List&lt;MockNetworkNotarySpec&gt;): MockNetworkParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$return MockNetworkParameters(networkSendManuallyPumped, threadPerNode, servicePeerAllocationStrategy, notarySpecs, networkParameters, emptyList())</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$val servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = InMemoryMessagingNetwork.ServicePeerAllocationStrategy.Random()</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNodeParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNodeParameters$fun withAdditionalCordapps(additionalCordapps: Collection&lt;TestCordapp&gt;): MockNodeParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNodeParameters$fun withConfigOverrides(configOverrides: MockNodeConfigOverrides): MockNodeParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$StartedMockNode$ fun &lt;F : FlowLogic&lt;*&gt;&gt; findStateMachines(flowClass: Class&lt;F&gt;): List&lt;Pair&lt;F, CordaFuture&lt;*&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:MockNetwork.kt$StartedMockNode$ fun &lt;F : FlowLogic&lt;*&gt;&gt; registerInitiatedFlow(initiatedFlowClass: Class&lt;F&gt;): Observable&lt;F&gt;</ID>
    <ID>MaxLineLength:MockNetwork.kt$StartedMockNode$ fun &lt;T&gt; startFlow(logic: FlowLogic&lt;T&gt;): CordaFuture&lt;T&gt;</ID>
    <ID>MaxLineLength:MockNetwork.kt$UnstartedMockNode$ fun &lt;T : SerializeAsToken&gt; installCordaService(serviceClass: Class&lt;T&gt;): T</ID>
    <ID>MaxLineLength:MockNetworkIntegrationTests.kt$MockNetworkIntegrationTests$assertEquals(0, startJavaProcess&lt;MockNetworkIntegrationTests&gt;(emptyList(), extraJvmArguments = listOf("-javaagent:$quasar")).waitFor())</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$ fun start(network: InMemoryMessagingNetwork, manuallyPumped: Boolean, id: Int, notaryService: PartyAndCertificate?)</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$ private fun unPopMessages(transfers: Collection&lt;InMemoryMessagingNetwork.MessageTransfer&gt;)</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$OpaqueBytes(message.data.bytes.copyOf())</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$handler.callback(receivedMessage, handler, InMemoryDeduplicationHandler(receivedMessage, transfer))</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$private</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$return InMemoryMessage(topic, OpaqueBytes(data), deduplicationId.deduplicationId, senderUUID = deduplicationId.senderUUID)</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$val matchingHandlers = handlers.filter { it.topicSession.isBlank() || transfer.message.topic == it.topicSession }</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService${ // Got no handlers for this message yet. Keep the message around and attempt redelivery after a new // handler has been registered. The purpose of this path is to make unit tests that have multi-threading // reliable, as a sender may attempt to send a message to a receiver that hasn't finished setting // up a handler for yet. Most unit tests don't run threaded, but we want to test true parallelism at // least sometimes. log.warn("Message to ${transfer.message.topic} could not be delivered") pendingRedelivery.add(transfer) null }</ID>
    <ID>MaxLineLength:MockPublicKeyToOwningIdentityCache.kt$MockPublicKeyToOwningIdentityCache : WritablePublicKeyToOwningIdentityCache</ID>
    <ID>MaxLineLength:MockPublicKeyToOwningIdentityCache.kt$MockPublicKeyToOwningIdentityCache$private val cache: MutableMap&lt;PublicKey, KeyOwningIdentity&gt; = mutableMapOf&lt;PublicKey, KeyOwningIdentity&gt;().toSynchronised()</ID>
    <ID>MaxLineLength:MockServices.kt$ fun &lt;T : SerializeAsToken&gt; createMockCordaService(serviceHub: MockServices, serviceConstructor: (AppServiceHub) -&gt; T): T</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$ fun addMockCordapp(contractClassName: ContractClassName)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$ override fun loadContractAttachment(stateRef: StateRef)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$/** * Create a mock [ServiceHub] that can't load CorDapp code, and which uses a default service identity. */ constructor(cordappPackages: Iterable&lt;String&gt;) : this(cordappPackages, CordaX500Name("TestIdentity", "", "GB"), makeTestIdentityService())</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$/** * Create a mock [ServiceHub] which uses the package of the caller to find CorDapp code. It uses a default service * identity. */ constructor() : this(listOf(getCallerPackage(MockServices::class)!!), CordaX500Name("TestIdentity", "", "GB"), makeTestIdentityService())</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$/** * Create a mock [ServiceHub] which uses the package of the caller to find CorDapp code. It uses the provided identity service * (you can get one from [makeTestIdentityService]) and which represents the given identity. */ @JvmOverloads constructor( initialIdentityName: CordaX500Name, identityService: IdentityService = makeTestIdentityService(), key: KeyPair, vararg moreKeys: KeyPair ) : this(listOf(getCallerPackage(MockServices::class)!!), TestIdentity(initialIdentityName, key), identityService, *moreKeys)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$/** * Create a mock [ServiceHub] which uses the package of the caller to find CorDapp code. It uses the provided identity service * (you can get one from [makeTestIdentityService]) and which represents the given identity. It has no keys. */ @JvmOverloads constructor(initialIdentityName: CordaX500Name, identityService: IdentityService = makeTestIdentityService()) : this(listOf(getCallerPackage(MockServices::class)!!), TestIdentity(initialIdentityName), identityService)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$constructor(firstIdentity: TestIdentity, networkParameters: NetworkParameters, vararg moreIdentities: TestIdentity) : this( listOf(getCallerPackage(MockServices::class)!!), firstIdentity, networkParameters, *moreIdentities )</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$get() = ServicesForResolutionImpl(identityService, attachments, cordappProvider, networkParametersService, validatedTransactions)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$internal</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$override var networkParametersService: NetworkParametersService = MockNetworkParametersStorage(initialNetworkParameters)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$return NodeInfo(listOf(NetworkHostAndPort("mock.node.services", 10000)), listOf(initialIdentity.identity), 1, serial = 1L)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$return NodeVaultService(clock, keyManagementService, servicesForResolution, database, schemaService, cordappLoader.appClassLoader).apply { start() }</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$this(cordappLoader, MockTransactionStorage(), identityService, networkParameters, initialIdentity, moreKeys, keyManagementService)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$this(cordappLoaderForPackages(cordappPackages), identityService, networkParameters, initialIdentity, moreKeys)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$this(cordappLoaderForPackages(cordappPackages), identityService, networkParameters, initialIdentity, moreKeys, keyManagementService)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$this(cordappLoaderForPackages(cordappPackages), identityService, testNetworkParameters(modifiedTime = Instant.MIN), initialIdentity, moreKeys)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$this(listOf(getCallerPackage(MockServices::class)!!), TestIdentity(initialIdentityName, key), identityService, *moreKeys)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$ @JvmStatic @JvmOverloads fun makeTestDatabaseAndMockServices( cordappPackages: List&lt;String&gt;, identityService: IdentityService, initialIdentity: TestIdentity, networkParameters: NetworkParameters = testNetworkParameters(modifiedTime = Instant.MIN), vararg moreKeys: KeyPair ): Pair&lt;CordaPersistence, MockServices&gt;</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$ @JvmStatic @JvmOverloads fun makeTestDatabaseAndPersistentServices( cordappPackages: List&lt;String&gt;, initialIdentity: TestIdentity, networkParameters: NetworkParameters = testNetworkParameters(modifiedTime = Instant.MIN), moreKeys: Set&lt;KeyPair&gt;, moreIdentities: Set&lt;PartyAndCertificate&gt; ): Pair&lt;CordaPersistence, MockServices&gt;</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$makeMockMockServices(cordappLoader, identityService, networkParameters, initialIdentity, moreKeys, keyManagementService, schemaService, persistence)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$makeMockMockServices(cordappLoader, identityService, networkParameters, initialIdentity, moreKeys.toSet(), keyManagementService, schemaService, database)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$private</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$props.setProperty("dataSource.url", "jdbc:h2:mem:${nodeName}_persistence;LOCK_TIMEOUT=10000;DB_CLOSE_ON_EXIT=FALSE")</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$return JarScanningCordappLoader.fromJarUrls(cordappsForPackages(packages).map { it.jarFile.toUri().toURL() }, versionInfo)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$return object : MockServices(cordappLoader, identityService, networkParameters, initialIdentity, moreKeys.toTypedArray(), keyManagementService) { override var networkParametersService: NetworkParametersService = MockNetworkParametersStorage(networkParameters) override val vaultService: VaultService = makeVaultService(schemaService, persistence, cordappLoader) override fun recordTransactions(statesToRecord: StatesToRecord, txs: Iterable&lt;SignedTransaction&gt;) { ServiceHubInternal.recordTransactions( statesToRecord, txs as? Collection ?: txs.toList(), validatedTransactions as WritableTransactionStorage, mockStateMachineRecordedTransactionMappingStorage, vaultService as VaultServiceInternal, persistence ) } override fun jdbcSession(): Connection = persistence.createSession() override fun &lt;T : Any?&gt; withEntityManager(block: EntityManager.() -&gt; T): T { return block(contextTransaction.restrictedEntityManager) } override fun withEntityManager(block: Consumer&lt;EntityManager&gt;) { return block.accept(contextTransaction.restrictedEntityManager) } }</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$val database = configureDatabase(dataSourceProps, DatabaseConfig(), identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous, schemaService, schemaService.internalSchemas())</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$val persistence = configureDatabase(dataSourceProps, DatabaseConfig(), identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous, schemaService, schemaService.internalSchemas())</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion${ val cordappLoader = cordappLoaderForPackages(cordappPackages) val dataSourceProps = makeTestDataSourceProperties() val schemaService = NodeSchemaService(cordappLoader.cordappSchemas) val identityService = PersistentIdentityService(TestingNamedCacheFactory()) val persistence = configureDatabase(dataSourceProps, DatabaseConfig(), identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous, schemaService, schemaService.internalSchemas()) // Create a persistent identity service and add all the supplied identities. identityService.apply { ourNames = setOf(initialIdentity.name) database = persistence start(DEV_ROOT_CA.certificate) persistence.transaction { identityService.loadIdentities(moreIdentities + initialIdentity.identity) } } // Create a persistent key management service and add the key pair which was created for the TestIdentity. // We only add the keypair for the initial identity and any other keys which this node may control. Note: We don't add the keys // for the other identities. val pkToIdCache = PublicKeyToOwningIdentityCacheImpl(persistence, TestingNamedCacheFactory()) val aliasKeyMap = mutableMapOf&lt;String, KeyPair&gt;() val aliasedMoreKeys = moreKeys.mapIndexed { index, keyPair -&gt; val alias = "Extra key $index" aliasKeyMap[alias] = keyPair KeyPair(keyPair.public, AliasPrivateKey(alias)) }.toSet() val identityAlias = "${initialIdentity.name} private key" aliasKeyMap[identityAlias] = initialIdentity.keyPair val aliasedIdentityKey = KeyPair(initialIdentity.publicKey, AliasPrivateKey(identityAlias)) val keyManagementService = BasicHSMKeyManagementService( TestingNamedCacheFactory(), identityService, persistence, MockCryptoService(aliasKeyMap), pkToIdCache ) persistence.transaction { keyManagementService.start(aliasedMoreKeys + aliasedIdentityKey) } val mockService = persistence.transaction { makeMockMockServices(cordappLoader, identityService, networkParameters, initialIdentity, moreKeys, keyManagementService, schemaService, persistence) } return Pair(persistence, mockService) }</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion.&lt;no name provided&gt;$override var networkParametersService: NetworkParametersService = MockNetworkParametersStorage(networkParameters)</ID>
    <ID>MaxLineLength:MockTransactionStorage.kt$MockTransactionStorage$override fun getTransaction(id: SecureHash): SignedTransaction?</ID>
    <ID>MaxLineLength:MockTransactionStorage.kt$MockTransactionStorage$override fun getTransactionInternal(id: SecureHash): Pair&lt;SignedTransaction, Boolean&gt;?</ID>
    <ID>MaxLineLength:Models.kt$Models</ID>
    <ID>MaxLineLength:MyCustomNotaryService.kt$MyCustomValidatingNotaryService : SinglePartyNotaryService</ID>
    <ID>MaxLineLength:MyCustomNotaryService.kt$MyCustomValidatingNotaryService$override fun createServiceFlow(otherPartySession: FlowSession): FlowLogic&lt;Void?&gt;</ID>
    <ID>MaxLineLength:MyCustomNotaryService.kt$MyCustomValidatingNotaryService$override val uniquenessProvider = PersistentUniquenessProvider(services.clock, services.database, services.cacheFactory)</ID>
    <ID>MaxLineLength:MyCustomNotaryService.kt$MyValidatingNotaryFlow : ValidatingNotaryFlow</ID>
    <ID>MaxLineLength:NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.kt$NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS$val ECDSAR1_KEYPAIR by lazy { Crypto.deriveKeyPairFromEntropy(Crypto.ECDSA_SECP256R1_SHA256, BigInteger.valueOf(0)) }</ID>
    <ID>MaxLineLength:NamedCacheTest.kt$NamedCacheTest$override</ID>
    <ID>MaxLineLength:NetParams.kt$ fun main(args: Array&lt;String&gt;)</ID>
    <ID>MaxLineLength:NetParams.kt$NetParamsSigner.AMQPInspectorSerializationScheme$override</ID>
    <ID>MaxLineLength:Network.kt$Network$centralLabel = mapLabels.firstOrDefault(SimpleObjectProperty(myLabel), { centralPeer?.contains(it.text, true) == true })</ID>
    <ID>MaxLineLength:Network.kt$Network$if (it is WireTransaction) it.outputStates.observable().getParties() // For ContractUpgradeWireTransaction and NotaryChangeWireTransaction the output parties are the same as input parties else inputParties</ID>
    <ID>MaxLineLength:Network.kt$Network$label(PartyNameFormatter.short.format(identities[0].name)) { font = Font.font(font.family, FontWeight.BOLD, 15.0) }</ID>
    <ID>MaxLineLength:Network.kt$Network$mapScrollPane.hvalue = (valX + adjustment.x) / (mapImageView.layoutBounds.width - mapScrollPane.viewportBounds.width)</ID>
    <ID>MaxLineLength:Network.kt$Network$mapScrollPane.vvalue = (valY + adjustment.y) / (mapImageView.layoutBounds.height - mapScrollPane.viewportBounds.height)</ID>
    <ID>MaxLineLength:Network.kt$Network$node.getWorldMapLocation()?.coordinate?.project(mapPane.width, mapPane.height, 85.0511, -85.0511, -180.0, 180.0) ?: ScreenCoordinate(0.0, 0.0)</ID>
    <ID>MaxLineLength:Network.kt$Network$private</ID>
    <ID>MaxLineLength:Network.kt$Network$private val peerButtons = peerComponents.filtered { myIdentity.value !in it.nodeInfo.legalIdentitiesAndCerts.map { it.party } }.map { it.button }</ID>
    <ID>MaxLineLength:Network.kt$Network$val inputParties = it.inputs.sequence() .map { it as? PartiallyResolvedTransaction.InputResolution.Resolved } .filterNotNull() .map { it.stateAndRef.state.data }.getParties() val outputParties = it.transaction.coreTransaction.let { if (it is WireTransaction) it.outputStates.observable().getParties() // For ContractUpgradeWireTransaction and NotaryChangeWireTransaction the output parties are the same as input parties else inputParties } val signingParties = it.transaction.sigs.map { it.by.toKnownParty() } // Input parties fire a bullets to all output parties, and to the signing parties. !! This is a rough guess of how the message moves in the network. // TODO : Expose artemis queue to get real message information. inputParties.cross(outputParties) + inputParties.cross(signingParties)</ID>
    <ID>MaxLineLength:Network.kt$Network$val mapLabel = label(PartyNameFormatter.short.format(identities.first().name)) // We choose the first one for the name of the node on the map.</ID>
    <ID>MaxLineLength:Network.kt$Network$val newHeight = Math.min(Math.max(mapImageView.prefHeight(-1.0) * zoomFactor, mapOriginalHeight), mapOriginalHeight * 10)</ID>
    <ID>MaxLineLength:Network.kt$Network$val receiver = destNode.label.boundsInParentProperty().map { Point2D(it.width / 2 + it.minX, it.height / 4 - 2.5 + it.minY) }</ID>
    <ID>MaxLineLength:Network.kt$Network$val sender = senderNode.label.boundsInParentProperty().map { Point2D(it.width / 2 + it.minX, it.height / 4 - 2.5 + it.minY) }</ID>
    <ID>MaxLineLength:Network.kt$Network${ // It has to be a copy if we want to have notary both in notaries list and in identity (if we are looking at that particular notary node). myIdentityPane.apply { center = node.renderButton(mapLabel) } myLabel = mapLabel }</ID>
    <ID>MaxLineLength:Network.kt$Network${ val node = this val identities = node.legalIdentitiesAndCerts.sortedBy { it.owningKey.toBase58String() } val mapLabel = label(PartyNameFormatter.short.format(identities.first().name)) // We choose the first one for the name of the node on the map. mapPane.add(mapLabel) // applyCss: This method does not normally need to be invoked directly but may be used in conjunction with Parent.layout() // to size a Node before the next pulse, or if the Scene is not in a Stage. // It's needed to properly add node label to the map (before that width and height are 0 which results in wrong placement of // nodes rendered after initial map rendering). mapPane.applyCss() mapPane.layout() mapLabel.apply { graphic = FontAwesomeIconView(FontAwesomeIcon.DOT_CIRCLE_ALT) contentDisplay = ContentDisplay.TOP val coordinate = Bindings.createObjectBinding({ // These coordinates are obtained when we generate the map using TileMill. node.getWorldMapLocation()?.coordinate?.project(mapPane.width, mapPane.height, 85.0511, -85.0511, -180.0, 180.0) ?: ScreenCoordinate(0.0, 0.0) }, arrayOf(mapPane.widthProperty(), mapPane.heightProperty())) // Center point of the label. layoutXProperty().bind(coordinate.map { it.screenX - width / 2 }) layoutYProperty().bind(coordinate.map { it.screenY - height / 4 }) } val button = node.renderButton(mapLabel) if (myIdentity.value in node.legalIdentitiesAndCerts.map { it.party }) { // It has to be a copy if we want to have notary both in notaries list and in identity (if we are looking at that particular notary node). myIdentityPane.apply { center = node.renderButton(mapLabel) } myLabel = mapLabel } return MapViewComponents(this, button, mapLabel) }</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$CopyCordapps$println("WARNING: ${it.fileName} already exists in $cordappsDir, ignoring and leaving existing CorDapp untouched")</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$CopyCordapps.FirstRunOnly$println("Not copying CorDapp JARs as --copy-cordapps is set to FirstRunOnly, and it looks like this network has already been bootstrapped.")</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$1 -&gt; return netParamsFilesGrouped.keys.first().deserialize().verifiedNetworkParametersCert(DEV_ROOT_CA.certificate)</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$bootstrap(directory, cordappJars, CopyCordapps.No, fromCordform = true, networkParametersOverrides = networkParametersOverrides)</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$bootstrap(directory, cordappJars, copyCordapps, fromCordform = false, networkParametersOverrides = networkParameterOverrides)</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$is NotaryCluster.CFT -&gt; DevIdentityGenerator.generateDistributedNotarySingularIdentity(directories, cluster.name)</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$listOf(CordaX500Name.parse(config.getString("notary.serviceLegalName")) to DirectoryAndConfig(path, config))</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$paths.filter { it.toString().endsWith(".jar") &amp;&amp; !it.isSameAs(bootstrapperJar) &amp;&amp; !jarsThatArentCordapps.contains(it.fileName.toString().toLowerCase()) }</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$require(networkParameterOverrides.minimumPlatformVersion == null || networkParameterOverrides.minimumPlatformVersion &lt;= PLATFORM_VERSION) { "Minimum platform version cannot be greater than $PLATFORM_VERSION" }</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val configuration = ConfigFactory.parseString(extraConfigurations).resolve().getObject("networkParameterOverrides").toConfig().parseAsNetworkParametersConfiguration()</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val msg = StringBuilder("Differing sets of network parameters were found. Make sure all the nodes have the same " + "network parameters by copying the correct $NETWORK_PARAMS_FILE_NAME file across.\n\n")</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val networkParametersOverrides = configuration.doOnErrors(::reportErrors).optional ?: throw IllegalStateException("Invalid configuration passed.")</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val newNetParams = installNetworkParameters(notaryInfos, newWhitelist, existingNetParams, nodeDirs, networkParametersOverrides)</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val newWhitelist = generateWhitelist(existingNetParams, readExcludeWhitelist(directory), unsignedJars.map(contractsJarConverter), readIncludeWhitelist(directory), signedJars.map(contractsJarConverter))</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val nodeDirs = directory.list { subDir -&gt; subDir.filter { (it / "node.conf").exists() &amp;&amp; !(it / "corda.jar").exists() }.toList() }</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val signedJars = cordappJars.filter { isSigned(it) } // signed JARs are excluded by default, optionally include them in order to transition states from CZ whitelist to signature constraint</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$webServerConfFiles.firstOrNull { directory.relativize(it).toString().removeSuffix("_web-server.conf") == nodeName }</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$when (legalIdentities.size) { // Single node notaries have just one identity like all other nodes. This identity is the notary identity 1 -&gt; legalIdentities[0] // Nodes which are part of a distributed notary have a second identity which is the composite identity of the // cluster and is shared by all the other members. This is the notary identity. 2 -&gt; legalIdentities[1] else -&gt; throw IllegalArgumentException("Not sure how to get the notary identity in this scenario: $this") }</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper.AMQPParametersSerializationScheme$override</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper.Companion$val timePerNode = 40.seconds // On the test machine, generating the node info takes 7 seconds for a single node.</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$@Test fun `test when a package is specified in the network parameters file it is passed through to the bootstrapper DSA`()</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$@Test fun `test when a package is specified in the network parameters file it is passed through to the bootstrapper EC`()</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper)</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides())</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides(eventHorizon = 7.days))</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides(maxMessageSize = 1))</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides(maxTransactionSize = 1))</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides(minimumPlatformVersion = 1))</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.No, NetworkParametersOverrides())</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(tempDir.toPath().toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides())</ID>
    <ID>MaxLineLength:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$assertContainsPackageOwner("bob", mapOf(Pair(alicePackageName, ALICE.publicKey), Pair(bobPackageName, BOB.publicKey)))</ID>
    <ID>MaxLineLength:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$bootstrap(packageOwnership = mapOf(Pair(alicePackageName, ALICE.publicKey), Pair(bobPackageName, BOB.publicKey)))</ID>
    <ID>MaxLineLength:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$private</ID>
    <ID>MaxLineLength:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$return list { it.filter { it.fileName.toString().startsWith(NODE_INFO_FILE_NAME_PREFIX) }.toList() }.single()</ID>
    <ID>MaxLineLength:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$val networkParameters = assertBootstrappedNetwork(fakeEmbeddedCorda, "alice" to aliceConfig, "notary" to notaryConfig)</ID>
    <ID>MaxLineLength:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$val networkParameters2 = assertBootstrappedNetwork(fakeEmbeddedCorda, "alice" to aliceConfig, "bob" to bobConfig)</ID>
    <ID>MaxLineLength:NetworkBuilder.kt$NetworkBuilderImpl$nodeInstantiator.createInstanceRequest(it).also { onNodeInstanceRequestedCallback(listOf(it)) }</ID>
    <ID>MaxLineLength:NetworkBuilder.kt$NetworkBuilderImpl$nodeInstantiator.instantiateNotaryInstance(request).thenApply { it.also(onNodeInstanceCallback) }</ID>
    <ID>MaxLineLength:NetworkHostAndPort.kt$NetworkHostAndPort.Companion$ @JvmStatic fun parse(str: String): NetworkHostAndPort</ID>
    <ID>MaxLineLength:NetworkHostAndPortTest.kt$NetworkHostAndPortTest${ NetworkHostAndPort("example.com", it) }</ID>
    <ID>MaxLineLength:NetworkHostAndPortTest.kt$NetworkHostAndPortTest${ NetworkHostAndPort.parse(it) }</ID>
    <ID>MaxLineLength:NetworkIdentityModel.kt$NetworkIdentityModel$val notaries = ChosenList(rpcProxy.map { FXCollections.observableList(it?.notaryIdentities() ?: emptyList()) }, "notaries")</ID>
    <ID>MaxLineLength:NetworkMap.kt$ParametersUpdate</ID>
    <ID>MaxLineLength:NetworkMapCache.kt$NetworkMapCache$ fun getNodeByLegalIdentity(party: AbstractParty): NodeInfo?</ID>
    <ID>MaxLineLength:NetworkMapCache.kt$NetworkMapCacheBase$ fun getNodeByLegalName(name: CordaX500Name): NodeInfo?</ID>
    <ID>MaxLineLength:NetworkMapCache.kt$NetworkMapCacheBase$ fun getNodesByLegalName(name: CordaX500Name): List&lt;NodeInfo&gt;</ID>
    <ID>MaxLineLength:NetworkMapCache.kt$NetworkMapCacheBase$ fun track(): DataFeed&lt;List&lt;NodeInfo&gt;, NetworkMapCache.MapChange&gt;</ID>
    <ID>MaxLineLength:NetworkMapCache.kt$NetworkMapCacheBase$/** * A list of notary services available on the network. * * Note that the identities are sorted based on legal name, and the ordering might change once new notaries are introduced. */ val notaryIdentities: List&lt;Party&gt;</ID>
    <ID>MaxLineLength:NetworkMapCacheTest.kt$NetworkMapCacheTest$assertEquals(aliceNode.info, bobCache.getNodesByLegalIdentityKey(aliceNode.info.singleIdentity().owningKey).single())</ID>
    <ID>MaxLineLength:NetworkMapCacheTest.kt$NetworkMapCacheTest$assertEquals(aliceNode.services.networkMapCache.getNodesByLegalIdentityKey(alice.owningKey).singleOrNull(), aliceNode.info)</ID>
    <ID>MaxLineLength:NetworkMapCacheTest.kt$NetworkMapCacheTest$assertEquals(aliceNode.services.networkMapCache.getNodesByLegalIdentityKey(alice.owningKey).singleOrNull(), bobNode.info)</ID>
    <ID>MaxLineLength:NetworkMapClient.kt$NetworkMapClient$logger.trace { "Fetched network parameters: '$networkParameterHash' successfully. Network Parameters: $networkParameter" }</ID>
    <ID>MaxLineLength:NetworkMapClient.kt$NetworkMapClient$logger.trace { "Sending network parameters with hash ${signedParametersHash.raw.deserialize()} approval to $ackURL." }</ID>
    <ID>MaxLineLength:NetworkMapClientTest.kt$NetworkMapClientTest$assertEquals(networkMapClient.getNetworkParameters(originalNetworkParameterHash).verified(), server.networkParameters)</ID>
    <ID>MaxLineLength:NetworkMapServer.kt$NetworkMapServer$val jerseyServlet = ServletHolder(ServletContainer(resourceConfig)).apply { initOrder = 0 } // Initialise at server start</ID>
    <ID>MaxLineLength:NetworkMapServer.kt$NetworkMapServer.InMemoryNetworkMapService$nodeInfoMap.filter { it.value.verified().legalIdentities.first().name == signedNodeInfo.verified().legalIdentities.first().name }</ID>
    <ID>MaxLineLength:NetworkMapServer.kt$NetworkMapServer.InMemoryNetworkMapService$return Response.ok(signedNetworkMap.serialize().bytes).header("Cache-Control", "max-age=${pollInterval.seconds}").build()</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$@Test fun `nodes process additions and removals from the network map correctly (and also download the network parameters)`()</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$assertEquals(laterHash, networkMapServer.latestParametersAccepted(alice.nodeInfo.legalIdentities.first().owningKey))</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$assertThat(nodeInfosDir.list().single().readObject&lt;SignedNodeInfo&gt;().verified().legalIdentities.first(), `is`(this.nodeInfo.legalIdentities.first()))</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$assertThatThrownBy { alice.rpc.acceptNewNetworkParameters(nextHash) }.hasMessageContaining("Refused to accept parameters with hash")</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$networkMapServer.scheduleParametersUpdate(laterParams, "Another update", Instant.ofEpochMilli(random63BitValue()))</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$networkMapServer.scheduleParametersUpdate(nextParams, "Next parameters", Instant.ofEpochMilli(random63BitValue()))</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$val aliceNode = startNode(providedName = ALICE_NAME, devMode = false).getOrThrow() val aliceNodeInfo = aliceNode.nodeInfo.serialize().hash assertThat(networkMapServer.networkMapHashes()).contains(aliceNodeInfo) networkMapServer.removeNodeInfo(aliceNode.nodeInfo) var maxRemoveRetries = 5 // Try to remove multiple times in case the network map republishes just in between the removal and the check. while (aliceNodeInfo in networkMapServer.networkMapHashes()) { networkMapServer.removeNodeInfo(aliceNode.nodeInfo) if (maxRemoveRetries-- == 0) { throw AssertionError("Could not remove Node info.") } } // Wait until the node info is republished. Thread.sleep(2000) assertThat(networkMapServer.networkMapHashes()).contains(aliceNodeInfo)</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest.Companion$nms.networkParameters = testNetworkParameters(it, modifiedTime = Instant.ofEpochMilli(random63BitValue()), epoch = 2)</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$"""Node is using network parameters with hash $currentParametersHash but the network map is advertising ${networkMap.networkParameterHash}. To resolve this mismatch, and move to the current parameters, delete the $NETWORK_PARAMS_FILE_NAME file from the node's directory and restart. The node will shutdown now."""</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$// Add new node info to the network map cache, these could be new node info or modification of node info for existing nodes. networkMapCache.addNodes(retrievedNodeInfos)</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$?:</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$ParametersUpdateInfo(it.first.newParametersHash, it.second.verified(), it.first.description, it.first.updateDeadline)</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$To resolve this mismatch, and move to the current parameters, delete the </ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$hash.serialize().sign { keyManagementService.sign(it.bytes, ourNodeInfo.verified().legalIdentities[0].owningKey) }</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$if (autoAcceptNetworkParameters &amp;&amp; networkParameters.canAutoAccept(newNetParams, excludedAutoAcceptNetworkParameters)) { logger.info("Auto-accepting network parameter update ${update.newParametersHash}") acceptNewNetworkParameters(update.newParametersHash) { hash -&gt; hash.serialize().sign { keyManagementService.sign(it.bytes, ourNodeInfo.verified().legalIdentities[0].owningKey) } } } else { parametersUpdatesTrack.onNext(updateInfo) }</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$logger.info("Auto-accept enabled for network parameter changes which modify only: $autoAcceptNetworkParametersNames")</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$logger.info("Fetched: ${hashesToFetch.size} using $threadsToUseForNetworkMapDownload Threads in ${System.currentTimeMillis() - networkMapDownloadStartTime}ms")</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$logger.warn("Error encountered when downloading node info '$nodeInfo', skipping...", e)</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$private</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$this.excludedAutoAcceptNetworkParameters = networkParameterAcceptanceSettings.excludedAutoAcceptableParameters</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$throw CordaRuntimeException("Network map cache can be updated only if network map/compatibility zone URL is specified")</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$val (update, signedNewNetParams) = requireNotNull(newNetworkParameters) { "Couldn't find parameters update for the hash: $parametersHash" }</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$val acceptedHash = if (updatesFile.exists()) updatesFile.readObject&lt;SignedNetworkParameters&gt;().raw.hash else null</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$val executorToUseForDownloadingNodeInfos = Executors.newFixedThreadPool(threadsToUseForNetworkMapDownload, NamedThreadFactory("NetworkMapUpdaterNodeInfoDownloadThread"))</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$val executorToUseForInsertionIntoDB = Executors.newSingleThreadExecutor(NamedThreadFactory("NetworkMapUpdateDBInsertThread"))</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$val networkMapDownloadFutures = hashesToFetch.chunked(max(hashesToFetch.size / threadsToUseForNetworkMapDownload, 1)) .map { nodeInfosToGet -&gt; // for a set of chunked hashes, get the nodeInfo for each hash CompletableFuture.supplyAsync(Supplier&lt;List&lt;NodeInfo&gt;&gt; { nodeInfosToGet.mapNotNull { nodeInfo -&gt; try { networkMapClient.getNodeInfo(nodeInfo) } catch (e: Exception) { // Failure to retrieve one node info shouldn't stop the whole update, log and return null instead. logger.warn("Error encountered when downloading node info '$nodeInfo', skipping...", e) null } } }, executorToUseForDownloadingNodeInfos).thenAcceptAsync(Consumer { retrievedNodeInfos -&gt; // Add new node info to the network map cache, these could be new node info or modification of node info for existing nodes. networkMapCache.addNodes(retrievedNodeInfos) }, executorToUseForInsertionIntoDB) }.toTypedArray()</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater${ // Failure to retrieve one node info shouldn't stop the whole update, log and return null instead. logger.warn("Error encountered when downloading node info '$nodeInfo', skipping...", e) null }</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater${ if (networkMapClient == null) { throw CordaRuntimeException("Network map cache can be updated only if network map/compatibility zone URL is specified") } val (globalNetworkMap, cacheTimeout) = networkMapClient.getNetworkMap() globalNetworkMap.parametersUpdate?.let { handleUpdateNetworkParameters(networkMapClient, it) } val additionalHashes = extraNetworkMapKeys.flatMap { try { networkMapClient.getNetworkMap(it).payload.nodeInfoHashes } catch (e: Exception) { // Failure to retrieve one network map using UUID shouldn't stop the whole update. logger.warn("Error encountered when downloading network map with uuid '$it', skipping...", e) emptyList&lt;SecureHash&gt;() } } val allHashesFromNetworkMap = (globalNetworkMap.nodeInfoHashes + additionalHashes).toSet() if (currentParametersHash != globalNetworkMap.networkParameterHash) { exitOnParametersMismatch(globalNetworkMap) } val currentNodeHashes = networkMapCache.allNodeHashes // Remove node info from network map. (currentNodeHashes - allHashesFromNetworkMap - nodeInfoWatcher.processedNodeInfoHashes) .mapNotNull { if (it != ourNodeInfoHash) networkMapCache.getNodeByHash(it) else null } .forEach(networkMapCache::removeNode) // at the moment we use a blocking HTTP library - but under the covers, the OS will interleave threads waiting for IO // as HTTP GET is mostly IO bound, use more threads than CPU's // maximum threads to use = 24, as if we did not limit this on large machines it could result in 100's of concurrent requests val threadsToUseForNetworkMapDownload = min(Runtime.getRuntime().availableProcessors() * 4, 24) val executorToUseForDownloadingNodeInfos = Executors.newFixedThreadPool(threadsToUseForNetworkMapDownload, NamedThreadFactory("NetworkMapUpdaterNodeInfoDownloadThread")) // DB insert is single threaded - use a single threaded executor for it. val executorToUseForInsertionIntoDB = Executors.newSingleThreadExecutor(NamedThreadFactory("NetworkMapUpdateDBInsertThread")) val hashesToFetch = (allHashesFromNetworkMap - currentNodeHashes) val networkMapDownloadStartTime = System.currentTimeMillis() if (hashesToFetch.isNotEmpty()) { val networkMapDownloadFutures = hashesToFetch.chunked(max(hashesToFetch.size / threadsToUseForNetworkMapDownload, 1)) .map { nodeInfosToGet -&gt; // for a set of chunked hashes, get the nodeInfo for each hash CompletableFuture.supplyAsync(Supplier&lt;List&lt;NodeInfo&gt;&gt; { nodeInfosToGet.mapNotNull { nodeInfo -&gt; try { networkMapClient.getNodeInfo(nodeInfo) } catch (e: Exception) { // Failure to retrieve one node info shouldn't stop the whole update, log and return null instead. logger.warn("Error encountered when downloading node info '$nodeInfo', skipping...", e) null } } }, executorToUseForDownloadingNodeInfos).thenAcceptAsync(Consumer { retrievedNodeInfos -&gt; // Add new node info to the network map cache, these could be new node info or modification of node info for existing nodes. networkMapCache.addNodes(retrievedNodeInfos) }, executorToUseForInsertionIntoDB) }.toTypedArray() // wait for all the futures to complete val waitForAllHashes = CompletableFuture.allOf(*networkMapDownloadFutures) waitForAllHashes.thenRunAsync { logger.info("Fetched: ${hashesToFetch.size} using $threadsToUseForNetworkMapDownload Threads in ${System.currentTimeMillis() - networkMapDownloadStartTime}ms") executorToUseForDownloadingNodeInfos.shutdown() executorToUseForInsertionIntoDB.shutdown() }.getOrThrow() } // Mark the network map cache as ready on a successful poll of the HTTP network map, even on the odd chance that // it's empty networkMapCache.nodeReady.set(null) return cacheTimeout }</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater${ networkMapClient ?: throw IllegalStateException("Network parameters updates are not supported without compatibility zone configured") // TODO This scenario will happen if node was restarted and didn't download parameters yet, but we accepted them. // Add persisting of newest parameters from update. val (update, signedNewNetParams) = requireNotNull(newNetworkParameters) { "Couldn't find parameters update for the hash: $parametersHash" } // We should check that we sign the right data structure hash. val newNetParams = signedNewNetParams.verifiedNetworkParametersCert(trustRoot) val newParametersHash = signedNewNetParams.raw.hash if (parametersHash == newParametersHash) { // The latest parameters have priority. signedNewNetParams.serialize() .open() .copyTo(baseDirectory / NETWORK_PARAMS_UPDATE_FILE_NAME, StandardCopyOption.REPLACE_EXISTING) networkMapClient.ackNetworkParametersUpdate(sign(parametersHash)) logger.info("Accepted network parameter update $update: $newNetParams") } else { throw OutdatedNetworkParameterHashException(parametersHash, newParametersHash) } }</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$autoAcceptableNamesAndGetters.none { it.key in excludedParameterNames &amp;&amp; valueChanged(newNetworkParameters, it.value) }</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$private fun KProperty1&lt;out NetworkParameters, Any?&gt;.isAutoAcceptable(): Boolean</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$private val memberPropertyPartition = NetworkParameters::class.declaredMemberProperties.partition { it.isAutoAcceptable() }</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$// Test fix for ENT-1882 // This scenario can happen when signing of network map server is performed much longer after the node joined the network. // Network map will advertise hashes without that node. @Test fun `not remove own node info when it is not in network map yet`()</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `network parameters not auto-accepted when update only changes whitelist but auto accept configured to be false`()</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `network parameters not auto-accepted when update only changes whitelist but parameter included in exclusion`()</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$Assert.assertThat(networkMapCache.allNodeHashes, IsIterableContainingInAnyOrder.containsInAnyOrder(signedNodeInfo1.raw.hash, signedNodeInfo2.raw.hash))</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$MockKeyManagementService(makeTestIdentityService(), ourKeyPair, pkToIdCache = MockPublicKeyToOwningIdentityCache())</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertFalse(netParams.canAutoAccept(netParamsAutoAcceptable, setOf("whitelistedContractImplementations")), "not auto-acceptable if only AutoAcceptable params have changed but one has been added to the exclusion set")</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertFalse(netParams.canAutoAccept(netParamsNotAutoAcceptable, emptySet()), "not auto-acceptable if non-AutoAcceptable param has changed")</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertThat(networkMapCache.allNodeHashes).containsExactlyInAnyOrder(fileNodeInfoAndSigned1.signed.raw.hash, fileNodeInfoAndSigned2.signed.raw.hash)</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertThat(networkMapCache.allNodeHashes).containsExactlyInAnyOrder(signedMyInfo.raw.hash, signedOtherInfo.raw.hash)</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertTrue(netParams.canAutoAccept(netParams, autoAcceptablePropertyNames), "auto acceptable if identical regardless of exclusions")</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertTrue(netParams.canAutoAccept(netParamsAutoAcceptable, emptySet()), "auto-acceptable if only AutoAcceptable params have changed")</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertTrue(netParams.canAutoAccept(netParamsAutoAcceptable, setOf("modifiedTime")), "auto-acceptable if only AutoAcceptable params have changed and excluded param has not changed")</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$on { getNodeByHash(any()) }.then { mock -&gt; data.values.singleOrNull { it.serialize().hash == mock.arguments[0] } }</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$updater = NetworkMapUpdater(networkMapCache, fileWatcher, netMapClient, baseDir, extraNetworkMapKeys, networkParametersStorage)</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$val fileName = "${NodeInfoFilesCopier.NODE_INFO_FILE_NAME_PREFIX}${localNodeInfo.legalIdentities[0].name.serialize().hash}"</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$val fileName1 = "${NodeInfoFilesCopier.NODE_INFO_FILE_NAME_PREFIX}${fileNodeInfoAndSigned1.nodeInfo.legalIdentities[0].name.serialize().hash}"</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest${ setUpdater() val nodeInfoBuilder = TestNodeInfoBuilder() val (_, key) = nodeInfoBuilder.addLegalIdentity(CordaX500Name("Info", "London", "GB")) val (serverNodeInfo, serverSignedNodeInfo) = nodeInfoBuilder.buildWithSigned(1, 1) // Construct node for exactly same identity, but different serial. This one will go to additional-node-infos only. val localNodeInfo = serverNodeInfo.copy(serial = 17) val localSignedNodeInfo = NodeInfoAndSigned(localNodeInfo) { _, serialised -&gt; key.sign(serialised.bytes) } // The one with higher serial goes to additional-node-infos. NodeInfoWatcher.saveToFile(nodeInfoDir, localSignedNodeInfo) // Publish to network map the one with lower serial. networkMapClient.publish(serverSignedNodeInfo) startUpdater() advanceTime() verify(networkMapCache, times(1)).addNode(localNodeInfo) Thread.sleep(2L * cacheExpiryMs) // Node from file has higher serial than the one from NetworkMapServer assertThat(networkMapCache.allNodeHashes).containsOnly(localSignedNodeInfo.signed.raw.hash) val fileName = "${NodeInfoFilesCopier.NODE_INFO_FILE_NAME_PREFIX}${localNodeInfo.legalIdentities[0].name.serialize().hash}" (nodeInfoDir / fileName).delete() advanceTime() verify(networkMapCache, times(1)).removeNode(any()) verify(networkMapCache).removeNode(localNodeInfo) Thread.sleep(2L * cacheExpiryMs) // Instead of node from file we should have now the one from NetworkMapServer assertThat(networkMapCache.allNodeHashes).containsOnly(serverSignedNodeInfo.raw.hash) }</ID>
    <ID>MaxLineLength:NetworkParameterOverridesSpec.kt$NetworkParameterOverridesSpec$internal</ID>
    <ID>MaxLineLength:NetworkParameterOverridesSpec.kt$NetworkParameterOverridesSpec.PackageOwnershipSpec$badValue("Error reading the key store from the file for keyStoreFilePath: $suppliedKeystorePath ${e.message}.")</ID>
    <ID>MaxLineLength:NetworkParameterOverridesSpec.kt$NetworkParameterOverridesSpec.PackageOwnershipSpec$badValue("Password is incorrect or the key store is damaged for keyStoreFilePath: $suppliedKeystorePath.")</ID>
    <ID>MaxLineLength:NetworkParameterOverridesSpec.kt$internal fun &lt;T&gt; badValue(msg: String): Valid&lt;T&gt;</ID>
    <ID>MaxLineLength:NetworkParameters.kt$NetworkParameters</ID>
    <ID>MaxLineLength:NetworkParametersCopier.kt$NetworkParametersCopier$private val serialisedSignedNetParams: SerializedBytes&lt;SignedDataWithCert&lt;NetworkParameters&gt;&gt; = signingCertAndKeyPair.sign(networkParameters).serialize()</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader$logger.info("No network-parameters file found. Expecting network parameters to be available from the network map.")</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader$private</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader${ // Node joins for the first time. downloadParameters(advertisedParametersHash) }</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader${ // TODO On one hand we have node starting without parameters and just accepting them by default, // on the other we have parameters update process - it needs to be unified. Say you start the node, you don't have matching parameters, // you get them from network map, but you have to run the approval step. if (signedParametersFromFile == null) { // Node joins for the first time. downloadParameters(advertisedParametersHash) } else if (signedParametersFromFile.raw.hash == advertisedParametersHash) { // Restarted with the same parameters. signedParametersFromFile } else { // Update case. readParametersUpdate(advertisedParametersHash, signedParametersFromFile.raw.hash) } }</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader${ logger.info("Unable to download network map", e) // If NetworkMap is down while restarting the node, we should be still able to continue with parameters from file null }</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader.Error$NetworkMapNotConfigured : Error</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader.Error$ParamsNotConfigured : Error</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader.Error.OldParamsAndUpdate$"parameters advertised by network map. Please update node to use correct network parameters file."</ID>
    <ID>MaxLineLength:NetworkParametersReaderTest.kt$NetworkParametersReaderTest$NetworkParametersCopier(server.networkParameters, update = true).install(baseDirectory)</ID>
    <ID>MaxLineLength:NetworkParametersReaderTest.kt$NetworkParametersReaderTest$val parameters = NetworkParametersReader(DEV_ROOT_CA.certificate, networkMapClient, baseDirectory).read().networkParameters</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$(megaCorpNode.services.networkParametersService as NetworkParametersStorage).saveParameters(certKeyPair.sign(defaultParams))</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$(megaCorpNode.services.networkParametersService as NetworkParametersStorage).saveParameters(certKeyPair.sign(params3))</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$assertThatExceptionOfType(TransactionVerificationException.TransactionNetworkParameterOrderingException::class.java)</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$cordappsForAllNodes = listOf(DUMMY_CONTRACTS_CORDAPP, cordappForClasses(ResolveTransactionsFlowTest.TestFlow::class.java, ResolveTransactionsFlowTest.TestResponseFlow::class.java))</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$params2 = testNetworkParameters(epoch = 2, minimumPlatformVersion = 3, notaries = listOf((NotaryInfo(notaryParty, true))))</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$params3 = testNetworkParameters(epoch = 3, minimumPlatformVersion = 4, notaries = listOf((NotaryInfo(notaryParty, true))))</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$private</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$val signatureMetadata = SignatureMetadata(services.myInfo.platformVersion, Crypto.findSignatureScheme(publicKey).schemeNumberID)</ID>
    <ID>MaxLineLength:NetworkParametersService.kt$NetworkParametersService$/** * For backwards compatibility, this parameters hash will be used for resolving historical transactions in the chain. */ val defaultHash: SecureHash</ID>
    <ID>MaxLineLength:NetworkParametersServiceInternal.kt$NetworkParametersStorage$ fun getEpochFromHash(hash: SecureHash): Int?</ID>
    <ID>MaxLineLength:NetworkParametersServiceInternal.kt$NetworkParametersStorage$ fun getHistoricNotary(party: Party): NotaryInfo?</ID>
    <ID>MaxLineLength:NetworkParametersServiceInternal.kt$NetworkParametersStorage$ fun lookupSigned(hash: SecureHash): SignedDataWithCert&lt;NetworkParameters&gt;?</ID>
    <ID>MaxLineLength:NetworkParametersTest.kt$NetworkParametersTest$alice.services.startFlow(CashIssueFlow(500.DOLLARS, OpaqueBytes.of(0x01), fakeNotaryId)).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:NetworkParametersTest.kt$NetworkParametersTest$val alice = mockNet.createUnstartedNode(InternalMockNodeParameters(legalName = ALICE_NAME, forcedID = 100, version = MOCK_VERSION_INFO.copy(platformVersion = 1)))</ID>
    <ID>MaxLineLength:NetworkParametersTest.kt$NetworkParametersTest$val alice = mockNet.createUnstartedNode(InternalMockNodeParameters(legalName = ALICE_NAME, forcedID = 100, version = MOCK_VERSION_INFO.copy(platformVersion = 2)))</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ fun generateKeysAndRegister()</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ | Please make sure the config is correct or that the correct certificate for the CRL issuer is added to the node's trust store.</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$"$networkRootTrustStorePath does not exist. This file must contain the root CA cert of your compatibility zone. "</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$certStore.query { setPrivateKey(SELF_SIGNED_PRIVATE_KEY, AliasPrivateKey(SELF_SIGNED_PRIVATE_KEY), listOf(NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.ECDSAR1_CERT), certificateStore.entryPassword) }</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$if (Crypto.toSupportedPublicKey(certificates.first().publicKey) != Crypto.toSupportedPublicKey(registeringPublicKey)) { throw CertificateRequestException("Received certificate contains incorrect public key, expected '$registeringPublicKey', got '${certificates.first().publicKey}'.") }</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$logError</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$logProgress("Certificate signing request with the following information will be submitted to the Corda certificate signing server.")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$logProgress("Successfully submitted request to Corda certificate signing server, request ID: $requestId.")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$onSuccess(nodeCaPublicKey, cryptoService.getSigner(nodeCaKeyAlias), nodeCaCertificates, tlsCrlIssuerCert?.subjectX500Principal?.toX500Name())</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$private val nextIdleDuration: (Duration?) -&gt; Duration? = FixedPeriodLimitedRetrialStrategy(10, Duration.ofMinutes(1))</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$throw CertificateRequestException("Received certificate contains incorrect public key, expected '$registeringPublicKey', got '${certificates.first().publicKey}'.")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$throw CertificateRequestException("Received certificate contains invalid cert role, expected '$certRole', got '$nodeCaCertRole'.")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$throw CertificateRequestException("Subject of received node CA cert doesn't match with node legal name: $nodeCaSubject")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$throw NodeRegistrationException("Compatibility Zone registration service is currently unavailable, " + "try again later!.", e)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$val certStore: CertificateStore = if (cryptoService is BCCryptoService) cryptoService.certificateStore else certificateStore</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$val request = X509Utilities.createCertificateSigningRequest(myLegalName.x500Principal, emailAddress, publicKey, contentSigner, certRole)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$val requestId = submitOrResumeCertificateSigningRequest(nodeCaPublicKey, cryptoService.getSigner(nodeCaKeyAlias))</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper${ // Create or load self signed keypair from the key store. // We use the self sign certificate to store the key temporarily in the keystore while waiting for the request approval. if (alias !in this) { // NODE_CA should be TLS compatible due to the cert hierarchy structure. val keyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val selfSignCert = X509Utilities.createSelfSignedCACertificate(myLegalName.x500Principal, keyPair) // Save to the key store. with(value) { setPrivateKey(alias, keyPair.private, listOf(selfSignCert), keyPassword = entryPassword) save() } } return query { getCertificateAndKeyPair(alias, entryPassword) }.keyPair }</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper${ certificatesDirectory.createDirectories() // We need this in case cryptoService and certificateStore share the same KeyStore (for backwards compatibility purposes). // If we didn't, then an update to cryptoService wouldn't be reflected to certificateStore that is already loaded in memory. val certStore: CertificateStore = if (cryptoService is BCCryptoService) cryptoService.certificateStore else certificateStore // SELF_SIGNED_PRIVATE_KEY is used as progress indicator. if (certStore.contains(nodeCaKeyAlias) &amp;&amp; !certStore.contains(SELF_SIGNED_PRIVATE_KEY)) { logProgress("Certificate already exists, Corda node will now terminate...") return } val tlsCrlIssuerCert = getTlsCrlIssuerCert() // We use SELF_SIGNED_PRIVATE_KEY as progress indicator so we just store a dummy key and cert. // When registration succeeds, this entry should be deleted. certStore.query { setPrivateKey(SELF_SIGNED_PRIVATE_KEY, AliasPrivateKey(SELF_SIGNED_PRIVATE_KEY), listOf(NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.ECDSAR1_CERT), certificateStore.entryPassword) } val nodeCaPublicKey = loadOrGenerateKeyPair() val requestId = submitOrResumeCertificateSigningRequest(nodeCaPublicKey, cryptoService.getSigner(nodeCaKeyAlias)) val nodeCaCertificates = pollServerForCertificates(requestId) validateCertificates(nodeCaPublicKey, nodeCaCertificates) certStore.setCertPathOnly(nodeCaKeyAlias, nodeCaCertificates) certStore.value.internal.deleteEntry(SELF_SIGNED_PRIVATE_KEY) certStore.value.save() logProgress("Private key '$nodeCaKeyAlias' and its certificate-chain stored successfully.") onSuccess(nodeCaPublicKey, cryptoService.getSigner(nodeCaKeyAlias), nodeCaCertificates, tlsCrlIssuerCert?.subjectX500Principal?.toX500Name()) // All done, clean up temp files. requestIdStore.deleteIfExists() }</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper${ val nodeCACertificate = certificates.first() val nodeCaSubject = try { CordaX500Name.build(nodeCACertificate.subjectX500Principal) } catch (e: IllegalArgumentException) { throw CertificateRequestException("Received node CA cert has invalid subject name: ${e.message}") } if (nodeCaSubject != myLegalName) { throw CertificateRequestException("Subject of received node CA cert doesn't match with node legal name: $nodeCaSubject") } val nodeCaCertRole = try { CertRole.extract(nodeCACertificate) } catch (e: IllegalArgumentException) { throw CertificateRequestException("Unable to extract cert role from received node CA cert: ${e.message}") } if (certRole != nodeCaCertRole) { throw CertificateRequestException("Received certificate contains invalid cert role, expected '$certRole', got '$nodeCaCertRole'.") } // Validate returned certificate is for the correct public key. if (Crypto.toSupportedPublicKey(certificates.first().publicKey) != Crypto.toSupportedPublicKey(registeringPublicKey)) { throw CertificateRequestException("Received certificate contains incorrect public key, expected '$registeringPublicKey', got '${certificates.first().publicKey}'.") } // Validate certificate chain returned from the doorman with the root cert obtained via out-of-band process, to prevent MITM attack on doorman server. X509Utilities.validateCertificateChain(rootCert, certificates) logProgress("Certificate signing request approved, storing private key with the certificate chain.") }</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationConfiguration$cryptoService = CryptoServiceFactory.makeCryptoService(SupportedCryptoServices.BC_SIMPLE, config.myLegalName, config.signingCertificateStore)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$computeNextIdleDoormanConnectionPollInterval: (Duration?) -&gt; Duration? = FixedPeriodLimitedRetrialStrategy(10, Duration.ofMinutes(1))</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$logger.info("Copying trusted certificate to the node's trust store: Alias: $it, Certificate: $certificate")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$logger.warn("The node's trust store already exists. The following certificates will be overridden: ${this.aliases().asSequence()}")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$val validityWindow = X509Utilities.getCertificateValidityWindow(DEFAULT_VALIDITY_WINDOW.first, DEFAULT_VALIDITY_WINDOW.second, issuerCertificate)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$CertRole.NODE_CA -&gt; NodeRegistrationHelper(NodeRegistrationConfiguration(config), certService, NodeRegistrationOption(config.certificatesDirectory / networkRootTrustStoreFileName, networkRootTrustStorePassword))</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$NameConstraints(arrayOf(GeneralSubtree(GeneralName(GeneralName.directoryName, legalName.toX500Name()))), arrayOf())</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$doReturn(CertificateStoreStubs.P2P.withCertificatesDirectory(certificatesDirectory)).whenever(it).p2pSslOptions</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$doReturn(CertificateStoreStubs.Signing.withCertificatesDirectory(certificatesDirectory)).whenever(it).signingCertificateStore</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$val rootAndIntermediateCA = createDevIntermediateCaCertPath().also { saveNetworkTrustStore(CORDA_ROOT_CA to it.first.certificate) }</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest${ createFixedResponseRegistrationHelper(nodeCaCertPath) }</ID>
    <ID>MaxLineLength:NetworkRegistrationService.kt$NetworkRegistrationService$ @Throws(CertificateRequestException::class) fun retrieveCertificates(requestId: String): CertificateResponse</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$CashTransaction.Exit -&gt; ExitRequest(Amount.fromDecimal(amount.value, currencyChoiceBox.value), issueRef)</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$CashTransaction.Issue -&gt; IssueAndPaymentRequest(Amount.fromDecimal(amount.value, currencyChoiceBox.value), issueRef, partyBChoiceBox.value.party, selectNotary(), anonymous)</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$CashTransaction.Pay -&gt; PaymentRequest(Amount.fromDecimal(amount.value, currencyChoiceBox.value), partyBChoiceBox.value.party, anonymous = anonymous, notary = selectNotary())</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$issueRefLabel.visibleProperty().bind(transactionTypeCB.valueProperty().map { it == CashTransaction.Issue || it == CashTransaction.Exit })</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$issuer.isNotNull.and(currencyChoiceBox.valueProperty().isNotNull).and(transactionTypeCB.valueProperty().booleanBinding(transactionTypeCB.valueProperty()) { it != CashTransaction.Issue })</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$partyATextField.textProperty().bind(myIdentity.map { it?.let { PartyNameFormatter.short.format(it.name) } ?: "" })</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$val filteredCash = cash.filtered { it.token.issuer.party == issuer.value &amp;&amp; it.token.product == currencyChoiceBox.value } .map { it.withoutIssuer() }.sumOrNull()</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$val issuer = Bindings.createObjectBinding({ if (issuerChoiceBox.isVisible) issuerChoiceBox.value else myIdentity.value }, arrayOf(myIdentity, issuerChoiceBox.visibleProperty(), issuerChoiceBox.valueProperty()))</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$visibleProperty().bind(transactionTypeCB.valueProperty().map { it == CashTransaction.Issue || it == CashTransaction.Exit })</ID>
    <ID>MaxLineLength:Node.kt$Node$ override fun startDatabase()</ID>
    <ID>MaxLineLength:Node.kt$Node$ private fun registerDefaultExceptionHandler()</ID>
    <ID>MaxLineLength:Node.kt$Node$"To disable autodetect set detectPublicIp = false in the node.conf, or consider using messagingServerAddress and messagingServerExternal"</ID>
    <ID>MaxLineLength:Node.kt$Node$ArtemisRpcBroker.withSsl(configuration.p2pSslOptions, this.address, adminAddress, sslConfig!!, securityManager, MAX_RPC_MESSAGE_SIZE, jmxMonitoringHttpPort != null, rpcBrokerDirectory, shouldStartLocalShell())</ID>
    <ID>MaxLineLength:Node.kt$Node$ArtemisRpcBroker.withoutSsl(configuration.p2pSslOptions, this.address, adminAddress, securityManager, MAX_RPC_MESSAGE_SIZE, jmxMonitoringHttpPort != null, rpcBrokerDirectory, shouldStartLocalShell())</ID>
    <ID>MaxLineLength:Node.kt$Node$ObjectName("$domain:type=$category,${if (component.isNotEmpty()) "component=$component," else ""}name=$subName")</ID>
    <ID>MaxLineLength:Node.kt$Node$System.setProperty("h2.allowedClasses", "org.h2.mvstore.db.MVTableEngine,org.locationtech.jts.geom.Geometry,org.h2.server.TcpServer")</ID>
    <ID>MaxLineLength:Node.kt$Node$System.setProperty("io.netty.allocator.numHeapArenas", min(memBasedArenas, NettyRuntime.availableProcessors() * 2L).toString())</ID>
    <ID>MaxLineLength:Node.kt$Node$if (configuration.shouldStartLocalShell()) RPCSecurityManagerWithAdditionalUser(this, User(INTERNAL_SHELL_USER, INTERNAL_SHELL_USER, setOf(Permissions.all()))) else this</ID>
    <ID>MaxLineLength:Node.kt$Node$internalRpcMessagingClient = InternalRPCMessagingClient(configuration.p2pSslOptions, it.admin, MAX_RPC_MESSAGE_SIZE, CordaX500Name.build(configuration.p2pSslOptions.keyStore.get()[X509Utilities.CORDA_CLIENT_TLS].subjectX500Principal), rpcServerConfiguration)</ID>
    <ID>MaxLineLength:Node.kt$Node$log</ID>
    <ID>MaxLineLength:Node.kt$Node$log.info("Detected public IP: ${foundPublicIP.hostAddress}. This will be used instead of the provided \"$host\" as the advertised address.")</ID>
    <ID>MaxLineLength:Node.kt$Node$log.info("Retrieved public IP from Network Map Service: $this. This will be used instead of the provided \"$host\" as the advertised address.")</ID>
    <ID>MaxLineLength:Node.kt$Node$override fun myAddresses(): List&lt;NetworkHostAndPort&gt;</ID>
    <ID>MaxLineLength:Node.kt$Node$private</ID>
    <ID>MaxLineLength:Node.kt$Node$registerScheme(AMQPClientSerializationScheme(cordappLoader.cordapps, Caffeine.newBuilder().maximumSize(128).build&lt;SerializationFactoryCacheKey, SerializerFactory&gt;().asMap()))</ID>
    <ID>MaxLineLength:Node.kt$Node$registerScheme(AMQPServerSerializationScheme(cordappLoader.cordapps, Caffeine.newBuilder().maximumSize(128).build&lt;SerializationFactoryCacheKey, SerializerFactory&gt;().asMap()))</ID>
    <ID>MaxLineLength:Node.kt$Node$require(nodeInfo.legalIdentities.size in 1..2) { "Currently nodes must have a primary address and optionally one serviced address" }</ID>
    <ID>MaxLineLength:Node.kt$Node$return BridgeControlListener(configuration.p2pSslOptions, networkParameters.maxMessageSize, configuration.crlCheckSoftFail, artemisMessagingClientFactory)</ID>
    <ID>MaxLineLength:Node.kt$Node$rpcClientContext = if (configuration.shouldInitCrashShell()) AMQP_RPC_CLIENT_CONTEXT.withClassLoader(classloader) else null</ID>
    <ID>MaxLineLength:Node.kt$Node$serviceIdentity = if (nodeInfo.legalIdentities.size == 1) null else nodeInfo.legalIdentities[1].owningKey</ID>
    <ID>MaxLineLength:Node.kt$Node$throw CouldNotCreateDataSourceException("Database password is required for H2 server listening on ${InetAddress.getByName(effectiveH2Settings.address.host)}.")</ID>
    <ID>MaxLineLength:Node.kt$Node${ // Netty arenas are approx 16MB each when max'd out. Set arenas based on memory, not core count, unless memory is abundant. val memBasedArenas = max(Runtime.getRuntime().maxMemory() / 256.MB, 1L) // We set the min of the above and the default. System.setProperty("io.netty.allocator.numHeapArenas", min(memBasedArenas, NettyRuntime.availableProcessors() * 2L).toString()) }</ID>
    <ID>MaxLineLength:Node.kt$Node${ check(!serverThread.isOnThread) synchronized(this) { if (shutdown) return shutdown = true // Unregister shutdown hook to prevent any unnecessary second calls to stop shutdownHook?.cancel() shutdownHook = null } printBasicNodeInfo("Shutting down ...") // All the Node started subsystems were registered with the runOnStop list at creation. // So now simply call the parent to stop everything in reverse order. // In particular this prevents premature shutdown of the Database by AbstractNode whilst the serverThread is active super.stop() shutdown = false log.info("Shutdown complete") }</ID>
    <ID>MaxLineLength:Node.kt$Node${ override fun createStartedNode(nodeInfo: NodeInfo, rpcOps: CordaRPCOps, notaryService: NotaryService?): NodeInfo = nodeInfo companion object { private val staticLog = contextLogger() var renderBasicInfoToConsole = true /** Used for useful info that we always want to show, even when not logging to the console */ fun printBasicNodeInfo(description: String, info: String? = null) { val msg = if (info == null) description else "${description.padEnd(40)}: $info" val loggerName = if (renderBasicInfoToConsole) "BasicInfo" else "Main" LoggerFactory.getLogger(loggerName).info(msg) } fun printInRed(message: String) { println("${ShellConstants.RED}$message${ShellConstants.RESET}") } fun printWarning(message: String) { Emoji.renderIfSupported { printInRed("${Emoji.warningSign} ATTENTION: $message") } staticLog.warn(message) } internal fun failStartUp(message: String): Nothing { println(message) println("Corda will now exit...") exitProcess(1) } private fun createClock(configuration: NodeConfiguration): CordaClock { return (if (configuration.useTestClock) ::DemoClock else ::SimpleClock)(Clock.systemUTC()) } private val sameVmNodeCounter = AtomicInteger() // TODO: make this configurable. const val MAX_RPC_MESSAGE_SIZE = 10485760 fun isInvalidJavaVersion(): Boolean { if (!hasMinimumJavaVersion()) { println("You are using a version of Java that is not supported (${SystemUtils.JAVA_VERSION}). Please upgrade to the latest version of Java 8.") println("Corda will now exit...") return true } return false } private fun hasMinimumJavaVersion(): Boolean { // when the ext.java8_minUpdateVersion gradle constant changes, so must this check return try { val update = getJavaUpdateVersion(SystemUtils.JAVA_VERSION) // To filter out cases like 1.8.0_202-ea SystemUtils.IS_JAVA_1_8 &amp;&amp; update &gt;= 171 } catch (e: NumberFormatException) { // custom JDKs may not have the update version (e.g. 1.8.0-adoptopenjdk) false } } } override val log: Logger get() = staticLog override val transactionVerifierWorkerCount: Int get() = 4 private var internalRpcMessagingClient: InternalRPCMessagingClient? = null private var rpcBroker: ArtemisBroker? = null private var shutdownHook: ShutdownHook? = null // DISCUSSION // // We use a single server thread for now, which means all message handling is serialized. // // Writing thread safe code is hard. In this project we are writing most node services and code to be thread safe, but // the possibility of mistakes is always present. Thus we make a deliberate decision here to trade off some multi-core // scalability in order to gain developer productivity by setting the size of the serverThread pool to one, which will // reduce the number of threading bugs we will need to tackle. // // This leaves us with four possibilities in future: // // (1) We discover that processing messages is fast and that our eventual use cases do not need very high // processing rates. We have benefited from the higher productivity and not lost anything. // // (2) We discover that we need greater multi-core scalability, but that the bulk of our time goes into particular CPU // hotspots that are easily multi-threaded e.g. signature checking. We successfully multi-thread those hotspots // and find that our software now scales sufficiently well to satisfy our user's needs. // // (3) We discover that it wasn't enough, but that we only need to run some messages in parallel and that the bulk of // the work can stay single threaded. For example perhaps we find that latency sensitive UI requests must be handled // on a separate thread pool where long blocking operations are not allowed, but that the bulk of the heavy lifting // can stay single threaded. In this case we would need a separate thread pool, but we still minimise the amount of // thread safe code we need to write and test. // // (4) None of the above are sufficient and we need to run all messages in parallel to get maximum (single machine) // scalability and fully saturate all cores. In that case we can go fully free-threaded, e.g. change the number '1' // below to some multiple of the core count. Alternatively by using the ForkJoinPool and let it figure out the right // number of threads by itself. This will require some investment in stress testing to build confidence that we // haven't made any mistakes, but it will only be necessary if eventual deployment scenarios demand it. // // Note that the messaging subsystem schedules work onto this thread in a blocking manner. That means if the server // thread becomes too slow and a backlog of work starts to builds up it propagates back through into the messaging // layer, which can then react to the backpressure. Artemis MQ in particular knows how to do flow control by paging // messages to disk rather than letting us run out of RAM. // // The primary work done by the server thread is execution of flow logics, and related // serialisation/deserialisation work. override fun makeMessagingService(): MessagingService { return P2PMessagingClient( config = configuration, versionInfo = versionInfo, serverAddress = configuration.messagingServerAddress ?: NetworkHostAndPort("localhost", configuration.p2pAddress.port), nodeExecutor = serverThread, database = database, networkMap = networkMapCache, isDrainingModeOn = nodeProperties.flowsDrainingMode::isEnabled, drainingModeWasChangedEvents = nodeProperties.flowsDrainingMode.values, metricRegistry = metricRegistry, cacheFactory = cacheFactory ) } override fun startMessagingService( rpcOps: RPCOps, nodeInfo: NodeInfo, myNotaryIdentity: PartyAndCertificate?, networkParameters: NetworkParameters ) { require(nodeInfo.legalIdentities.size in 1..2) { "Currently nodes must have a primary address and optionally one serviced address" } network as P2PMessagingClient if (System.getProperty("io.netty.allocator.numHeapArenas").isNullOrBlank()) { // Netty arenas are approx 16MB each when max'd out. Set arenas based on memory, not core count, unless memory is abundant. val memBasedArenas = max(Runtime.getRuntime().maxMemory() / 256.MB, 1L) // We set the min of the above and the default. System.setProperty("io.netty.allocator.numHeapArenas", min(memBasedArenas, NettyRuntime.availableProcessors() * 2L).toString()) } // Construct security manager reading users data either from the 'security' config section // if present or from rpcUsers list if the former is missing from config. val securityManagerConfig = configuration.security?.authService ?: SecurityConfiguration.AuthService.fromUsers(configuration.rpcUsers) val securityManager = with(RPCSecurityManagerImpl(securityManagerConfig, cacheFactory)) { if (configuration.shouldStartLocalShell()) RPCSecurityManagerWithAdditionalUser(this, User(INTERNAL_SHELL_USER, INTERNAL_SHELL_USER, setOf(Permissions.all()))) else this } val messageBroker = if (!configuration.messagingServerExternal) { val brokerBindAddress = configuration.messagingServerAddress ?: NetworkHostAndPort("0.0.0.0", configuration.p2pAddress.port) ArtemisMessagingServer(configuration, brokerBindAddress, networkParameters.maxMessageSize) } else { null } val rpcServerAddresses = if (configuration.rpcOptions.standAloneBroker) { BrokerAddresses(configuration.rpcOptions.address, configuration.rpcOptions.adminAddress) } else { startLocalRpcBroker(securityManager) } val bridgeControlListener = makeBridgeControlListener(network.serverAddress, networkParameters) printBasicNodeInfo("Advertised P2P messaging addresses", nodeInfo.addresses.joinToString()) val rpcServerConfiguration = RPCServerConfiguration.DEFAULT rpcServerAddresses?.let { internalRpcMessagingClient = InternalRPCMessagingClient(configuration.p2pSslOptions, it.admin, MAX_RPC_MESSAGE_SIZE, CordaX500Name.build(configuration.p2pSslOptions.keyStore.get()[X509Utilities.CORDA_CLIENT_TLS].subjectX500Principal), rpcServerConfiguration) printBasicNodeInfo("RPC connection address", it.primary.toString()) printBasicNodeInfo("RPC admin connection address", it.admin.toString()) } // Start up the embedded MQ server messageBroker?.apply { closeOnStop() start() } rpcBroker?.apply { closeOnStop() start() } // Start P2P bridge service bridgeControlListener.apply { closeOnStop() start() } // Start up the MQ clients. internalRpcMessagingClient?.run { closeOnStop() init(rpcOps, securityManager, cacheFactory) } network.closeOnStop() network.start( myIdentity = nodeInfo.legalIdentities[0].owningKey, serviceIdentity = if (nodeInfo.legalIdentities.size == 1) null else nodeInfo.legalIdentities[1].owningKey, advertisedAddress = nodeInfo.addresses[0], maxMessageSize = networkParameters.maxMessageSize ) } private fun makeBridgeControlListener(serverAddress: NetworkHostAndPort, networkParameters: NetworkParameters): BridgeControlListener { val artemisMessagingClientFactory = { ArtemisMessagingClient( configuration.p2pSslOptions, serverAddress, networkParameters.maxMessageSize, failoverCallback = { errorAndTerminate("ArtemisMessagingClient failed. Shutting down.", null) } ) } return BridgeControlListener(configuration.p2pSslOptions, networkParameters.maxMessageSize, configuration.crlCheckSoftFail, artemisMessagingClientFactory) } private fun startLocalRpcBroker(securityManager: RPCSecurityManager): BrokerAddresses? { return with(configuration) { rpcOptions.address.let { val rpcBrokerDirectory: Path = baseDirectory / "brokers" / "rpc" with(rpcOptions) { rpcBroker = if (useSsl) { ArtemisRpcBroker.withSsl(configuration.p2pSslOptions, this.address, adminAddress, sslConfig!!, securityManager, MAX_RPC_MESSAGE_SIZE, jmxMonitoringHttpPort != null, rpcBrokerDirectory, shouldStartLocalShell()) } else { ArtemisRpcBroker.withoutSsl(configuration.p2pSslOptions, this.address, adminAddress, securityManager, MAX_RPC_MESSAGE_SIZE, jmxMonitoringHttpPort != null, rpcBrokerDirectory, shouldStartLocalShell()) } } rpcBroker!!.addresses } } } override fun myAddresses(): List&lt;NetworkHostAndPort&gt; = listOf(getAdvertisedAddress()) + configuration.additionalP2PAddresses private fun getAdvertisedAddress(): NetworkHostAndPort { return with(configuration) { require(p2pAddress.host != "0.0.0.0") { "Invalid p2pAddress: $p2pAddress contains 0.0.0.0 which is not suitable as an advertised node address" } val host = if (detectPublicIp) { tryDetectIfNotPublicHost(p2pAddress.host) ?: p2pAddress.host } else { p2pAddress.host } NetworkHostAndPort(host, p2pAddress.port) } } /** * Checks whether the specified [host] is a public IP address or hostname. If not, tries to discover the current * machine's public IP address to be used instead by looking through the network interfaces. */ private fun tryDetectIfNotPublicHost(host: String): String? { return if (host.toLowerCase() == "localhost") { log.warn("p2pAddress specified as localhost. Trying to autodetect a suitable public address to advertise in network map." + "To disable autodetect set detectPublicIp = false in the node.conf, or consider using messagingServerAddress and messagingServerExternal") val foundPublicIP = AddressUtils.tryDetectPublicIP() if (foundPublicIP == null) { try { val retrievedHostName = networkMapClient?.myPublicHostname() if (retrievedHostName != null) { log.info("Retrieved public IP from Network Map Service: $this. This will be used instead of the provided \"$host\" as the advertised address.") } retrievedHostName } catch (ignore: Exception) { // Cannot reach the network map service, ignore the exception and use provided P2P address instead. log.warn("Cannot connect to the network map service for public IP detection.") null } } else { log.info("Detected public IP: ${foundPublicIP.hostAddress}. This will be used instead of the provided \"$host\" as the advertised address.") foundPublicIP.hostAddress } } else { null } } /** * If the node is persisting to an embedded H2 database, then expose this via TCP with a DB URL of the form: * jdbc:h2:tcp://&lt;host&gt;:&lt;port&gt;/node * with username and password as per the DataSource connection details. The key element to enabling this support is to * ensure that you specify a DB connection URL of the form jdbc:h2:file: in the node config and that you include * the H2 option AUTO_SERVER_PORT set to the port you desire to use (0 will give a dynamically allocated port number) * but exclude the H2 option AUTO_SERVER=TRUE. * This is not using the H2 "automatic mixed mode" directly but leans on many of the underpinnings. For more details * on H2 URLs and configuration see: http://www.h2database.com/html/features.html#database_url */ override fun startDatabase() { val databaseUrl = configuration.dataSourceProperties.getProperty("dataSource.url") val h2Prefix = "jdbc:h2:file:" if (databaseUrl != null &amp;&amp; databaseUrl.startsWith(h2Prefix)) { val effectiveH2Settings = configuration.effectiveH2Settings // forbid execution of arbitrary code via SQL except those classes required by H2 itself System.setProperty("h2.allowedClasses", "org.h2.mvstore.db.MVTableEngine,org.locationtech.jts.geom.Geometry,org.h2.server.TcpServer") if (effectiveH2Settings?.address != null) { if (!InetAddress.getByName(effectiveH2Settings.address.host).isLoopbackAddress &amp;&amp; configuration.dataSourceProperties.getProperty("dataSource.password").isBlank()) { throw CouldNotCreateDataSourceException("Database password is required for H2 server listening on ${InetAddress.getByName(effectiveH2Settings.address.host)}.") } val databaseName = databaseUrl.removePrefix(h2Prefix).substringBefore(';') val baseDir = Paths.get(databaseName).parent.toString() val server = org.h2.tools.Server.createTcpServer( "-tcpPort", effectiveH2Settings.address.port.toString(), "-tcpAllowOthers", "-tcpDaemon", "-baseDir", baseDir, "-key", "node", databaseName) // override interface that createTcpServer listens on (which is always 0.0.0.0) System.setProperty("h2.bindAddress", effectiveH2Settings.address.host) runOnStop += server::stop val url = try { server.start().url } catch (e: JdbcSQLNonTransientConnectionException) { if (e.cause is BindException) { throw AddressBindingException(effectiveH2Settings.address) } else { throw e } } printBasicNodeInfo("Database connection url is", "jdbc:h2:$url/node") } } super.startDatabase() database.closeOnStop() } private val _startupComplete = openFuture&lt;Unit&gt;() val startupComplete: CordaFuture&lt;Unit&gt; get() = _startupComplete override fun generateAndSaveNodeInfo(): NodeInfo { initialiseSerialization() return super.generateAndSaveNodeInfo() } override fun start(): NodeInfo { registerDefaultExceptionHandler() initialiseSerialization() val nodeInfo: NodeInfo = super.start() nodeReadyFuture.thenMatch({ serverThread.execute { registerJmxReporter(services.monitoringService.metrics) _startupComplete.set(Unit) } }, { th -&gt; staticLog.error("Unexpected exception", th) } // XXX: Why not use log? ) shutdownHook = addShutdownHook { stop() } return nodeInfo } /** * Register a default exception handler for all threads that terminates the process if the database connection goes away and * cannot be recovered. */ private fun registerDefaultExceptionHandler() { Thread.setDefaultUncaughtExceptionHandler(DbExceptionHandler(Thread.getDefaultUncaughtExceptionHandler())) } /** * A hook to allow configuration override of the JmxReporter being used. */ fun registerJmxReporter(metrics: MetricRegistry) { log.info("Registering JMX reporter:") when (configuration.jmxReporterType) { JmxReporterType.JOLOKIA -&gt; registerJolokiaReporter(metrics) JmxReporterType.NEW_RELIC -&gt; registerNewRelicReporter(metrics) } } private fun registerJolokiaReporter(registry: MetricRegistry) { log.info("Registering Jolokia JMX reporter:") // Begin exporting our own metrics via JMX. These can be monitored using any agent, e.g. Jolokia: // // https://jolokia.org/agent/jvm.html JmxReporter.forRegistry(registry).inDomain("net.corda").createsObjectNamesWith { _, domain, name -&gt; // Make the JMX hierarchy a bit better organised. val category = name.substringBefore('.').substringBeforeLast('/') val component = name.substringBefore('.').substringAfterLast('/', "") val subName = name.substringAfter('.', "") (if (subName == "") ObjectName("$domain:name=$category${if (component.isNotEmpty()) ",component=$component," else ""}") else ObjectName("$domain:type=$category,${if (component.isNotEmpty()) "component=$component," else ""}name=$subName")) }.build().start() } private fun registerNewRelicReporter(registry: MetricRegistry) { log.info("Registering New Relic JMX Reporter:") val reporter = NewRelicReporter.forRegistry(registry) .name("New Relic Reporter") .filter(MetricFilter.ALL) .attributeFilter(AllEnabledMetricAttributeFilter()) .rateUnit(TimeUnit.SECONDS) .durationUnit(TimeUnit.MILLISECONDS) .metricNamePrefix("corda/") .build() reporter.start(1, TimeUnit.MINUTES) } override val rxIoScheduler: Scheduler get() = Schedulers.io() private fun initialiseSerialization() { if (!initialiseSerialization) return val classloader = cordappLoader.appClassLoader nodeSerializationEnv = SerializationEnvironment.with( SerializationFactoryImpl().apply { registerScheme(AMQPServerSerializationScheme(cordappLoader.cordapps, Caffeine.newBuilder().maximumSize(128).build&lt;SerializationFactoryCacheKey, SerializerFactory&gt;().asMap())) registerScheme(AMQPClientSerializationScheme(cordappLoader.cordapps, Caffeine.newBuilder().maximumSize(128).build&lt;SerializationFactoryCacheKey, SerializerFactory&gt;().asMap())) }, p2pContext = AMQP_P2P_CONTEXT.withClassLoader(classloader), rpcServerContext = AMQP_RPC_SERVER_CONTEXT.withClassLoader(classloader), rpcClientContext = if (configuration.shouldInitCrashShell()) AMQP_RPC_CLIENT_CONTEXT.withClassLoader(classloader) else null, // even Shell embeded in the node connects via RPC to the node storageContext = AMQP_STORAGE_CONTEXT.withClassLoader(classloader), checkpointSerializer = KryoCheckpointSerializer, checkpointContext = KRYO_CHECKPOINT_CONTEXT.withClassLoader(classloader) ) } /** Starts a blocking event loop for message dispatch. */ fun run() { internalRpcMessagingClient?.start(rpcBroker!!.serverControl) (network as P2PMessagingClient).run() } private var shutdown = false override fun stop() { check(!serverThread.isOnThread) synchronized(this) { if (shutdown) return shutdown = true // Unregister shutdown hook to prevent any unnecessary second calls to stop shutdownHook?.cancel() shutdownHook = null } printBasicNodeInfo("Shutting down ...") // All the Node started subsystems were registered with the runOnStop list at creation. // So now simply call the parent to stop everything in reverse order. // In particular this prevents premature shutdown of the Database by AbstractNode whilst the serverThread is active super.stop() shutdown = false log.info("Shutdown complete") } fun &lt;T : FlowLogic&lt;*&gt;&gt; registerInitiatedFlow(smm: StateMachineManager, initiatedFlowClass: Class&lt;T&gt;) { this.flowManager.registerInitiatedFlow(initiatedFlowClass) } }</ID>
    <ID>MaxLineLength:Node.kt$Node.Companion$println("You are using a version of Java that is not supported (${SystemUtils.JAVA_VERSION}). Please upgrade to the latest version of Java 8.")</ID>
    <ID>MaxLineLength:Node.kt$Node.Companion${ val update = getJavaUpdateVersion(SystemUtils.JAVA_VERSION) // To filter out cases like 1.8.0_202-ea SystemUtils.IS_JAVA_1_8 &amp;&amp; update &gt;= 171 }</ID>
    <ID>MaxLineLength:Node.kt$NodeWithInfo$fun &lt;T : FlowLogic&lt;*&gt;&gt; registerInitiatedFlow(initiatedFlowClass: Class&lt;T&gt;)</ID>
    <ID>MaxLineLength:Node.kt$NodeWithInfo$val services: StartedNodeServices = object : StartedNodeServices, ServiceHubInternal by node.services, FlowStarter by node.flowStarter {}</ID>
    <ID>MaxLineLength:NodeAdder.kt$NodeAdder$?:</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$/** * This caches contract attachment versions by contract class name. For each version, we support one signed and one unsigned attachment, since that is allowed. * * It is correctly invalidated as new attachments are uploaded. */ private val contractsCache = InfrequentlyMutatedCache&lt;ContractClassName, NavigableMap&lt;Version, AttachmentIds&gt;&gt;("NodeAttachmentService_contractAttachmentVersions", cacheFactory)</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$AttachmentSort.AttachmentSortColumn(AttachmentSort.AttachmentSortAttribute.INSERTION_DATE, Sort.Direction.DESC)</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$ContractAttachment</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$HashCheckingStream : FilterInputStream</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$HashMismatchException : CordaRuntimeException</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$log.warn("(Dev Mode) Multiple signed attachments ${signed.map { it.toString() }} for contract $contractClassName version '${it.key}'.")</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$log.warn("Selecting attachment ${unsigned.first()} from duplicated, unsigned attachments ${unsigned.map { it.toString() }} for contract $contractClassName version '${it.key}'.")</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$log.warn("Several versions based on whitelistedContractImplementations position are available: ${versions.toSet()}. $msg")</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$private</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$require(inputStream !is JarInputStream) { "Input stream must not be a JarInputStream" } // Read the file into RAM and then calculate its hash. The attachment must fit into memory. // TODO: Switch to a two-phase insert so we can handle attachments larger than RAM. // To do this we must pipe stream into the database without knowing its hash, which we will learn only once // the insert/upload is complete. We can then query to see if it's a duplicate and if so, erase, and if not // set the hash field of the new attachment record. val bytes = inputStream.readFully() val id = bytes.sha256() if (!hasAttachment(id)) { checkIsAValidJAR(bytes.inputStream()) val jarSigners = getSigners(bytes) val contractVersion = increaseDefaultVersionIfWhitelistedAttachment(contractClassNames, getVersion(bytes), id) val session = currentDBSession() val attachment = NodeAttachmentService.DBAttachment( attId = id.toString(), content = bytes, uploader = uploader, filename = filename, contractClassNames = contractClassNames, signers = jarSigners, version = contractVersion ) session.save(attachment) attachmentCount.inc() log.info("Stored new attachment: id=$id uploader=$uploader filename=$filename") contractClassNames.forEach { contractsCache.invalidate(it) } return@withContractsInJar id } if (isUploaderTrusted(uploader)) { val session = currentDBSession() val attachment = session.get(NodeAttachmentService.DBAttachment::class.java, id.toString()) // update the `uploader` field (as the existing attachment may have been resolved from a peer) if (attachment.uploader != uploader) { attachment.uploader = uploader log.info("Updated attachment $id with uploader $uploader") contractClassNames.forEach { contractsCache.invalidate(it) } loadAttachmentContent(id)?.let { attachmentAndContent -&gt; // TODO: this is racey. ENT-2870 attachmentContentCache.put(id, Optional.of(attachmentAndContent)) attachmentCache.put(id, Optional.of(attachmentAndContent.first)) } return@withContractsInJar id } // If the uploader is the same, throw the exception because the attachment cannot be overridden by the same uploader. } throw DuplicateAttachmentException(id.toString())</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$val attachmentImpl = AttachmentImpl(id, { attachment.content }, checkAttachmentsOnLoad, attachment.uploader).let { val contracts = attachment.contractClassNames if (contracts != null &amp;&amp; contracts.isNotEmpty()) { ContractAttachment.create(it, contracts.first(), contracts.drop(1).toSet(), attachment.uploader, attachment.signers?.toList() ?: emptyList(), attachment.version) } else { it } }</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$val attachmentQueryCriteria = AttachmentQueryCriteria.AttachmentsQueryCriteria(contractClassNamesCondition = Builder.equal(listOf(name)), versionCondition = Builder.greaterThanOrEqual(0), uploaderCondition = Builder.`in`(TRUSTED_UPLOADERS))</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$val attachmentSort = AttachmentSort(listOf(AttachmentSort.AttachmentSortColumn(AttachmentSort.AttachmentSortAttribute.VERSION, Sort.Direction.DESC), AttachmentSort.AttachmentSortColumn(AttachmentSort.AttachmentSortAttribute.INSERTION_DATE, Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$val contractVersion = increaseDefaultVersionIfWhitelistedAttachment(contractClassNames, getVersion(bytes), id)</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$val versions = contractClassNames.mapNotNull { servicesForResolution.networkParameters.whitelistedContractImplementations[it]?.indexOf(attachmentId) } .filter { it &gt;= 0 }.map { it + 1 } // +1 as versions starts from 1 not 0</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$weigher = Weigher&lt;SecureHash, Optional&lt;Pair&lt;Attachment, ByteArray&gt;&gt;&gt; { key, value -&gt; key.size + if (value.isPresent) value.get().second.size else 0 }</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService${ val session = currentDBSession() val attachment = session.get(NodeAttachmentService.DBAttachment::class.java, id.toString()) // update the `uploader` field (as the existing attachment may have been resolved from a peer) if (attachment.uploader != uploader) { attachment.uploader = uploader log.info("Updated attachment $id with uploader $uploader") contractClassNames.forEach { contractsCache.invalidate(it) } loadAttachmentContent(id)?.let { attachmentAndContent -&gt; // TODO: this is racey. ENT-2870 attachmentContentCache.put(id, Optional.of(attachmentAndContent)) attachmentCache.put(id, Optional.of(attachmentAndContent.first)) } return@withContractsInJar id } // If the uploader is the same, throw the exception because the attachment cannot be overridden by the same uploader. }</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.AttachmentImpl$return if (checkOnLoad &amp;&amp; id is SecureHash.SHA256) HashCheckingStream(id, attachmentData.size, stream) else stream</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.AttachmentImpl.Token$override fun fromToken(context: SerializeAsTokenContext)</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.AttachmentImpl.Token$private</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.Companion$// Just iterate over the entries with verification enabled: should be good enough to catch mistakes. // Note that JarInputStream won't throw any kind of error at all if the file stream is in fact not // a ZIP! It'll just pretend it's an empty archive, which is kind of stupid but that's how it works. // So we have to check to ensure we found at least one item. // // For signed Jars add additional checks to close security holes left by the default jarSigner verifier: // - All entries listed in the Manifest are in the JAR file. // - No extra files in the JAR that were not listed in the Manifest. // Together with the check that all entries need to be signed by the same signers that is performed when the signers are read, // it should close any possibility of foul play. internal fun checkIsAValidJAR(stream: InputStream)</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.Companion$if (manifestHasEntries &amp;&amp; !allManifestEntries!!.remove(cursor.name)) extraFilesNotFoundInEntries.add(cursor)</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.Companion$private val PRIVILEGED_UPLOADERS = listOf(DEPLOYED_CORDAPP_UPLOADER, RPC_UPLOADER, P2P_UPLOADER, UNKNOWN_UPLOADER)</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.Companion$require(!('\\' in cursor.name || cursor.name == "." || cursor.name == "..")) { "Bad character in $entryPath" }</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.Companion$throw SecurityException("Signed jar has been tampered with. Files $allManifestEntries have been removed.")</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.Companion$throw SecurityException("Signed jar has been tampered with. Files $extraSignableFiles have been added to the JAR.")</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.Companion$val extraSignableFiles = extraFilesNotFoundInEntries.filterNot { JarSignatureCollector.isNotSignable(it) }</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.DBAttachment$( @Id @Column(name = "att_id", nullable = false) var attId: String, @Column(name = "content", nullable = false) @Lob var content: ByteArray, @Column(name = "insertion_date", nullable = false, updatable = false) var insertionDate: Instant = Instant.now(), @Column(name = "uploader", nullable = true) var uploader: String? = null, @Column(name = "filename", updatable = false, nullable = true) var filename: String? = null, @ElementCollection @Column(name = "contract_class_name", nullable = false) @CollectionTable(name = "${NODE_DATABASE_PREFIX}attachments_contracts", joinColumns = [(JoinColumn(name = "att_id", referencedColumnName = "att_id"))], foreignKey = ForeignKey(name = "FK__ctr_class__attachments")) var contractClassNames: List&lt;ContractClassName&gt;? = null, @ElementCollection(targetClass = PublicKey::class, fetch = FetchType.EAGER) @Column(name = "signer", nullable = false) @CollectionTable(name = "${NODE_DATABASE_PREFIX}attachments_signers", joinColumns = [(JoinColumn(name = "att_id", referencedColumnName = "att_id"))], foreignKey = ForeignKey(name = "FK__signers__attachments")) var signers: List&lt;PublicKey&gt;? = null, // Assumption: only Contract Attachments are versioned, version unknown or value for other attachments other than Contract Attachment defaults to 1 @Column(name = "version", nullable = false) var version: Int = DEFAULT_CORDAPP_VERSION )</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.DBAttachment$@CollectionTable(name = "${NODE_DATABASE_PREFIX}attachments_contracts", joinColumns = [(JoinColumn(name = "att_id", referencedColumnName = "att_id"))], foreignKey = ForeignKey(name = "FK__ctr_class__attachments"))</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.DBAttachment$@CollectionTable(name = "${NODE_DATABASE_PREFIX}attachments_signers", joinColumns = [(JoinColumn(name = "att_id", referencedColumnName = "att_id"))], foreignKey = ForeignKey(name = "FK__signers__attachments"))</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$(uploaderCondition("complexB").and(filenamerCondition("archiveB.zip"))).or(filenamerCondition("archiveC.zip"))</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `The strict JAR verification function fails signed JARs with removed or extra files that are valid according to the usual jarsigner`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `attachments can be queried by providing a intersection of signers using an EQUAL statement - EQUAL containing a single public key`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `attachments can be queried by providing a intersection of signers using an EQUAL statement - EQUAL containing multiple public keys`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `can import duplicated contract class and version from signed attachment if an unsigned attachment already exists`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `can import duplicated contract class and version from unsigned attachment if a signed attachment already exists`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `can import jar with duplicated contract class, version and signers - when one uploader is trusted and other isnt`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `can promote to trusted uploader if other trusted attachment already has duplicated contract class, version and signers`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `development mode - retrieve latest versions of signed contracts - multiple versions of same version id exist in store`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$AttachmentSort(listOf(AttachmentSort.AttachmentSortColumn(AttachmentSort.AttachmentSortAttribute.VERSION)))</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertEquals(listOf(jarAndSigner.second.hash), storage.openAttachment(attachmentId)!!.signerKeys.map { it.hash })</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertFalse(isAttachmentTrusted(storage.openAttachment(attachmentC)!!, storage), "Contract $attachmentC should not be trusted (no chain of trust)")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertFalse(isAttachmentTrusted(storage.openAttachment(v1Id)!!, storage), "Initial attachment $v1Id should not be trusted")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertFalse(isAttachmentTrusted(storage.openAttachment(v1Id)!!, storage), "Initial contract $v1Id should not be trusted")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertFalse(isAttachmentTrusted(storage.openAttachment(v2Id)!!, storage), "Other attachment $v2Id should not be trusted")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertFalse(isAttachmentTrusted(storage.openAttachment(v2Id)!!, storage), "Upgraded contract $v2Id should not be trusted")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertThat((storage.openAttachment(expectedAttachmentId) as ContractAttachment).uploader).isEqualTo(initialUploader)</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertThat((storage.openAttachment(expectedAttachmentId) as ContractAttachment).uploader).isEqualTo(trustedUploader)</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertThatThrownBy { attachment.read { storage.privilegedImportAttachment(it, untrustedUploader, null) } }.isInstanceOf(DuplicateAttachmentException::class.java)</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertTrue(isAttachmentTrusted(storage.openAttachment(attachmentA)!!, storage), "Contract $attachmentA should be trusted")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertTrue(isAttachmentTrusted(storage.openAttachment(attachmentB)!!, storage), "Contract $attachmentB should inherit trust")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertTrue(isAttachmentTrusted(storage.openAttachment(attachmentId)!!, storage), "Attachment $attachmentId should be trusted but isn't")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertTrue(isAttachmentTrusted(storage.openAttachment(signedId)!!, storage), "Signed contract $signedId should be trusted but isn't")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertTrue(isAttachmentTrusted(storage.openAttachment(unsignedId)!!, storage), "Unsigned contract $unsignedId should be trusted but isn't")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertTrue(isAttachmentTrusted(storage.openAttachment(v1Id)!!, storage), "Initial attachment $v1Id should be trusted")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertTrue(isAttachmentTrusted(storage.openAttachment(v1Id)!!, storage), "Initial attachment $v1Id should not be trusted")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertTrue(isAttachmentTrusted(storage.openAttachment(v1Id)!!, storage), "Initial contract $v1Id should be trusted")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertTrue(isAttachmentTrusted(storage.openAttachment(v2Id)!!, storage), "Other attachment $v2Id should be trusted")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertTrue(isAttachmentTrusted(storage.openAttachment(v2Id)!!, storage), "Upgraded contract $v2Id should be trusted")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$contractClassNamesCondition = Builder.equal(listOf("com.example.MyContract", "com.example.AnotherContract"))</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$contractJarV2.read { attachmentIdV2Unsigned = storage.privilegedImportAttachment(it, "app", "contract-V2.jar") }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$fun filenameSort(direction: Sort.Direction)</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$signedContractJar.read { attachmentIdV1Signed = storage.privilegedImportAttachment(it, "app", "contract-signed.jar") }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$signedContractJarSameVersion.read { attachmentIdSameVersionLatest = devModeStorage.privilegedImportAttachment(it, "app", "contract-signed-same-version.jar") }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$signedContractJarV2.read { attachmentIdV2Signed = storage.privilegedImportAttachment(it, "app", "contract-signed-V2.jar") }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$storage.queryAttachments(AttachmentsQueryCriteria(contractClassNamesCondition = Builder.equal(listOf("com.example.MyContract")))).size</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$storage.queryAttachments(AttachmentsQueryCriteria(signersCondition = Builder.equal(listOf(publicKey)))).size</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val (signedContractJarSameVersion, _) = makeTestSignedContractJar(file.path, "com.example.MyContract", versionSeed = Random().nextInt())</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val alias = "testAlias" val password = "testPassword" // Directly use the ContractJarTestUtils version of makeTestJar to ensure jars are created in the right place, in order to sign // them. var counter = 0 val jarV1 = file.path / "$counter.jar" ContractJarTestUtils.makeTestJar(jarV1.outputStream()) counter++ val jarV2 = file.path / "$counter.jar" // Ensure that the first and second jars do not have the same hash ContractJarTestUtils.makeTestJar(jarV2.outputStream(), entries = listOf(Pair("foo", "bar"))) file.path.generateKey(alias, password) val key1 = file.path.signJar(jarV1.toAbsolutePath().toString(), alias, password) val key2 = file.path.signJar(jarV2.toAbsolutePath().toString(), alias, password) val v1Id = jarV1.read { storage.privilegedImportAttachment(it, "app", "dummy-attachment.jar") } val v2Id = jarV2.read { storage.privilegedImportAttachment(it, "untrusted", "dummy-attachment-2.jar") } // Sanity check. assertEquals(key1, key2, "Different public keys used to sign jars") assertTrue(isAttachmentTrusted(storage.openAttachment(v1Id)!!, storage), "Initial attachment $v1Id should be trusted") assertTrue(isAttachmentTrusted(storage.openAttachment(v2Id)!!, storage), "Other attachment $v2Id should be trusted")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val alias = "testAlias" val password = "testPassword" // Directly use the ContractJarTestUtils version of makeTestJar to ensure jars are created in the right place, in order to sign // them. var counter = 0 val jarV1 = file.path / "$counter.jar" ContractJarTestUtils.makeTestJar(jarV1.outputStream()) counter++ val jarV2 = file.path / "$counter.jar" // Ensure that the first and second jars do not have the same hash ContractJarTestUtils.makeTestJar(jarV2.outputStream(), entries = listOf(Pair("foo", "bar"))) file.path.generateKey(alias, password) val key1 = file.path.signJar(jarV1.toAbsolutePath().toString(), alias, password) val key2 = file.path.signJar(jarV2.toAbsolutePath().toString(), alias, password) val v1Id = jarV1.read { storage.privilegedImportAttachment(it, "untrusted", "dummy-attachment.jar") } val v2Id = jarV2.read { storage.privilegedImportAttachment(it, "untrusted", "dummy-attachment-2.jar") } // Sanity check. assertEquals(key1, key2, "Different public keys used to sign jars") assertFalse(isAttachmentTrusted(storage.openAttachment(v1Id)!!, storage), "Initial attachment $v1Id should not be trusted") assertFalse(isAttachmentTrusted(storage.openAttachment(v2Id)!!, storage), "Other attachment $v2Id should not be trusted")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val anotherAttachmentId = anotherContractJar.read { storage.privilegedImportAttachment(it, "app", "another-sample.jar") }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val anotherContractJar = makeTestContractJar(file.path, listOf("com.example.MyContract", "com.example.AnotherContract"), generateManifest = false, jarFileName = "another-sample.jar")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val anotherContractJar = makeTestContractJar(file.path, listOf("com.example.MyContract", "com.example.AnotherContract"), true, generateManifest = false, jarFileName = "another-sample.jar")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val attachmentB = jarSignedByAB.read { storage.privilegedImportAttachment(it, "untrusted", "dummy-contract.jar") }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val attachmentC = jarSignedByBC.read { storage.privilegedImportAttachment(it, "untrusted", "dummy-contract.jar") }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val attachments = storage.queryAttachments(AttachmentsQueryCriteria(contractClassNamesCondition = Builder.equal(listOf("com.example.MyContract"))))</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val corruptAttachment = NodeAttachmentService.DBAttachment(attId = id.toString(), content = bytes, version = DEFAULT_CORDAPP_VERSION)</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val overriddenAttachmentId = attachment.read { storage.privilegedImportAttachment(it, trustedUploader, null) }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val reimportedAttachmentId = contractJar.read { storage.privilegedImportAttachment(it, "app", "sample.jar") }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val signedAttachments = storage.queryAttachments(AttachmentsQueryCriteria(isSignedCondition = Builder.equal(true)))</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val unsignedAttachments = storage.queryAttachments(AttachmentsQueryCriteria(isSignedCondition = Builder.equal(false)))</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest.FetchAttachmentsFlow$serviceHub.attachments.importAttachment(baos.toByteArray().inputStream(), "$P2P_UPLOADER:${ourIdentity.name}", null)</ID>
    <ID>MaxLineLength:NodeBasedTest.kt$InProcessNode$assertFalse(isInvalidJavaVersion(), "You are using a version of Java that is not supported (${SystemUtils.JAVA_VERSION}). Please upgrade to the latest version of Java 8.")</ID>
    <ID>MaxLineLength:NodeBasedTest.kt$NodeBasedTest</ID>
    <ID>MaxLineLength:NodeBasedTest.kt$NodeBasedTest$val customCordapps = cordappsForPackages(getCallerPackage(NodeBasedTest::class)?.let { cordappPackages + it } ?: cordappPackages)</ID>
    <ID>MaxLineLength:NodeBasedTest.kt$NodeBasedTest$val node = InProcessNode(parsedConfig, MOCK_VERSION_INFO.copy(platformVersion = platformVersion), flowManager = flowManager)</ID>
    <ID>MaxLineLength:NodeBuilder.kt$NodeBuilder$localDockerClient.buildImageCmd() .withDockerfile(File(nodeDir, "Dockerfile")) .withBaseDirectory(nodeDir)</ID>
    <ID>MaxLineLength:NodeBuilder.kt$NodeBuilder.&lt;no name provided&gt;$future.completeExceptionally(IllegalStateException("Could not build image for: $nodeDir, reason: ${result?.errorDetail}"))</ID>
    <ID>MaxLineLength:NodeBuilder.kt$NodeBuilder.&lt;no name provided&gt;$val config = nodeConfig.parseAsNodeConfigWithFallback(ConfigFactory.parseFile(copiedNode.configFile)).value()</ID>
    <ID>MaxLineLength:NodeBuilder.kt$fun Config.parseAsNodeConfigWithFallback(preCopyConfig: Config): Validated&lt;NodeConfiguration, Configuration.Validation.Error&gt;</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$InitialRegistrationCmdLineOptions$"Cannot perform initial registration when 'devMode' is true, unless 'devModeOptions.allowCompatibilityZone' is also true."</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$InitialRegistrationCmdLineOptions$"compatibilityZoneURL or networkServices must be present in the node configuration file in registration mode."</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$NodeCmdLineOptions$"compatibilityZoneURL or networkServices must be present in the node configuration file in registration mode."</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$NodeCmdLineOptions$description = ["DEPRECATED. Clears local copy of network map, on node startup it will be restored from server or file system."]</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$NodeCmdLineOptions$description = ["DEPRECATED. Performs the node start-up tasks necessary to generate the nodeInfo file, saves it to disk, then exits."]</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$NodeCmdLineOptions$description = ["DEPRECATED. Starts initial node registration with Corda network to obtain certificate from the permissioning server."]</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$NodeCmdLineOptions$valid(ConfigHelper.loadConfig(baseDirectory, configFile, configOverrides = ConfigFactory.parseMap(configOverrides)))</ID>
    <ID>MaxLineLength:NodeConfig.kt$NodeConfig$@VisibleForTesting internal</ID>
    <ID>MaxLineLength:NodeConfig.kt$NodeConfig$return NodeConfigurationData(myLegalName, p2pAddress, this.rpcSettings.address, notary, h2port, rpcUsers, useTestClock, detectPublicIp, devMode) .toConfig() .withoutPath("rpcAddress") .withoutPath("rpcAdminAddress") .withValue("rpcSettings", rpcSettings)</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$NetworkParameterAcceptanceSettings</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$NodeConfiguration$@Deprecated(message = "Use of single compatibility zone URL is deprecated", replaceWith = ReplaceWith("networkServices.networkMapURL"))</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$NodeConfiguration$val flowMonitorSuspensionLoggingThresholdMillis: Duration get() = DEFAULT_FLOW_MONITOR_SUSPENSION_LOGGING_THRESHOLD_MILLIS</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$SecurityConfiguration.AuthService.DataSource$AuthDataSourceType.DB -&gt; require(users == null &amp;&amp; connection != null) { "Database-backed authentication must not specify a user list, and must configure a database" }</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$SecurityConfiguration.AuthService.DataSource$AuthDataSourceType.INMEMORY -&gt; require(users != null &amp;&amp; connection == null) { "In-memory authentication must specify a user list, and must not configure a database" }</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$// TODO: There are two implications here: // 1. "signingCertificateStore" and "p2pKeyStore" have the same passwords. In the future we should re-visit this "rule" and see of they can be made different; // 2. The passwords for store and for keys in this store are the same, this is due to limitations of Artemis. override val signingCertificateStore = FileBasedCertificateStoreSupplier(signingCertificateStorePath, keyStorePassword, keyStorePassword)</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$logger</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$logger.warn("Top-level declaration of property 'rpcAddress' is deprecated. Please use 'rpcSettings.address' instead.")</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$override</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$override val flowMonitorSuspensionLoggingThresholdMillis: Duration = Defaults.flowMonitorSuspensionLoggingThresholdMillis</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$override val networkParameterAcceptanceSettings: NetworkParameterAcceptanceSettings = Defaults.networkParameterAcceptanceSettings</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$private val p2pTrustStore = FileBasedCertificateStoreSupplier(p2pTrustStoreFilePath, trustStorePassword, trustStorePassword)</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$require(h2port == null || h2Settings == null) { "Cannot specify both 'h2port' and 'h2Settings' in configuration" }</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$require(rpcSettings.address == null) { "Can't provide top-level rpcAddress and rpcSettings.address (they control the same property)." }</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$return listOf("cannot specify 'compatibilityZoneURL' when 'devMode' is true, unless 'devModeOptions.allowCompatibilityZone' is also true")</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$return listOf("cannot specify 'networkServices' when 'devMode' is true, unless 'devModeOptions.allowCompatibilityZone' is also true")</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl.Defaults$initialiseAppSchema = if (devMode) SchemaInitializationType.UPDATE else SchemaInitializationType.VALIDATE</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl.Defaults$val flowMonitorSuspensionLoggingThresholdMillis: Duration = NodeConfiguration.DEFAULT_FLOW_MONITOR_SUSPENSION_LOGGING_THRESHOLD_MILLIS</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl.Defaults$val networkParameterAcceptanceSettings: NetworkParameterAcceptanceSettings = NetworkParameterAcceptanceSettings()</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeRpcSettings.&lt;no name provided&gt;$return "address: $address, adminAddress: $adminAddress, standAloneBroker: $standAloneBroker, useSsl: $useSsl, sslConfig: $sslConfig"</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$@Test fun `validation succeeds when compatibilityZoneURL is present and devMode is true and allowCompatibilityZoneURL is set`()</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertEquals(listOf(baseDirPath / "./myCorDapps1", baseDirPath / "./myCorDapps2"), nodeConfiguration.value().cordappDirectories)</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertFalse(getConfig("test-config-DevMode.conf", ConfigFactory.parseMap(mapOf("devMode" to false))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertFalse(getConfig("test-config-empty.conf", ConfigFactory.parseMap(mapOf("devMode" to false))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertFalse(getConfig("test-config-noDevMode.conf", ConfigFactory.parseMap(mapOf("devMode" to false))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertThat(config.errors.asSequence().map(Configuration.Validation.Error::message).filter { it.contains("rpcSettings.adminAddress") }.toList()).isNotEmpty</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertThat(errors).hasOnlyOneElementSatisfying { error -&gt; error.contains("compatibilityZoneURL") &amp;&amp; error.contains("devMode") }</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertThat(errors).hasOnlyOneElementSatisfying { error -&gt; error.contains("networkServices") &amp;&amp; error.contains("devMode") }</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertThat(rawConfig.parseAsNodeConfiguration().errors.single())</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertThatThrownBy { configDebugOptions(false, debugOptions) }.hasMessageMatching("Cannot use devModeOptions outside of dev mode")</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertTrue(getConfig("test-config-DevMode.conf", ConfigFactory.parseMap(mapOf("devMode" to true))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertTrue(getConfig("test-config-empty.conf", ConfigFactory.parseMap(mapOf("devMode" to true))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertTrue(getConfig("test-config-noDevMode.conf", ConfigFactory.parseMap(mapOf("devMode" to true))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$return testConfiguration.copy(tlsCertCrlDistPoint = tlsCertCrlDistPoint, tlsCertCrlIssuer = tlsCertCrlIssuer?.let { X500Principal(it) }, crlCheckSoftFail = crlCheckSoftFail)</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$val configValidationResult = configTlsCertCrlOptions(null, "C=US, L=New York, OU=Corda, O=R3 HoldCo LLC, CN=Corda Root CA").validate()</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$val rawConfig = ConfigFactory.parseResources("working-config.conf", ConfigParseOptions.defaults().setAllowMissing(false))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$var rawConfig = ConfigFactory.parseResources("working-config.conf", ConfigParseOptions.defaults().setAllowMissing(false))</ID>
    <ID>MaxLineLength:NodeConnection.kt$NodeConnection$fun clearDb()</ID>
    <ID>MaxLineLength:NodeConnection.kt$NodeConnection$return runShellCommandGetOutput("sudo netstat -tlpn | grep ${remoteNode.rpcPort} | awk '{print $7}' | grep -oE '[0-9]+'").getResultOrThrow().replace("\n", "")</ID>
    <ID>MaxLineLength:NodeConnection.kt$NodeConnection$runShellCommandGetOutput("until sudo netstat -tlpn | grep ${remoteNode.rpcPort} &gt; /dev/null ; do sleep 1 ; done")</ID>
    <ID>MaxLineLength:NodeConnection.kt$NodeConnection$val proxy: CordaRPCOps get() = rpcConnection?.proxy ?: throw IllegalStateException("proxy requested, but the client is not running")</ID>
    <ID>MaxLineLength:NodeController.kt$NodeController$(cordappConfigDir / "${CordappController.FINANCE_WORKFLOWS_CORDAPP_FILENAME}.conf").writeText(config.nodeConfig.toFinanceConfText())</ID>
    <ID>MaxLineLength:NodeController.kt$NodeController$issuableCurrencies = nodeData.extraServices.filterIsInstance&lt;CurrencyIssuer&gt;().map { it.currency.toString() }</ID>
    <ID>MaxLineLength:NodeController.kt$NodeController$require((config.nodeConfig.notary != null).xor(notaryIdentity != null)) { "There must be exactly one notary in the network" }</ID>
    <ID>MaxLineLength:NodeController.kt$NodeController$val nextPort = 1 + arrayOf(config.p2pAddress.port, config.rpcSettings.address.port, config.webAddress.port, config.h2port).max() as Int</ID>
    <ID>MaxLineLength:NodeData.kt$SuggestedDetails$( // Mike: Rome? Why Rome? // Roger: Notaries public (also called "notaries", "notarial officers", or "public notaries") hold an office // which can trace its origins back to the ancient Roman Republic, when they were called scribae ("scribes"), // tabelliones forenses, or personae publicae.[4] // Mike: Can't argue with that. It's even got a citation. "Notary" to "Rome", "Bank of Breakfast Tea" to "Liverpool", "Bank of Big Apples" to "New York", "Bank of Baguettes" to "Paris", "Bank of Fondue" to "Geneve", "Bank of Maple Syrup" to "Toronto", "Bank of Golden Gates" to "San Francisco" )</ID>
    <ID>MaxLineLength:NodeFlowManagerTest.kt$NodeFlowManagerTest$val nodeFlowManager = NodeFlowManager(FlowOverrideConfig(listOf(FlowOverride(Init::class.qualifiedName!!, Resp::class.qualifiedName!!))))</ID>
    <ID>MaxLineLength:NodeInfo.kt$NodeInfo</ID>
    <ID>MaxLineLength:NodeInfo.kt$NodeInfoSigner$@Option(names = ["--address"], paramLabel = "host:port", description = ["Public address of node"], converter = [NetworkHostAndPortConverter::class])</ID>
    <ID>MaxLineLength:NodeInfo.kt$NodeInfoSigner$@Option(names = ["--platform-version"], paramLabel = "int", description = ["Platform version that this node supports"])</ID>
    <ID>MaxLineLength:NodeInfo.kt$NodeInfoSigner$require(keyStorePath != null &amp;&amp; keyAlias != null) { "The --keystore and --keyalias parameters must be specified" }</ID>
    <ID>MaxLineLength:NodeInfo.kt$NodeInfoSigner.AMQPInspectorSerializationScheme$override</ID>
    <ID>MaxLineLength:NodeInfoFilesCopier.kt$NodeInfoFilesCopier$atomicCopy(previouslySeenFile, newNodeFile.additionalNodeInfoDirectory.resolve(previouslySeenFile.fileName))</ID>
    <ID>MaxLineLength:NodeInfoFilesCopier.kt$NodeInfoFilesCopier$for (destination in this.values.filter { it.nodeDir != nodeData.nodeDir }.map { it.additionalNodeInfoDirectory }) { val fullDestinationPath = destination.resolve(path.fileName) atomicCopy(path, fullDestinationPath) }</ID>
    <ID>MaxLineLength:NodeInfoFilesCopier.kt$NodeInfoFilesCopier$private fun allPreviouslySeenFiles()</ID>
    <ID>MaxLineLength:NodeInfoSchema.kt$NodeInfoSchemaV1$mappedTypes = listOf(PersistentNodeInfo::class.java, DBPartyAndCertificate::class.java, DBHostAndPort::class.java, NodePropertiesPersistentStore.DBNodeProperty::class.java)</ID>
    <ID>MaxLineLength:NodeInfoSchema.kt$NodeInfoSchemaV1.DBPartyAndCertificate$@ManyToMany(mappedBy = "legalIdentitiesAndCerts", cascade = [(CascadeType.ALL)])</ID>
    <ID>MaxLineLength:NodeInfoSchema.kt$NodeInfoSchemaV1.PersistentNodeInfo$(this.legalIdentitiesAndCerts.filter { it.isMain } + this.legalIdentitiesAndCerts.filter { !it.isMain }).map { it.toLegalIdentityAndCert() }</ID>
    <ID>MaxLineLength:NodeInfoSchema.kt$NodeInfoSchemaV1.PersistentNodeInfo$inverseJoinColumns = [(JoinColumn(name = "party_name", foreignKey = ForeignKey(name = "FK__link_ni_p__info_p_cert")))]</ID>
    <ID>MaxLineLength:NodeInfoSchema.kt$NodeInfoSchemaV1.PersistentNodeInfo$joinColumns = [(JoinColumn(name = "node_info_id", foreignKey = ForeignKey(name = "FK__link_nodeinfo_party__infos")))]</ID>
    <ID>MaxLineLength:NodeInfoWatcher.kt$NodeInfoWatcher$ fun nodeInfoUpdates(): Observable&lt;List&lt;NodeInfoUpdate&gt;&gt;</ID>
    <ID>MaxLineLength:NodeInfoWatcher.kt$NodeInfoWatcher$nodeInfoFilesMap[file] = NodeInfoFromFile(nodeInfoSigned.signed.raw.hash, file.lastModifiedTime())</ID>
    <ID>MaxLineLength:NodeInfoWatcher.kt$NodeInfoWatcher$val newOrChangedFile = previousLastModifiedTime == null || lastModifiedTime &gt; previousLastModifiedTime</ID>
    <ID>MaxLineLength:NodeInfoWatcher.kt$NodeInfoWatcher.Companion${ // By using the hash of the node's first name we ensure: // 1) node info files for the same node map to the same filename and thus avoid having duplicate files for // the same node // 2) avoid having to deal with characters in the X.500 name which are incompatible with the local filesystem val fileNameHash = nodeInfoAndSigned.nodeInfo.legalIdentities[0].name.serialize().hash nodeInfoAndSigned .signed .serialize() .open() .copyTo(path / "${NodeInfoFilesCopier.NODE_INFO_FILE_NAME_PREFIX}$fileNameHash", REPLACE_EXISTING) }</ID>
    <ID>MaxLineLength:NodeInfoWatcherTest.kt$NodeInfoWatcherTest$keyManagementService = MockKeyManagementService(identityService, pkToIdCache = MockPublicKeyToOwningIdentityCache())</ID>
    <ID>MaxLineLength:NodeInfoWatcherTest.kt$NodeInfoWatcherTest$val nodeInfoFiles = tempFolder.root.list().filter { it.startsWith(NodeInfoFilesCopier.NODE_INFO_FILE_NAME_PREFIX) }</ID>
    <ID>MaxLineLength:NodeInstanceRequest.kt$NodeInstanceRequest$localImageId</ID>
    <ID>MaxLineLength:NodeInstanceRequest.kt$NodeInstanceRequest$return "NodeInstanceRequest(nodeInstanceName='$nodeInstanceName', actualX500='$actualX500', expectedFqName='$expectedFqName') ${super.toString()}"</ID>
    <ID>MaxLineLength:NodeInstantiator.kt$NodeInstantiator$return instantiateNodeInstance(request.remoteImageName, request.instanceName, request.fqdn, request.instanceX500).thenApplyAsync { InstanceInfo(request.groupName, request.instanceName, request.fqdn, it.first, it.second) }</ID>
    <ID>MaxLineLength:NodeInstantiator.kt$NodeInstantiator$return instantiateNodeInstance(request.remoteImageName, request.nodeInstanceName, request.expectedFqName, request.actualX500) .thenApplyAsync { (reachableName, portMapping) -&gt; request.toNodeInstance(reachableName, portMapping) }</ID>
    <ID>MaxLineLength:NodeInterestRates.kt$NodeInterestRates.Oracle$// TODO There is security problem with that. What if transaction contains several commands of the same type, but // Oracle gets signing request for only some of them with a valid partial tree? We sign over a whole transaction. // It will be fixed by adding partial signatures later. // DOCSTART 1 fun sign(ftx: FilteredTransaction): TransactionSignature</ID>
    <ID>MaxLineLength:NodeInterestRates.kt$NodeInterestRates.Oracle$knownFixes = parseFile(IOUtils.toString(this::class.java.classLoader.getResourceAsStream("net/corda/irs/simulation/example.rates.txt"), Charsets.UTF_8.name()))</ID>
    <ID>MaxLineLength:NodeInterestRatesTest.kt$NodeInterestRatesTest$TransactionState(1000.DOLLARS.CASH issuedBy dummyCashIssuer.party ownedBy ALICE, Cash.PROGRAM_ID, DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:NodeInterestRatesTest.kt$NodeInterestRatesTest$assertFailsWith&lt;IllegalArgumentException&gt; { oracle.sign(ftx) }</ID>
    <ID>MaxLineLength:NodeInterestRatesTest.kt$NodeInterestRatesTest$private val services = MockServices(listOf("net.corda.finance.contracts.asset"), dummyCashIssuer, rigorousMock(), MEGA_CORP_KEY)</ID>
    <ID>MaxLineLength:NodeKeystoreCheckTest.kt$NodeKeystoreCheckTest$setPrivateKey(X509Utilities.CORDA_CLIENT_CA, nodeCA.keyPair.private, listOf(badNodeCACert, badRoot), signingCertStore.entryPassword)</ID>
    <ID>MaxLineLength:NodeKeystoreCheckTest.kt$NodeKeystoreCheckTest$val badNodeCACert = X509Utilities.createCertificate(CertificateType.NODE_CA, badRoot, badRootKeyPair, ALICE_NAME.x500Principal, nodeCA.keyPair.public)</ID>
    <ID>MaxLineLength:NodeKeystoreCheckTest.kt$NodeKeystoreCheckTest$val badRoot = X509Utilities.createSelfSignedCACertificate(X500Principal("O=Bad Root,L=Lodnon,C=GB"), badRootKeyPair)</ID>
    <ID>MaxLineLength:NodeKeystoreCheckTest.kt$NodeKeystoreCheckTest$val p2pSslConfig = CertificateStoreStubs.P2P.withCertificatesDirectory(certificatesDirectory, keyStorePassword = keystorePassword, trustStorePassword = keystorePassword)</ID>
    <ID>MaxLineLength:NodeKeystoreCheckTest.kt$NodeKeystoreCheckTest$val signingCertStore = CertificateStoreStubs.Signing.withCertificatesDirectory(certificatesDirectory, keystorePassword)</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$NodeMonitorModel$futureProgressTrackerUpdates.startWith(currentProgressTrackerUpdates).flatMap { it }.retry().subscribe(progressTrackingSubject)</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$NodeMonitorModel$val (statesSnapshot, vaultUpdates) = rpc.vaultTrackBy&lt;ContractState&gt;(QueryCriteria.VaultQueryCriteria(Vault.StateStatus.ALL), PageSpecification(DEFAULT_PAGE_NUM, MAX_PAGE_SIZE))</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$NodeMonitorModel$val stateMachineTransactionMapping: Observable&lt;StateMachineTransactionMapping&gt; = stateMachineTransactionMappingSubject</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$NodeMonitorModel${ rpc = ReconnectingCordaRPCOps(nodeHostAndPort, username, password) proxyObservable.value = rpc // Vault snapshot (force single page load with MAX_PAGE_SIZE) + updates val (statesSnapshot, vaultUpdates) = rpc.vaultTrackBy&lt;ContractState&gt;(QueryCriteria.VaultQueryCriteria(Vault.StateStatus.ALL), PageSpecification(DEFAULT_PAGE_NUM, MAX_PAGE_SIZE)) val unconsumedStates = statesSnapshot.states.filterIndexed { index, _ -&gt; statesSnapshot.statesMetadata[index].status == Vault.StateStatus.UNCONSUMED }.toSet() val consumedStates = statesSnapshot.states.toSet() - unconsumedStates val initialVaultUpdate = Vault.Update(consumedStates, unconsumedStates, references = emptySet()) vaultUpdates.startWith(initialVaultUpdate).subscribe(vaultUpdatesSubject::onNext) // Transactions val (transactions, newTransactions) = rpc.internalVerifiedTransactionsFeed() newTransactions.startWith(transactions).subscribe(transactionsSubject::onNext) // SM -&gt; TX mapping val (smTxMappings, futureSmTxMappings) = rpc.stateMachineRecordedTransactionMappingFeed() futureSmTxMappings.startWith(smTxMappings).subscribe(stateMachineTransactionMappingSubject::onNext) // Parties on network val (parties, futurePartyUpdate) = rpc.networkMapFeed() futurePartyUpdate.startWith(parties.map(MapChange::Added)).subscribe(networkMapSubject::onNext) val stateMachines = rpc.stateMachinesSnapshot() notaryIdentities = rpc.notaryIdentities() // Extract the flow tracking stream // TODO is there a nicer way of doing this? Stream of streams in general results in code like this... // TODO `progressTrackingSubject` doesn't seem to be used anymore - should it be removed? val currentProgressTrackerUpdates = stateMachines.mapNotNull { stateMachine -&gt; ProgressTrackingEvent.createStreamFromStateMachineInfo(stateMachine) } val futureProgressTrackerUpdates = stateMachineUpdatesSubject.map { stateMachineUpdate -&gt; if (stateMachineUpdate is StateMachineUpdate.Added) { ProgressTrackingEvent.createStreamFromStateMachineInfo(stateMachineUpdate.stateMachineInfo) ?: Observable.empty&lt;ProgressTrackingEvent&gt;() } else { Observable.empty&lt;ProgressTrackingEvent&gt;() } } // We need to retry, because when flow errors, we unsubscribe from progressTrackingSubject. So we end up with stream of state machine updates and no progress trackers. futureProgressTrackerUpdates.startWith(currentProgressTrackerUpdates).flatMap { it }.retry().subscribe(progressTrackingSubject) }</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$ProgressTrackingEvent.Companion$future.map { ProgressTrackingEvent(stateMachine.id, it) }.startWith(ProgressTrackingEvent(stateMachine.id, current))</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$name == "HibernateConfiguration_sessionFactories" -&gt; caffeine.maximumSize(database.mappedSchemaCacheSize)</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$name == "NodeAttachmentService_attachmentContent" -&gt; caffeine.maximumWeight(attachmentContentCacheSizeBytes)</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$name.startsWith("RPCSecurityManagerShiroCache_") -&gt; with(security?.authService?.options?.cache!!) { caffeine.maximumSize(maxEntries).expireAfterWrite(expireAfterSecs, TimeUnit.SECONDS) }</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$override</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$override fun bindWithConfig(nodeConfiguration: NodeConfiguration): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$override fun bindWithMetrics(metricRegistry: MetricRegistry): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:NodeParameters.kt$NodeParameters</ID>
    <ID>MaxLineLength:NodeParameters.kt$NodeParameters$/** * Create a new node parameters object with default values. Each parameter can be specified with its wither method which returns a copy * with that value. */ constructor() : this(providedName = null)</ID>
    <ID>MaxLineLength:NodeParameters.kt$NodeParameters$fun withAdditionalCordapps(additionalCordapps: Set&lt;TestCordapp&gt;): NodeParameters</ID>
    <ID>MaxLineLength:NodeParameters.kt$NodeParameters$fun withCustomOverrides(customOverrides: Map&lt;String, Any?&gt;): NodeParameters</ID>
    <ID>MaxLineLength:NodeParameters.kt$NodeParameters$fun withFlowOverrides(flowOverrides: Map&lt;Class&lt;out FlowLogic&lt;*&gt;&gt;, Class&lt;out FlowLogic&lt;*&gt;&gt;&gt;): NodeParameters</ID>
    <ID>MaxLineLength:NodeParameters.kt$NodeParameters$fun withStartInSameProcess(startInSameProcess: Boolean?): NodeParameters</ID>
    <ID>MaxLineLength:NodePerformanceTests.kt$NodePerformanceTests$connection.proxy.startFlow(::CashIssueFlow, 1.DOLLARS, OpaqueBytes.of(0), defaultNotaryIdentity).returnValue</ID>
    <ID>MaxLineLength:NodeProcess.kt$NodeProcess$Factory</ID>
    <ID>MaxLineLength:NodeProcess.kt$NodeProcess.Factory$networkParametersCopier = NetworkParametersCopier(testNetworkParameters(notaries = listOf(notaryInfo)))</ID>
    <ID>MaxLineLength:NodeProcess.kt$NodeProcess.Factory.Companion$val formatter: DateTimeFormatter = DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss.SSS").withZone(systemDefault())</ID>
    <ID>MaxLineLength:NodeRPC.kt$NodeRPC : AutoCloseable</ID>
    <ID>MaxLineLength:NodeRPCTests.kt$NodeRPCTests$driver</ID>
    <ID>MaxLineLength:NodeRegistrationTest.kt$RegistrationHandler$require(!name.organisation.contains("\\s".toRegex())) { "Whitespace in the organisation name not supported" }</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService : SchedulerServiceAutoCloseableSingletonSerializeAsToken</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService$nextScheduledAction = schedulerRepo.getLatest(deduplicate.size + 1).firstOrNull { !deduplicate.contains(it.second) }?.second</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService$val deduplicate = HashSet(startingStateRefs) // Take an immutable copy to remove races with afterDatabaseCommit.</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService${ // We are earliest rescheduleWakeUp() }</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService${ log.trace { "Scheduler starting FlowLogic $flowLogic" } // Add this to the in memory list of starting refs so it is not picked up on the next rescheduleWakeUp() startingStateRefs.add(scheduledState) flowLogic }</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService.Companion$ // We should try to make the Clock used in our code injectable (for tests etc) and to use the extension below // to wait in our code, rather than &lt;code&gt;Thread.sleep()&lt;/code&gt; or other time-based pauses. @Suspendable @VisibleForTesting // We specify full classpath on SettableFuture to differentiate it from the Quasar class of the same name fun awaitWithDeadline( clock: CordaClock, deadline: Instant, future: Future&lt;*&gt; = GuavaSettableFuture.create&lt;Any&gt;() ): Boolean</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService.Companion$ private fun &lt;T : Any&gt; makeStrandFriendlySettableFuture(future: Future&lt;T&gt;)</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService.Companion$private</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService.Companion${ // This will return when it times out, or when the clock mutates or when when the original future completes. originalFutureCompleted.get(nanos, TimeUnit.NANOSECONDS) }</ID>
    <ID>MaxLineLength:NodeSchedulerServiceTest.kt$NodeSchedulerServiceTest$private val database = configureDatabase(MockServices.makeTestDataSourceProperties(), DatabaseConfig(), { null }, { null })</ID>
    <ID>MaxLineLength:NodeSchedulerServiceTest.kt$NodeSchedulerServiceTestBase$verify(flowStarter, timeout(5000)).startFlow(argForWhich&lt;ExternalEvent.ExternalStartFlowEvent&lt;*&gt;&gt; { this.flowLogic == flowLogic })</ID>
    <ID>MaxLineLength:NodeSchemaService.kt$NodeSchemaService : SchemaServiceSingletonSerializeAsToken</ID>
    <ID>MaxLineLength:NodeSchemaService.kt$NodeSchemaService$fun internalSchemas()</ID>
    <ID>MaxLineLength:NodeSchemaService.kt$NodeSchemaService$override val schemaOptions: Map&lt;MappedSchema, SchemaService.SchemaOptions&gt; = requiredSchemas + extraSchemas.associateBy({ it }, { SchemaOptions() })</ID>
    <ID>MaxLineLength:NodeSchemaService.kt$NodeSchemaService$return VaultSchemaV1.VaultFungibleStates(owner = null, quantity = state.amount.quantity, issuer = null, issuerRef = null)</ID>
    <ID>MaxLineLength:NodeSchemaService.kt$NodeSchemaService$return VaultSchemaV1.VaultFungibleStates(state.owner, state.amount.quantity, state.amount.token.issuer.party, state.amount.token.issuer.reference)</ID>
    <ID>MaxLineLength:NodeSchemaServiceTest.kt$NodeSchemaServiceTest$val mockNet = InternalMockNetwork(cordappsForAllNodes = cordappsForPackages(DummyLinearStateSchemaV1::class.packageName))</ID>
    <ID>MaxLineLength:NodeSchemaServiceTest.kt$TestSchema.Child$@JoinColumns(JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id"), JoinColumn(name = "output_index", referencedColumnName = "output_index"))</ID>
    <ID>MaxLineLength:NodeSchemaServiceTest.kt$TestSchema.Parent$@JoinColumns(JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id"), JoinColumn(name = "output_index", referencedColumnName = "output_index"))</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeCliCommand$abstract</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"""\____/ /_/ \__,_/\__,_/"""</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"Check your contracts carefully. The fine print\nis usually a clause for suspicion ${Emoji.santaClaus}"</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"How did my parents fight boredom before the internet?\nI asked my 17 siblings and they didn't know either."</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"My boss asked me who is the stupid one, me or him?\nI said everyone knows he doesn't hire stupid people."</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"Please see https://docs.corda.net/troubleshooting.html#slow-localhost-resolution for information on how to fix this. "</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"The good thing about lending out your time machine\nis that you basically get it back immediately."</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"Your computer took over a second to resolve localhost due an incorrect configuration. Corda will work but start very slowly until this is fixed. "</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$Node.printWarning("This node is running in development mode! ${Emoji.developer} This is not safe for production deployment.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$if (attempt { banJavaSerialisation(configuration) }.doOnFailure(Consumer { error -&gt; error.logAsUnexpected("Exception while configuring serialisation") }) !is Try.Success) return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$if (attempt { preNetworkRegistration(configuration) }.doOnFailure(Consumer(::handleRegistrationError)) !is Try.Success) return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$if (requireCertificates &amp;&amp; !canReadCertificatesDirectory(configuration.certificatesDirectory, configuration.devMode)) return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$logger.info("The Corda node is running in production mode. If this is a developer environment you can set 'devMode=true' in the node.conf file.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$logger.warn("${it.info} will be unable to run on Corda in the future due to missing entries in JAR's manifest file.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$nodeStartedMessage = "$nodeStartedMessage with additional Network Map keys ${conf.extraNetworkMapKeys.joinToString(prefix = "[", postfix = "]", separator = ", ")}"</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$printError("Unable to access certificates directory $certDirectory. This could be because the node has not been registered with the Identity Operator.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$println("Application user '$appUser' does not have necessary permissions for Node base directory '$baseDirectory'.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$println("Corda Node process in now exiting. Please check directory permissions and try starting the Node again.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$val configuration = cmdLineOptions.parseConfiguration(rawConfig).doIfValid { logRawConfig(rawConfig) }.doOnErrors(::logConfigurationErrors).optional ?: return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup.Companion$private val logger by lazy { loggerFor&lt;Node&gt;() } // I guess this is lazy to allow for logging init, but why Node?</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$Node.printWarning("The --clear-network-map-cache flag has been deprecated and will be removed in a future version. Use the clear-network-cache command instead.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$Node.printWarning("The --initial-registration flag has been deprecated and will be removed in a future version. Use the initial-registration command instead.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$Node.printWarning("The --just-generate-node-info flag has been deprecated and will be removed in a future version. Use the generate-node-info command instead.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$Node.printWarning("The --just-generate-rpc-ssl-settings flag has been deprecated and will be removed in a future version. Use the generate-rpc-ssl-settings command instead.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$initialRegistrationCli.networkRootTrustStorePathParameter = cmdLineOptions.networkRootTrustStorePathParameter</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$override fun additionalSubCommands()</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$println("Node was started before in `initial-registration` mode, but the registration was not completed.\nResuming registration.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$requireNotNull(cmdLineOptions.networkRootTrustStorePassword) { "Network root trust store password must be provided in registration mode using --network-root-truststore-password." }</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$error is Errors.NativeIoException &amp;&amp; error.message?.contains("Address already in use") == true -&gt; error.logAsExpected("One of the ports required by the Corda node is already in use.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$error is Errors.NativeIoException &amp;&amp; error.message?.contains("Can't assign requested address") == true -&gt; error.logAsExpected("Exception during node startup. Check that addresses in node config resolve correctly.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$error is UnresolvedAddressException -&gt; error.logAsExpected("Exception during node startup. Check that addresses in node config resolve correctly.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$error.isOpenJdkKnownIssue() -&gt; error.logAsExpected("Exception during node startup - ${error.message}. This is a known OpenJDK issue on some Linux distributions, please use OpenJDK from zulu.org or Oracle JDK.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$fun Throwable.logAsExpected(message: String? = this.message, print: (String?) -&gt; Unit = logger::error)</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging.Companion$val startupErrors = setOf(MultipleCordappsForFlowException::class, CheckpointIncompatibleException::class, AddressBindingException::class, NetworkParametersReader::class, DatabaseIncompatibleException::class)</ID>
    <ID>MaxLineLength:NodeStartup.kt$System.setProperty("defaultLogLevel", specifiedLogLevel)</ID>
    <ID>MaxLineLength:NodeStartupCliTest.kt$NodeStartupCliTest$Assertions.assertThat(startup.cmdLineOptions.configFile).isEqualTo(workingDirectory / "another-base-dir" / "node.conf")</ID>
    <ID>MaxLineLength:NodeStartupCliTest.kt$NodeStartupCliTest$CommandLine.populateCommand(startup, CommonCliConstants.BASE_DIR, (workingDirectory / "another-base-dir").toString())</ID>
    <ID>MaxLineLength:NodeStartupPerformanceTests.kt$NodeStartupPerformanceTests$// Measure the startup time of nodes. Note that this includes an RPC roundtrip, which causes e.g. Kryo initialisation. @Test fun `single node startup time`()</ID>
    <ID>MaxLineLength:NodeStatePersistenceTests.kt$NodeStatePersistenceTests$val nodeHandle = startNode(providedName = nodeName, rpcUsers = listOf(user), customOverrides = mapOf("devMode" to "false")).getOrThrow()</ID>
    <ID>MaxLineLength:NodeStatePersistenceTests.kt$NodeStatePersistenceTests$val user = User("mark", "dadada", setOf(Permissions.startFlow&lt;SendMessageFlow&gt;(), Permissions.invokeRpc("vaultQuery")))</ID>
    <ID>MaxLineLength:NodeStatePersistenceTests.kt$SendMessageFlow$val txBuilder = TransactionBuilder(notary).withItems(StateAndContract(messageState, MESSAGE_CONTRACT_PROGRAM_ID), txCommand)</ID>
    <ID>MaxLineLength:NodeStatePersistenceTests.kt$SendMessageFlow.Companion$fun tracker()</ID>
    <ID>MaxLineLength:NodeTabView.kt$NodeTabView$CityDatabase.cityMap.values.map { it.countryCode }.toSet().map { it to Image(resources["/net/corda/demobench/flags/$it.png"]) }.toMap()</ID>
    <ID>MaxLineLength:NodeTabView.kt$NodeTabView$notaryTypeToggleGroup.selectedValueProperty&lt;NotaryService&gt;()</ID>
    <ID>MaxLineLength:NodeTerminalView.kt$NodeTerminalView${ // TODO: Remove this special case once Rick's serialisation work means we can deserialise states that weren't on our own classpath. }</ID>
    <ID>MaxLineLength:NodeTest.kt$NodeTest$assertEquals(node.generateNodeInfo(), node.generateNodeInfo())</ID>
    <ID>MaxLineLength:NodeTestUtils.kt$ fun testActor(owningLegalIdentity: CordaX500Name = CordaX500Name("Test Company Inc.", "London", "GB"))</ID>
    <ID>MaxLineLength:NodeTestUtils.kt$ fun testContext(owningLegalIdentity: CordaX500Name = CordaX500Name("Test Company Inc.", "London", "GB"))</ID>
    <ID>MaxLineLength:NodeUnloadHandlerTests.kt$NodeUnloadHandlerTests$assertTrue("Timed out waiting for AbstractNode to invoke the test service shutdown callback", shutdownLatch.await(30, TimeUnit.SECONDS))</ID>
    <ID>MaxLineLength:NodeUnloadHandlerTests.kt$NodeUnloadHandlerTests$private val mockNet = InternalMockNetwork(cordappsForAllNodes = listOf(enclosedCordapp()), notarySpecs = emptyList())</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$ @Throws(VaultQueryException::class) override fun &lt;T : ContractState&gt; _trackBy( criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt; ): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$ private fun &lt;T : ContractState&gt; hasBeenSeen( update: Vault.Update&lt;T&gt;, snapshotStatesRefs: Set&lt;StateRef&gt;, snapshotConsumedStatesRefs: Set&lt;StateRef&gt; ): Boolean</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$// Only update the state if it has not previously been consumed (this could have happened if the transaction is being // re-recorded. if (stateStatus != Vault.StateStatus.CONSUMED) { stateStatus = Vault.StateStatus.CONSUMED consumedTime = clock.instant() // remove lock (if held) if (lockId != null) { lockId = null lockUpdateTime = clock.instant() log.trace("Releasing soft lock on consumed state: $stateRef") } session.save(state) }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$// Returns only output states that can be deserialised successfully. fun WireTransaction.deserializableOutputStates(): Map&lt;Int, TransactionState&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$// Returns only reference states that can be deserialised successfully. fun LedgerTransaction.deserializableRefStates(): Map&lt;Int, StateAndRef&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$Vault.Page(states = statesAndRefs, statesMetadata = statesMeta, stateTypes = criteriaParser.stateTypes, totalStatesAvailable = totalStates, otherResults = otherResults)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$fun &lt;T&gt; withValidDeserialization(list: List&lt;T&gt;, txId: SecureHash): Map&lt;Int, T&gt;</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$fun execute(configure: Root&lt;*&gt;.(CriteriaUpdate&lt;*&gt;, Array&lt;Predicate&gt;) -&gt; Any?)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$if (paging.pageNumber &lt; DEFAULT_PAGE_NUM) throw VaultQueryException("Page specification: invalid page number ${paging.pageNumber} [page numbers start from $DEFAULT_PAGE_NUM]")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$if (paging.pageSize &lt; 1) throw VaultQueryException("Page specification: invalid page size ${paging.pageSize} [minimum is 1]")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$if (paging.pageSize &gt; MAX_PAGE_SIZE) throw VaultQueryException("Page specification: invalid page size ${paging.pageSize} [maximum is $MAX_PAGE_SIZE]")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$isRelevant(value.data, keyManagementService.filterMyKeys(outputs.values.flatMap { it.data.participants.map { it.owningKey } }).toSet())</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$log.debug { "Vault Query for contract type: $contractStateType, criteria: $criteria, pagination: $paging, sorting: $sorting" }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$log.trace { "Removing $consumedStateRefs consumed contract states and adding $producedStateRefs produced contract states to the database." }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$log.warn("There are unknown contract state types in the vault, which will prevent these states from being used. The relevant CorDapps must be loaded for these states to be used. The types not on the classpath are ${unknownTypes.joinToString(", ", "[", "]")}.")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$log.warn("trackBy is called with an already existing, open DB transaction. As a result, there might be states missing from both the snapshot and observable, included in the returned data feed, because of race conditions.")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$private</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$private val criteriaBuilder: CriteriaBuilder by lazy { database.hibernateConfig.sessionFactoryForRegisteredSchemas.criteriaBuilder }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$query.maxResults = if (pageSize &gt; 0) pageSize else Integer.MAX_VALUE</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$relevancyStatus = if (isRelevant) Vault.RelevancyStatus.RELEVANT else Vault.RelevancyStatus.NOT_RELEVANT</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$return Vault.Update(consumedStateAndRefs.toSet(), producedStateAndRefs.toSet(), null, updateType, referenceStateAndRefs.toSet())</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$return Vault.Update(consumedStates.toSet(), ourNewStates.toSet(), references = newReferenceStateAndRefs.toSet())</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$return snapshotStatesRefs.containsAll(updateProducedStatesRefs) &amp;&amp; snapshotConsumedStatesRefs.containsAll(updateConsumedStatesRefs)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$softLockingCondition = QueryCriteria.SoftLockingCondition(QueryCriteria.SoftLockingType.UNLOCKED_AND_SPECIFIED, listOf(lockId))</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$throw StatesNotAvailableException("Attempted to reserve $stateRefs for $lockId but only $updatedRows rows available")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$throw VaultQueryException("There are ${results.size} results, which exceeds the limit of $DEFAULT_PAGE_SIZE for queries that do not specify paging. In order to retrieve these results, provide a `PageSpecification(pageNumber, pageSize)` to the method invoked.")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$update.set(get&lt;String&gt;(VaultSchemaV1.VaultStates::lockId.name), criteriaBuilder.nullLiteral(String::class.java))</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$update.set&lt;String&gt;(get&lt;String&gt;(VaultSchemaV1.VaultStates::lockId.name), criteriaBuilder.nullLiteral(String::class.java))</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val criteriaParser = HibernateQueryCriteriaParser(contractStateType, contractStateTypeMappings, criteriaBuilder, criteriaQuery, queryRootVaultStates)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val lockIdPredicate = criteriaBuilder.equal(get&lt;String&gt;(VaultSchemaV1.VaultStates::lockId.name), lockId.toString())</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val lockUpdateTime = criteriaBuilder.equal(get&lt;Instant&gt;(VaultSchemaV1.VaultStates::lockUpdateTime.name), softLockTimestamp)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val myKeys by lazy { keyManagementService.filterMyKeys(ltx.outputs.flatMap { it.data.participants.map { it.owningKey } }) }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val persistentStateRefs = stateRefs.map { PersistentStateRef(it.txhash.bytes.toHexString(), it.index) }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val results = _queryBy(criteria.and(countCriteria), PageSpecification(), Sort(emptyList()), contractStateType, true) // only skip pagination checks for total results count query</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val state = session.get&lt;VaultSchemaV1.VaultStates&gt;(VaultSchemaV1.VaultStates::class.java, PersistentStateRef(stateRef))</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val stateOnly = stateAndRef.value.state.data // TODO: Optimise this. // // For EVERY state to be committed to the vault, this checks whether it is spendable by the recording // node. The behaviour is as follows: // // 1) All vault updates marked as RELEVANT will, of course, all have relevancy_status = 1 in the // "vault_states" table. // 2) For ALL_VISIBLE updates, those which are not relevant according to the relevancy rules will have // relevancy_status = 0 in the "vault_states" table. // // This is useful when it comes to querying for fungible states, when we do not want irrelevant states // included in the result. // // The same functionality could be obtained by passing in a list of participants to the vault query, // however this: // // * requires a join on the participants table which results in slow queries // * states may flip from being non-relevant to relevant // * it's more complicated for CorDapp developers // // Adding a new column in the "VaultStates" table was considered the best approach. val keys = stateOnly.participants.map { it.owningKey } val persistentStateRef = PersistentStateRef(stateAndRef.key) // This check is done to set the "relevancyStatus". When one performs a vault query, it is possible to return ALL states, ONLY // RELEVANT states or NOT relevant states. val isRelevant = isRelevant(stateOnly, keyManagementService.filterMyKeys(keys).toSet()) val constraintInfo = Vault.ConstraintInfo(stateAndRef.value.state.constraint) // Save a row for each party in the state_party table. // TODO: Perhaps these can be stored in a batch? stateOnly.participants.groupBy { it.owningKey }.forEach { participants -&gt; val persistentParty = VaultSchemaV1.PersistentParty(persistentStateRef, participants.value.first()) session.save(persistentParty) } val stateToAdd = VaultSchemaV1.VaultStates( notary = stateAndRef.value.state.notary, contractStateClassName = stateAndRef.value.state.data.javaClass.name, stateStatus = Vault.StateStatus.UNCONSUMED, recordedTime = clock.instant(), relevancyStatus = if (isRelevant) Vault.RelevancyStatus.RELEVANT else Vault.RelevancyStatus.NOT_RELEVANT, constraintType = constraintInfo.type(), constraintData = constraintInfo.data() ) stateToAdd.stateRef = persistentStateRef session.save(stateToAdd)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val stateRef = StateRef(SecureHash.parse(vaultState.stateRef!!.txId), vaultState.stateRef!!.index)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val stateStatusPredication = criteriaBuilder.equal(get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultStates::stateStatus.name), Vault.StateStatus.UNCONSUMED)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val txIdPredicate = criteriaBuilder.equal(vaultStates.get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultTxnNote::txId.name), txnId.toString())</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService${ // For transactions being re-recorded, the node must check its vault to find out what states it has already seen. Note // that some of the outputs previously seen may have been consumed in the meantime, so the check must look for all state // statuses. val outputRefs = tx.outRefsOfType&lt;ContractState&gt;().map { it.ref } val seenRefs = loadStates(outputRefs).map { it.ref } val unseenRefs = outputRefs - seenRefs val unseenOutputIdxs = unseenRefs.map { it.index }.toSet() outputs.filter { it.key in unseenOutputIdxs } }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService${ // We decrement by one if the client requests MAX_PAGE_SIZE, assuming they can not notice this because they don't have enough memory // to request `MAX_PAGE_SIZE` states at once. val paging = if (paging_.pageSize == Integer.MAX_VALUE) { paging_.copy(pageSize = Integer.MAX_VALUE - 1) } else { paging_ } log.debug { "Vault Query for contract type: $contractStateType, criteria: $criteria, pagination: $paging, sorting: $sorting" } return database.transaction { // calculate total results where a page specification has been defined var totalStates = -1L if (!skipPagingChecks &amp;&amp; !paging.isDefault) { val count = builder { VaultSchemaV1.VaultStates::recordedTime.count() } val countCriteria = QueryCriteria.VaultCustomQueryCriteria(count, Vault.StateStatus.ALL) val results = _queryBy(criteria.and(countCriteria), PageSpecification(), Sort(emptyList()), contractStateType, true) // only skip pagination checks for total results count query totalStates = results.otherResults.last() as Long } val session = getSession() val criteriaQuery = criteriaBuilder.createQuery(Tuple::class.java) val queryRootVaultStates = criteriaQuery.from(VaultSchemaV1.VaultStates::class.java) // TODO: revisit (use single instance of parser for all queries) val criteriaParser = HibernateQueryCriteriaParser(contractStateType, contractStateTypeMappings, criteriaBuilder, criteriaQuery, queryRootVaultStates) // parse criteria and build where predicates criteriaParser.parse(criteria, sorting) // prepare query for execution val query = session.createQuery(criteriaQuery) // pagination checks if (!skipPagingChecks &amp;&amp; !paging.isDefault) { // pagination if (paging.pageNumber &lt; DEFAULT_PAGE_NUM) throw VaultQueryException("Page specification: invalid page number ${paging.pageNumber} [page numbers start from $DEFAULT_PAGE_NUM]") if (paging.pageSize &lt; 1) throw VaultQueryException("Page specification: invalid page size ${paging.pageSize} [minimum is 1]") if (paging.pageSize &gt; MAX_PAGE_SIZE) throw VaultQueryException("Page specification: invalid page size ${paging.pageSize} [maximum is $MAX_PAGE_SIZE]") } // For both SQLServer and PostgresSQL, firstResult must be &gt;= 0. So we set a floor at 0. // TODO: This is a catch-all solution. But why is the default pageNumber set to be -1 in the first place? // Even if we set the default pageNumber to be 1 instead, that may not cover the non-default cases. // So the floor may be necessary anyway. query.firstResult = maxOf(0, (paging.pageNumber - 1) * paging.pageSize) val pageSize = paging.pageSize + 1 query.maxResults = if (pageSize &gt; 0) pageSize else Integer.MAX_VALUE // detection too many results, protected against overflow // execution val results = query.resultList // final pagination check (fail-fast on too many results when no pagination specified) if (!skipPagingChecks &amp;&amp; paging.isDefault &amp;&amp; results.size &gt; DEFAULT_PAGE_SIZE) { throw VaultQueryException("There are ${results.size} results, which exceeds the limit of $DEFAULT_PAGE_SIZE for queries that do not specify paging. In order to retrieve these results, provide a `PageSpecification(pageNumber, pageSize)` to the method invoked.") } val statesAndRefs: MutableList&lt;StateAndRef&lt;T&gt;&gt; = mutableListOf() val statesMeta: MutableList&lt;Vault.StateMetadata&gt; = mutableListOf() val otherResults: MutableList&lt;Any&gt; = mutableListOf() val stateRefs = mutableSetOf&lt;StateRef&gt;() results.asSequence() .forEachIndexed { index, result -&gt; if (result[0] is VaultSchemaV1.VaultStates) { if (!paging.isDefault &amp;&amp; index == paging.pageSize) // skip last result if paged return@forEachIndexed val vaultState = result[0] as VaultSchemaV1.VaultStates val stateRef = StateRef(SecureHash.parse(vaultState.stateRef!!.txId), vaultState.stateRef!!.index) stateRefs.add(stateRef) statesMeta.add(Vault.StateMetadata(stateRef, vaultState.contractStateClassName, vaultState.recordedTime, vaultState.consumedTime, vaultState.stateStatus, vaultState.notary, vaultState.lockId, vaultState.lockUpdateTime, vaultState.relevancyStatus, constraintInfo(vaultState.constraintType, vaultState.constraintData) )) } else { // TODO: improve typing of returned other results log.debug { "OtherResults: ${Arrays.toString(result.toArray())}" } otherResults.addAll(result.toArray().asList()) } } if (stateRefs.isNotEmpty()) statesAndRefs.addAll(uncheckedCast(servicesForResolution.loadStates(stateRefs))) Vault.Page(states = statesAndRefs, statesMetadata = statesMeta, stateTypes = criteriaParser.stateTypes, totalStatesAvailable = totalStates, otherResults = otherResults) } }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService${ // When resolving transaction dependencies we might encounter contracts we haven't installed locally. // This will cause a failure as we can't deserialize such states in the context of the `appClassloader`. // For now we ignore these states. // In the future we will use the AttachmentsClassloader to correctly deserialize and asses the relevancy. log.debug { "Could not deserialize state $idx from transaction $txId. Cause: $e" } null }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService${ val outputs: Map&lt;Int, TransactionState&lt;ContractState&gt;&gt; = tx.deserializableOutputStates() val ourNewStates = when (statesToRecord) { StatesToRecord.NONE -&gt; throw AssertionError("Should not reach here") StatesToRecord.ONLY_RELEVANT -&gt; outputs.filter { (_, value) -&gt; isRelevant(value.data, keyManagementService.filterMyKeys(outputs.values.flatMap { it.data.participants.map { it.owningKey } }).toSet()) } StatesToRecord.ALL_VISIBLE -&gt; if (previouslySeen) { // For transactions being re-recorded, the node must check its vault to find out what states it has already seen. Note // that some of the outputs previously seen may have been consumed in the meantime, so the check must look for all state // statuses. val outputRefs = tx.outRefsOfType&lt;ContractState&gt;().map { it.ref } val seenRefs = loadStates(outputRefs).map { it.ref } val unseenRefs = outputRefs - seenRefs val unseenOutputIdxs = unseenRefs.map { it.index }.toSet() outputs.filter { it.key in unseenOutputIdxs } } else { outputs } }.map { (idx, _) -&gt; tx.outRef&lt;ContractState&gt;(idx) } // Retrieve all unconsumed states for this transaction's inputs. val consumedStates = loadStates(tx.inputs) // Is transaction irrelevant? If so, then we don't care about the reference states either. if (consumedStates.isEmpty() &amp;&amp; ourNewStates.isEmpty()) { log.trace { "tx ${tx.id} was irrelevant to this vault, ignoring" } return null } // This list should only contain NEW states which we have not seen before as an output in another transaction. If we can't // obtain the references from the vault then the reference must be a state we have not seen before, therefore we should store it // in the vault. If StateToRecord is set to ALL_VISIBLE or ONLY_RELEVANT then we should store all of the previously unseen // states in the reference list. The assumption is that we might need to inspect them at some point if they were referred to // in the contracts of the input or output states. If states to record is none then we shouldn't record any reference states. val newReferenceStateAndRefs = if (tx.references.isEmpty()) { emptyList() } else { when (statesToRecord) { StatesToRecord.NONE -&gt; throw AssertionError("Should not reach here") StatesToRecord.ALL_VISIBLE, StatesToRecord.ONLY_RELEVANT -&gt; { val notSeenReferences = tx.references - loadStates(tx.references).map { it.ref } // TODO: This is expensive - is there another way? tx.toLedgerTransaction(servicesForResolution).deserializableRefStates() .filter { (_, stateAndRef) -&gt; stateAndRef.ref in notSeenReferences } .values } } } return Vault.Update(consumedStates.toSet(), ourNewStates.toSet(), references = newReferenceStateAndRefs.toSet()) }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService.Companion$ fun isRelevant(state: ContractState, myKeys: Set&lt;PublicKey&gt;): Boolean</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService.InnerState$// For use during publishing only. val updatesPublisher: rx.Observer&lt;Vault.Update&lt;ContractState&gt;&gt; get() = _updatesPublisher.bufferUntilDatabaseCommit().tee(_rawUpdatesPublisher)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$private</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$(services.validatedTransactions as WritableTransactionStorage).addTransaction(SignedTransaction(changeNotaryTx, listOf(NullKeys.NULL_SIGNATURE)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$Cash().generateIssue(this, 100.DOLLARS `issued by` MEGA_CORP.ref(1), AnonymousParty(freshKey), DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$Cash().generateIssue(this, 200.POUNDS `issued by` MEGA_CORP.ref(1), AnonymousParty(freshKey), DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$CashUtils.generateSpend(services, this, Amount(amount.quantity, GBP), identity, thirdPartyIdentity.party.anonymise())</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$FungibleFoo : FungibleState</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$addOutputState(DummyDealContract.State(listOf(megaCorp.party), "Dummy linear id"), DUMMY_DEAL_PROGRAM_ID)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$addOutputState(UniqueDummyFungibleContract.State(10.DOLLARS `issued by` DUMMY_CASH_ISSUER, megaCorp.party), UNIQUE_DUMMY_FUNGIBLE_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$addOutputState(UniqueDummyLinearContract.State(listOf(megaCorp.party), "Dummy linear id"), UNIQUE_DUMMY_LINEAR_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$assertThat(spendableStatesUSD[0].state.data.amount.token.issuer).isNotEqualTo(spendableStatesUSD[1].state.data.amount.token.issuer)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$assertThat(spendableStatesUSD[0].state.data.amount.token.issuer.reference).isIn(BOC.ref(1).reference, BOC.ref(2).reference)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$assertThat(spendableStatesUSD[0].state.data.amount.token.issuer.reference).isNotEqualTo(spendableStatesUSD[1].state.data.amount.token.issuer.reference)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$assertThat(spendableStatesUSD[1].state.data.amount.token.issuer.reference).isIn(BOC.ref(1).reference, BOC.ref(2).reference)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$cash.generateIssue(issuance, Amount(howMuch.quantity, Issued(DUMMY_CASH_ISSUER, howMuch.token)), services.myInfo.singleIdentity(), dummyNotary.party)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$makeTestIdentityService(MEGA_CORP_IDENTITY, MINI_CORP_IDENTITY, DUMMY_CASH_ISSUER_IDENTITY, DUMMY_NOTARY_IDENTITY)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$private</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$services.recordTransactions(StatesToRecord.ALL_VISIBLE, listOf(createTx(6, megaCorp.party, bankOfCorda.party)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$services.recordTransactions(StatesToRecord.ONLY_RELEVANT, listOf(createTx(3, miniCorp.party, megaCorp.party)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val cashStateWithNewNotary = StateAndRef(initialCashState.state.copy(notary = newNotary), StateRef(changeNotaryTx.id, 0))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val changeNotaryTx = NotaryChangeTransactionBuilder(listOf(initialCashState.ref), issueStx.notary!!, newNotary, services.networkParametersService.currentHash).build()</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val criteriaByLockId = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(softLockId)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val criteriaByLockId1 = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(softLockId1)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val criteriaByLockId2 = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(softLockId2)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val criteriaLocked = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.LOCKED_ONLY))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val criteriaLocked = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(lockId)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val expectedNotaryChangeUpdate = Vault.Update(setOf(initialCashState), setOf(cashStateWithNewNotary), null, Vault.UpdateType.NOTARY_CHANGE)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val myKeys = services.keyManagementService.filterMyKeys(listOf(identity.owningKey, myAnonymousIdentity.owningKey)).toSet()</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val states = vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(stateRefs = listOf(w1[1].ref, w1[2].ref))).states</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val thirdPartyIdentity = thirdPartyServices.keyManagementService.freshKeyAndCert(thirdPartyServices.myInfo.singleIdentityAndCert(), false)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val unlockedStates = vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_ONLY))).states</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val unlockedStates1 = vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_ONLY))).states</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val unlockedStates2 = vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_ONLY))).states</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val w1 = vaultService.queryBy&lt;Cash.State&gt;(PageSpecification(pageNumber = 1, pageSize = Integer.MAX_VALUE)).states</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$vaultService.queryBy(Cash.State::class.java, QueryCriteria.VaultQueryCriteria(relevancyStatus = Vault.RelevancyStatus.ALL), PageSpecification(1)).totalStatesAvailable</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest.Companion$val cordappPackages = listOf("net.corda.finance.contracts.asset", CashSchemaV1::class.packageName, "net.corda.testing.contracts", "net.corda.testing.internal.vault")</ID>
    <ID>MaxLineLength:NodeVersioningTest.kt$NodeVersioningTest$assertThat(rpc.startFlow(NodeVersioningTest::GetPlatformVersionFlow).returnValue.getOrThrow()).isEqualTo(PLATFORM_VERSION)</ID>
    <ID>MaxLineLength:NodeWebServer.kt$NodeWebServer$/** Fetch WebServerPluginRegistry classes registered in META-INF/services/net.corda.webserver.services.WebServerPluginRegistry files that exist in the classpath */ val pluginRegistries: List&lt;WebServerPluginRegistry&gt; by lazy { ServiceLoader.load(WebServerPluginRegistry::class.java).toList() }</ID>
    <ID>MaxLineLength:NodeWebServer.kt$NodeWebServer$if (e is BindException || e is Errors.NativeIoException &amp;&amp; e.message?.contains("Address already in use") == true) { throw AddressBindingException(address) } else { throw e }</ID>
    <ID>MaxLineLength:NodeWebServer.kt$NodeWebServer$private fun reconnectingCordaRPCOps()</ID>
    <ID>MaxLineLength:NodeWebServer.kt$NodeWebServer$val sslConnector = ServerConnector(server, SslConnectionFactory(sslContextFactory, "http/1.1"), HttpConnectionFactory(httpsConfiguration))</ID>
    <ID>MaxLineLength:NodeWebServer.kt$NodeWebServer.&lt;no name provided&gt;$@Throws(IOException::class) override</ID>
    <ID>MaxLineLength:NonInvalidatingCache.kt$NonInvalidatingCache.Companion$private</ID>
    <ID>MaxLineLength:NonInvalidatingUnboundCache.kt$NonInvalidatingUnboundCache.Companion$val builder = Caffeine.newBuilder().removalListener(removalListener).executor(SameThreadExecutor.getExecutor())</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow : NotaryServiceFlow</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$"Notary specified by the transaction ($notary) is not on the network parameter whitelist: ${notaryWhitelist.joinToString()}"</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$"expected either ${FilteredTransaction::class.java.simpleName} or ${NotaryChangeWireTransaction::class.java.simpleName}"</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$?:</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$is FilteredTransaction -&gt; TransactionParts(tx.id, tx.inputs, tx.timeWindow, tx.notary, tx.references, networkParametersHash = tx.networkParametersHash)</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$is NotaryChangeWireTransaction</ID>
    <ID>MaxLineLength:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests$private</ID>
    <ID>MaxLineLength:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests$val modifiedSignature = NotarisationRequestSignature(randomKeyPair.sign(bytesToSign), aliceNode.services.myInfo.platformVersion)</ID>
    <ID>MaxLineLength:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests.&lt;no name provided&gt;$val alteredMessage = InMemoryMessage(message.topic, OpaqueBytes(alteredMessageData.serialize().bytes), message.uniqueMessageId)</ID>
    <ID>MaxLineLength:Notarise.kt$NotaryDemoClientApi$rpc.startFlow(::RPCStartableNotaryFlowClient, it).returnValue.toCompletableFuture().thenApply { it.map { it.by.toStringShort() } }</ID>
    <ID>MaxLineLength:NotaryChangeFlow.kt$NotaryChangeFlow$val signableData = SignableData(tx.id, SignatureMetadata(serviceHub.myInfo.platformVersion, Crypto.findSignatureScheme(myKey).schemeNumberID))</ID>
    <ID>MaxLineLength:NotaryChangeTests.kt$NotaryChangeTests$assertTrue { originalLinkedStates.size == notaryChangeLinkedStates.size &amp;&amp; originalLinkedStates.containsAll(notaryChangeLinkedStates) }</ID>
    <ID>MaxLineLength:NotaryChangeTests.kt$NotaryChangeTests$clientNodeB.services.recordTransactions(clientNodeA.services.validatedTransactions.getTransaction(issued.ref.txhash)!!)</ID>
    <ID>MaxLineLength:NotaryChangeTests.kt$NotaryChangeTests$private</ID>
    <ID>MaxLineLength:NotaryChangeTests.kt$fun issueInvalidState(services: ServiceHub, identity: Party, notary: Party): StateAndRef&lt;DummyContract.SingleOwnerState&gt;</ID>
    <ID>MaxLineLength:NotaryChangeTests.kt$fun issueState(services: ServiceHub, nodeIdentity: Party, notaryIdentity: Party): StateAndRef&lt;DummyContract.SingleOwnerState&gt;</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction$ private fun checkNewNotaryWhitelisted()</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction$?:</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction$@Deprecated("NotaryChangeLedgerTransaction should not be created directly, use NotaryChangeWireTransaction.resolve instead.")</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction$override fun equals(other: Any?): Boolean</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction$val inputPositionIndex: Map&lt;StateRef, Int&gt; = inputs.mapIndexed { index, stateAndRef -&gt; stateAndRef.ref to index }.toMap()</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$ @CordaInternal internal fun resolveOutputComponent(services: ServicesForResolution, stateRef: StateRef, params: NetworkParameters): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$ @DeleteForDJVM fun resolve(services: ServiceHub, sigs: List&lt;TransactionSignature&gt;)</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$@CordaInternal internal</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$@Deprecated("Required only for backwards compatibility purposes. This type of transaction should not be constructed outside Corda code.", ReplaceWith("NotaryChangeTransactionBuilder"), DeprecationLevel.WARNING)</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$@Deprecated("Required only for backwards compatibility purposes. This type of transaction should not be constructed outside Corda code.", ReplaceWith("NotaryChangeTransactionBuilder"), DeprecationLevel.WARNING) constructor(inputs: List&lt;StateRef&gt;, notary: Party, newNotary: Party) : this(listOf(inputs, notary, newNotary).map { it.serialize() })</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$return NotaryChangeLedgerTransaction.create(resolvedInputs, notary, newNotary, id, sigs, resolvedNetworkParameters)</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.Conflict$"${consumedStates.asSequence().joinToString(",\n", limit = 5) { it.key.toString() + " -&gt; " + it.value }}.\n"</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.Conflict$"To find out if any of the conflicting transactions have been generated by this node you can use the hashLookup Corda shell command."</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.Conflict$override</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.TimeWindowInvalid$override fun toString()</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.WrongNotary$@Deprecated("Deprecated since platform version 4. This object is no longer used, [TransactionInvalid] will be reported in case of notary mismatch")</ID>
    <ID>MaxLineLength:NotaryError.kt$StateConsumptionDetails$fun copy(hashOfTransactionId: SecureHash): StateConsumptionDetails</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$ private fun generateRequestSignature(): NotarisationRequestSignature</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$"Notary $notaryParty is not on the network parameter whitelist. A non-whitelisted notary can only be used for notary change transactions"</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$?:</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$@Suspendable private</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$NotarySendTransactionFlow : DataVendingFlow</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$check</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$it is StateRef || it is ReferenceStateRef || it is TimeWindow || it == notaryParty || it is NetworkParametersHash</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$protected</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$val historicNotary = (serviceHub.networkParametersService as NetworkParametersStorage).getHistoricNotary(notaryParty) ?: throw IllegalStateException("The notary party $notaryParty specified by transaction ${stx.id}, is not recognised as a current or historic notary.")</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$val notarisationRequest = NotarisationRequest(stx.inputs.map { it.copy(txhash = SecureHash.parse(it.txhash.toString())) }, stx.id)</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client.NotarySendTransactionFlow$@Suspendable override</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client.NotarySendTransactionFlow$private</ID>
    <ID>MaxLineLength:NotaryFlow.kt$net.corda.core.flows.NotaryFlow.kt</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$ private fun maybeInstallSerializationFilter(serviceClass: Class&lt;out NotaryService&gt;)</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$ private fun scanCorDapps(cordappLoader: CordappLoader): Class&lt;out NotaryService&gt;</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$ private fun validateNotaryType(myNotaryIdentity: PartyAndCertificate?, services: ServiceHubInternal)</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$"Configured as validating: $configuredAsValidatingNotary. Advertised as validating: $validatingNotaryInNetworkMapCache"</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$?:</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$fun loadService(myNotaryIdentity: PartyAndCertificate?, services: ServiceHubInternal, cordappLoader: CordappLoader): NotaryService</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$throw IllegalStateException("There is a discrepancy in the configured notary type and the one advertised in the network parameters - shutting down. " + "Configured as validating: $configuredAsValidatingNotary. Advertised as validating: $validatingNotaryInNetworkMapCache")</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$val notaryParty = myNotaryIdentity?.party ?: throw IllegalStateException("Could not establish notary identity of this node")</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow : FlowLogic</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$ @Suspendable abstract fun verifyTransaction(requestPayload: NotarisationPayload)</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$"The notary specified on the transaction: [$notary] does not match the notary service's identity: [${service.notaryIdentityKey}] "</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$@Suspendable private</ID>
    <ID>MaxLineLength:NotaryServiceTests.kt$NotaryServiceTests$assertThat(notaryError.cause).hasMessageContaining("Transaction for notarisation contains unknown parameters hash: $hash")</ID>
    <ID>MaxLineLength:NotaryServiceTests.kt$NotaryServiceTests$assertThat(notaryError.cause).hasMessageContaining("Transaction for notarisation doesn't contain network parameters hash.")</ID>
    <ID>MaxLineLength:NotaryServiceTests.kt$NotaryServiceTests.Companion$ fun notariseWithTooManyInputs(node: TestStartedNode, party: Party, notary: Party, network: InternalMockNetwork)</ID>
    <ID>MaxLineLength:NotaryServiceTests.kt$NotaryServiceTests.Companion$val signableData = SignableData(tx.id, SignatureMetadata(myInfo.platformVersion, Crypto.findSignatureScheme(myKey).schemeNumberID))</ID>
    <ID>MaxLineLength:NotarySpec.kt$NotarySpec</ID>
    <ID>MaxLineLength:NotarySpec.kt$NotarySpec$// These extra fields are handled this way to preserve Kotlin wire compatibility wrt additional parameters with default values. constructor( name: CordaX500Name, validating: Boolean = true, rpcUsers: List&lt;User&gt; = emptyList(), verifierType: VerifierType = VerifierType.InMemory, cluster: ClusterSpec? = null, maximumHeapSize: String = "512m" ) : this(name, validating, rpcUsers, verifierType, cluster) { this.maximumHeapSize = maximumHeapSize }</ID>
    <ID>MaxLineLength:NotaryUtils.kt$"Expected a signature by ${intendedSigner.owningKey.toBase58String()}, but received by ${signature.by.toBase58String()}}"</ID>
    <ID>MaxLineLength:NotaryUtils.kt$require(notary.owningKey.isFulfilledBy(signingKeys)) { "Insufficient signatures to fulfill the notary signing requirement for $notary" }</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests$ @Test fun `can perform notary change on a de-listed notary`()</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests$ @Test fun `can't perform a regular transaction on a de-listed notary`()</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests$notarySpecs = listOf(MockNetworkNotarySpec(oldNotaryName, validating = isValidating), MockNetworkNotarySpec(newNotaryName, validating = isValidating))</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests$private</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests${ // Issue a state using the old notary. It is currently whitelisted. val stateFakeNotary = issueStateOnOldNotary(oldNotary) // Remove old notary from the whitelist val parameters = aliceNode.services.networkParameters val newParameters = removeOldNotary(parameters) mockNet.nodes.forEach { (it.networkParametersStorage as MockNetworkParametersStorage).setCurrentParametersUnverified(newParameters) } // Re-point the state to the remaining whitelisted notary. The transaction itself should be considered valid, even though the old notary is not whitelisted. val futureChange = aliceNode.services.startFlow(NotaryChangeFlow(stateFakeNotary, newNotary)).resultFuture mockNet.runNetwork() val newSTate = futureChange.getOrThrow() // Create a valid transaction consuming the re-pointed state. val validTxBuilder = TransactionBuilder(newNotary) .addInputState(newSTate) .addCommand(dummyCommand(alice.owningKey)) val validStx = aliceNode.services.signInitialTransaction(validTxBuilder) // The transaction verifies. validStx.verify(aliceNode.services, false) // Notarisation should succeed. val future = runNotaryClient(validStx) future.getOrThrow() }</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests${ Assume.assumeTrue(isValidating) // Skip the test for non-validating notaries val fakeNotaryKeyPair = generateKeyPair() val fakeNotaryParty = Party(DUMMY_NOTARY_NAME.copy(organisation = "Fake notary"), fakeNotaryKeyPair.public) // Issue a state using an unlisted notary. This transaction should not verify when checked by counterparties. val stateFakeNotary = issueStateWithFakeNotary(fakeNotaryParty, fakeNotaryKeyPair) // Re-point the state to the whitelisted notary. The transaction itself should be considered valid, even though the old notary is not whitelisted. val notaryChangeLtx = changeNotary(stateFakeNotary, fakeNotaryParty, fakeNotaryKeyPair) // Create a valid transaction consuming the re-pointed state. val inputStateValidNotary = notaryChangeLtx.outRef&lt;DummyContract.State&gt;(0) val validTxBuilder = TransactionBuilder(oldNotary) .addInputState(inputStateValidNotary) .addCommand(dummyCommand(alice.owningKey)) val validStx = aliceNode.services.signInitialTransaction(validTxBuilder) // The transaction itself verifies, as no resolution is done here. validStx.verify(aliceNode.services, false) val future = runNotaryClient(validStx) // The notary should reject this transaction – the issue transaction in the dependencies should not verify. val ex = assertFailsWith(NotaryException::class) { future.getOrThrow() } assert(ex.error is NotaryError.TransactionInvalid) assertEquals(validStx.id, ex.txId) }</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests${ val notaryChangeTx = NotaryChangeTransactionBuilder( listOf(inputState.ref), fakeNotaryParty, oldNotary, aliceNode.services.networkParametersService.currentHash ).build() val notaryChangeAliceSig = getAliceSig(notaryChangeTx) val notaryChangeNotarySig = run { val metadata = SignatureMetadata(4, Crypto.findSignatureScheme(fakeNotaryParty.owningKey).schemeNumberID) val data = SignableData(notaryChangeTx.id, metadata) fakeNotaryKeyPair.sign(data) } val notaryChangeStx = SignedTransaction(notaryChangeTx, listOf(notaryChangeAliceSig, notaryChangeNotarySig)) aliceNode.services.validatedTransactions.addTransaction(notaryChangeStx) // Resolving the ledger transaction verifies the whitelist checking logic – for notary change transactions the old notary // does not need to be whitelisted. val notaryChangeLtx = notaryChangeStx.resolveNotaryChangeTransaction(aliceNode.services) notaryChangeLtx.verifyRequiredSignatures() return notaryChangeLtx }</ID>
    <ID>MaxLineLength:NotaryWireFormat.kt$NotarisationPayload</ID>
    <ID>MaxLineLength:NotaryWireFormat.kt$NotarisationRequest</ID>
    <ID>MaxLineLength:NotaryWireFormat.kt$NotarisationRequest$/** States this request specifies to be consumed. Sorted to ensure the serialized form does not get affected by the state order. */ val statesToConsume: List&lt;StateRef&gt; get() = _statesToConsumeSorted // Getter required for AMQP serialization</ID>
    <ID>MaxLineLength:NullKeys.kt$NullKeys$/** A signature with a key and value of zero. Useful when you want a signature object that you know won't ever be used. */ val NULL_SIGNATURE = TransactionSignature(ByteArray(32), NullPublicKey, SignatureMetadata(1, -1))</ID>
    <ID>MaxLineLength:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$val defnsCcp1 = RatesCalibrationCsvLoader.load(GROUPS_RESOURCE_CCP1, SETTINGS_RESOURCE_CCP1, CALIBRATION_RESOURCE_CCP1)</ID>
    <ID>MaxLineLength:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$val defnsCcp2 = RatesCalibrationCsvLoader.load(GROUPS_RESOURCE_CCP2, SETTINGS_RESOURCE_CCP2, CALIBRATION_RESOURCE_CCP2)</ID>
    <ID>MaxLineLength:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$val marketData = ImmutableMarketData.builder(VAL_DATE).addValueMap(quotesCcp1).addValueMap(quotesCcp2).addTimeSeriesMap(fixings).build()</ID>
    <ID>MaxLineLength:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$val marketDataConfig = MarketDataConfig.builder().add(CURVE_GROUP_NAME_CCP1, curveGroupDefinitionCcp1).add(CURVE_GROUP_NAME_CCP2, curveGroupDefinitionCcp2).build()</ID>
    <ID>MaxLineLength:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$val tradeInfo = TradeInfo.builder().id(StandardId.of("example", "1")).addAttribute(TradeAttributeType.DESCRIPTION, "Fixed vs Libor 3m").counterparty(ctptyId).settlementDate(LocalDate.of(2014, 9, 12)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$PeriodicSchedule.builder() .startDate(LocalDate.of(2014, 9, 12)) .endDate(LocalDate.of(2016, 6, 12)) .frequency(Frequency.P3M) .businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY))</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$PeriodicSchedule.builder() .startDate(LocalDate.of(2014, 9, 12)) .endDate(LocalDate.of(2016, 6, 12)) .stubConvention(StubConvention.SHORT_INITIAL) .frequency(Frequency.P6M)</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$PeriodicSchedule.builder() .startDate(LocalDate.of(2014, 9, 12)) .endDate(LocalDate.of(2020, 9, 12)) .frequency(Frequency.P3M) .businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY))</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "10")).addAttribute(TradeAttributeType.DESCRIPTION, "Zero-coupon fixed vs libor 3m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "11")).addAttribute(TradeAttributeType.DESCRIPTION, "Compounding fixed vs fed funds").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 2, 5)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "12")).addAttribute(TradeAttributeType.DESCRIPTION, "Compounding fed funds vs libor 3m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "13")).addAttribute(TradeAttributeType.DESCRIPTION, "Compounding libor 6m vs libor 3m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 8, 27)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "15")).addAttribute(TradeAttributeType.DESCRIPTION, "USD fixed vs GBP Libor 3m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 1, 24)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "16")).addAttribute(TradeAttributeType.DESCRIPTION, "USD fixed vs GBP Libor 3m (notional exchange)").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 1, 24)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "2")).addAttribute(TradeAttributeType.DESCRIPTION, "Libor 3m + spread vs Libor 6m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "7")).addAttribute(TradeAttributeType.DESCRIPTION, "Fixed vs Libor 3m (1m short initial stub)").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "8")).addAttribute(TradeAttributeType.DESCRIPTION, "Fixed vs Libor 6m (interpolated 3m short initial stub)").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "9")).addAttribute(TradeAttributeType.DESCRIPTION, "Fixed vs Libor 6m (interpolated 4m short initial stub)").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(receiveLeg, payLeg)).info(TradeInfo.builder().id(StandardId.of("example", "14")).addAttribute(TradeAttributeType.DESCRIPTION, "GBP Libor 3m vs USD Libor 3m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 1, 24)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val calculationResults = ReportCalculationResults.of(valuationDate, trades, columns, results, functions, refData)</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.GBLO)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.of(Currency.GBP, 61600000.0)).calculation(IborRateCalculation.of(IborIndices.GBP_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.GBLO)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.builder().currency(Currency.USD).amount(ValueSchedule.of(100000000.0)).initialExchange(true).finalExchange(true).build()).calculation(FixedRateCalculation.of(0.03, DayCounts.THIRTY_U_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.GBLO)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.of(Currency.USD, 100000000.0)).calculation(FixedRateCalculation.of(0.03, DayCounts.THIRTY_U_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 2, 5)).endDate(LocalDate.of(2014, 4, 7)).frequency(Frequency.TERM).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.TERM).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(FixedRateCalculation.of(0.00123, DayCounts.ACT_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 8, 27)).endDate(LocalDate.of(2024, 8, 27)).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(IborRateCalculation.of(IborIndices.USD_LIBOR_6M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2016, 6, 12)).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).stubConvention(StubConvention.SHORT_INITIAL).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(IborRateCalculation.builder().index(IborIndices.USD_LIBOR_6M).initialStub(IborRateStubCalculation.ofIborInterpolatedRate(IborIndices.USD_LIBOR_3M, IborIndices.USD_LIBOR_6M)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2016, 7, 12)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).stubConvention(StubConvention.SHORT_INITIAL).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(IborRateCalculation.of(IborIndices.USD_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2016, 7, 12)).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).stubConvention(StubConvention.SHORT_INITIAL).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(IborRateCalculation.builder().index(IborIndices.USD_LIBOR_6M).initialStub(IborRateStubCalculation.ofIborInterpolatedRate(IborIndices.USD_LIBOR_3M, IborIndices.USD_LIBOR_6M)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2020, 9, 12)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(IborRateCalculation.of(IborIndices.USD_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2021, 9, 12)).frequency(Frequency.P12M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.TERM).paymentDateOffset(DaysAdjustment.NONE).compoundingMethod(CompoundingMethod.STRAIGHT).build()).notionalSchedule(notional).calculation(FixedRateCalculation.of(0.015, DayCounts.THIRTY_U_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.GBLO)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.builder().currency(Currency.GBP).amount(ValueSchedule.of(61600000.0)).initialExchange(true).finalExchange(true).build()).calculation(IborRateCalculation.of(IborIndices.GBP_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.GBLO)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.of(Currency.GBP, 61600000.0)).calculation(IborRateCalculation.of(IborIndices.GBP_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.of(Currency.USD, 100000000.0)).calculation(IborRateCalculation.builder().index(IborIndices.USD_LIBOR_3M).spread(ValueSchedule.of(0.0091)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 2, 5)).endDate(LocalDate.of(2014, 4, 7)).frequency(Frequency.TERM).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).stubConvention(StubConvention.SHORT_INITIAL).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.TERM).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(OvernightRateCalculation.of(OvernightIndices.USD_FED_FUND)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 8, 27)).endDate(LocalDate.of(2024, 8, 27)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).compoundingMethod(CompoundingMethod.STRAIGHT).build()).notionalSchedule(notional).calculation(IborRateCalculation.of(IborIndices.USD_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2016, 6, 12)).stubConvention(StubConvention.SHORT_INITIAL).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(FixedRateCalculation.of(0.01, DayCounts.THIRTY_U_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2016, 7, 12)).stubConvention(StubConvention.SHORT_INITIAL).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(FixedRateCalculation.of(0.01, DayCounts.THIRTY_U_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2020, 9, 12)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(OvernightRateCalculation.builder().index(OvernightIndices.USD_FED_FUND).accrualMethod(OvernightAccrualMethod.AVERAGED).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2021, 9, 12)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.TERM).paymentDateOffset(DaysAdjustment.NONE).compoundingMethod(CompoundingMethod.STRAIGHT).build()).notionalSchedule(notional).calculation(IborRateCalculation.of(IborIndices.USD_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGTrade.kt$OGTrade$val groups: List&lt;LedgerTransaction.InOutGroup&lt;IRSState, UniqueIdentifier&gt;&gt; = tx.groupStates { state -&gt; state.linearId }</ID>
    <ID>MaxLineLength:ObjectBuilder.kt$ConstructorCaller$"Constructor for ${javaConstructor.declaringClass} (isAccessible=${javaConstructor.isAccessible}) "</ID>
    <ID>MaxLineLength:ObjectBuilder.kt$EvolutionObjectBuilder.Companion$ fun makeProvider( typeIdentifier: TypeIdentifier, constructor: LocalConstructorInformation, localProperties: Map&lt;String, LocalPropertyInformation&gt;, remoteTypeInformation: RemoteTypeInformation.Composable, mustPreserveData: Boolean ): () -&gt; ObjectBuilder</ID>
    <ID>MaxLineLength:ObjectBuilder.kt$ObjectBuilder.Companion$ConstructorBasedObjectBuilder(ConstructorCaller(constructor.observedMethod), constructorIndices.values.toIntArray())</ID>
    <ID>MaxLineLength:ObjectBuilder.kt$ObjectBuilder.Companion$is LocalPropertyInformation.PrivateConstructorPairedProperty -&gt; property.constructorSlot.parameterIndex</ID>
    <ID>MaxLineLength:ObjectBuilder.kt$ObjectBuilderProvider : </ID>
    <ID>MaxLineLength:ObjectDiffer.kt$DiffTree$is Step -&gt; branches.flatMap { (step, tree) -&gt; tree.toPaths().map { it.copy(path = listOf(step) + it.path) } }</ID>
    <ID>MaxLineLength:ObjectDiffer.kt$ObjectDiffer$val branches = aFields.mapNotNull { field -&gt; diff(field.get(a), field.get(b))?.let { field.name to it } }</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$ComposableObjectReader$"${propertySerializers.size} properties in described type ${typeIdentifier.prettyPrint(false)}"</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$ComposableObjectReader$fun readObject(obj: Any, schemas: SerializationSchemas, input: DeserializationInput, context: SerializationContext): Any</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$EvolutionObjectSerializer.Companion$ComposableTypePropertySerializer.makeForEvolution(name, isCalculated, property.type.typeIdentifier, type)</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$EvolutionObjectSerializer.Companion$val type = localProperty?.type?.observedType ?: property.type.typeIdentifier.getLocalType(classLoader)</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$ObjectSerializer.Companion$serializers.isNotEmpty() -&gt; "Registered custom serializers:\n ${serializers.joinToString("\n ")}"</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$ObjectSerializer.Companion$val writer = ComposableObjectWriter(typeNotation, typeInformation.interfacesOrEmptyList, propertySerializers)</ID>
    <ID>MaxLineLength:Obligation.kt$ fun &lt;P : AbstractParty, T : Any&gt; sumAmountsDue(balances: Map&lt;Pair&lt;P, P&gt;, Amount&lt;T&gt;&gt;): Map&lt;P, Long&gt;</ID>
    <ID>MaxLineLength:Obligation.kt$ fun &lt;P : Any&gt; extractAmountsDue(product: Obligation.Terms&lt;P&gt;, states: Iterable&lt;Obligation.State&lt;P&gt;&gt;): Map&lt;Pair&lt;AbstractParty, AbstractParty&gt;, Amount&lt;Obligation.Terms&lt;P&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$"amount in settle command ${command.value.amount} matches settled total $totalAmountSettled" using (command.value.amount == totalAmountSettled)</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$"amounts paid must match recipients to settle" using inputs.map { it.owner }.containsAll(amountReceivedByOwner.keys)</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$"output state corresponds exactly to input state, with lifecycle changed" using (expectedOutput == actualOutput)</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$// Insist that we can be the only contract consuming inputs, to ensure no other contract can think it's being // settled as well "all move commands relate to this contract" using (moveCommands.map { it.value.contract } .all { it == null || it == this@Obligation.javaClass }) // Settle commands exclude all other commands, so we don't need to check for contracts moving at the same // time. "amounts paid must match recipients to settle" using inputs.map { it.owner }.containsAll(amountReceivedByOwner.keys) "amount in settle command ${command.value.amount} matches settled total $totalAmountSettled" using (command.value.amount == totalAmountSettled) "signatures are present from all obligors" using command.signers.containsAll(requiredSigners) "there are no zero sized inputs" using inputs.none { it.amount.quantity == 0L } "at obligor $obligor the obligations after settlement balance" using (inputAmount == outputAmount + Amount(totalPenniesSettled, groupingKey))</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$NetType.CLOSE_OUT -&gt; require(command.signers.intersect(involvedParties).isNotEmpty()) { "any involved party has signed" }</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$NetType.PAYMENT -&gt; require(command.signers.containsAll(involvedParties)) { "all involved parties have signed" }</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$val exitCommand = tx.commands.select&lt;Commands.Exit&lt;P&gt;&gt;(parties = null, signers = exitKeys).singleOrNull { it.value.amount.token == key }</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$val inputAmount = inputs.sumObligationsOrNull&lt;P&gt;() ?: throw IllegalArgumentException("there is at least one obligation input for this group")</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$val inputAmount: Amount&lt;Issued&lt;Terms&lt;P&gt;&gt;&gt; = inputs.sumObligationsOrNull() ?: throw IllegalArgumentException("there is at least one obligation input for this group")</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$val involvedParties: Set&lt;PublicKey&gt; = groupInputs.map { it.beneficiary.owningKey }.union(groupInputs.map { it.obligor.owningKey }).toSet()</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation${ val template = key.template // Create two maps of balances from obligors to beneficiaries, one for input states, the other for output states. val inputBalances = extractAmountsDue(template, groupInputs) val outputBalances = extractAmountsDue(template, groupOutputs) // Sum the columns of the matrices. This will yield the net amount payable to/from each party to/from all other participants. // The two summaries must match, reflecting that the amounts owed match on both input and output. requireThat { "all input states use the same template" using (groupInputs.all { it.template == template }) "all output states use the same template" using (groupOutputs.all { it.template == template }) "amounts owed on input and output must match" using (sumAmountsDue(inputBalances) == sumAmountsDue (outputBalances)) } // TODO: Handle proxies nominated by parties, i.e. a central clearing service val involvedParties: Set&lt;PublicKey&gt; = groupInputs.map { it.beneficiary.owningKey }.union(groupInputs.map { it.obligor.owningKey }).toSet() when (command.value.type) { // For close-out netting, allow any involved party to sign NetType.CLOSE_OUT -&gt; require(command.signers.intersect(involvedParties).isNotEmpty()) { "any involved party has signed" } // Require signatures from all parties (this constraint can be changed for other contracts, and is used as a // placeholder while exact requirements are established), or fail the transaction. NetType.PAYMENT -&gt; require(command.signers.containsAll(involvedParties)) { "all involved parties have signed" } } }</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation.Commands$SetLifecycle : CommandData</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation.State$override fun withNewOwner(newOwner: AbstractParty)</ID>
    <ID>MaxLineLength:Obligation.kt$infix fun &lt;T : Any&gt; Obligation.State&lt;T&gt;.between(parties: Pair&lt;AbstractParty, AbstractParty&gt;)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$ @Test fun `generate close-out net transaction with remainder`()</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$ @Test fun `generate payment net transaction with remainder`()</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$ObligationUtils.generatePaymentNetting(this, obligationAliceToBob.state.data.amount.token, DUMMY_NOTARY, obligationAliceToBob, obligationBobToAlice)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$ObligationUtils.generatePaymentNetting(this, obligationAliceToBobState.amount.token, DUMMY_NOTARY, obligationAliceToBob, obligationBobToAlice)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$ObligationUtils.generateSettle(this, listOf(obligationTx.outRef&lt;Obligation.State&lt;Currency&gt;&gt;(0)), listOf(cashTx.outRef(0)), Cash.Commands.Move(), DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$assertNotEquals(oneKDollarsFromMiniToMega.bilateralNetState, oneKDollarsFromMiniToMega.copy(template = megaCorpPoundSettlement).bilateralNetState)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$command(ALICE_PUBKEY, Obligation.Commands.Settle(Amount(oneMillionDollars.quantity / 2, inState.amount.token)))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$command(ALICE_PUBKEY, Obligation.Commands.Settle(Amount(oneMillionDollars.quantity, inState.amount.token)))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$command(ALICE_PUBKEY, Obligation.Commands.Settle(Amount(oneUnitFcoj.quantity, oneUnitFcojObligation.amount.token)))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$command(CHARLIE.owningKey, Obligation.Commands.Exit(Amount(200.DOLLARS.quantity, inState.amount.token.copy(product = megaCorpDollarSettlement))))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$command(CHARLIE.owningKey, Obligation.Commands.Exit(Amount(200.POUNDS.quantity, inState.amount.token.copy(product = megaCorpPoundSettlement))))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$fiveKDollarsFromMegaToMega.copy(template = megaCorpDollarSettlement.copy(acceptableContracts = NonEmptySet.of(SecureHash.randomSHA256()))).bilateralNetState</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$fiveKDollarsFromMegaToMega.copy(template = megaCorpDollarSettlement.copy(acceptableIssuedProducts = miniCorpIssuer)).bilateralNetState</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$fiveKDollarsFromMegaToMega.copy(template = megaCorpDollarSettlement.copy(dueBefore = sixPm)).bilateralNetState</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$fiveKDollarsFromMegaToMini</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$get() = Obligation.State(Obligation.Lifecycle.NORMAL, DUMMY_OBLIGATION_ISSUER, token.OBLIGATION_DEF, quantity, NULL_PARTY)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$get() = Obligation.Terms(NonEmptySet.of(cashContractBytes.sha256() as SecureHash), NonEmptySet.of(this), TEST_TX_TIME)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$input(Obligation.PROGRAM_ID, inState.copy(template = inState.template.copy(acceptableIssuedProducts = megaIssuedDollars)))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$input(Obligation.PROGRAM_ID, inState.copy(template = inState.template.copy(acceptableIssuedProducts = megaIssuedPounds)))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, "Alice's $1,000,000 obligation to Bob", oneMillionDollars.OBLIGATION between Pair(ALICE, BOB))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, "Alice's $500,000 obligation to Bob", halfAMillionDollars.OBLIGATION between Pair(ALICE, BOB))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, "Alice's 1 FCOJ obligation to Bob", oneUnitFcojObligation between Pair(ALICE, BOB))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, "Alice's defaulted $1,000,000 obligation to Bob", (oneMillionDollars.OBLIGATION between Pair(ALICE, BOB) at futureTestTime).copy(lifecycle = Lifecycle.DEFAULTED))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, "Alice's defaulted $1,000,000 obligation to Bob", (oneMillionDollars.OBLIGATION between Pair(ALICE, BOB) at pastTestTime).copy(lifecycle = Lifecycle.DEFAULTED))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, "Alice's defaulted $1,000,000 obligation to Bob", (oneMillionDollars.OBLIGATION between Pair(ALICE, BOB)).copy(lifecycle = Lifecycle.DEFAULTED))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, "Bob's $1,000,000 obligation to Alice", oneMillionDollars.OBLIGATION between Pair(BOB, ALICE))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, "MegaCorp's $1,000,000 obligation to Alice", oneMillionDollars.OBLIGATION between Pair(MEGA_CORP, ALICE))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, "MegaCorp's $1,000,000 obligation to Bob", oneMillionDollars.OBLIGATION between Pair(MEGA_CORP, BOB))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, "change", oneMillionDollars.splitEvenly(2).first().OBLIGATION between Pair(ALICE, BOB))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, inState.copy(beneficiary = AnonymousParty(BOB_PUBKEY), quantity = 200000L))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, inState.copy(template = inState.template.copy(acceptableIssuedProducts = megaIssuedDollars), quantity = inState.quantity - 200.DOLLARS.quantity))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, inState.copy(template = inState.template.copy(acceptableIssuedProducts = megaIssuedPounds), quantity = inState.quantity - 200.POUNDS.quantity))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$private</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$private inline</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$private val cashContractBytes = fakeAttachment("file1.txt", "https://www.big-book-of-banking-law.gov/cash-claims.html")</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$private val ledgerServices get() = MockServices(listOf("net.corda.finance.contracts.asset", "net.corda.testing.contracts"), MEGA_CORP.name, identityService)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val commodityContractBytes = fakeAttachment("file1.txt", "https://www.big-book-of-banking-law.gov/commodity-claims.html")</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val defaultedObligation: Obligation.State&lt;Currency&gt; = (oneMillionDollars.OBLIGATION between Pair(ALICE, BOB)).copy(lifecycle = Lifecycle.DEFAULTED)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val expected = obligationBobToAliceState.copy(quantity = obligationBobToAliceState.quantity - obligationAliceToBobState.quantity)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val expected: Map&lt;Pair&lt;AbstractParty, AbstractParty&gt;, Amount&lt;Currency&gt;&gt; = emptyMap() // Zero balances are stripped before returning</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val expected: Map&lt;Pair&lt;AbstractParty, AbstractParty&gt;, Amount&lt;Obligation.Terms&lt;Currency&gt;&gt;&gt; = mapOf(Pair(Pair(MEGA_CORP, MINI_CORP), Amount(amount.quantity, amount.token.product)))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val obligationAliceToBob = getStateAndRef((2000000.DOLLARS `issued by` defaultIssuer).OBLIGATION between Pair(ALICE, BOB), Obligation.PROGRAM_ID)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val obligationAliceToBob = getStateAndRef(oneMillionDollars.OBLIGATION between Pair(ALICE, BOB), Obligation.PROGRAM_ID)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val obligationBobToAlice = getStateAndRef((2000000.DOLLARS `issued by` defaultIssuer).OBLIGATION between Pair(BOB, ALICE), Obligation.PROGRAM_ID)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val obligationBobToAlice = getStateAndRef(oneMillionDollars.OBLIGATION between Pair(BOB, ALICE), Obligation.PROGRAM_ID)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val obligationDef = Obligation.Terms(NonEmptySet.of(commodityContractBytes.sha256() as SecureHash), NonEmptySet.of(defaultFcoj), TEST_TX_TIME)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val pounds = Obligation.State(Lifecycle.NORMAL, MINI_CORP, megaCorpPoundSettlement, 658.POUNDS.quantity, AnonymousParty(BOB_PUBKEY))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val simple: Map&lt;Pair&lt;AbstractParty, AbstractParty&gt;, Amount&lt;Currency&gt;&gt; = mapOf(Pair(Pair(ALICE, BOB), Amount(100000000, GBP)))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val txState = TransactionState(state, contractClassName, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests.&lt;no name provided&gt;$override fun loadState(stateRef: StateRef): TransactionState&lt;*&gt;</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$"all obligation states are in the normal state" using (statesAndRefs.all { it.state.data.lifecycle == Obligation.Lifecycle.NORMAL })</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$"all obligation states have the same beneficiary" using (statesAndRefs.all { it.state.data.beneficiary == obligationOwner })</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$"all obligation states have the same obligor" using (statesAndRefs.all { it.state.data.obligor == obligationIssuer })</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$"all states are in the normal lifecycle state " using (states.all { it.lifecycle == Obligation.Lifecycle.NORMAL })</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$Obligation.State(Obligation.Lifecycle.NORMAL, obligor, issuanceDef, amount.quantity, beneficiary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$deriveState = { state, amount, owner -&gt; state.copy(data = state.data.withNewOwnerAndAmount(amount, owner)) }</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$private</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$require(states.all { it.lifecycle == existingLifecycle }) { "initial lifecycle must be $existingLifecycle for all input states" }</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addCommand(Obligation.Commands.Settle(Amount((obligationTotal - obligationRemaining).quantity, issuanceDef)), obligationIssuer.owningKey)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addOutputState(Obligation.State(Obligation.Lifecycle.NORMAL, obligationIssuer, template, obligationRemaining.quantity, obligationOwner), Obligation.PROGRAM_ID, notary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addOutputState(assetState.withNewOwnerAndAmount(assetState.amount - change, assetState.owner), Obligation.PROGRAM_ID, notary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addOutputState(assetState.withNewOwnerAndAmount(assetState.amount, obligationOwner), Obligation.PROGRAM_ID, notary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addOutputState(assetState.withNewOwnerAndAmount(change, obligationOwner), Obligation.PROGRAM_ID, notary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$val changeOwner = assetStates.map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amountIssued)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils${ val states = statesAndRefs.map { it.state } val obligationIssuer = states.first().data.obligor val obligationOwner = states.first().data.beneficiary requireThat { "all fungible asset states use the same notary" using (assetStatesAndRefs.all { it.state.notary == notary }) "all obligation states are in the normal state" using (statesAndRefs.all { it.state.data.lifecycle == Obligation.Lifecycle.NORMAL }) "all obligation states use the same notary" using (statesAndRefs.all { it.state.notary == notary }) "all obligation states have the same obligor" using (statesAndRefs.all { it.state.data.obligor == obligationIssuer }) "all obligation states have the same beneficiary" using (statesAndRefs.all { it.state.data.beneficiary == obligationOwner }) } // TODO: A much better (but more complex) solution would be to have two iterators, one for obligations, // one for the assets, and step through each in a semi-synced manner. For now however we just bundle all the states // on each side together val issuanceDef = getIssuanceDefinitionOrThrow(statesAndRefs.map { it.state.data }) val template: Obligation.Terms&lt;P&gt; = issuanceDef.product val obligationTotal: Amount&lt;P&gt; = Amount(states.map { it.data }.sumObligations&lt;P&gt;().quantity, template.product) var obligationRemaining: Amount&lt;P&gt; = obligationTotal val assetSigners = HashSet&lt;AbstractParty&gt;() statesAndRefs.forEach { tx.addInputState(it) } // Move the assets to the new beneficiary assetStatesAndRefs.forEach { ref -&gt; if (obligationRemaining.quantity &gt; 0L) { tx.addInputState(ref) val assetState = ref.state.data val amount = Amount(assetState.amount.quantity, assetState.amount.token.product) obligationRemaining -= if (obligationRemaining &gt;= amount) { tx.addOutputState(assetState.withNewOwnerAndAmount(assetState.amount, obligationOwner), Obligation.PROGRAM_ID, notary) amount } else { val change = Amount(obligationRemaining.quantity, assetState.amount.token) // Split the state in two, sending the change back to the previous beneficiary tx.addOutputState(assetState.withNewOwnerAndAmount(change, obligationOwner), Obligation.PROGRAM_ID, notary) tx.addOutputState(assetState.withNewOwnerAndAmount(assetState.amount - change, assetState.owner), Obligation.PROGRAM_ID, notary) Amount(0L, obligationRemaining.token) } assetSigners.add(assetState.owner) } } // If we haven't cleared the full obligation, add the remainder as an output if (obligationRemaining.quantity &gt; 0L) { tx.addOutputState(Obligation.State(Obligation.Lifecycle.NORMAL, obligationIssuer, template, obligationRemaining.quantity, obligationOwner), Obligation.PROGRAM_ID, notary) } else { // Destroy all of the states } // Add the asset move command and obligation settle tx.addCommand(moveCommand, assetSigners.map { it.owningKey }) tx.addCommand(Obligation.Commands.Settle(Amount((obligationTotal - obligationRemaining).quantity, issuanceDef)), obligationIssuer.owningKey) }</ID>
    <ID>MaxLineLength:ObservableFold.kt$ fun &lt;T, R&gt; Observable&lt;T&gt;.fold(accumulator: R, folderFun: (R, T) -&gt; Unit): R</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$ fun &lt;A&gt; Collection&lt;ObservableValue&lt;out A&gt;&gt;.sequence(): ObservableList&lt;A&gt;</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$ fun &lt;K : Any, A : Any, B&gt; ObservableList&lt;out A&gt;.associateByAggregation(toKey: (A) -&gt; K, assemble: (K, A) -&gt; B): ObservableMap&lt;K, ObservableList&lt;B&gt;&gt;</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$ fun &lt;K : Any, A : Any&gt; ObservableList&lt;out A&gt;.associateByAggregation(toKey: (A) -&gt; K): ObservableMap&lt;K, ObservableList&lt;A&gt;&gt;</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$Pair(left, ChosenList(rightValue.map { it ?: FXCollections.emptyObservableList() }, "ChosenList from leftOuterJoin"))</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$net.corda.client.jfx.utils.ObservableUtilities.kt</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$return AssociatedList(AggregatedList(this, toKey) { key, members -&gt; Pair(key, members) }, { it.first }) { key, pair -&gt; pair.second.map { assemble(key, it) } }</ID>
    <ID>MaxLineLength:ObservableUtilities.kt${ // TODO This is a tactical work round for an issue with SAM conversion (https://youtrack.jetbrains.com/issue/ALL-1552) so that the M10 explorer works. return uncheckedCast(uncheckedCast&lt;Any, ObservableList&lt;A?&gt;&gt;(this).filtered { t -&gt; t != null }) }</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests$StartMessageChainFlow : FlowLogic</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests$alice.services.startFlow(SplitMessagesFlow(message, bob.info.singleIdentity(), notary)).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests$node.services.startFlow(SendTransaction(regulator.info.singleIdentity(), transactionList[transactionIdx])).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ContinueMessageChainFlow$val txCommand = Command(MessageChainContract.Commands.Send(), messageState.participants.map { it.owningKey })</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ContinueMessageChainFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ContinueMessageChainFlow.Companion$fun tracker()</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow$val txCommand = Command(MessageChainContract.Commands.Split(), listOf(ourIdentity.owningKey, counterparty.owningKey))</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow.Companion$fun tracker()</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow$val txBuilder = TransactionBuilder(notary).withItems(StateAndContract(messageState, MESSAGE_CHAIN_CONTRACT_PROGRAM_ID), txCommand)</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow$val txCommand = Command(MessageChainContract.Commands.Send(), messageState.participants.map { it.owningKey })</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow.Companion$fun tracker()</ID>
    <ID>MaxLineLength:OffsetDateTimeSerializer.kt$OffsetDateTimeSerializer : Proxy</ID>
    <ID>MaxLineLength:OffsetDateTimeSerializer.kt$OffsetDateTimeSerializer$override fun toProxy(obj: OffsetDateTime): OffsetDateTimeProxy</ID>
    <ID>MaxLineLength:OffsetDateTimeSerializer.kt$OffsetDateTimeSerializer$override val additionalSerializers: Iterable&lt;CustomSerializer&lt;out Any&gt;&gt; = listOf(LocalDateTimeSerializer(factory), ZoneIdSerializer(factory))</ID>
    <ID>MaxLineLength:OffsetTimeSerializer.kt$OffsetTimeSerializer : Proxy</ID>
    <ID>MaxLineLength:OffsetTimeSerializer.kt$OffsetTimeSerializer$override val additionalSerializers: Iterable&lt;CustomSerializer&lt;out Any&gt;&gt; = listOf(LocalTimeSerializer(factory), ZoneIdSerializer(factory))</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset$abstract</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset$abstract fun extractCommands(commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;): Collection&lt;CommandWithParties&lt;C&gt;&gt;</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset$val changeOwner = assetStates.map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amountIssued)</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$ @Throws(InsufficientBalanceException::class) @JvmStatic @Deprecated("Replaced with generateExit() which takes in a party to pay change to") fun &lt;S : FungibleAsset&lt;T&gt;, T : Any&gt; generateExit( tx: TransactionBuilder, amountIssued: Amount&lt;Issued&lt;T&gt;&gt;, assetStates: List&lt;StateAndRef&lt;S&gt;&gt;, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData, generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData ): Set&lt;PublicKey&gt;</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$ @Throws(InsufficientBalanceException::class) @JvmStatic fun &lt;S : FungibleAsset&lt;T&gt;, T : Any&gt; generateExit( tx: TransactionBuilder, amountIssued: Amount&lt;Issued&lt;T&gt;&gt;, assetStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData, generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData ): Set&lt;PublicKey&gt;</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$log.trace { "Gathered coins: requested $amount, available $gatheredAmount, change: ${gatheredAmount - amount}" }</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$remainingFromEachIssuer[remainingFromEachIssuer.lastIndex] = Pair(token, Amount(delta, token))</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$return generateExit(tx, amountIssued, assetStates, owner, deriveState, generateMoveCommand, generateExitCommand)</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$return generateSpend(tx, listOf(PartyAndAmount(to, amount)), acceptableStates, payChangeTo, deriveState, generateMoveCommand)</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$val owner = assetStates.map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amountIssued)</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion${ // Discussion // // This code is analogous to the Wallet.send() set of methods in bitcoinj, and has the same general outline. // // First we must select a set of asset states (which for convenience we will call 'coins' here, as in bitcoinj). // The input states can be considered our "vault", and may consist of different products, and with different // issuers and deposits. // // Coin selection is a complex problem all by itself and many different approaches can be used. It is easily // possible for different actors to use different algorithms and approaches that, for example, compete on // privacy vs efficiency (number of states created). Some spends may be artificial just for the purposes of // obfuscation and so on. // // Having selected input states of the correct asset, we must craft output states for the amount we're sending and // the "change", which goes back to us. The change is required to make the amounts balance. We may need more // than one change output in order to avoid merging assets from different deposits. The point of this design // is to ensure that ledger entries are immutable and globally identifiable. // // Finally, we add the states to the provided partial transaction. // TODO: We should be prepared to produce multiple transactions spending inputs from // different notaries, or at least group states by notary and take the set with the // highest total value. // TODO: Check that re-running this on the same transaction multiple times does the right thing. // The notary may be associated with a locked state only. tx.notary = acceptableStates.firstOrNull()?.state?.notary // Calculate the total amount we're sending (they must be all of a compatible token). val totalSendAmount = payments.map { it.amount }.sumOrThrow() // Select a subset of the available states we were given that sums up to &gt;= totalSendAmount. val (gathered, gatheredAmount) = gatherCoins(acceptableStates, totalSendAmount) check(gatheredAmount &gt;= totalSendAmount) val keysUsed = gathered.map { it.state.data.owner.owningKey } // Now calculate the output states. This is complicated by the fact that a single payment may require // multiple output states, due to the need to keep states separated by issuer. We start by figuring out // how much we've gathered for each issuer: this map will keep track of how much we've used from each // as we work our way through the payments. val statesGroupedByIssuer = gathered.groupBy { it.state.data.amount.token } val remainingFromEachIssuer = statesGroupedByIssuer .mapValues { it.value.map { it.state.data.amount }.sumOrThrow() }.toList().toMutableList() val outputStates = mutableListOf&lt;TransactionState&lt;S&gt;&gt;() for ((party, paymentAmount) in payments) { var remainingToPay = paymentAmount.quantity while (remainingToPay &gt; 0) { val (token, remainingFromCurrentIssuer) = remainingFromEachIssuer.last() val templateState = statesGroupedByIssuer[token]!!.first().state val delta = remainingFromCurrentIssuer.quantity - remainingToPay when { delta &gt; 0 -&gt; { // The states from the current issuer more than covers this payment. outputStates += deriveState(templateState, Amount(remainingToPay, token), party) remainingFromEachIssuer[remainingFromEachIssuer.lastIndex] = Pair(token, Amount(delta, token)) remainingToPay = 0 } delta == 0L -&gt; { // The states from the current issuer exactly covers this payment. outputStates += deriveState(templateState, Amount(remainingToPay, token), party) remainingFromEachIssuer.removeAt(remainingFromEachIssuer.lastIndex) remainingToPay = 0 } delta &lt; 0 -&gt; { // The states from the current issuer don't cover this payment, so we'll have to use &gt;1 output // state to cover this payment. outputStates += deriveState(templateState, remainingFromCurrentIssuer, party) remainingFromEachIssuer.removeAt(remainingFromEachIssuer.lastIndex) remainingToPay -= remainingFromCurrentIssuer.quantity } } } } // Whatever values we have left over for each issuer must become change outputs. for ((token, amount) in remainingFromEachIssuer) { val templateState = statesGroupedByIssuer[token]!!.first().state outputStates += deriveState(templateState, amount, payChangeTo) } for (state in gathered) tx.addInputState(state) for (state in outputStates) tx.addOutputState(state) // What if we already have a move command with the right keys? Filter it out here or in platform code? tx.addCommand(generateMoveCommand(), keysUsed) return Pair(tx, keysUsed) }</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion${ // The states from the current issuer don't cover this payment, so we'll have to use &gt;1 output // state to cover this payment. outputStates += deriveState(templateState, remainingFromCurrentIssuer, party) remainingFromEachIssuer.removeAt(remainingFromEachIssuer.lastIndex) remainingToPay -= remainingFromCurrentIssuer.quantity }</ID>
    <ID>MaxLineLength:OpaqueBytesSubSequenceSerializer.kt$OpaqueBytesSubSequenceSerializer$CustomSerializer.Proxy&lt;OpaqueBytesSubSequence, OpaqueBytes&gt;(OpaqueBytesSubSequence::class.java, OpaqueBytes::class.java, factory)</ID>
    <ID>MaxLineLength:OpaqueBytesSubSequenceSerializer.kt$OpaqueBytesSubSequenceSerializer$override fun fromProxy(proxy: OpaqueBytes): OpaqueBytesSubSequence</ID>
    <ID>MaxLineLength:OpenGammaCordaUtils.kt$ fun InitialMarginTriple.toCordaCompatible()</ID>
    <ID>MaxLineLength:OpenGammaCordaUtils.kt$return MultiCurrencyAmount.of(this.amounts.map { CurrencyAmount.of(Currency.of(it.currency.code).serialize().deserialize(), twoDecimalPlaces((it.amount))) })</ID>
    <ID>MaxLineLength:OptionalSerializer.kt$OptionalSerializer : Proxy</ID>
    <ID>MaxLineLength:OracleNodeTearOffTests.kt$OracleNodeTearOffTests$TransactionBuilder(DUMMY_NOTARY) .withItems(TransactionState(1000.DOLLARS.CASH issuedBy dummyCashIssuer.party ownedBy alice.party, Cash.PROGRAM_ID, DUMMY_NOTARY))</ID>
    <ID>MaxLineLength:OracleNodeTearOffTests.kt$OracleNodeTearOffTests$TransactionState(1000.DOLLARS.CASH issuedBy dummyCashIssuer.party ownedBy alice.party, Cash.PROGRAM_ID, DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:OverridePKSerializerTest.kt$OverridePKSerializerTest.TestPublicKeySerializer$get() = TODO("not implemented") // To change initializer of created properties use File | Settings | File Templates.</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$driver</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$nodeA.rpc.hasCancelledDrainingShutdown().doOnError(Throwable::printStackTrace).doOnError { successful = false }.doOnCompleted { successful = true }.doAfterTerminate(latch::countDown).subscribe()</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$nodeA.rpc.waitForShutdown().doOnError(Throwable::printStackTrace).doOnError { successful = false }.doOnCompleted(nodeA::stop)</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$nodeA.waitForShutdown().doOnError(Throwable::printStackTrace).doAfterTerminate { successful = false }.doAfterTerminate(latch::countDown).subscribe()</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$nodeA.waitForShutdown().doOnError(Throwable::printStackTrace).doOnError { successful = false }.doOnCompleted { successful = true }.doAfterTerminate(latch::countDown).subscribe()</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$val nodeA = startNode(providedName = ALICE_NAME, rpcUsers = users).getOrThrow() var successful = false val latch = CountDownLatch(1) // This would not be needed, as `terminate(true)` sets draining mode anyway, but it's here to ensure that it removes the persistent value anyway. nodeA.rpc.setFlowsDrainingModeEnabled(true) nodeA.rpc.waitForShutdown().doOnError(Throwable::printStackTrace).doOnError { successful = false }.doOnCompleted(nodeA::stop).doOnCompleted { val nodeARestarted = startNode(providedName = ALICE_NAME, rpcUsers = users).getOrThrow() successful = !nodeARestarted.rpc.isFlowsDrainingModeEnabled() }.doAfterTerminate(latch::countDown).subscribe() nodeA.rpc.terminate(true) latch.await() assertThat(successful).isTrue()</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator$fromPersistentEntity = { Pair(DeduplicationId(it.id), MessageMeta(it.insertionTime, it.hash, it.seqNo)) }</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator$private</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator$private fun isDuplicateInDatabase(msg: ReceivedMessage): Boolean</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator$val senderHash: String? = if (receivedSenderUUID != null &amp;&amp; receivedSenderSeqNo != null) senderHash(SenderKey(receivedSenderUUID, msg.peer, msg.isSessionInit)) else null</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient : SingletonSerializeAsTokenMessagingServiceAddressToArtemisQueueResolver</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$ fun start( myIdentity: PublicKey, serviceIdentity: PublicKey?, maxMessageSize: Int, advertisedAddress: NetworkHostAndPort = serverAddress )</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$// Never time out on our loopback Artemis connections. If we switch back to using the InVM transport this // would be the default and the two lines below can be deleted. connectionTTL = 60000 clientFailureCheckPeriod = 30000 minLargeMessageSize = maxMessageSize + JOURNAL_HEADER_SIZE isUseGlobalPools = nodeSerializationEnv != null</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$deliverTo(msg, HandlerRegistration(msg.topic, deliverTo), MessageDeduplicationHandler(artemisMessage, msg))</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$log.trace { "Received message from: ${message.address} user: $user topic: $topic id: $uniqueMessageId senderUUID: $receivedSenderUUID senderSeqNo: $receivedSenderSeqNo isSessionInit: $isSessionInit" }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$log.warn("Received message ${msg.uniqueMessageId} for ${msg.topic} that doesn't have any registered handlers yet")</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$p2pConsumer = P2PMessagingConsumer(inboxes, createNewSession, isDrainingModeOn, drainingModeWasChangedEvents, metricRegistry)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$p2pConsumer!!.messages // this `run()` method is semantically meant to block until the message consumption runs, hence the latch here .doOnCompleted(latch::countDown)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$return ArtemisReceivedMessage(topic, CordaX500Name.parse(user), platformVersion, uniqueMessageId, receivedSenderUUID, receivedSenderSeqNo, isSessionInit, message)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$return NodeClientMessage(topic, OpaqueBytes(data), deduplicationId.deduplicationId, deduplicationId.senderUUID, additionalHeaders)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$throw IllegalStateException("Cannot add another acking handler for $topic, there is already an acking one")</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$val createNewSession = { sessionFactory!!.createSession(ArtemisMessagingComponent.NODE_P2P_USER, ArtemisMessagingComponent.NODE_P2P_USER, false, true, true, false, ActiveMQClient.DEFAULT_ACK_BATCH_SIZE) }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$val isSessionInit = message.getStringProperty(P2PMessagingHeaders.Type.KEY) == P2PMessagingHeaders.Type.SESSION_INIT_VALUE</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$val receivedSenderSeqNo = if (message.containsProperty(P2PMessagingHeaders.senderSeqNo)) message.getLongProperty(P2PMessagingHeaders.senderSeqNo) else null</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$val uniqueMessageId = message.required(HDR_DUPLICATE_DETECTION_ID) { DeduplicationId(message.getStringProperty(it)) }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient${ val running = state.locked { // We allow stop() to be called without a run() in between, but it must have at least been started. check(started) val prevRunning = running running = false networkChangeSubscription?.unsubscribe() require(p2pConsumer != null, { "stop can't be called twice" }) require(producer != null, { "stop can't be called twice" }) close(p2pConsumer) p2pConsumer = null close(producer) producer = null producerSession!!.commit() close(executorProducer) executorProducer = null executorSession!!.commit() close(bridgeNotifyConsumer) knownQueues.clear() eventsSubscription?.unsubscribe() eventsSubscription = null prevRunning } synchronized(handlersChangedSignal) { handlersChangedSignal.notifyAll() } if (running &amp;&amp; !nodeExecutor.isOnThread) { // Wait for the main loop to notice the consumer has gone and finish up. shutdownLatch.await() } // Only first caller to gets running true to protect against double stop, which seems to happen in some integration tests. state.locked { locator?.close() } }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient.ArtemisReceivedMessage$override val data: ByteSequence by lazy { OpaqueBytes(ByteArray(message.bodySize).apply { message.bodyBuffer.readBytes(this) }) }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingConsumer$logger.warn("Node is currently in draining mode, new flows will not be processed! Flows in flight: ${metricsRegistry.gauges["Flows.InFlight"]?.value}")</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingConsumer.Companion$private const val initialSessionMessages = "${P2PMessagingHeaders.Type.KEY}&lt;&gt;'${P2PMessagingHeaders.Type.SESSION_INIT_VALUE}'"</ID>
    <ID>MaxLineLength:P2PMessagingTest.kt$P2PMessagingTest$ inline fun MessagingService.runOnNextMessage(topic: String, crossinline callback: (ReceivedMessage) -&gt; Unit)</ID>
    <ID>MaxLineLength:P2PMessagingTest.kt$P2PMessagingTest$internalServices.networkService.send("test.request", TestRequest(replyTo = internalServices.networkService.myAddress), target)</ID>
    <ID>MaxLineLength:P2PMessagingTest.kt$P2PMessagingTest${ // Setup each node in the distributed service to return back it's NodeInfo so that we can know which node is being used participatingServiceNodes.forEach { node -&gt; node.respondWith(node.services.myInfo) } val serviceAddress = originatingNode.services.networkMapCache.run { originatingNode.internalServices.networkService.getAddressOfParty(getPartyInfo(getNotary(serviceName)!!)!!) } val participatingNodes = HashSet&lt;Any&gt;() // Try several times so that we can be fairly sure that any node not participating is not due to Artemis' selection // strategy. 3 attempts for each node seems to be sufficient. // This is not testing the distribution of the requests - DistributedServiceTests already does that for (it in 1..participatingServiceNodes.size * 3) { participatingNodes += originatingNode.receiveFrom(serviceAddress).getOrThrow(10.seconds) if (participatingNodes.size == participatingServiceNodes.size) { break } } assertThat(participatingNodes).containsOnlyElementsOf(participatingServiceNodes.map { it.services.myInfo }) }</ID>
    <ID>MaxLineLength:PackageOwnershipVerificationTests.kt$PackageOwnershipVerificationTests$output(DUMMY_CONTRACT, "c1", DUMMY_NOTARY, null, HashAttachmentConstraint(SecureHash.allOnesHash), DummyContractState())</ID>
    <ID>MaxLineLength:Parameters.kt$Parameters$@CommandLine.Option(names = ["-d", "--double-spend-ratio"], description = ["The double spend ratio (default: 0.02)"])</ID>
    <ID>MaxLineLength:Parameters.kt$Parameters$@CommandLine.Option(names = ["-n", "--num-transactions"], description = ["How many transactions to generate (default: 20)"])</ID>
    <ID>MaxLineLength:ParametersUtilities.kt$ fun NetworkParameters.addNotary(party: Party, validating: Boolean = true): NetworkParameters</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree$PartialTree</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree$if (!leafIndexHelper(leaf, this.root, flagPath)) throw MerkleTreeException("The provided hash $leaf is not in the tree.")</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree.Companion$ fun rootAndUsedHashes(node: PartialTree, usedHashes: MutableList&lt;SecureHash&gt;): SecureHash</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree.Companion$// Check if a MerkleTree is full binary tree. Returns the height of the tree if full, otherwise throws exception. private fun checkFull(tree: MerkleTree, level: Int = 0): Int</ID>
    <ID>MaxLineLength:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$assertFailsWith&lt;MerkleTreeException&gt; { PartialMerkleTree.build(merkleTree, listOf&lt;SecureHash&gt;(SecureHash.sha256("20"))) }</ID>
    <ID>MaxLineLength:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$assertFailsWith&lt;MerkleTreeException&gt; { PartialMerkleTree.build(merkleTree, listOf&lt;SecureHash&gt;(SecureHash.sha256("20"), SecureHash.sha256("1"), SecureHash.sha256("5"))) }</ID>
    <ID>MaxLineLength:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$networkParameters = testNetworkParameters(minimumPlatformVersion = 4, notaries = listOf(NotaryInfo(DUMMY_NOTARY, true)))</ID>
    <ID>MaxLineLength:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$val pmt = PartialMerkleTree.build(merkleTree, listOf&lt;SecureHash&gt;(SecureHash.sha256("1"), SecureHash.sha256("5"), SecureHash.sha256("0"), SecureHash.sha256("19")))</ID>
    <ID>MaxLineLength:PartialMerkleTreeTest.kt$PartialMerkleTreeTest${ // We even use the same privacySalt, and thus the only difference between the two transactions is the notary party. val privacySalt = PrivacySalt() val wtx1 = makeSimpleCashWtx(DUMMY_NOTARY, privacySalt) val wtx2 = makeSimpleCashWtx(MEGA_CORP, privacySalt) assertEquals(wtx1.privacySalt, wtx2.privacySalt) assertNotEquals(wtx1.id, wtx2.id) }</ID>
    <ID>MaxLineLength:Party.kt$Party : DestinationAbstractParty</ID>
    <ID>MaxLineLength:Party.kt$Party$this(CordaX500Name.build(certificate.subjectX500Principal), Crypto.toSupportedPublicKey(certificate.publicKey))</ID>
    <ID>MaxLineLength:PartyAndCertificate.kt$PartyAndCertificate</ID>
    <ID>MaxLineLength:PartyAndCertificate.kt$PartyAndCertificate$require(role?.isIdentity ?: false) { "Party certificate ${certificate.subjectDN} does not have a well known or confidential identity role. Found: $role" }</ID>
    <ID>MaxLineLength:PartyAndCertificate.kt$PartyAndCertificate$throw CertPathValidatorException("Child certificate whose issuer includes a Corda role, must also specify Corda role")</ID>
    <ID>MaxLineLength:PartyAndCertificate.kt$PartyAndCertificate$throw CertPathValidatorException("The issuing certificate for $certificateString has role $parentRole, expected one of ${role.validParents}")</ID>
    <ID>MaxLineLength:PathManager.kt$PathManager&lt;T : PathManager&lt;T&gt;&gt; : Closeable</ID>
    <ID>MaxLineLength:PathManagerTests.kt$PathManagerTests$MyPathManager : PathManager</ID>
    <ID>MaxLineLength:PathUtils.kt$ fun Path.attributes(vararg options: LinkOption): BasicFileAttributes</ID>
    <ID>MaxLineLength:PathUtils.kt$inline</ID>
    <ID>MaxLineLength:Perceivable.kt$( @Suppress("UNUSED_PARAMETER") amount: BigDecimal, @Suppress("UNUSED_PARAMETER") dayCountConvention: String, @Suppress("UNUSED_PARAMETER") interest: BigDecimal /* todo - appropriate type */, @Suppress("UNUSED_PARAMETER") start: String, @Suppress("UNUSED_PARAMETER") end: String )</ID>
    <ID>MaxLineLength:Perceivable.kt$Interest(Const(amount), dayCountConvention, interest, const(parseDate(start).toInstant()), const(parseDate(end).toInstant()))</ID>
    <ID>MaxLineLength:Perceivable.kt$PerceivableOperation&lt;T&gt; : Perceivable</ID>
    <ID>MaxLineLength:Perceivable.kt$fun fix(source: String, date: LocalDate, tenor: Tenor): Perceivable&lt;BigDecimal&gt;</ID>
    <ID>MaxLineLength:Perceivable.kt$operator fun Perceivable&lt;BigDecimal&gt;.minus(n: Double)</ID>
    <ID>MaxLineLength:Perceivable.kt$operator fun Perceivable&lt;BigDecimal&gt;.times(n: Double)</ID>
    <ID>MaxLineLength:PeriodSerializer.kt$PeriodSerializer : Proxy</ID>
    <ID>MaxLineLength:PersistentIdentityMigration.kt$PersistentIdentityMigration$generatedStatements.addAll(MigrationData(oldPkHash, partyAndCertificate).let { listOf(updateHashToIdentityRow(it, dataSource), updateNameToHashRow(it, dataSource)) })</ID>
    <ID>MaxLineLength:PersistentIdentityMigration.kt$PersistentIdentityMigration$return UpdateStatement(dataSource.connection.catalog, dataSource.connection.schema, PUB_KEY_HASH_TO_PARTY_AND_CERT_TABLE) .setWhereClause("pk_hash=?") .addNewColumnValue("pk_hash", migrationData.newPkHash) .addWhereParameter(migrationData.oldPkHash)</ID>
    <ID>MaxLineLength:PersistentIdentityMigration.kt$PersistentIdentityMigration$return UpdateStatement(dataSource.connection.catalog, dataSource.connection.schema, X500_NAME_TO_PUB_KEY_HASH_TABLE) .setWhereClause("pk_hash=? AND name=?") .addNewColumnValue("pk_hash", migrationData.newPkHash) .addWhereParameters(migrationData.oldPkHash, migrationData.x500.toString())</ID>
    <ID>MaxLineLength:PersistentIdentityMigration.kt$PersistentIdentityMigration$val partyAndCertificate = PartyAndCertificate(X509CertificateFactory().delegate.generateCertPath(identityBytes.inputStream()))</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTable.kt$PersistentIdentitiesMigrationSchema</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTable.kt$PersistentIdentitiesMigrationSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTable.kt$PersistentIdentityMigrationNewTable : CordaMigration</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTable.kt$PersistentIdentityMigrationNewTable$logger.info("Migrating persistent identities with certificates table into persistent table with no certificate data.")</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTable.kt$PersistentIdentityMigrationNewTable$throw PersistentIdentitiesMigrationException("Cannot migrate persistent states as liquibase failed to provide a suitable database connection")</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTable.kt$PersistentIdentityMigrationNewTable$val name = PartyAndCertificate(X509CertificateFactory().delegate.generateCertPath(partyBytes.inputStream())).party.name</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTable.kt$TestIdentity</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTable.kt$TestIdentity$/** Creates an identity with a deterministic [keyPair] i.e. same [entropy] same keyPair. */ @JvmOverloads constructor(name: CordaX500Name, entropy: Long, signatureScheme: SignatureScheme = Crypto.DEFAULT_SIGNATURE_SCHEME) : this(name, Crypto.deriveKeyPairFromEntropy(signatureScheme, BigInteger.valueOf(entropy)))</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTableTest.kt$PersistentIdentityMigrationNewTableTest$notaryServices = MockServices(listOf("net.corda.finance.contracts"), dummyNotary, identityService, dummyCashIssuer.keyPair, BOC_KEY)</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTableTest.kt$PersistentIdentityMigrationNewTableTest$session.save(PersistentIdentityService.PersistentPublicKeyHashToCertificate(it.owningKey.hash.toString(), it.certPath.encoded))</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTableTest.kt$PersistentIdentityMigrationNewTableTest$val identityService = makeTestIdentityService(PersistentIdentityMigrationNewTableTest.dummyNotary.identity, BOB_IDENTITY, ALICE_IDENTITY)</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTableTest.kt$PersistentIdentityMigrationNewTableTest${ /** * TODO - We have to mock every statement/ result to test this properly. * * The workaround for now is the [PersistentIdentitiesMigration.addTestMapping] and * [PersistentIdentitiesMigration.deleteTestMapping] methods that allow us to see the migration occur properly during debugging. * * Since [PersistentIdentitiesMigration] implements [CordaMigration] the migration will run when the DB is setup. */ PersistentIdentityMigrationNewTable() }</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$ @Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) private fun verifyAndRegisterIdentity(trustAnchor: TrustAnchor, identity: PartyAndCertificate): PartyAndCertificate?</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$/** Stores notary identities obtained from the network parameters, for which we don't need to perform a database lookup. */ private val notaryIdentityCache = HashSet&lt;Party&gt;()</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$// Allows us to eliminate keys we know belong to others by using the cache contents that might have been seen during other identity activity. // Concentrating activity on the identity cache works better than spreading checking across identity and key management, because we cache misses too. fun stripNotOurKeys(keys: Iterable&lt;PublicKey&gt;): Iterable&lt;PublicKey&gt;</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$@Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class)</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$@Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) private</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$@Throws(UnknownAnonymousPartyException::class) override</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$_caCertStore = CertStore.getInstance("Collection", CollectionCertStoreParameters(caCertificates.toSet() + trustRoot))</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$it.filter { x500Matches(query, exactMatch, it.first) }.map { keyToPartyAndCert[it.second]!!.party }.toSet()</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$log.warn("Certificate validation failed for ${identity.name} against trusted root ${trustAnchor.trustedCert.subjectX500Principal}.")</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$throw IllegalArgumentException("The public key ${key.hash} is already assigned to a different party than the supplied .")</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService${ // If there is no entry in the legal keyToPartyAndCert table then the party must be a confidential identity so we perform // a lookup in the keyToName table. If an entry for that public key exists, then we attempt val name = keyToName[party.owningKey.toStringShort()] if (name != null) { wellKnownPartyFromX500Name(name) } else { null } }</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService${ // Skip database lookup if the party is a notary identity. // This also prevents an issue where the notary identity can't be resolved if it's not in the network map cache. The node obtains // a trusted list of notary identities from the network parameters automatically. return if (party is Party &amp;&amp; party in notaryIdentityCache) { party } else { database.transaction { // Try and resolve the party from the table to public keys to party and certificates // If we cannot find it then we perform a lookup on the public key to X500 name table val legalIdentity = super.wellKnownPartyFromAnonymous(party) if (legalIdentity == null) { // If there is no entry in the legal keyToPartyAndCert table then the party must be a confidential identity so we perform // a lookup in the keyToName table. If an entry for that public key exists, then we attempt val name = keyToName[party.owningKey.toStringShort()] if (name != null) { wellKnownPartyFromX500Name(name) } else { null } } else { legalIdentity } } } }</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService.Companion$PartyAndCertificate(X509CertificateFactory().delegate.generateCertPath(it.identity.inputStream()))</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService.Companion$fun createKeyToPartyAndCertMap(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;String, PartyAndCertificate, PersistentPublicKeyHashToCertificate, String&gt;</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService.Companion$fun createKeyToX500Map(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;String, CordaX500Name, PersistentPublicKeyHashToParty, String&gt;</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService.Companion$fun createX500ToKeyMap(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;CordaX500Name, String, PersistentPartyToPublicKeyHash, String&gt;</ID>
    <ID>MaxLineLength:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests$ @Test fun `assert ownership`()</ID>
    <ID>MaxLineLength:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests$ @Test fun `get anonymous identity by key`()</ID>
    <ID>MaxLineLength:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests$listOf("Organisation A", "Organisation B", "Organisation C") .map { getTestPartyAndCertificate(CordaX500Name(organisation = it, locality = "London", country = "GB"), generateKeyPair().public) }</ID>
    <ID>MaxLineLength:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests$val alicente = getTestPartyAndCertificate(CordaX500Name(organisation = "Alicente Worldwide", locality = "London", country = "GB"), generateKeyPair().public)</ID>
    <ID>MaxLineLength:PersistentMap.kt$PersistentMap$cache.getAll(session.createQuery(criteriaQuery).resultList.map { e -&gt; fromPersistentEntity(e as E).first }.asIterable())</ID>
    <ID>MaxLineLength:PersistentMap.kt$PersistentMap${ // This happens when the key was queried before with no value associated. We invalidate the cached null // value and recursively call set again. This is to avoid race conditions where another thread queries after // the invalidate but before the set. cache.invalidate(key) return set(key, value) }</ID>
    <ID>MaxLineLength:PersistentMap.kt$PersistentMap.NotReallyMutableEntry$private</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$"SELECT DISTINCT l FROM ${NodeInfoSchemaV1.PersistentNodeInfo::class.java.name} n JOIN n.legalIdentitiesAndCerts l WHERE l.name = :name"</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$"SELECT n FROM ${NodeInfoSchemaV1.PersistentNodeInfo::class.java.name} n JOIN n.addresses a WHERE a.host = :host AND a.port = :port"</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$"SELECT n FROM ${NodeInfoSchemaV1.PersistentNodeInfo::class.java.name} n JOIN n.legalIdentitiesAndCerts l WHERE l.name = :name"</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$"SELECT n FROM ${NodeInfoSchemaV1.PersistentNodeInfo::class.java.name} n JOIN n.legalIdentitiesAndCerts l WHERE l.owningKeyHash = :owningKeyHash"</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$logger.info("Previous node was found for ${node.legalIdentities.first().name} as: $previousNode")</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$private</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$val failures = node.legalIdentitiesAndCerts.mapNotNull { Try.on { it.verify(identityService.trustAnchor) } as? Try.Failure }</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$val info = findByIdentityKey(session, nodeInfo.legalIdentitiesAndCerts.first().owningKey).singleOrNull { it.serial == nodeInfo.serial }</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$where(builder.equal(get&lt;String&gt;(NodeInfoSchemaV1.PersistentNodeInfo::hash.name), nodeHash.toString()))</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache${ // TODO For now the main legal identity is left in NodeInfo, this should be set comparision/come up with index for NodeInfo? val info = findByIdentityKey(session, nodeInfo.legalIdentitiesAndCerts.first().owningKey) val nodeInfoEntry = generateMappedObject(nodeInfo) if (info.isNotEmpty()) { nodeInfoEntry.id = info.first().id } session.merge(nodeInfoEntry) // invalidate cache last - this way, we might serve up the wrong info for a short time, but it will get refreshed // on the next load invalidateCaches(nodeInfo) }</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache${ // findByIdentityKey might returns multiple node info with the same key, need to pick the right one by comparing serial. val info = findByIdentityKey(session, nodeInfo.legalIdentitiesAndCerts.first().owningKey).singleOrNull { it.serial == nodeInfo.serial } info?.let { session.remove(it) } // invalidate cache last - this way, we might serve up the wrong info for a short time, but it will get refreshed // on the next load invalidateCaches(nodeInfo) }</ID>
    <ID>MaxLineLength:PersistentNetworkMapCacheTest.kt$PersistentNetworkMapCacheTest$assertThat(charlieNetMapCache.getNodesByLegalName(DUMMY_NOTARY_NAME)).containsOnlyElementsOf(distServiceNodeInfos)</ID>
    <ID>MaxLineLength:PersistentNetworkMapCacheTest.kt$PersistentNetworkMapCacheTest$private val charlieNetMapCache = PersistentNetworkMapCache(TestingNamedCacheFactory(), database, InMemoryIdentityService(trustRoot = DEV_ROOT_CA.certificate))</ID>
    <ID>MaxLineLength:PersistentScheduledFlowRepository.kt$PersistentScheduledFlowRepository$criteriaQuery.orderBy(session.criteriaBuilder.asc(shed.get&lt;NodeSchedulerService.PersistentScheduledState&gt;("scheduledAt")))</ID>
    <ID>MaxLineLength:PersistentScheduledFlowRepository.kt$PersistentScheduledFlowRepository$private</ID>
    <ID>MaxLineLength:PersistentScheduledFlowRepository.kt$PersistentScheduledFlowRepository$return Pair(StateRef(SecureHash.parse(txId), index), ScheduledStateRef(StateRef(SecureHash.parse(txId), index), scheduledStateRecord.scheduledAt))</ID>
    <ID>MaxLineLength:PersistentScheduledFlowRepository.kt$PersistentScheduledFlowRepository$val criteriaQuery = session.criteriaBuilder.createQuery(NodeSchedulerService.PersistentScheduledState::class.java)</ID>
    <ID>MaxLineLength:PersistentScheduledFlowRepository.kt$PersistentScheduledFlowRepository$val elem = session.find(NodeSchedulerService.PersistentScheduledState::class.java, toPersistentEntityKey(key))</ID>
    <ID>MaxLineLength:PersistentScheduledFlowRepository.kt$PersistentScheduledFlowRepository$val existingEntry = session.find(NodeSchedulerService.PersistentScheduledState::class.java, toPersistentEntityKey(value.ref))</ID>
    <ID>MaxLineLength:PersistentStateService.kt$PersistentStateService</ID>
    <ID>MaxLineLength:PersistentStateServiceTests.kt$PersistentStateServiceTests$persistentStateService.persist(setOf(StateAndRef(TransactionState(TestState(), DummyContract.PROGRAM_ID, MEGA_CORP, constraint = AlwaysAcceptAttachmentConstraint), StateRef(SecureHash.sha256("dummy"), 0))))</ID>
    <ID>MaxLineLength:PersistentStateServiceTests.kt$PersistentStateServiceTests$val database = configureDatabase(makeTestDataSourceProperties(), DatabaseConfig(), rigorousMock(), rigorousMock(), schemaService)</ID>
    <ID>MaxLineLength:PersistentStateServiceTests.kt$PersistentStateServiceTests.&lt;no name provided&gt;$override val schemaOptions: Map&lt;MappedSchema, SchemaService.SchemaOptions&gt; = mapOf(testSchema to SchemaService.SchemaOptions())</ID>
    <ID>MaxLineLength:PersistentTypes.kt$DirectStatePersistable : StatePersistable</ID>
    <ID>MaxLineLength:PersistentTypes.kt$IndirectStatePersistable&lt;T : DirectStatePersistable&gt; : StatePersistable</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator$annotations.any { annotation -&gt; annotation.toString().startsWith("@javax.persistence.") &amp;&amp; annotation !is javax.persistence.Transient }</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator${ field -&gt; field.type.enclosingClass != null &amp;&amp; MappedSchema::class.java.isAssignableFrom(field.type.enclosingClass) &amp;&amp; hasJpaAnnotation(field.declaredAnnotations) &amp;&amp; field.type.enclosingClass != schema.javaClass }</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator${ method -&gt; method.returnType.enclosingClass != null &amp;&amp; MappedSchema::class.java.isAssignableFrom(method.returnType.enclosingClass) &amp;&amp; method.returnType.enclosingClass != schema.javaClass &amp;&amp; hasJpaAnnotation(method.declaredAnnotations) }</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator.SchemaCrossReferenceReport$"MappedSchema '${schema.substringAfterLast(".")}' entity '$entity' field '$fieldOrMethod' is of type '$fieldOrMethodType' "</ID>
    <ID>MaxLineLength:PersistentTypes.kt$PersistentState : DirectStatePersistable</ID>
    <ID>MaxLineLength:PersistentUniquenessProvider.kt$PersistentUniquenessProvider : UniquenessProviderSingletonSerializeAsToken</ID>
    <ID>MaxLineLength:PersistentUniquenessProvider.kt$PersistentUniquenessProvider$commitOne(request.states, request.txId, request.callerIdentity, request.requestSignature, request.timeWindow, request.references)</ID>
    <ID>MaxLineLength:PersistentUniquenessProvider.kt$PersistentUniquenessProvider$if (consumingTx != null) conflictingStates[stateRef] = StateConsumptionDetails(consumingTx.sha256(), type)</ID>
    <ID>MaxLineLength:PersistentUniquenessProvider.kt$PersistentUniquenessProvider$request.future.setException(NotaryInternalException(NotaryError.General(Exception("Internal service error."))))</ID>
    <ID>MaxLineLength:PersistentUniquenessProvider.kt$PersistentUniquenessProvider.Companion$fun createMap(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;StateRef, SecureHash, CommittedState, PersistentStateRef&gt;</ID>
    <ID>MaxLineLength:PhysicalLocationStructures.kt$WorldCoordinate$fun latitudeToScreenY(lat: Double)</ID>
    <ID>MaxLineLength:PhysicalLocationStructures.kt$WorldCoordinate$require(longitude in leftLongitude..rightLongitude) { "Longitude must be between $leftLongitude and $rightLongitude" }</ID>
    <ID>MaxLineLength:PortAllocationTest.kt$PortAllocationTest$val iterCount = 8_000 // Default port range 10000-30000 since we will have 2 processes we want to make sure there is enough leg room</ID>
    <ID>MaxLineLength:PortAllocationTest.kt$PortAllocationTest$val terminationStatuses = processes.parallelStream().map { if (it.waitFor(1, TimeUnit.MINUTES)) "OK" else "STILL RUNNING" }.toList()</ID>
    <ID>MaxLineLength:PortAllocationTest.kt$PortAllocationTest$while (spinnerBuffer.getShort(1) != 10.toShort() &amp;&amp; spinnerBuffer.getShort(2) != 10.toShort() &amp;&amp; timeWaited &lt; 60_000) { logger.info("Waiting to childProcesses to report back. waited ${timeWaited}ms") Thread.sleep(1000) timeWaited += 1000 }</ID>
    <ID>MaxLineLength:PortAllocationTest.kt$PortAllocationTest${ assumeFalse(System.getProperty("os.name").toLowerCase().contains("windows")) logger.info("Starting multiprocess port allocation test") val spinnerFile = Files.newTemporaryFile().also { it.deleteOnExit() }.absolutePath val iterCount = 8_000 // Default port range 10000-30000 since we will have 2 processes we want to make sure there is enough leg room // If we rollover, we may well receive the ports that were already given to a different process val process1 = buildJvmProcess(spinnerFile, 1, iterCount) val process2 = buildJvmProcess(spinnerFile, 2, iterCount) logger.info("Started child processes") val processes = listOf(process1, process2) val spinnerBackingFile = RandomAccessFile(spinnerFile, "rw") logger.info("Mapped spinner file at: $spinnerFile") val spinnerBuffer = spinnerBackingFile.channel.map(FileChannel.MapMode.READ_WRITE, 0, 512) logger.info("Created spinner buffer") var timeWaited = 0L while (spinnerBuffer.getShort(1) != 10.toShort() &amp;&amp; spinnerBuffer.getShort(2) != 10.toShort() &amp;&amp; timeWaited &lt; 60_000) { logger.info("Waiting to childProcesses to report back. waited ${timeWaited}ms") Thread.sleep(1000) timeWaited += 1000 } // GO! logger.info("Instructing child processes to start allocating ports") spinnerBuffer.putShort(0, 8) logger.info("Waiting for child processes to terminate") val terminationStatuses = processes.parallelStream().map { if (it.waitFor(1, TimeUnit.MINUTES)) "OK" else "STILL RUNNING" }.toList() logger.info("child processes terminated: $terminationStatuses") fun List&lt;String&gt;.setOfPorts(): Set&lt;Int&gt; { // May include warnings when ports are busy return map { Try.on { Integer.parseInt(it) } }.filter { it.isSuccess }.map { it.getOrThrow() }.toSet() } val lines1 = process1.inputStream.reader().readLines() val portsAllocated1 = lines1.setOfPorts() val lines2 = process2.inputStream.reader().readLines() val portsAllocated2 = lines2.setOfPorts() logger.info("child process out captured") Assert.assertThat(lines1.joinToString(), portsAllocated1.size, `is`(iterCount)) Assert.assertThat(lines2.joinToString(), portsAllocated2.size, `is`(iterCount)) // there should be no overlap between the outputs as each process should have been allocated a unique set of ports val intersect = portsAllocated1.intersect(portsAllocated2) Assert.assertThat(intersect.joinToString(), intersect, `is`(emptySet())) }</ID>
    <ID>MaxLineLength:PortfolioApi.kt$PortfolioApi$counterparties = counterParties.flatMap { it.legalIdentitiesAndCerts.map { ApiParty(it.owningKey.toBase58String(), it.name) } }</ID>
    <ID>MaxLineLength:PortfolioApi.kt$PortfolioApi$rpc.startFlow(SimmRevaluation::Initiator, getPortfolioStateAndRefWith(otherParty).ref, params.valuationDate)</ID>
    <ID>MaxLineLength:PortfolioApi.kt$PortfolioApi$val history = AggregatedHistoryView(state.valuation!!.trades, notional.toDouble(), LocalDate.now(), state.valuation!!.margin.first, mtm)</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$"fixedRatePayer" to (fixedRatePayer.nameOrNull()?.organisation ?: fixedRatePayer.owningKey.toBase58String())</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$"floatingRatePayer" to (floatingRatePayer.nameOrNull()?.organisation ?: floatingRatePayer.owningKey.toBase58String())</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$val completeSubgroups = subgroups.mapValues { it.value.mapValues { it.value[0].third.toDouble() }.toSortedMap() }</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$val processedSensitivities = valuation.totalSensivities.sensitivities.map { it.marketDataName to it.parameterMetadata.map { it.label }.zip(it.sensitivity.toList()).toMap() }.toMap()</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$val trade = if (state.buyer == ownParty as AbstractParty) state.swap.toFloatingLeg() else state.swap.toFloatingLeg()</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$val yieldCurveCurrenciesValues = marketData.filter { !it.key.contains("/") }.map { it -&gt; Triple(it.key.split("-")[0], it.key.split("-", limit = 2)[1], it.value) }</ID>
    <ID>MaxLineLength:PortfolioState.kt$PortfolioState$override</ID>
    <ID>MaxLineLength:PortfolioState.kt$PortfolioState$return ScheduledActivity(flow, LocalDate.now().plus(1, ChronoUnit.DAYS).atStartOfDay().toInstant(ZoneOffset.UTC))</ID>
    <ID>MaxLineLength:PortfolioState.kt$PortfolioState$return TransactionBuilder(notary).withItems(StateAndContract(copy(), PORTFOLIO_SWAP_PROGRAM_ID), Command(PortfolioSwap.Commands.Agree(), participants.map { it.owningKey }))</ID>
    <ID>MaxLineLength:PortfolioState.kt$PortfolioState$val flow = flowLogicRefFactory.create("net.corda.vega.flows.SimmRevaluation\$Initiator", thisStateRef, LocalDate.now())</ID>
    <ID>MaxLineLength:PortfolioSwap.kt$PortfolioSwap$val groups: List&lt;LedgerTransaction.InOutGroup&lt;PortfolioState, UniqueIdentifier&gt;&gt; = tx.groupStates { state -&gt; state.linearId }</ID>
    <ID>MaxLineLength:PrettyPrint.kt$PrettyPrint$println("val ${createPartyName(it)} = Party(\"${it.name.organisation}\", \"${it.owningKey.toStringShort()}\")")</ID>
    <ID>MaxLineLength:PrintingInterceptor.kt$PrintingInterceptor$val (continuation, nextState) = delegate.executeTransition(fiber, previousState, event, transition, actionExecutor)</ID>
    <ID>MaxLineLength:PrintingInterceptor.kt$PrintingInterceptor$val transitionRecord = TransitionDiagnosticRecord(Instant.now(), fiber.id, previousState, nextState, event, transition, continuation)</ID>
    <ID>MaxLineLength:PrivateKeySerializationTest.kt$PrivateKeySerializationTest$assertTrue { privateKey.checkpointSerialize(context = CheckpointSerializationDefaults.CHECKPOINT_CONTEXT).bytes.isNotEmpty() }</ID>
    <ID>MaxLineLength:PrivateKeySerializationTest.kt$PrivateKeySerializationTest.Companion$return privateKeys.map { arrayOf&lt;Any&gt;(it, PrivateKeySerializationTest::class.java.simpleName + "-" + it.javaClass.simpleName) }</ID>
    <ID>MaxLineLength:PrivateKeySerializationTest.kt$PrivateKeySerializationTest.Companion$val privateKeys: List&lt;PrivateKey&gt; = Crypto.supportedSignatureSchemes().filterNot { Crypto.COMPOSITE_KEY === it } .map { Crypto.generateKeyPair(it).private }</ID>
    <ID>MaxLineLength:PrivateKeySerializer.kt$PrivateKeySerializer$override val schemaForDocumentation = Schema(listOf(RestrictedType(type.toString(), "", listOf(type.toString()), AMQPTypeIdentifiers.primitiveTypeName(ByteArray::class.java), descriptor, emptyList())))</ID>
    <ID>MaxLineLength:ProcessUtilities.kt$ProcessUtilities$return startJavaProcess(C::class.java.name, arguments, classPath, workingDirectory, jdwpPort, extraJvmArguments, maximumHeapSize)</ID>
    <ID>MaxLineLength:ProfileController.kt$ProfileController$StreamSupport.stream(fs.rootDirectories.spliterator(), false) .flatMap { Files.find(it, 2, BiPredicate { p, attr -&gt; "node.conf" == p?.fileName.toString() &amp;&amp; attr.isRegularFile }) }</ID>
    <ID>MaxLineLength:ProfileController.kt$ProfileController$StreamSupport.stream(fs.rootDirectories.spliterator(), false) .flatMap { Files.find(it, 3, BiPredicate { p, attr -&gt; p.inCordappsDir &amp;&amp; p.isCordapp &amp;&amp; attr.isRegularFile }) }</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker$/** * A list of all steps label in this ProgressTracker and the children, with the indent level provided starting at zero. * Note that UNSTARTED is never counted, and DONE is only counted at the calling level. */ val allStepsLabels: List&lt;Pair&lt;Int, String&gt;&gt; get() = _allStepsLabels()</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker$if (it is Change.Structural || it is Change.Rendering) rebuildStepsTree() else recalculateStepsTreeIndex()</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker$log.warnOnce("Found ProgressTracker Step(s) with the same label: ${labels.groupBy { it }.filter { it.value.size &gt; 1 }.map { it.key }}")</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker$private fun _allStepsLabels(level: Int = 0): List&lt;Pair&lt;Int, String&gt;&gt;</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker${ // This gets the index of the current step in the context of this progress tracker, so it will always be at the top level in // the allStepsCache. val index = _allStepsCache.indexOf(Pair(0, currentStep)) return if (index &gt;= 0) index else 0 }</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker${ steps.forEach { configureChildTrackerForStep(it) } // Immediately update the step tree observable to ensure the first update the client receives is the initial state of the progress // tracker. _stepsTreeChanges.onNext(allStepsLabels) this.currentStep = UNSTARTED }</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker.Step$private fun definitionLocation(): String</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$override fun valueIn(configuration: Config): List&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$return delegate.schema?.let { schema -&gt; valueDescription(valueIn(configuration).asSequence().map { element -&gt; valueDescription(element, serialiseValue) }.map { it as ConfigObject }.map(ConfigObject::toConfig).map { schema.describe(it, serialiseValue) }.toList(), serialiseValue) } ?: valueDescription(valueIn(configuration), serialiseValue)</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$val errors = list.asSequence().map { configObject(key to ConfigValueFactory.fromAnyRef(it)) }.mapIndexed { index, value -&gt; delegate.validate(value.toConfig(), options).errors.map { error -&gt; error.withContainingPath(*error.containingPath(index).toTypedArray()) } }.fold(emptyList&lt;Configuration.Validation.Error&gt;()) { one, other -&gt; one + other }.toSet()</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$( delegate: Configuration.Property.Definition.Standard&lt;TYPE&gt;, private val mappedTypeName: String, internal val extractListValue: (Config, String) -&gt; List&lt;TYPE&gt;, private val convert: (TYPE) -&gt; Valid&lt;MAPPED&gt; )</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$errors += convert.invoke(delegate.valueIn(target)).mapErrors { error -&gt; error.with(delegate.key, mappedTypeName) }.errors</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$override fun &lt;M&gt; mapValid(mappedTypeName: String, convert: (MAPPED) -&gt; Valid&lt;M&gt;): Configuration.Property.Definition.Standard&lt;M&gt;</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue)</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$override val typeName: String = if (super.typeName == "#$mappedTypeName") super.typeName else "$mappedTypeName(${super.typeName})"</ID>
    <ID>MaxLineLength:Properties.kt$ListMappingProperty$errors += convert.invoke(delegate.valueIn(target)).mapErrors { error -&gt; error.with(delegate.key, mappedTypeName) }.errors</ID>
    <ID>MaxLineLength:Properties.kt$ListMappingProperty$override</ID>
    <ID>MaxLineLength:Properties.kt$ListMappingProperty$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue): ConfigValue?</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$errors += valueIn(target).asSequence().map { element -&gt; element as ConfigObject }.map(ConfigObject::toConfig).mapIndexed { index, targetConfig -&gt; schema.validate(targetConfig, options).errors.map { error -&gt; error.withContainingPath(*error.containingPath(index).toTypedArray()) } }.fold(emptyList&lt;Configuration.Validation.Error&gt;()) { one, other -&gt; one + other }.toSet()</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$val elementsDescription = valueIn(configuration).asSequence().map { it as ConfigObject }.map(ConfigObject::toConfig).map { delegate.schema.describe(it, serialiseValue) }.toList()</ID>
    <ID>MaxLineLength:Properties.kt$LongProperty$internal</ID>
    <ID>MaxLineLength:Properties.kt$LongProperty$return invalid(ConfigException.WrongType(target.origin(), key, Long::class.javaObjectType.simpleName, Double::class.javaObjectType.simpleName).toValidationError(key, typeName))</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue)</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$override fun withDefaultValue(defaultValue: TYPE): Configuration.Property.Definition&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$val missingValueError = errors.asSequence().filterIsInstance&lt;Configuration.Validation.Error.MissingValue&gt;().filter { it.pathAsString == key }.singleOrNull()</ID>
    <ID>MaxLineLength:Properties.kt$OptionalPropertyWithDefault$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue): ConfigValue?</ID>
    <ID>MaxLineLength:Properties.kt$OptionalPropertyWithDefault$override fun validate(target: Config, options: Configuration.Validation.Options): Valid&lt;Config&gt;</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$errors += nestedSchema.validate(nestedConfig, options).errors.map { error -&gt; error.withContainingPathPrefix(*key.split(".").toTypedArray()) }</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (TYPE) -&gt; Valid&lt;MAPPED&gt;): Configuration.Property.Definition.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$return schema?.describe(configuration.getConfig(key), serialiseValue) ?: valueDescription(valueIn(configuration), serialiseValue)</ID>
    <ID>MaxLineLength:Properties.kt$private</ID>
    <ID>MaxLineLength:Properties.kt$private fun isErrorExpected(error: ConfigException)</ID>
    <ID>MaxLineLength:Properties.kt$private val expectedExceptionTypes = setOf(ConfigException.Missing::class, ConfigException.WrongType::class, ConfigException.BadValue::class, ConfigException.BadPath::class, ConfigException.Parse::class)</ID>
    <ID>MaxLineLength:PropertyDescriptor.kt$// Construct a map of PropertyDescriptors by name, by merging the raw field map with the map of classified property methods private fun Map&lt;String, Map&lt;MethodClassifier, Method&gt;&gt;.toClassProperties(fieldMap: Map&lt;String, Field&gt;): Map&lt;String, PropertyDescriptor&gt;</ID>
    <ID>MaxLineLength:PropertyDescriptor.kt$// Merge the given method into a map of methods by method classifier, picking the least generic method for each classifier. private fun EnumMap&lt;MethodClassifier, Method&gt;.merge(classifier: MethodClassifier, method: Method): EnumMap&lt;MethodClassifier, Method&gt;</ID>
    <ID>MaxLineLength:PropertyDescriptor.kt$?:</ID>
    <ID>MaxLineLength:PropertyDescriptor.kt$private</ID>
    <ID>MaxLineLength:PropertyTest.kt$PropertyTest$val property = Configuration.Property.Definition.long(key).map(::AtomicLong).list().map { list -&gt; list.map(AtomicLong::get).max() }</ID>
    <ID>MaxLineLength:PropertyTest.kt$PropertyTest$val property = Configuration.Property.Definition.long(key).map(::AtomicLong).list().map { list -&gt; list.map(AtomicLong::get).max() }.optional()</ID>
    <ID>MaxLineLength:PropertyValidationTest.kt$PropertyValidationTest$assertThat(errors.first())</ID>
    <ID>MaxLineLength:PropertyValidationTest.kt$PropertyValidationTest$return invalid(Configuration.Validation.Error.BadValue.of("Value must be of format \"host(String):port(Int &gt; 0)\" e.g., \"127.0.0.1:8080\""))</ID>
    <ID>MaxLineLength:PropertyValidationTest.kt$PropertyValidationTest$val nestedPropertySchema = Configuration.Schema.withProperties(Configuration.Property.Definition.long(nestedKey))</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$private</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$serverParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$signingCertificateStore.get(true).also { it.installDevNodeCaCertPath(ALICE_NAME, rootCa.certificate, intermediateCa) }</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$sslConfig.keyStore.get(true).also { it.registerDevP2pCertificates(ALICE_NAME, rootCa.certificate, intermediateCa) }</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$val client = ArtemisMessagingClient(artemisConfig.p2pSslOptions, NetworkHostAndPort("localhost", artemisPort), maxMessageSize)</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$val signingCertificateStore = CertificateStoreStubs.Signing.withCertificatesDirectory(certificatesDirectory, "serverstorepass")</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$val sslConfig = CertificateStoreStubs.P2P.withCertificatesDirectory(certificatesDirectory, keyStorePassword = "serverstorepass")</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests${ val maxMessageSize = 100_000 val (server, artemisClient) = createArtemisServerAndClient(maxMessageSize) val amqpClient = createClient(maxMessageSize) val clientConnected = amqpClient.onConnection.toFuture() amqpClient.start() assertEquals(true, clientConnected.get().connected) assertEquals(CHARLIE_NAME, CordaX500Name.build(clientConnected.get().remoteCert!!.subjectX500Principal)) val artemis = artemisClient.started!! val sendAddress = P2P_PREFIX + "Test" artemis.session.createQueue(sendAddress, RoutingType.ANYCAST, "queue", true) val consumer = artemis.session.createConsumer("queue") val testProperty = mutableMapOf&lt;String, Any?&gt;() testProperty["TestProp"] = "1" // Send normal message. val testData = ByteArray(maxMessageSize) val message = amqpClient.createMessage(testData, sendAddress, CHARLIE_NAME.toString(), testProperty) amqpClient.write(message) assertEquals(MessageStatus.Acknowledged, message.onComplete.get()) val received = consumer.receive() assertEquals("1", received.getStringProperty("TestProp")) assertArrayEquals(testData, ByteArray(received.bodySize).apply { received.bodyBuffer.readBytes(this) }) // Send message larger then max message size. val largeData = ByteArray(maxMessageSize + 1) // Create message will fail. assertThatThrownBy { amqpClient.createMessage(largeData, sendAddress, CHARLIE_NAME.toString(), testProperty) }.hasMessageContaining("Message exceeds maxMessageSize network parameter") // Send normal message again to confirm the large message didn't reach the server and client is not killed by the message. val message2 = amqpClient.createMessage(testData, sendAddress, CHARLIE_NAME.toString(), testProperty) amqpClient.write(message2) assertEquals(MessageStatus.Acknowledged, message2.onComplete.get()) val received2 = consumer.receive() assertEquals("1", received2.getStringProperty("TestProp")) assertArrayEquals(testData, ByteArray(received2.bodySize).apply { received2.bodyBuffer.readBytes(this) }) amqpClient.stop() artemisClient.stop() server.stop() }</ID>
    <ID>MaxLineLength:ProviderMap.kt$// Among the others, we should register [CordaSecurityProvider] as the first provider, to ensure that when invoking [SecureRandom()] // the [platformSecureRandom] is returned (which is registered in CordaSecurityProvider). // Note that internally, [SecureRandom()] will look through all registered providers. // Then it returns the first PRNG algorithm of the first provider that has registered a SecureRandom // implementation (in our case [CordaSecurityProvider]), or null if none of the registered providers supplies // a SecureRandom implementation. Security.insertProviderAt(it, 1) // The position is 1-based.</ID>
    <ID>MaxLineLength:ProviderMap.kt$// This map is required to defend against users that forcibly call Security.addProvider / Security.removeProvider // that could cause unexpected and suspicious behaviour. // i.e. if someone removes a Provider and then he/she adds a new one with the same name. // The val is private to avoid any harmful state changes. val providerMap = listOf(cordaBouncyCastleProvider, cordaSecurityProvider, bouncyCastlePQCProvider).map { it.name to it }.toMap()</ID>
    <ID>MaxLineLength:ProviderMap.kt$// This registration is needed for reading back EdDSA key from java keystore. // TODO: Find a way to make JKS work with bouncy castle provider or implement our own provide so we don't have to register bouncy castle provider. Security.addProvider(it)</ID>
    <ID>MaxLineLength:ProviderMap.kt$&lt;no name provided&gt;$override fun generatePublic(keyInfo: SubjectPublicKeyInfo)</ID>
    <ID>MaxLineLength:ProviderMap.kt$@DeleteForDJVM fun platformSecureRandomFactory(): SecureRandom</ID>
    <ID>MaxLineLength:PublicKeySerializer.kt$PublicKeySerializer$override val schemaForDocumentation = Schema(listOf(RestrictedType(type.toString(), "", listOf(type.toString()), AMQPTypeIdentifiers.primitiveTypeName(ByteArray::class.java), descriptor, emptyList())))</ID>
    <ID>MaxLineLength:PublicKeySerializer.kt$PublicKeySerializer${ // TODO: Instead of encoding to the default X509 format, we could have a custom per key type (space-efficient) serialiser. output.writeObject(obj.encoded, data, clazz, context) }</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCache.kt$PublicKeyToOwningIdentityCache</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl : WritablePublicKeyToOwningIdentityCache</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$ override operator fun get(key: PublicKey): KeyOwningIdentity?</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$ override operator fun set(key: PublicKey, value: KeyOwningIdentity)</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$ private fun isKeyIdentityKey(key: PublicKey): Boolean</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$ private fun isKeyPartOfNodeKeyPairs(key: PublicKey): Boolean</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$criteriaBuilder.equal(queryRoot.get&lt;String&gt;(BasicHSMKeyManagementService.PersistentKey::publicKeyHash.name), key.toStringShort())</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$criteriaBuilder.equal(queryRoot.get&lt;String&gt;(PersistentIdentityService.PersistentPublicKeyHashToCertificate::publicKeyHash.name), key.toStringShort())</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$criteriaBuilder.equal(queryRoot.get&lt;String&gt;(PublicKeyHashToExternalId::publicKeyHash.name), key.toStringShort())</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$log.debug { "Attempted to find owning identity for public key ${key.toStringShort()}, but key is unknown to node" }</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$log.debug { "Database lookup for public key ${key.toStringShort()}, found signing entity $signingEntity" }</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$private val cache = cacheFactory.buildNamed&lt;PublicKey, KeyOwningIdentity&gt;(Caffeine.newBuilder(), "PublicKeyToOwningIdentityCache_cache")</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$val queryRoot = criteriaQuery.from(PersistentIdentityService.PersistentPublicKeyHashToCertificate::class.java)</ID>
    <ID>MaxLineLength:PublicKeyToTextConverter.kt$PublicKeyToTextConverter$override fun convertToEntityAttribute(text: String?): PublicKey?</ID>
    <ID>MaxLineLength:PushedNode.kt$PushedNode$fun toNodeInstanceRequest(nodeInstanceName: String, actualX500: String, expectedFqName: String): NodeInstanceRequest</ID>
    <ID>MaxLineLength:PushedNode.kt$PushedNode$return NodeInstanceRequest(configFile, baseDirectory, copiedNodeConfig, copiedNodeDir, nodeConfig, localImageId, remoteImageName, nodeInstanceName, actualX500, expectedFqName)</ID>
    <ID>MaxLineLength:QuasarInstrumentationHook.kt$ fun recordUsedInstrumentedCallStack()</ID>
    <ID>MaxLineLength:QuasarInstrumentationHook.kt$QuasarInstrumentationHook$val instrumentClassMethods = clazz.methods.filter { it.name == "instrumentClass" } // TODO this is very brittle, we want to match on a specific instrumentClass() function. We could use the function signature, but that may change between versions anyway. Why is this function overloaded?? instrumentClassMethods[0].insertBefore( "$hookClassName.${::recordScannedClass.name}(className);" )</ID>
    <ID>MaxLineLength:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$println("Instrumented classes: ${classRecorder.instrumentedClasses.size}") classRecorder.instrumentedClasses.forEach { println(" $it") } println("Used instrumented classes: ${classRecorder.usedInstrumentedClasses.size}") classRecorder.usedInstrumentedClasses.forEach { println(" $it") } println("Scanned classes: ${classRecorder.scannedClasses.size}") classRecorder.scannedClasses.keys.take(20).forEach { println(" $it") } println(" (...)") val scannedTree = PackageTree.fromStrings(classRecorder.scannedClasses.keys.toList(), '/') val instrumentedTree = PackageTree.fromStrings(classRecorder.instrumentedClasses.keys.toList(), '/') val alwaysExclude = arguments.alwaysExcluded?.let { PackageTree.fromStrings(it, arguments.separator) } val alwaysExcludedTree = alwaysExclude?.let { instrumentedTree.truncate(it) } ?: instrumentedTree println("Suggested exclude globs:") val truncate = arguments.truncate?.let { PackageTree.fromStrings(it, arguments.separator) } // The separator append is a hack, it causes a package with an empty name to be added to the exclude tree, // which practically causes that level of the tree to be always expanded in the output globs. val expand = arguments.expand?.let { PackageTree.fromStrings(it.map { "$it${arguments.separator}" }, arguments.separator) } val truncatedTree = truncate?.let { scannedTree.truncate(it) } ?: scannedTree val expandedTree = expand?.let { alwaysExcludedTree.merge(it) } ?: alwaysExcludedTree val globs = truncatedTree.toGlobs(expandedTree) globs.forEach { println(" $it") } println("Quasar exclude expression:") println(" x(${globs.joinToString(";")})")</ID>
    <ID>MaxLineLength:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$val expand = arguments.expand?.let { PackageTree.fromStrings(it.map { "$it${arguments.separator}" }, arguments.separator) }</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria$@CordaSerializable sealed</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria$AndComposition : AttachmentQueryCriteriaAndVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria$OrComposition : AttachmentQueryCriteriaOrVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$@DeprecatedConstructorForDeserialization(version = 2) constructor(uploaderCondition: ColumnPredicate&lt;String&gt;?, filenameCondition: ColumnPredicate&lt;String&gt;?) : this(uploaderCondition, filenameCondition, null)</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun isSigned(isSignedPredicate: ColumnPredicate&lt;Boolean&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withContractClassNames(contractClassNamesPredicate: ColumnPredicate&lt;List&lt;ContractClassName&gt;&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withFilename(filenamePredicate: ColumnPredicate&lt;String&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withSigners(signersPredicate: ColumnPredicate&lt;List&lt;PublicKey&gt;&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withUploadDate(uploadDatePredicate: ColumnPredicate&lt;Instant&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withUploader(uploaderPredicate: ColumnPredicate&lt;String&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withVersion(versionPredicate: ColumnPredicate&lt;Int&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentsQueryCriteriaParser : BaseQueryCriteriaParser</ID>
    <ID>MaxLineLength:QueryCriteria.kt$BaseQueryCriteriaParser&lt;Q : GenericQueryCriteria&lt;Q, P&gt;, in P : BaseQueryCriteriaParser&lt;Q, P, S&gt;, in S : BaseSort&gt;</ID>
    <ID>MaxLineLength:QueryCriteria.kt$GenericQueryCriteria.ChainableQueryCriteria$AndVisitor&lt;Q : GenericQueryCriteria&lt;Q, P&gt;, in P : BaseQueryCriteriaParser&lt;Q, P, S&gt;, in S : BaseSort&gt; : GenericQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$GenericQueryCriteria.ChainableQueryCriteria$OrVisitor&lt;Q : GenericQueryCriteria&lt;Q, P&gt;, in P : BaseQueryCriteriaParser&lt;Q, P, S&gt;, in S : BaseSort&gt; : GenericQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria$@CordaSerializable sealed</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria$AndComposition : QueryCriteriaAndVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria$OrComposition : QueryCriteriaOrVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$( participants: List&lt;AbstractParty&gt;? = null, owner: List&lt;AbstractParty&gt;? = null, quantity: ColumnPredicate&lt;Long&gt;? = null, issuer: List&lt;AbstractParty&gt;? = null, issuerRef: List&lt;OpaqueBytes&gt;? = null, status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): FungibleAssetQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$fun withParticipants(participants: List&lt;AbstractParty&gt;): FungibleAssetQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): FungibleAssetQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleStateQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): FungibleStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleStateQueryCriteria$fun withParticipants(participants: List&lt;AbstractParty&gt;): FungibleStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleStateQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): FungibleStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.LinearStateQueryCriteria$( participants: List&lt;AbstractParty&gt;? = null, linearId: List&lt;UniqueIdentifier&gt;? = null, status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, relevancyStatus: Vault.RelevancyStatus = Vault.RelevancyStatus.ALL )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.LinearStateQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): LinearStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.LinearStateQueryCriteria$fun withParticipants(participants: List&lt;AbstractParty&gt;): LinearStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.LinearStateQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): LinearStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultCustomQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): VaultCustomQueryCriteria&lt;L&gt;</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultCustomQueryCriteria$fun withExpression(expression: CriteriaExpression&lt;L, Boolean&gt;): VaultCustomQueryCriteria&lt;L&gt;</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultCustomQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): VaultCustomQueryCriteria&lt;L&gt;</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, stateRefs: List&lt;StateRef&gt;? = null, notary: List&lt;AbstractParty&gt;? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, stateRefs: List&lt;StateRef&gt;? = null, notary: List&lt;AbstractParty&gt;? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: Vault.RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt; = emptySet(), constraints: Set&lt;Vault.ConstraintInfo&gt; = emptySet(), participants: List&lt;AbstractParty&gt;? = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$@DeprecatedConstructorForDeserialization(version = 2) constructor(status: Vault.StateStatus, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;?) : this(status, contractStateTypes, participants = null)</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withConstraintTypes(constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt;): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withConstraints(constraints: Set&lt;Vault.ConstraintInfo&gt;): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withSoftLockingCondition(softLockingCondition: SoftLockingCondition): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$/** * Note: use [PageSpecification] to correctly handle a number of bounded pages of a pre-configured page size. */ // Here we subtract 1 to allow the Vault to figure out whether there are more results and pages by querying for `pageSize + 1`. const val MAX_PAGE_SIZE = Int.MAX_VALUE - 1</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R : Comparable&lt;R&gt;&gt; Field.comparePredicate(operator: BinaryComparisonOperator, value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.`in`(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.notIn(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.equal(value: R, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.notEqual(value: R, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O&gt; KProperty1&lt;O, String?&gt;.like(string: String, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O&gt; KProperty1&lt;O, String?&gt;.notLike(string: String, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; `in`(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; notIn(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;R&gt; equal(value: R, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;R&gt; notEqual(value: R, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun notLike(string: String, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R : Comparable&lt;R&gt;&gt; Field.`in`(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R : Comparable&lt;R&gt;&gt; Field.notIn(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.avg(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.max(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.min(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.sum(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.`in`(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.notIn(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.greaterThan(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.greaterThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.lessThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.comparePredicate(operator: BinaryComparisonOperator, value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.greaterThan(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.greaterThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.lessThan(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.lessThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.count()</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.predicate(predicate: ColumnPredicate&lt;R&gt;)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.comparePredicate(operator: BinaryComparisonOperator, value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R : Comparable&lt;R&gt;&gt; compare(operator: BinaryComparisonOperator, value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R : Comparable&lt;R&gt;&gt; greaterThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R&gt; FieldInfo.predicate(predicate: ColumnPredicate&lt;R&gt;)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.AVG), groupByColumns?.map { Column(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.AVG), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.MAX), groupByColumns?.map { Column(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.MAX), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.MIN), groupByColumns?.map { Column(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.MIN), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.SUM), groupByColumns?.map { Column(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.SUM), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Column.Companion$when (property) { // This is to ensure that, for a JPA Entity, a field declared in a MappedSuperclass will not cause Hibernate to reject a query referencing it. // TODO remove the cast and access the owner properly after it will be exposed as Kotlin's public API (https://youtrack.jetbrains.com/issue/KT-24170). is CallableReference -&gt; ((property as CallableReference).owner as KClass&lt;*&gt;).javaObjectType else -&gt; property.javaGetter!!.declaringClass }</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$ColumnPredicate$BinaryComparison&lt;C : Comparable&lt;C&gt;&gt; : ColumnPredicate</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$ColumnPredicate$CollectionExpression&lt;C&gt; : ColumnPredicate</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$ColumnPredicate$EqualityComparison&lt;C&gt; : ColumnPredicate</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$CriteriaExpression$ColumnPredicateExpression&lt;O, C&gt; : CriteriaExpression</ID>
    <ID>MaxLineLength:R3Pty.kt$R3Pty : AutoCloseable</ID>
    <ID>MaxLineLength:R3Pty.kt$R3Pty$private</ID>
    <ID>MaxLineLength:RPCApi.kt$RPCApi.ServerToClient$FailedToDeserializeReply : RuntimeException</ID>
    <ID>MaxLineLength:RPCApi.kt$RPCApi.ServerToClient.Companion$val id = message.invocationId(RPC_ID_FIELD_NAME, RPC_ID_TIMESTAMP_FIELD_NAME) ?: throw IllegalStateException("Cannot parse invocation id from client message.")</ID>
    <ID>MaxLineLength:RPCApi.kt$RPCApi.ServerToClient.Companion$val observableId = message.invocationId(OBSERVABLE_ID_FIELD_NAME, OBSERVABLE_ID_TIMESTAMP_FIELD_NAME) ?: throw IllegalStateException("Cannot parse invocation id from client message.")</ID>
    <ID>MaxLineLength:RPCApi.kt$RPCApi.ServerToClient.Companion$val payload = message.getBodyAsByteArray().deserialize&lt;Notification&lt;*&gt;&gt;(context = poolWithIdContext)</ID>
    <ID>MaxLineLength:RPCApi.kt$RPCApi.ServerToClient.Companion${ val id = message.invocationId(RPC_ID_FIELD_NAME, RPC_ID_TIMESTAMP_FIELD_NAME) ?: throw IllegalStateException("Cannot parse invocation id from client message.") val poolWithIdContext = context.withProperty(RpcRequestOrObservableIdKey, id) // The result here is a Try&lt;&gt; that represents the attempt to try the operation on the server side. // If anything goes wrong with deserialisation of the response, we propagate it differently because // we also need to pass through the invocation and dedupe IDs. val result: Try&lt;Any?&gt; = try { message.getBodyAsByteArray().deserialize(context = poolWithIdContext) } catch (e: Exception) { throw FailedToDeserializeReply(id, e) } RpcReply( id = id, deduplicationIdentity = deduplicationIdentity, result = result ) }</ID>
    <ID>MaxLineLength:RPCApi.kt$RPCApi.ServerToClient.Observation$message.bodyBuffer.writeBytes(content.safeSerialize(context) { Notification.createOnError&lt;Void?&gt;(it) }.bytes)</ID>
    <ID>MaxLineLength:RPCApi.kt$net.corda.nodeapi.RPCApi.kt</ID>
    <ID>MaxLineLength:RPCApi.kt$private fun ClientMessage.invocationId(valueProperty: String, timestampProperty: String): InvocationId?</ID>
    <ID>MaxLineLength:RPCApi.kt$private fun ClientMessage.sessionId(valueProperty: String, timestampProperty: String): SessionId?</ID>
    <ID>MaxLineLength:RPCApi.kt$private fun SessionId.mapTo(message: ClientMessage)</ID>
    <ID>MaxLineLength:RPCApi.kt$private fun Trace.mapToExternal(message: ClientMessage)</ID>
    <ID>MaxLineLength:RPCApi.kt$return invocationId(RPC_ID_FIELD_NAME, RPC_ID_TIMESTAMP_FIELD_NAME) ?: throw IllegalStateException("Cannot extract reply id from client message.")</ID>
    <ID>MaxLineLength:RPCApi.kt$return sessionId(RPC_SESSION_ID_FIELD_NAME, RPC_SESSION_ID_TIMESTAMP_FIELD_NAME) ?: throw IllegalStateException("Cannot extract the session id from client message.")</ID>
    <ID>MaxLineLength:RPCClient.kt$RPCClient$reconnectAttempts = if (haPoolTransportConfigurations.isEmpty()) rpcConfiguration.maxReconnectAttempts else 0</ID>
    <ID>MaxLineLength:RPCClient.kt$RPCClient$throw RPCException("Requested minimum protocol version (${rpcConfiguration.minimumServerProtocolVersion}) is higher" + " than the server's supported protocol version ($serverProtocolVersion)")</ID>
    <ID>MaxLineLength:RPCClient.kt$RPCClient$val ops: I = uncheckedCast(Proxy.newProxyInstance(rpcOpsClass.classLoader, arrayOf(rpcOpsClass), proxyHandler))</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$ObservableContext</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler : InvocationHandler</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$ fun notifyServerAndClose()</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$ private fun close(notify: Boolean = true)</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$artemisMessage.putLongProperty(RPCApi.DEDUPLICATION_SEQUENCE_NUMBER_FIELD_NAME, deduplicationSequenceNumber.getAndIncrement())</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$if (deduplicationChecker.checkDuplicateMessageId(serverToClient.deduplicationIdentity, deduplicationSequenceNumber)) { log.info("Message duplication detected, discarding message") return }</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$log</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$log.debug("Server locator is closed or garbage collected. Proxy may have been closed during reconnect.")</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$log.error("RPC reply arrived to unknown RPC ID ${serverToClient.id}, this indicates an internal RPC error.")</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$private</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$private val deduplicationChecker = DeduplicationChecker(rpcConfiguration.deduplicationCacheExpiry, cacheFactory = cacheFactory)</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$private val serializationContextWithObservableContext = RpcClientObservableDeSerializer.createContext(serializationContext, observableContext)</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$producerSession = sessionFactory!!.createSession(rpcUsername, rpcPassword, false, true, true, false, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$retryInterval = minOf(maxRetryInterval, retryInterval.times(rpcConfiguration.connectionRetryIntervalMultiplier.toLong()))</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$return "{rpcUsername='$rpcUsername', clientAddress=$clientAddress, sessionId=$sessionId, targetLegalIdentity=$targetLegalIdentity}"</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$return cacheFactory.buildNamed(Caffeine.newBuilder().weakValues().removalListener(onObservableRemove).executor(SameThreadExecutor.getExecutor()), "RpcClientProxyHandler_rpcObservable")</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$throw UnsupportedOperationException("Method $calledMethod was added in RPC protocol version $sinceVersion but the server is running $serverProtocolVersion")</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$val observable: UnicastSubject&lt;Notification&lt;*&gt;&gt;? = observableContext.observableMap.getIfPresent(serverToClient.id)</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$val serialisedArguments = (arguments?.toList() ?: emptyList()).serialize(context = serializationContextWithObservableContext)</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$var reconnectAttempts = rpcConfiguration.maxReconnectAttempts.times(serverLocator.staticTransportConfigurations.size)</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler${ // Deserialize the reply from the server, both the wrapping metadata and the actual body of the return value. val serverToClient: RPCApi.ServerToClient = try { RPCApi.ServerToClient.fromClientMessage(serializationContextWithObservableContext, message) } catch (e: RPCApi.ServerToClient.FailedToDeserializeReply) { // Might happen if something goes wrong during mapping the response to classes, evolution, class synthesis etc. log.error("Failed to deserialize RPC body", e) completeExceptionally(e.id, e, rpcReplyMap.remove(e.id)) return } val deduplicationSequenceNumber = message.getLongProperty(RPCApi.DEDUPLICATION_SEQUENCE_NUMBER_FIELD_NAME) if (deduplicationChecker.checkDuplicateMessageId(serverToClient.deduplicationIdentity, deduplicationSequenceNumber)) { log.info("Message duplication detected, discarding message") return } log.debug { "Got message from RPC server $serverToClient" } when (serverToClient) { is RPCApi.ServerToClient.RpcReply -&gt; { val replyFuture = rpcReplyMap.remove(serverToClient.id) if (replyFuture == null) { log.error("RPC reply arrived to unknown RPC ID ${serverToClient.id}, this indicates an internal RPC error.") } else { val result: Try&lt;Any?&gt; = serverToClient.result when (result) { is Try.Success -&gt; replyFuture.set(result.value) is Try.Failure -&gt; { completeExceptionally(serverToClient.id, result.exception, replyFuture) } } } } is RPCApi.ServerToClient.Observation -&gt; { val observable: UnicastSubject&lt;Notification&lt;*&gt;&gt;? = observableContext.observableMap.getIfPresent(serverToClient.id) if (observable == null) { log.debug("Observation ${serverToClient.content} arrived to unknown Observable with ID ${serverToClient.id}. " + "This may be due to an observation arriving before the server was " + "notified of observable shutdown") } else { // We schedule the onNext() on an executor sticky-pooled based on the Observable ID. observationExecutorPool.run(serverToClient.id) { executor -&gt; executor.submit { val content = serverToClient.content if (content.isOnCompleted || content.isOnError) { observableContext.observableMap.invalidate(serverToClient.id) } // Add call site information on error if (content.isOnError) { val rpcCallSite = callSiteMap?.get(serverToClient.id) if (rpcCallSite != null) addRpcCallSiteToThrowable(content.throwable, rpcCallSite) } observable.onNext(content) } } } } } }</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler${ // Might happen if something goes wrong during mapping the response to classes, evolution, class synthesis etc. log.error("Failed to deserialize RPC body", e) completeExceptionally(e.id, e, rpcReplyMap.remove(e.id)) return }</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler${ // This is going to send remote message, see `org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.doCleanUp()`. sessionFactory?.close() }</ID>
    <ID>MaxLineLength:RPCConcurrencyTests.kt$RPCConcurrencyTests$// We construct a rose tree of immediate Observables and check that parent observations arrive before children. val proxy = testProxy() val treeDepth = 6 val treeBranchingFactor = 3 val remainingLatch = CountDownLatch((intPower(treeBranchingFactor, treeDepth + 1) - 1) / (treeBranchingFactor - 1)) val depthsSeen = Collections.synchronizedSet(HashSet&lt;Int&gt;()) fun ObservableRose&lt;Int&gt;.subscribeToAll() { remainingLatch.countDown() this.branches.subscribe { tree -&gt; (tree.value + 1 until treeDepth).forEach { require(it in depthsSeen) { "Got ${tree.value} before $it" } } depthsSeen.add(tree.value) tree.subscribeToAll() } } proxy.ops.getImmediateObservableTree(treeDepth, treeBranchingFactor).subscribeToAll() remainingLatch.await()</ID>
    <ID>MaxLineLength:RPCConcurrencyTests.kt$RPCConcurrencyTests$val remainingLatch = CountDownLatch((intPower(treeBranchingFactor, treeDepth + 1) - 1) / (treeBranchingFactor - 1))</ID>
    <ID>MaxLineLength:RPCDriver.kt$RPCDriverDSL$val artemisConfig = createRpcServerArtemisConfig(maxFileSize, maxBufferedBytesPerClient, driverDSL.driverDirectory / serverName, hostAndPort)</ID>
    <ID>MaxLineLength:RPCDriver.kt$RPCDriverDSL$val process = ProcessUtilities.startJavaProcess&lt;RandomRpcUser&gt;(listOf(rpcOpsClass.name, rpcAddress.toString(), username, password))</ID>
    <ID>MaxLineLength:RPCDriver.kt$RPCDriverDSL$val rpcSecurityManager = RPCSecurityManagerImpl.fromUserList(users = listOf(InternalUser(rpcUser.username, rpcUser.password, rpcUser.permissions)), id = AuthServiceId("TEST_SECURITY_MANAGER"))</ID>
    <ID>MaxLineLength:RPCDriver.kt$RPCDriverDSL$val session = sessionFactory.createSession(username, password, false, true, true, locator.isPreAcknowledge, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:RPCDriver.kt$RandomRpcUser.Companion$private inline fun &lt;reified T&gt; HashMap&lt;Class&lt;*&gt;, Generator&lt;*&gt;&gt;.add(generator: Generator&lt;T&gt;)</ID>
    <ID>MaxLineLength:RPCDriver.kt$RandomRpcUser.Companion$val handle = RPCClient&lt;RPCOps&gt;(hostAndPort, null, serializationContext = AMQP_RPC_CLIENT_CONTEXT).start(rpcClass, username, password)</ID>
    <ID>MaxLineLength:RPCDriver.kt$SingleUserSecurityManager$override fun validateUserAndRole(user: String?, password: String?, roles: MutableSet&lt;Role&gt;?, checkType: CheckType?)</ID>
    <ID>MaxLineLength:RPCHighThroughputObservableTests.kt$RPCHighThroughputObservableTests$val proxy = testProxy() // This tests that the observations are transmitted correctly, also check that server side doesn't try to serialize the whole lot // till client consumed some of the output produced. val observations = proxy.makeObservable() val observationsList = observations.take(4).toBlocking().toIterable().toList() assertEquals(listOf(1, 2, 3, 4), observationsList)</ID>
    <ID>MaxLineLength:RPCHighThroughputObservableTests.kt$RPCHighThroughputObservableTests.TestOpsImpl$override fun makeObservable(): Observable&lt;Int&gt;</ID>
    <ID>MaxLineLength:RPCOpsWithContext.kt$return Proxy.newProxyInstance(InternalCordaRPCOps::class.java.classLoader, arrayOf(InternalCordaRPCOps::class.java)) { _, method, args -&gt; try { method.invoke(cordaRPCOps, *(args ?: arrayOf())) } catch (e: InvocationTargetException) { // Unpack exception. throw e.targetException } } as InternalCordaRPCOps</ID>
    <ID>MaxLineLength:RPCPerformanceTests.kt$RPCPerformanceTests$Mbps = bigSize.toDouble() * numberOfMessages.toDouble() / elapsed * (1000000.0 / (1024.0 * 1024.0))</ID>
    <ID>MaxLineLength:RPCSecurityManagerImpl.kt$RPCPermission$/** * Helper constructor directly setting actions and target field * * @param methods Set of allowed RPC methods * @param target An optional "target" type on which methods act */ constructor(methods: Set&lt;String&gt;, target: String? = null) : super(methods, target?.let { setOf(it.replace(".", ":")) })</ID>
    <ID>MaxLineLength:RPCSecurityManagerTest.kt$RPCSecurityManagerTest$val userRealms = RPCSecurityManagerImpl(SecurityConfiguration.AuthService.fromUsers(listOf(user)), TestingNamedCacheFactory())</ID>
    <ID>MaxLineLength:RPCSecurityManagerWithAdditionalUser.kt$RPCSecurityManagerWithAdditionalUser : RPCSecurityManager</ID>
    <ID>MaxLineLength:RPCSecurityManagerWithAdditionalUser.kt$RPCSecurityManagerWithAdditionalUser$private</ID>
    <ID>MaxLineLength:RPCServer.kt$// TODO replace this by creating a new CordaRPCImpl for each request, passing the context, after we fix Shell and WebServer @JvmField internal val CURRENT_RPC_CONTEXT: ThreadLocal&lt;RpcAuthContext&gt; = CurrentRpcContext()</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$consumerSession = sessionFactory!!.createSession(rpcServerUsername, rpcServerPassword, false, true, true, false, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$methodTable[methodName] ?: throw RPCException("Received RPC for unknown method $methodName - possible client/server version skew?")</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$private val deduplicationChecker = DeduplicationChecker(rpcConfiguration.deduplicationCacheExpiry, cacheFactory = cacheFactory)</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$producerSession = sessionFactory!!.createSession(rpcServerUsername, rpcServerPassword, false, true, true, false, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$require(notificationType == CoreNotificationType.BINDING_ADDED.name) { "Message contained notification type of $notificationType instead of expected ${CoreNotificationType.BINDING_ADDED.name}" }</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$require(notificationType == CoreNotificationType.BINDING_REMOVED.name) { "Message contained notification type of $notificationType instead of expected ${CoreNotificationType.BINDING_REMOVED.name}" }</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$return Pair(Actor(Id(validatedUser), securityManager.id, targetLegalIdentity), securityManager.buildSubject(validatedUser))</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$return RpcAuthContext(InvocationContext.rpc(rpcActor.first, trace, externalTrace, impersonatedActor), rpcActor.second)</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$return cacheFactory.buildNamed(Caffeine.newBuilder().removalListener(onObservableRemove).executor(SameThreadExecutor.getExecutor()), "RPCServer_observableSubscription")</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$val deduplicationSequenceNumber = artemisMessage.getLongProperty(RPCApi.DEDUPLICATION_SEQUENCE_NUMBER_FIELD_NAME)</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$val targetLegalIdentity = message.getStringProperty(RPCApi.RPC_TARGET_LEGAL_IDENTITY)?.let(CordaX500Name.Companion::parse) ?: nodeLegalName</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$val validatedUser = message.getStringProperty(Message.HDR_VALIDATED_USER) ?: throw IllegalArgumentException("Missing validated user from the Artemis message")</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer${ lifeCycle.requireState(State.UNSTARTED) log.info("Starting RPC server with configuration $rpcConfiguration") senderThread = startSenderThread() rpcExecutor = Executors.newScheduledThreadPool( rpcConfiguration.rpcThreadPoolSize, ThreadFactoryBuilder().setNameFormat("rpc-server-handler-pool-%d").build() ) reaperExecutor = Executors.newSingleThreadScheduledExecutor( ThreadFactoryBuilder().setNameFormat("rpc-server-reaper-%d").build() ) reaperScheduledFuture = reaperExecutor!!.scheduleAtFixedRate( this::reapSubscriptions, rpcConfiguration.reapInterval.toMillis(), rpcConfiguration.reapInterval.toMillis(), TimeUnit.MILLISECONDS ) sessionFactory = serverLocator.createSessionFactory() producerSession = sessionFactory!!.createSession(rpcServerUsername, rpcServerPassword, false, true, true, false, DEFAULT_ACK_BATCH_SIZE) createRpcProducer(producerSession!!) consumerSession = sessionFactory!!.createSession(rpcServerUsername, rpcServerPassword, false, true, true, false, DEFAULT_ACK_BATCH_SIZE) createRpcConsumer(consumerSession!!) createNotificationConsumers(consumerSession!!) serverControl = activeMqServerControl deduplicationIdentity = UUID.randomUUID().toString() lifeCycle.transition(State.UNSTARTED, State.STARTED) // We delay the consumer session start because Artemis starts delivering messages immediately, so we need to be // fully initialised. producerSession!!.start() consumerSession!!.start() }</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$"Threads have leaked. New threads created: $newThreads (total before: ${threadsBefore.size}, total after: ${threadsAfter.size})"</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$@Ignore</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$RPCClient&lt;RPCOps&gt;(server.broker.hostAndPort!!).start(RPCOps::class.java, rpcTestUser.username, rpcTestUser.password).close()</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$configuration = CordaRPCClientConfiguration.DEFAULT.copy(minimumServerProtocolVersion = 1000)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$message.putLongProperty(RPCApi.DEDUPLICATION_SEQUENCE_NUMBER_FIELD_NAME, dedupeId.getAndIncrement())</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$pollUntilTrue("number of times subscribe() has been called") { trackSubscriberOpsImpl.subscriberCount.get() == 0 }.get()</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$pollUntilTrue("number of times subscribe() has been called") { trackSubscriberOpsImpl.subscriberCount.get() &gt;= 100 }.get()</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$private</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$serialisedArguments = emptyList&lt;Any&gt;().serialize(context = SerializationDefaults.RPC_SERVER_CONTEXT)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$serialisedArguments = listOf(100.millis, 1234).serialize(context = SerializationDefaults.RPC_SERVER_CONTEXT)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val client = startRpcClient&lt;ServerOps&gt;(listOf(NetworkHostAndPort("localhost", 12345), serverAddress, NetworkHostAndPort("localhost", 54321))).getOrThrow()</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val client = startRpcClient&lt;ServerOps&gt;(listOf(server1.broker.hostAndPort!!, server2.broker.hostAndPort!!, server3.broker.hostAndPort!!)).getOrThrow()</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val clientConfiguration = CordaRPCClientConfiguration.DEFAULT.copy(connectionRetryInterval = 1.seconds, maxReconnectAttempts = 5)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val clientConfiguration = CordaRPCClientConfiguration.DEFAULT.copy(connectionRetryInterval = 500.millis, maxReconnectAttempts = 1)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val connection = RPCClient&lt;RPCOps&gt;(server.broker.hostAndPort!!).start(RPCOps::class.java, rpcTestUser.username, rpcTestUser.password)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val connection1 = RPCClient&lt;RPCOps&gt;(server.broker.hostAndPort!!).start(RPCOps::class.java, rpcTestUser.username, rpcTestUser.password)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val connection2 = RPCClient&lt;RPCOps&gt;(server.broker.hostAndPort!!).start(RPCOps::class.java, rpcTestUser.username, rpcTestUser.password)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val server = startRpcServer(maxBufferedBytesPerClient = 10 * 1024 * 1024, ops = SlowConsumerRPCOpsImpl()).get()</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val server = startRpcServer(maxBufferedBytesPerClient = 10 * 1024 * 1024, ops = SlowConsumerRPCOpsImpl()).get() // Construct an RPC session manually so that we can hang in the message handler val myQueue = "${RPCApi.RPC_CLIENT_QUEUE_NAME_PREFIX}.test.${random63BitValue()}" val session = startArtemisSession(server.broker.hostAndPort!!) session.createTemporaryQueue(myQueue, ActiveMQDefaultConfiguration.getDefaultRoutingType(), myQueue) val consumer = session.createConsumer(myQueue, null, -1, -1, false) consumer.setMessageHandler { Thread.sleep(5000) // Needs to be slower than one per second to get kicked. it.acknowledge() } val producer = session.createProducer(RPCApi.RPC_SERVER_QUEUE_NAME) session.start() pollUntilClientNumber(server, 1) val message = session.createMessage(false) val request = RPCApi.ClientToServer.RpcRequest( clientAddress = SimpleString(myQueue), methodName = SlowConsumerRPCOps::streamAtInterval.name, serialisedArguments = listOf(100.millis, 1234).serialize(context = SerializationDefaults.RPC_SERVER_CONTEXT), replyId = Trace.InvocationId.newInstance(), sessionId = Trace.SessionId.newInstance() ) request.writeToClientMessage(message) message.putLongProperty(RPCApi.DEDUPLICATION_SEQUENCE_NUMBER_FIELD_NAME, 0) producer.send(message) session.commit() // We are consuming slower than the server is producing, so we should be kicked after a while if slow consumers are enabled. pollUntilClientNumber(server, 0)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val servers = mutableMapOf("server1" to serverFollower1, "server2" to serverFollower2, "server3" to serverFollower3)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests.&lt;no name provided&gt;$val trackSubscriberCountObservable = UnicastSubject.create&lt;Unit&gt;().share().doOnSubscribe { subscriberCount.incrementAndGet() }.doOnUnsubscribe { subscriberCount.decrementAndGet() }</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$val clientAddresses = server.broker.serverControl.addressNames.filter { it.startsWith(RPCApi.RPC_CLIENT_QUEUE_NAME_PREFIX) }</ID>
    <ID>MaxLineLength:RaftNotaryService.kt$RaftNotaryService$?:</ID>
    <ID>MaxLineLength:RaftNotaryServiceTests.kt$RaftNotaryServiceTests$val builder = DummyContract.generateInitial(Random().nextInt(), defaultNotaryIdentity, bankA.services.myInfo.singleIdentity().ref(0)) .setTimeWindow(bankA.services.clock.instant(), 30.seconds)</ID>
    <ID>MaxLineLength:RaftNotaryServiceTests.kt$RaftNotaryServiceTests$val builder = DummyContract.generateInitial(Random().nextInt(), notary, nodeHandle.services.myInfo.singleIdentity().ref(0))</ID>
    <ID>MaxLineLength:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$fun checkConflict(states: List&lt;StateRef&gt;, type: StateConsumptionDetails.ConsumedStateType)</ID>
    <ID>MaxLineLength:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$log.debug("State machine commit: attempting to store entries with keys (${commitCommand.states.joinToString()})")</ID>
    <ID>MaxLineLength:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$private</ID>
    <ID>MaxLineLength:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$val deleteQuery = session.criteriaBuilder.createCriteriaDelete(PersistentUniquenessProvider.Request::class.java)</ID>
    <ID>MaxLineLength:RaftTransactionCommitLog.kt$RaftTransactionCommitLog.Companion.CordaKryoSerializer$private val context = CheckpointSerializationDefaults.CHECKPOINT_CONTEXT.withEncoding(CordaSerializationEncoding.SNAPPY)</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$private</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$val commitCommand = RaftTransactionCommitLog.Commands.CommitTransaction(states, txId, requestingPartyName.toString(), requestSignature)</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$val commitCommandFirst = RaftTransactionCommitLog.Commands.CommitTransaction(states, txIdFirst, requestingPartyName.toString(), requestSignature)</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$val commitCommandSecond = RaftTransactionCommitLog.Commands.CommitTransaction(states, txIdSecond, requestingPartyName.toString(), requestSignature)</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$val database = configureDatabase(makeTestDataSourceProperties(), DatabaseConfig(), { null }, { null }, NodeSchemaService(extraSchemas = setOf(RaftNotarySchemaV1)))</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$val stateMachineFactory = { RaftTransactionCommitLog(database, Clock.systemUTC(), { RaftUniquenessProvider.createMap(TestingNamedCacheFactory()) }) }</ID>
    <ID>MaxLineLength:RaftUniquenessProvider.kt$RaftUniquenessProvider : UniquenessProviderSingletonSerializeAsToken</ID>
    <ID>MaxLineLength:RaftUniquenessProvider.kt$RaftUniquenessProvider.Companion$fun createMap(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;StateRef, Pair&lt;Long, SecureHash&gt;, CommittedState, String&gt;</ID>
    <ID>MaxLineLength:RaftUniquenessProvider.kt$RaftUniquenessProvider.Companion$it.value.deserialize&lt;SecureHash&gt;(context = SerializationDefaults.STORAGE_CONTEXT)</ID>
    <ID>MaxLineLength:Rate.kt$Rate$override fun toString(): String</ID>
    <ID>MaxLineLength:RatesFixFlow.kt$RatesFixFlow$ @Suspendable protected open fun filtering(elem: Any): Boolean</ID>
    <ID>MaxLineLength:ReactiveArtemisConsumer.kt$ReactiveArtemisConsumer.Companion$fun multiplex(queueNames: Set&lt;String&gt;, createSession: () -&gt; ClientSession, filter: String? = null): ReactiveArtemisConsumer</ID>
    <ID>MaxLineLength:ReceiveAllFlowTests.kt$ReceiveMultipleFlowTests$ParallelAlgorithmMap : AlgorithmDefinition</ID>
    <ID>MaxLineLength:ReceiveAllFlowTests.kt$ReceiveMultipleFlowTests$nodes[0].startFlowAndRunNetwork(ParallelAlgorithmList(nodes[1].info.singleIdentity(), nodes[2].info.singleIdentity()))</ID>
    <ID>MaxLineLength:ReceiveAllFlowTests.kt$ReceiveMultipleFlowTests$nodes[0].startFlowAndRunNetwork(ParallelAlgorithmMap(nodes[1].info.singleIdentity(), nodes[2].info.singleIdentity()))</ID>
    <ID>MaxLineLength:ReceiveAllFlowTests.kt$ReceiveMultipleFlowTests.AlgorithmDefinition$@InitiatingFlow abstract</ID>
    <ID>MaxLineLength:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest$bob = mockNet.restartNode(bob, parameters = InternalMockNodeParameters(additionalCordapps = listOf(FINANCE_CONTRACTS_CORDAPP)))</ID>
    <ID>MaxLineLength:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest$private val mockNet = InternalMockNetwork(notarySpecs = listOf(MockNetworkNotarySpec(DUMMY_NOTARY_NAME, validating = false)))</ID>
    <ID>MaxLineLength:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest$val alice = mockNet.createNode(InternalMockNodeParameters(legalName = ALICE_NAME, additionalCordapps = FINANCE_CORDAPPS))</ID>
    <ID>MaxLineLength:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest$val paymentReceiverFuture = bob.smm.track().updates.filter { it.logic is CashPaymentReceiverFlow }.map { it.logic.runId }.toFuture()</ID>
    <ID>MaxLineLength:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest$var bob = mockNet.createNode(InternalMockNodeParameters(legalName = BOB_NAME, additionalCordapps = listOf(FINANCE_WORKFLOWS_CORDAPP)))</ID>
    <ID>MaxLineLength:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest${ val alice = mockNet.createNode(InternalMockNodeParameters(legalName = ALICE_NAME, additionalCordapps = FINANCE_CORDAPPS)) // Bob initially does not have the finance contracts CorDapp so that it can throw an exception in ReceiveFinalityFlow when receiving // the payment from Alice var bob = mockNet.createNode(InternalMockNodeParameters(legalName = BOB_NAME, additionalCordapps = listOf(FINANCE_WORKFLOWS_CORDAPP))) val paymentReceiverFuture = bob.smm.track().updates.filter { it.logic is CashPaymentReceiverFlow }.map { it.logic.runId }.toFuture() alice.services.startFlow(CashIssueAndPaymentFlow( 100.POUNDS, OpaqueBytes.of(0), bob.info.singleIdentity(), false, mockNet.defaultNotaryIdentity )) mockNet.runNetwork() val paymentReceiverId = paymentReceiverFuture.getOrThrow() assertThat(bob.services.vaultService.queryBy&lt;FungibleAsset&lt;*&gt;&gt;().states).isEmpty() bob.assertFlowSentForObservationDueToConstraintError(paymentReceiverId) // Restart Bob with the contracts CorDapp so that it can recover from the error bob = mockNet.restartNode(bob, parameters = InternalMockNodeParameters(additionalCordapps = listOf(FINANCE_CONTRACTS_CORDAPP))) mockNet.runNetwork() assertThat(bob.services.getCashBalance(GBP)).isEqualTo(100.POUNDS) }</ID>
    <ID>MaxLineLength:ReceiveTransactionFlow.kt$ReceiveStateAndRefFlow&lt;out T : ContractState&gt; : FlowLogic</ID>
    <ID>MaxLineLength:ReceiveTransactionFlow.kt$ReceiveTransactionFlow : FlowLogic</ID>
    <ID>MaxLineLength:ReceiveTransactionFlow.kt$ReceiveTransactionFlow$logger.trace { "Receiving a transaction (but without checking the signatures) from ${otherSideSession.counterparty}" }</ID>
    <ID>MaxLineLength:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps : AutoCloseableInternalCordaRPCOps</ID>
    <ID>MaxLineLength:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps$ fun runFlowWithLogicalRetry( runFlow: (CordaRPCOps) -&gt; StateMachineRunId, hasFlowStarted: (CordaRPCOps) -&gt; Boolean, onFlowConfirmed: () -&gt; Unit = {}, timeout: Duration = 4.seconds )</ID>
    <ID>MaxLineLength:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.Companion$private</ID>
    <ID>MaxLineLength:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$log.error("Node is being shutdown. Operation ${method.name} rejected. Retrying when node is up...", e)</ID>
    <ID>MaxLineLength:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$CurrentState.CONNECTING, CurrentState.DIED -&gt; throw IllegalArgumentException("Illegal state: $currentState ")</ID>
    <ID>MaxLineLength:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$attemptedAddress</ID>
    <ID>MaxLineLength:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$private tailrec</ID>
    <ID>MaxLineLength:ReconnectingObservable.kt$ReconnectingObservable.ReconnectingSubscriber$backingSubscription = dataFeed.updates.subscribe(subscriber::onNext, ::scheduleResubscribe, subscriber::onCompleted)</ID>
    <ID>MaxLineLength:ReferenceInputStateTests.kt$ReferenceStateTests$networkParameters = testNetworkParameters(minimumPlatformVersion = 4, notaries = listOf(NotaryInfo(DUMMY_NOTARY, true)))</ID>
    <ID>MaxLineLength:ReferenceInputStateTests.kt$ReferenceStateTests$output(ExampleContract::class.java.typeName, "UPDATED REF DATA", "REF DATA".output&lt;ExampleState&gt;().copy(data = "NEW STUFF!"))</ID>
    <ID>MaxLineLength:ReferenceInputStateTests.kt$ReferenceStateTests$val stateAndRef = StateAndRef(TransactionState(state, CONTRACT_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), StateRef(SecureHash.zeroHash, 0))</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$UseRefState : FlowLogic</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$assertEquals(2, nodes[2].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size)</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$assertEquals(3, nodes[2].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size)</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$assertEquals(4, nodes[1].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size)</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$nodes[0].services.startFlow(ReportTransactionFlow(nodes[2].info.legalIdentities.first(), newRefTx)).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$nodes[0].services.startFlow(ReportTransactionFlow(nodes[2].info.legalIdentities.first(), newTx)).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$nodes[0].services.startFlow(ReportTransactionFlow(nodes[2].info.legalIdentities.first(), updatedRefTx)).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$val newTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$val updatedQuery = QueryCriteria.VaultQueryCriteria(stateRefs = listOf(newRefState.ref), status = Vault.StateStatus.ALL)</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$val updatedTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$val useRefTx = nodes[1].services.startFlow(WithReferencedStatesFlow { UseRefState(nodeOneIdentity, newRefState.state.data.linearId) }) .resultFuture</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests${ // 1. Create a state to be used as a reference state. Don't share it. val newRefTx = nodes[0].services.startFlow(CreateRefState()).resultFuture.getOrThrow() val newRefState = newRefTx.tx.outRefsOfType&lt;RefState.State&gt;().single() // 2. Use the "newRefState" a transaction involving another party (nodes[1]) which creates a new state. They should store the new state and the reference state. val newTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow() // Wait until node 1 stores the new tx. nodes[1].services.validatedTransactions.trackTransaction(newTx.id).getOrThrow() // Check that nodes[1] has finished recording the transaction (and updating the vault.. hopefully!). // nodes[1] should have two states. The newly created output of type "Regular.State" and the reference state created by nodes[0]. assertEquals(2, nodes[1].services.vaultService.queryBy&lt;LinearState&gt;().states.size) // Now let's find the specific reference state on nodes[1]. val refStateLinearId = newRefState.state.data.linearId val query = QueryCriteria.LinearStateQueryCriteria(linearId = listOf(refStateLinearId)) val theReferencedState = nodes[1].services.vaultService.queryBy&lt;RefState.State&gt;(query) // There should be one result - the reference state. assertEquals(newRefState, theReferencedState.states.single()) println(theReferencedState.statesMetadata.single()) // nodes[0] should also have the same state. val nodeZeroQuery = QueryCriteria.LinearStateQueryCriteria(linearId = listOf(refStateLinearId)) val theReferencedStateOnNodeZero = nodes[0].services.vaultService.queryBy&lt;RefState.State&gt;(nodeZeroQuery) assertEquals(newRefState, theReferencedStateOnNodeZero.states.single()) // nodes[0] sends the tx that created the reference state to nodes[1]. nodes[0].services.startFlow(Initiator(newRefState)).resultFuture.getOrThrow() // Query again. val theReferencedStateAgain = nodes[1].services.vaultService.queryBy&lt;RefState.State&gt;(query) // There should be one result - the reference state. assertEquals(newRefState, theReferencedStateAgain.states.single()) }</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests${ // 1. Create a state to be used as a reference state. Don't share it. val newRefTx = nodes[0].services.startFlow(CreateRefState()).resultFuture.getOrThrow() val newRefState = newRefTx.tx.outRefsOfType&lt;RefState.State&gt;().single() // 2. Use the "newRefState" a transaction involving another party (nodes[1]) which creates a new state. They should store the new state and the reference state. val newTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow() // Wait until node 1 stores the new tx. nodes[1].services.validatedTransactions.trackTransaction(newTx.id).getOrThrow() // Check that nodes[1] has finished recording the transaction (and updating the vault.. hopefully!). val allRefStates = nodes[1].services.vaultService.queryBy&lt;LinearState&gt;() // nodes[1] should have two states. The newly created output and the reference state created by nodes[0]. assertEquals(2, allRefStates.states.size) }</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests${ // 1. Create a state to be used as a reference state. Don't share it. val newRefTx = nodes[0].services.startFlow(CreateRefState()).resultFuture.getOrThrow() val newRefState = newRefTx.tx.outRefsOfType&lt;RefState.State&gt;().single() // 2. Use the "newRefState" in a transaction involving another party (nodes[1]) which creates a new state. They should store the new state and the reference state. val newTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow() // Wait until node 1 stores the new tx. nodes[1].services.validatedTransactions.trackTransaction(newTx.id).getOrThrow() // Check that nodes[1] has finished recording the transaction (and updating the vault.. hopefully!). // nodes[1] should have two states. The newly created output of type "Regular.State" and the reference state created by nodes[0]. assertEquals(2, nodes[1].services.vaultService.queryBy&lt;LinearState&gt;().states.size) // 3. Update the reference state but don't share the update. val updatedRefTx = nodes[0].services.startFlow(UpdateRefState(newRefState)).resultFuture.getOrThrow() // 4. Now report the transactions that created the two reference states to a third party. nodes[0].services.startFlow(ReportTransactionFlow(nodes[2].info.legalIdentities.first(), newRefTx)).resultFuture.getOrThrow() nodes[0].services.startFlow(ReportTransactionFlow(nodes[2].info.legalIdentities.first(), updatedRefTx)).resultFuture.getOrThrow() // Check that there are two linear states in the vault (note that one is consumed) assertEquals(2, nodes[2].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size) // 5. Report the transaction that uses the consumed reference state nodes[0].services.startFlow(ReportTransactionFlow(nodes[2].info.legalIdentities.first(), newTx)).resultFuture.getOrThrow() // There should be 3 linear states in the vault assertEquals(3, nodes[2].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size) }</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests${ // 1. Create a state to be used as a reference state. Don't share it. val newRefTx = nodes[0].services.startFlow(CreateRefState()).resultFuture.getOrThrow() val newRefState = newRefTx.tx.outRefsOfType&lt;RefState.State&gt;().single() // 2. Use the "newRefState" in a transaction involving another party (nodes[1]) which creates a new state. They should store the new state and the reference state. val newTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow() // Wait until node 1 stores the new tx. nodes[1].services.validatedTransactions.trackTransaction(newTx.id).getOrThrow() // Check that nodes[1] has finished recording the transaction (and updating the vault.. hopefully!). // nodes[1] should have two states. The newly created output of type "Regular.State" and the reference state created by nodes[0]. assertEquals(2, nodes[1].services.vaultService.queryBy&lt;LinearState&gt;().states.size) // Now let's find the specific reference state on nodes[1]. val refStateLinearId = newRefState.state.data.linearId val query = QueryCriteria.LinearStateQueryCriteria(linearId = listOf(refStateLinearId)) val theReferencedState = nodes[1].services.vaultService.queryBy&lt;RefState.State&gt;(query) // There should be one result - the reference state. assertEquals(newRefState, theReferencedState.states.single()) // The reference state should not be consumed. assertEquals(Vault.StateStatus.UNCONSUMED, theReferencedState.statesMetadata.single().status) // nodes[0] should also have the same state. val nodeZeroQuery = QueryCriteria.LinearStateQueryCriteria(linearId = listOf(refStateLinearId)) val theReferencedStateOnNodeZero = nodes[0].services.vaultService.queryBy&lt;RefState.State&gt;(nodeZeroQuery) assertEquals(newRefState, theReferencedStateOnNodeZero.states.single()) assertEquals(Vault.StateStatus.UNCONSUMED, theReferencedStateOnNodeZero.statesMetadata.single().status) // 3. Update the reference state but don't share the update. nodes[0].services.startFlow(UpdateRefState(newRefState)).resultFuture.getOrThrow() // 4. Use the evolved state as a reference state. val updatedTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow() // Wait until node 1 stores the new tx. nodes[1].services.validatedTransactions.trackTransaction(updatedTx.id).getOrThrow() // Check that nodes[1] has finished recording the transaction (and updating the vault.. hopefully!). // nodes[1] should have four states. The originals, plus the newly created output of type "Regular.State" and the reference state created by nodes[0]. assertEquals(4, nodes[1].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size) // Now let's find the original reference state on nodes[1]. val updatedQuery = QueryCriteria.VaultQueryCriteria(stateRefs = listOf(newRefState.ref), status = Vault.StateStatus.ALL) val theOriginalReferencedState = nodes[1].services.vaultService.queryBy&lt;RefState.State&gt;(updatedQuery) // There should be one result - the original reference state. assertEquals(newRefState, theOriginalReferencedState.states.single()) // The reference state should be consumed. assertEquals(Vault.StateStatus.CONSUMED, theOriginalReferencedState.statesMetadata.single().status) // nodes[0] should also have the same state. val theOriginalReferencedStateOnNodeZero = nodes[0].services.vaultService.queryBy&lt;RefState.State&gt;(updatedQuery) assertEquals(newRefState, theOriginalReferencedStateOnNodeZero.states.single()) assertEquals(Vault.StateStatus.CONSUMED, theOriginalReferencedStateOnNodeZero.statesMetadata.single().status) }</ID>
    <ID>MaxLineLength:RemoteSerializerFactory.kt$DefaultRemoteSerializerFactory : RemoteSerializerFactory</ID>
    <ID>MaxLineLength:RemoteSerializerFactory.kt$DefaultRemoteSerializerFactory$RemoteAndLocalTypeInformation(remoteInformation, localInformationByIdentifier[remoteInformation.typeIdentifier]!!)</ID>
    <ID>MaxLineLength:RemoteSerializerFactory.kt$DefaultRemoteSerializerFactory$logger.trace("get Serializer descriptor=$typeDescriptor") // Interpret all of the types in the schema into RemoteTypeInformation, and reflect that into LocalTypeInformation. val remoteTypeInformationMap = remoteTypeModel.interpret(schema) val reflected = reflect(remoteTypeInformationMap, context) // Get, and record in the registry, serializers for all of the types contained in the schema. // This will save us having to re-interpret the entire schema on re-entry when deserialising individual property values. val serializers = reflected.mapValues { (descriptor, remoteLocalPair) -&gt; descriptorBasedSerializerRegistry.getOrBuild(descriptor) { getUncached(remoteLocalPair.remoteTypeInformation, remoteLocalPair.localTypeInformation) } } // Return the specific serializer the caller asked for. serializers[typeDescriptor] ?: throw NotSerializableException( "Could not find type matching descriptor $typeDescriptor.")</ID>
    <ID>MaxLineLength:RemoteSerializerFactory.kt$DefaultRemoteSerializerFactory$when { // If descriptors match, we can return the local serializer straight away. localDescriptor == remoteDescriptor -&gt; localSerializer // Can we deserialise without evolution, e.g. going from List&lt;Foo&gt; to List&lt;*&gt;? remoteTypeInformation.isDeserialisableWithoutEvolutionTo(localTypeInformation) -&gt; localSerializer // Are the remote/local types evolvable? If so, ask the evolution serializer factory for a serializer, returning // the local serializer if it returns null (i.e. no evolution required). remoteTypeInformation.isEvolvableTo(localTypeInformation) -&gt; evolutionSerializerFactory.getEvolutionSerializer(remoteTypeInformation, localTypeInformation) ?: localSerializer // Descriptors don't match, and something is probably broken, but we let the framework do what it can with the local // serialiser (BlobInspectorTest uniquely breaks if we throw an exception here, and passes if we just warn and continue). else -&gt; { logger.warn(""" Mismatch between type descriptors, but remote type is not evolvable to local type. Remote type (descriptor: $remoteDescriptor) ${remoteTypeInformation.prettyPrint(false)} Local type (descriptor $localDescriptor): ${localTypeInformation.prettyPrint(false)} """) localSerializer } }</ID>
    <ID>MaxLineLength:RemoteSerializerFactory.kt$RemoteSerializerFactory$ @Throws(NotSerializableException::class, ClassNotFoundException::class) fun get(typeDescriptor: TypeDescriptor, schema: SerializationSchemas, context: SerializationContext): AMQPSerializer&lt;Any&gt;</ID>
    <ID>MaxLineLength:RemoteTypeCarpenter.kt$SchemaBuildingRemoteTypeCarpenter$if (typeInformation.typeIdentifier !is TypeIdentifier.Parameterised) typeInformation.carpentComposable()</ID>
    <ID>MaxLineLength:RemoteTypeInformation.kt$RemoteTypeInformation</ID>
    <ID>MaxLineLength:RemoteTypeInformation.kt$RemoteTypeInformation$ fun prettyPrint(simplifyClassNames: Boolean = true): String</ID>
    <ID>MaxLineLength:RemoteTypeInformation.kt$RemoteTypeInformation.Unparameterised$data</ID>
    <ID>MaxLineLength:ReplayedList.kt$ReplayedList&lt;A&gt; : TransformationList</ID>
    <ID>MaxLineLength:Reporter.kt$ObjectName("$domain:type=$category,${if (component.isNotEmpty()) "component=$component," else ""}name=$subName")</ID>
    <ID>MaxLineLength:RequiresDb.kt$RequiresDb</ID>
    <ID>MaxLineLength:RequiresDb.kt$RequiresSql</ID>
    <ID>MaxLineLength:ResolveStatePointersTest.kt$ResolveStatePointersTest$networkParameters = testNetworkParameters(minimumPlatformVersion = 4, notaries = listOf(NotaryInfo(notary.party, true)))</ID>
    <ID>MaxLineLength:ResolveStatePointersTest.kt$ResolveStatePointersTest.Foo$@BelongsToContract(DummyContract::class) private data</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$ // TODO This can also be done in parallel. See comment to [fetchMissingAttachments] above. @Suspendable fun fetchMissingNetworkParameters(transaction: SignedTransaction): Boolean</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$ // TODO: This could be done in parallel with other fetches for extra speed. @Suspendable fun fetchMissingAttachments(transaction: SignedTransaction): Boolean</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$constructor(txHashes: Set&lt;SecureHash&gt;, otherSide: FlowSession, statesToRecord: StatesToRecord = StatesToRecord.NONE) : this(null, txHashes, otherSide, statesToRecord)</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$val counterpartyPlatformVersion = checkNotNull(serviceHub.networkMapCache.getNodeByLegalIdentity(otherSide.counterparty)?.platformVersion) { "Couldn't retrieve party's ${otherSide.counterparty} platform version from NetworkMapCache" }</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$val usedStatesToRecord = if (statesToRecord == StatesToRecord.NONE) StatesToRecord.ONLY_RELEVANT else statesToRecord</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow${ // TODO This error should actually cause the flow to be sent to the flow hospital to be retried val counterpartyPlatformVersion = checkNotNull(serviceHub.networkMapCache.getNodeByLegalIdentity(otherSide.counterparty)?.platformVersion) { "Couldn't retrieve party's ${otherSide.counterparty} platform version from NetworkMapCache" } // Fetch missing parameters flow was added in version 4. This check is needed so we don't end up with node V4 sending parameters // request to node V3 that doesn't know about this protocol. fetchNetParamsFromCounterpart = counterpartyPlatformVersion &gt;= 4 if (initialTx != null) { fetchMissingAttachments(initialTx) fetchMissingNetworkParameters(initialTx) } val resolver = (serviceHub as ServiceHubCoreInternal).createTransactionsResolver(this) resolver.downloadDependencies() otherSide.send(FetchDataFlow.Request.End) // Finish fetching data. // If transaction resolution is performed for a transaction where some states are relevant, then those should be // recorded if this has not already occurred. val usedStatesToRecord = if (statesToRecord == StatesToRecord.NONE) StatesToRecord.ONLY_RELEVANT else statesToRecord resolver.recordDependencies(usedStatesToRecord) }</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$// Used for checking larger chains resolve correctly. Note that this takes a long time to run, and so is not suitable for a CI gate. @Test @Ignore fun `Can resolve large chain of transactions`()</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$currentTx = createContractUpgradeTransaction(currentTx.tx.outRefsOfType&lt;ContractState&gt;().map { it.ref }, currentTx)</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$private</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$val ledgerTx = (currentTx.coreTransaction as ContractUpgradeWireTransaction).resolve(megaCorpNode.services, currentTx.sigs)</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$val ledgerTx = (currentTx.coreTransaction as NotaryChangeWireTransaction).resolve(megaCorpNode.services, currentTx.sigs)</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$val notaryTx = NotaryChangeTransactionBuilder(inputs, notary, newNotary, notaryNode.services.networkParametersService.defaultHash).build()</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$val signableData = SignableData(contractTx.id, SignatureMetadata(4, Crypto.findSignatureScheme(notaryKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$val signableData = SignableData(notaryTx.id, SignatureMetadata(4, Crypto.findSignatureScheme(notaryKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest.TestFlow$constructor(txHashes: Set&lt;SecureHash&gt;, otherSide: Party) : this(otherSide, { ResolveTransactionsFlow(txHashes, it) })</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest.TestResponseResolveNoRightsFlow$otherSideSession.sendAndReceive&lt;Any&gt;(FetchDataFlow.Request.Data(NonEmptySet.of(noRightsTx.inputs.first().txhash), FetchDataFlow.DataType.TRANSACTION))</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest.TestResponseResolveTwiceFlow$otherSideSession.sendAndReceive&lt;Any&gt;(FetchDataFlow.Request.Data(NonEmptySet.of(parent1), FetchDataFlow.DataType.TRANSACTION))</ID>
    <ID>MaxLineLength:RetryFlowMockTest.kt$RetryFlowMockTest${ val messagesSent = Collections.synchronizedList(mutableListOf&lt;Message&gt;()) val partyB = nodeB.info.legalIdentities.first() nodeA.setMessagingServiceSpy(object : MessagingServiceSpy() { override fun send(message: Message, target: MessageRecipients, sequenceKey: Any) { messagesSent.add(message) messagingService.send(message, target) } }) val count = 10000 // Lots of iterations so the flow keeps going long enough nodeA.startFlow(KeepSendingFlow(count, partyB)) eventually(duration = Duration.ofSeconds(30), waitBetween = Duration.ofMillis(100)) { assertTrue(messagesSent.isNotEmpty()) assertNotNull(messagesSent.first().senderUUID) } nodeA = mockNet.restartNode(nodeA) // This is a bit racy because restarting the node actually starts it, so we need to make sure there's enough iterations we get here with flow still going. nodeA.setMessagingServiceSpy(object : MessagingServiceSpy() { override fun send(message: Message, target: MessageRecipients, sequenceKey: Any) { messagesSent.add(message) messagingService.send(message, target) } }) // Now short circuit the iterations so the flow finishes soon. KeepSendingFlow.count.set(count - 2) eventually(duration = Duration.ofSeconds(30), waitBetween = Duration.ofMillis(100)) { assertTrue(nodeA.smm.allStateMachines.isEmpty()) } assertNull(messagesSent.last().senderUUID) }</ID>
    <ID>MaxLineLength:RetryFlowMockTest.kt$RetryFlowMockTest.&lt;no name provided&gt;$override</ID>
    <ID>MaxLineLength:RetryFlowMockTest.kt$RetryFlowMockTest.RetryInsertFlow$val tx = DBTransactionStorage.DBTransaction("Foo", null, Utils.EMPTY_BYTES, DBTransactionStorage.TransactionStatus.VERIFIED)</ID>
    <ID>MaxLineLength:RigorousMock.kt$ fun &lt;T&gt; participant(clazz: Class&lt;out T&gt;)</ID>
    <ID>MaxLineLength:RigorousMock.kt$ fun &lt;T&gt; rigorousMock(clazz: Class&lt;out T&gt;)</ID>
    <ID>MaxLineLength:RigorousMock.kt$ fun &lt;T&gt; spectator(clazz: Class&lt;out T&gt;)</ID>
    <ID>MaxLineLength:RigorousMock.kt$ParticipantDefaultAnswer$"Please specify what should happen when '${invocation.method}' is called, or don't call it. Args: ${Arrays.toString(invocation.arguments)}"</ID>
    <ID>MaxLineLength:RigorousMock.kt$RigorousMockDefaultAnswer$return if (Modifier.isAbstract(invocation.method.modifiers)) ParticipantDefaultAnswer.answerImpl(invocation) else invocation.callRealMethod()</ID>
    <ID>MaxLineLength:RigorousMock.kt$SpectatorDefaultAnswer.MethodInfo$private fun newSpectator(invocation: InvocationOnMock)</ID>
    <ID>MaxLineLength:RigorousMock.kt$SpectatorDefaultAnswer.MethodInfo$return context.actualTypeArguments[clazz.typeParameters.indexOf(resolveType(clazz.genericSuperclass, type))]</ID>
    <ID>MaxLineLength:RigorousMock.kt$UndefinedMockBehaviorException : RuntimeException</ID>
    <ID>MaxLineLength:RigorousMockTest.kt$RigorousMockTest$assertSame&lt;Any&gt;(UndefinedMockBehaviorException::class.java, catchThrowable { collaborator.noClearDefault() }.javaClass)</ID>
    <ID>MaxLineLength:RigorousMockTest.kt$RigorousMockTest$assertSame&lt;Any&gt;(UndefinedMockBehaviorException::class.java, catchThrowable { m.a }.javaClass)</ID>
    <ID>MaxLineLength:RigorousMockTest.kt$RigorousMockTest$assertSame&lt;Any&gt;(UndefinedMockBehaviorException::class.java, catchThrowable { m.kotlinDefaultFun() }.javaClass)</ID>
    <ID>MaxLineLength:RoundTripObservableSerializerTests.kt$RoundTripObservableSerializerTests$return Caffeine.newBuilder().weakValues().removalListener(onObservableRemove).executor(SameThreadExecutor.getExecutor()).build()</ID>
    <ID>MaxLineLength:RoundTripObservableSerializerTests.kt$RoundTripObservableSerializerTests$serializationContext</ID>
    <ID>MaxLineLength:RoundTripObservableSerializerTests.kt$RoundTripObservableSerializerTests$val subMap: Cache&lt;Trace.InvocationId, ObservableSubscription&gt; = Caffeine.newBuilder().expireAfterWrite(1, TimeUnit.MINUTES) .maximumSize(100) .build()</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$journalBufferSize_AIO = maxMessageSize</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$journalBufferSize_NIO = maxMessageSize</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$private</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$return Role(name, send, consume, createDurableQueue, deleteDurableQueue, createNonDurableQueue, deleteNonDurableQueue, manage, browse, createDurableQueue || createNonDurableQueue, deleteDurableQueue || deleteNonDurableQueue)</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$securityRoles[RPCApi.RPC_SERVER_QUEUE_NAME] = setOf(nodeInternalRole, restrictedRole(BrokerJaasLoginModule.RPC_ROLE, send = true))</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$val addRPCRoleToUsers = if (shouldStartLocalShell) listOf(ArtemisMessagingComponent.INTERNAL_SHELL_USER) else emptyList()</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$val nodeInternalRole = Role(BrokerJaasLoginModule.NODE_RPC_ROLE, true, true, true, true, true, true, true, true, true, true)</ID>
    <ID>MaxLineLength:RpcClientCordaFutureSerializer.kt$RpcClientCordaFutureSerializer$throw NotSerializableException("Failed to deserialize Future from proxy Observable - ${e.message}\n").apply { initCause(e.cause) }</ID>
    <ID>MaxLineLength:RpcClientObservableDeSerializer.kt$RpcClientObservableDeSerializer : Implements</ID>
    <ID>MaxLineLength:RpcClientObservableDeSerializer.kt$RpcClientObservableDeSerializer$private</ID>
    <ID>MaxLineLength:RpcClientObservableDeSerializer.kt$RpcClientObservableDeSerializer$val observableId: Trace.InvocationId = Trace.InvocationId((obj[0] as String), Instant.ofEpochMilli((obj[1] as Long)))</ID>
    <ID>MaxLineLength:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest$assertEquals((exception.cause as CordaRuntimeException).originalExceptionClassName, SQLException::class.qualifiedName)</ID>
    <ID>MaxLineLength:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest$assertThatThrownBy { devModeNode.throwExceptionFromFlow() }</ID>
    <ID>MaxLineLength:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest$assertThatThrownBy { node.throwExceptionFromFlow() }</ID>
    <ID>MaxLineLength:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest$assertThatThrownBy { scenario(ALICE_NAME, BOB_NAME, true) }</ID>
    <ID>MaxLineLength:RpcExceptions.kt$DuplicateAttachmentException : FileAlreadyExistsExceptionClientRelevantError</ID>
    <ID>MaxLineLength:RpcExceptions.kt$InternalNodeException : CordaRuntimeExceptionClientRelevantErrorIdentifiableException</ID>
    <ID>MaxLineLength:RpcExceptions.kt$NonRpcFlowException : IllegalArgumentExceptionClientRelevantError</ID>
    <ID>MaxLineLength:RpcExceptions.kt$OutdatedNetworkParameterHashException : CordaRuntimeExceptionClientRelevantError</ID>
    <ID>MaxLineLength:RpcExceptions.kt$OutdatedNetworkParameterHashException.Companion$private const val TEMPLATE = "Refused to accept parameters with hash %s because network map advertises update with hash %s. Please check newest version"</ID>
    <ID>MaxLineLength:RpcFlowsDrainingModeTest.kt$RpcFlowsDrainingModeTest$driver</ID>
    <ID>MaxLineLength:RpcHelpers.kt$return Observable.interval(interval, unit).map { isWaitingForShutdown() }.takeFirst { waiting -&gt; waiting == false }.map { Unit }</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$assertThat(stateMachineEvents.count { it is StateMachineUpdate.Added }).isGreaterThanOrEqualTo(NUMBER_OF_FLOWS_TO_RUN / 3)</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$assertThat(stateMachineEvents.count { it is StateMachineUpdate.Removed }).isGreaterThanOrEqualTo(NUMBER_OF_FLOWS_TO_RUN / 3)</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$assertTrue(missingProgressEvents.isEmpty(), "The flow progress tracker is missing events: $missingProgressEvents")</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$bankAReconnectingRpc .vaultQueryByWithPagingSpec(Cash.State::class.java, QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.CONSUMED), PageSpecification(1, 10000))</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$driver</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$fun startBankA(address: NetworkHostAndPort)</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$fun startProxy(addressPair: AddressPair)</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$log.info("Timed out waiting for confirmation that all flows have started. Remaining flows: ${flowsCountdownLatch.count}")</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$log.info("vault update produced ${update.produced.map { it.state.data.amount }} consumed ${update.consumed.map { it.ref }}")</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$val bankAReconnectingRpc = client.start(demoUser.username, demoUser.password, gracefulReconnect = true).proxy as ReconnectingCordaRPCOps</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$val criteria = QueryCriteria.VaultCustomQueryCriteria(builder { CashSchemaV1.PersistentCashState::pennies.equal(amount.toLong() * 100) }, status = Vault.StateStatus.ALL)</ID>
    <ID>MaxLineLength:RpcServerObservableSerializer.kt$RpcServerObservableSerializer.&lt;no name provided&gt;$observableContext.clientAddressToObservables</ID>
    <ID>MaxLineLength:RpcServerObservableSerializerTests.kt$RpcServerObservableSerializerTests$val subMap: Cache&lt;Trace.InvocationId, ObservableSubscription&gt; = Caffeine.newBuilder().expireAfterWrite(1, TimeUnit.MINUTES) .maximumSize(100) .build()</ID>
    <ID>MaxLineLength:RpcSslTest.kt$RpcSslTest$val connection = CordaRPCClient(node.rpcAddress, sslConfiguration = clientSslOptions).start(user.username, user.password)</ID>
    <ID>MaxLineLength:RpcSslTest.kt$RpcSslTest$val connection2 = CordaRPCClient(node.rpcAddress, sslConfiguration = clientSslOptions).start(user.username, "wrong")</ID>
    <ID>MaxLineLength:RpcSslTest.kt$RpcSslTest$val node = startNode(rpcUsers = listOf(user), customOverrides = brokerSslOptions.useSslRpcOverrides()).getOrThrow()</ID>
    <ID>MaxLineLength:SSLHelper.kt$// As per Javadoc in: https://docs.oracle.com/javase/8/docs/api/javax/net/ssl/KeyManagerFactory.html `init` method // 2nd parameter `password` - the password for recovering keys in the KeyStore fun KeyManagerFactory.init(keyStore: CertificateStore)</ID>
    <ID>MaxLineLength:SSLHelper.kt$LoggingTrustManagerWrapper$AuthorityKeyIdentifier.getInstance(bcCert.getExtension(Extension.authorityKeyIdentifier).parsedValue).keyIdentifier.toHex()</ID>
    <ID>MaxLineLength:SSLHelper.kt$LoggingTrustManagerWrapper$SubjectKeyIdentifier.getInstance(bcCert.getExtension(Extension.subjectKeyIdentifier).parsedValue).keyIdentifier.toHex()</ID>
    <ID>MaxLineLength:SSLHelper.kt$internal</ID>
    <ID>MaxLineLength:SSLHelper.kt$private const val DEFAULT_SSL_TIMEOUT = 20000 // Aligned with sun.security.provider.certpath.URICertStore.DEFAULT_CRL_CONNECT_TIMEOUT</ID>
    <ID>MaxLineLength:SSLHelper.kt$sslHandler.handshakeTimeoutMillis = Integer.getInteger(SSL_HANDSHAKE_TIMEOUT_PROP_NAME, DEFAULT_SSL_TIMEOUT).toLong()</ID>
    <ID>MaxLineLength:SSLHelper.kt$val trustManagers = trustManagerFactory.trustManagers.filterIsInstance(X509ExtendedTrustManager::class.java).map { LoggingTrustManagerWrapper(it) }.toTypedArray()</ID>
    <ID>MaxLineLength:SSLHelper.kt${ val secureHash = SecureHash.sha256(x500Name.toString()) // RFC 1035 specifies a limit 255 bytes for hostnames with each label being 63 bytes or less. Due to this, the string // representation of the SHA256 hash is truncated to 32 characters. return String.format(HOSTNAME_FORMAT, secureHash.toString().take(32).toLowerCase()) }</ID>
    <ID>MaxLineLength:SSLHelperTest.kt$SSLHelperTest$assertEquals("$legalNameHash.corda.net", (sslHandler.engine().sslParameters.serverNames.first() as SNIHostName).asciiName)</ID>
    <ID>MaxLineLength:SSLHelperTest.kt$SSLHelperTest$keyManagerFactory.init(CertificateStore.fromFile(keyStore.path, keyStore.storePassword, keyStore.entryPassword, false))</ID>
    <ID>MaxLineLength:SSLHelperTest.kt$SSLHelperTest$trustManagerFactory.init(initialiseTrustStoreAndEnableCrlChecking(CertificateStore.fromFile(trustStore.path, trustStore.storePassword, trustStore.entryPassword, false), false))</ID>
    <ID>MaxLineLength:SSLHelperTest.kt$SSLHelperTest$val sslHandler = createClientSslHelper(NetworkHostAndPort("localhost", 1234), setOf(legalName), keyManagerFactory, trustManagerFactory)</ID>
    <ID>MaxLineLength:SampleCashSchemaV1.kt$SampleCashSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:SampleCashSchemaV1.kt$SampleCashSchemaV1.PersistentCashState$@Table(name = "contract_cash_states_v1", indexes = [Index(name = "ccy_code_idx1", columnList = "ccy_code"), Index(name = "pennies_idx1", columnList = "pennies")])</ID>
    <ID>MaxLineLength:SampleCashSchemaV2.kt$SampleCashSchemaV2.PersistentCashState$@CollectionTable(name = "cash_states_v2_participants", joinColumns = [JoinColumn(name = "output_index", referencedColumnName = "output_index"), JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id")])</ID>
    <ID>MaxLineLength:ScheduledActivityObserver.kt$ScheduledActivityObserver$val scheduledAt = sandbox { producedState.nextScheduledActivity(produced.ref, FlowLogicRefFactory)?.scheduledAt } ?: return</ID>
    <ID>MaxLineLength:ScheduledActivityObserver.kt$ScheduledActivityObserver.Companion$consumed.forEach { if (it.state.data is SchedulableState) schedulerService.unscheduleStateActivity(it.ref) }</ID>
    <ID>MaxLineLength:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$cordappsForAllNodes = listOf(DUMMY_CONTRACTS_CORDAPP, cordappWithPackages("net.corda.testMessage"), enclosedCordapp())</ID>
    <ID>MaxLineLength:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$val (alice, bob) = listOf(ALICE_NAME, BOB_NAME).map { startNode(providedName = it, rpcUsers = listOf(rpcUser)) }.transpose().getOrThrow()</ID>
    <ID>MaxLineLength:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$val N = 23 val rpcUser = User("admin", "admin", setOf("ALL")) val (alice, bob) = listOf(ALICE_NAME, BOB_NAME).map { startNode(providedName = it, rpcUsers = listOf(rpcUser)) }.transpose().getOrThrow() val aliceClient = CordaRPCClient(alice.rpcAddress).start(rpcUser.username, rpcUser.password) val bobClient = CordaRPCClient(bob.rpcAddress).start(rpcUser.username, rpcUser.password) val scheduledFor = Instant.now().plusSeconds(10) val initialiseFutures = mutableListOf&lt;CordaFuture&lt;*&gt;&gt;() for (i in 0 until N) { initialiseFutures.add(aliceClient.proxy.startFlow( ::InsertInitialStateFlow, bob.nodeInfo.legalIdentities.first(), defaultNotaryIdentity, i, scheduledFor ).returnValue) initialiseFutures.add(bobClient.proxy.startFlow( ::InsertInitialStateFlow, alice.nodeInfo.legalIdentities.first(), defaultNotaryIdentity, i + 100, scheduledFor ).returnValue) } initialiseFutures.getOrThrowAll() val spendAttemptFutures = mutableListOf&lt;CordaFuture&lt;*&gt;&gt;() for (i in (0 until N).reversed()) { spendAttemptFutures.add(aliceClient.proxy.startFlow(::AnotherFlow, (i).toString()).returnValue) spendAttemptFutures.add(bobClient.proxy.startFlow(::AnotherFlow, (i + 100).toString()).returnValue) } spendAttemptFutures.getOrThrowAll() // TODO: the queries below are not atomic so we need to allow enough time for the scheduler to finish. Would be better to query scheduler. Thread.sleep(20.seconds.toMillis()) val aliceStates = aliceClient.proxy.vaultQuery(ScheduledState::class.java).states.filter { it.state.data.processed } val aliceSpentStates = aliceClient.proxy.vaultQuery(SpentState::class.java).states val bobStates = bobClient.proxy.vaultQuery(ScheduledState::class.java).states.filter { it.state.data.processed } val bobSpentStates = bobClient.proxy.vaultQuery(SpentState::class.java).states assertEquals(aliceStates.count() + aliceSpentStates.count(), N * 2) assertEquals(bobStates.count() + bobSpentStates.count(), N * 2) assertEquals(aliceSpentStates.count(), bobSpentStates.count())</ID>
    <ID>MaxLineLength:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$val aliceStates = aliceClient.proxy.vaultQuery(ScheduledState::class.java).states.filter { it.state.data.processed }</ID>
    <ID>MaxLineLength:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$val bobStates = bobClient.proxy.vaultQuery(ScheduledState::class.java).states.filter { it.state.data.processed }</ID>
    <ID>MaxLineLength:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests.AnotherFlow$val results = serviceHub.vaultService.queryBy&lt;ScheduledState&gt;(QueryCriteria.LinearStateQueryCriteria(externalId = ImmutableList.of(identity)))</ID>
    <ID>MaxLineLength:ScheduledFlowTests.kt$ScheduledFlowTests$mockNet = InternalMockNetwork(cordappsForAllNodes = listOf(DUMMY_CONTRACTS_CORDAPP, enclosedCordapp()), threadPerNode = true)</ID>
    <ID>MaxLineLength:ScheduledFlowTests.kt$ScheduledFlowTests.Companion$val SORTING = Sort(listOf(Sort.SortColumn(SortAttribute.Standard(Sort.CommonStateAttribute.STATE_REF_TXN_ID), Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:ScheduledFlowTests.kt$ScheduledFlowTests.ScheduledState$override</ID>
    <ID>MaxLineLength:ScheduledFlowsDrainingModeTest.kt$ScheduledFlowsDrainingModeTest.ScheduledState$override</ID>
    <ID>MaxLineLength:ScheduledState.kt$ScheduledState$override</ID>
    <ID>MaxLineLength:Schema.kt$ClassSchema$superclass: Schema? = null</ID>
    <ID>MaxLineLength:Schema.kt$CompositeType.Companion$return CompositeType(list[0] as String, list[1] as? String, uncheckedCast(list[2]), list[3] as Descriptor, uncheckedCast(list[4]))</ID>
    <ID>MaxLineLength:Schema.kt$CompositeType.Companion$return newInstance(listOf(list[0], list[1], list[2], Descriptor.get(list[3]!!), (list[4] as List&lt;*&gt;).map { Field.get(it!!) }))</ID>
    <ID>MaxLineLength:Schema.kt$Field.Companion$return Field(list[0] as String, list[1] as String, uncheckedCast(list[2]), list[3] as? String, list[4] as? String, list[5] as Boolean, list[6] as Boolean)</ID>
    <ID>MaxLineLength:Schema.kt$RestrictedType.Companion$return RestrictedType(list[0] as String, list[1] as? String, uncheckedCast(list[2]), list[3] as String, list[4] as Descriptor, uncheckedCast(list[5]))</ID>
    <ID>MaxLineLength:Schema.kt$RestrictedType.Companion$return newInstance(listOf(list[0], list[1], list[2], list[3], Descriptor.get(list[4]!!), (list[5] as List&lt;*&gt;).map { Choice.get(it!!) }))</ID>
    <ID>MaxLineLength:Schema.kt$Schema$internal</ID>
    <ID>MaxLineLength:Schema.kt$Schema$return properties.asSequence().map { it.key to it.describe(configuration, serialiseValue) }.filter { it.second != null }.fold(configObject()) { config, (key, value) -&gt; config.withValue(key, value) }</ID>
    <ID>MaxLineLength:Schema.kt$Schema$throw IllegalArgumentException("More than one property was found for keys ${invalid.keys.joinToString(", ", "[", "]")}.")</ID>
    <ID>MaxLineLength:Schema.kt$Schema$val invalid = properties.groupBy(Configuration.Property.Definition&lt;*&gt;::key).mapValues { entry -&gt; entry.value.size }.filterValues { propertiesForKey -&gt; propertiesForKey &gt; 1 }</ID>
    <ID>MaxLineLength:Schema.kt$Schema$val nestedProperties = (properties + properties.flatMap { it.schema?.properties ?: emptySet() }).asSequence().distinctBy(Configuration.Property.Definition&lt;*&gt;::schema)</ID>
    <ID>MaxLineLength:Schema.kt$Schema$val root = properties.asSequence().map { it.key to ConfigValueFactory.fromAnyRef(it.typeName) }.fold(configObject()) { config, (key, value) -&gt; config.withValue(key, value) }</ID>
    <ID>MaxLineLength:Schema.kt$fun typeDescriptorFor(typeId: TypeIdentifier): Symbol</ID>
    <ID>MaxLineLength:Schema.kt$return if (obj == null || obj is DescribedType || obj is Binary || forGenericType(type).run { isPrimitive(this) || this == TopType }) { obj } else { /** * This must be a primitive [obj] that has a non-primitive [type]. * Rewrap it with the required descriptor for further deserialization. */ RedescribedType(typeDescriptorFor(type), obj) }</ID>
    <ID>MaxLineLength:SchemaMigration.kt$CheckpointsException : DatabaseMigrationException</ID>
    <ID>MaxLineLength:SchemaMigration.kt$CheckpointsException$"This is dangerous because the node might not be able to restore the flows correctly and could consequently fail. "</ID>
    <ID>MaxLineLength:SchemaMigration.kt$DatabaseIncompatibleException : DatabaseMigrationException</ID>
    <ID>MaxLineLength:SchemaMigration.kt$DatabaseIncompatibleException.Companion$fun errorMessageFor(reason: String): String</ID>
    <ID>MaxLineLength:SchemaMigration.kt$MissingMigrationException : DatabaseMigrationException</ID>
    <ID>MaxLineLength:SchemaMigration.kt$MissingMigrationException.Companion$fun errorMessageFor(mappedSchema: MappedSchema): String</ID>
    <ID>MaxLineLength:SchemaMigration.kt$OutstandingDatabaseChangesException : DatabaseMigrationException</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$ private fun migrateOlderDatabaseToUseLiquibase(existingCheckpoints: Boolean): Boolean</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$(hasLiquibase &amp;&amp; it.createStatement().use { noLiquibaseEntryLogForFinanceApp(it) })</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$(mappedSchema::class.qualifiedName == "net.corda.finance.schemas.CashSchemaV1" || mappedSchema::class.qualifiedName == "net.corda.finance.schemas.CommercialPaperSchemaV1") &amp;&amp; mappedSchema.migrationResource == null -&gt; null</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$(run &amp;&amp; !check) &amp;&amp; (unRunChanges.isNotEmpty() &amp;&amp; existingCheckpoints!!) -&gt; throw CheckpointsException()</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$// Collect all changelog file referenced in the included schemas. // For backward compatibility reasons, when failOnMigrationMissing=false, we don't manage CorDapps via Liquibase but use the hibernate hbm2ddl=update. val changelogList = schemas.mapNotNull { mappedSchema -&gt; val resource = getMigrationResource(mappedSchema, classLoader) when { resource != null -&gt; resource // Corda OS FinanceApp in v3 has no Liquibase script, so no error is raised (mappedSchema::class.qualifiedName == "net.corda.finance.schemas.CashSchemaV1" || mappedSchema::class.qualifiedName == "net.corda.finance.schemas.CommercialPaperSchemaV1") &amp;&amp; mappedSchema.migrationResource == null -&gt; null else -&gt; throw MissingMigrationException(mappedSchema) } } val path = currentDirectory?.toString() if (path != null) { System.setProperty(NODE_BASE_DIR_KEY, path) // base dir for any custom change set which may need to load a file (currently AttachmentVersionNumberMigration) } System.setProperty(NODE_X500_NAME, ourName.toString()) val customResourceAccessor = CustomResourceAccessor(dynamicInclude, changelogList, classLoader) checkResourcesInClassPath(changelogList) // current version of Liquibase appears to be non-threadsafe // this is apparent when multiple in-process nodes are all running migrations simultaneously mutex.withLock { val liquibase = Liquibase(dynamicInclude, customResourceAccessor, getLiquibaseDatabase(JdbcConnection(connection))) val unRunChanges = liquibase.listUnrunChangeSets(Contexts(), LabelExpression()) when { (run &amp;&amp; !check) &amp;&amp; (unRunChanges.isNotEmpty() &amp;&amp; existingCheckpoints!!) -&gt; throw CheckpointsException() // Do not allow database migration when there are checkpoints run &amp;&amp; !check -&gt; liquibase.update(Contexts()) check &amp;&amp; !run &amp;&amp; unRunChanges.isNotEmpty() -&gt; throw OutstandingDatabaseChangesException(unRunChanges.size) check &amp;&amp; !run -&gt; { } // Do nothing will be interpreted as "check succeeded" else -&gt; throw IllegalStateException("Invalid usage.") } }</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$System.setProperty(NODE_BASE_DIR_KEY, path)</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$check &amp;&amp; !run &amp;&amp; unRunChanges.isNotEmpty() -&gt; throw OutstandingDatabaseChangesException(unRunChanges.size)</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$it.execute("SELECT COUNT(*) FROM DATABASECHANGELOG WHERE FILENAME IN ('migration/cash.changelog-init.xml','migration/commercial-paper.changelog-init.xml')")</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$private</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$throw DatabaseMigrationException("Could not find Liquibase database migration script $resource. Please ensure the jar file containing it is deployed in the cordapps directory.")</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$val dynamicInclude = "master.changelog.json" // Virtual file name of the changelog that includes all schemas.</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$val isFinanceAppWithLiquibaseNotMigrated = isFinanceAppWithLiquibase &amp;&amp; // If Finance App is pre v4.0 then no need to migrate it so no need to check. existingDatabase &amp;&amp; (!hasLiquibase || // Migrate as other tables. (hasLiquibase &amp;&amp; it.createStatement().use { noLiquibaseEntryLogForFinanceApp(it) })) // If Liquibase is already in the database check if Finance App schema log is missing.</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$val liquibase = Liquibase(dynamicInclude, customResourceAccessor, getLiquibaseDatabase(JdbcConnection(connection)))</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration.CustomResourceAccessor$val includeAllFiles = mapOf("databaseChangeLog" to changelogList.filter { it != null }.map { file -&gt; mapOf("include" to mapOf("file" to file)) })</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$assertThat(descriptionObj.getAnyRef("prop3.prop5")).isEqualTo(Configuration.Property.Definition.SENSITIVE_DATA_PLACEHOLDER)</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$assertThat(obj.toConfig().getString("prop5")).isEqualTo(Configuration.Property.Definition.SENSITIVE_DATA_PLACEHOLDER)</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val barConfigSchema = Configuration.Schema.withProperties { setOf(string(prop1), long(prop2), nestedObject("prop3", fooConfigSchema)) }</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val barConfigSchema = Configuration.Schema.withProperties(name = "Bar") { setOf(string(prop1), long(prop2), nestedObject("prop3", fooConfigSchema)) }</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val barConfigSchema = Configuration.Schema.withProperties(name = "Bar") { setOf(string(prop1), long(prop2), nestedObject("prop3", fooConfigSchema).list()) }</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val configuration = configObject(prop1 to prop1Value, prop2 to prop2Value, prop3 to prop3Value, "prop4" to "value4").toConfig()</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val fooConfigSchema = Configuration.Schema.withProperties(name = "Foo") { setOf(boolean("prop4"), double("prop5")) }</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val fooConfigSchema = Configuration.Schema.withProperties(name = "Foo") { setOf(boolean("prop4"), string("prop5", sensitive = true)) }</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val prop3Value = ConfigValueFactory.fromIterable(listOf(configObject(prop4 to prop4Value, prop5 to prop5Value), configObject(prop4 to prop4Value, prop5 to prop5Value)))</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val strictErrors = barConfigSchema.validate(configuration, Configuration.Validation.Options(strict = true)).errors</ID>
    <ID>MaxLineLength:SearchField.kt$SearchField&lt;T&gt; : UIComponent</ID>
    <ID>MaxLineLength:SecureArtemisConfiguration.kt$SecureArtemisConfiguration${ // Artemis allows multiple servers to be grouped together into a cluster for load balancing purposes. The cluster // user is used for connecting the nodes together. It has super-user privileges and so it's imperative that its // password be changed from the default (as warned in the docs). Since we don't need this feature we turn it off // by having its password be an unknown securely random 128-bit value. clusterPassword = BigInteger(128, newSecureRandom()).toString(16) }</ID>
    <ID>MaxLineLength:SecureHash.kt$SecureHash.Companion$ @JvmStatic fun parse(str: String?): SHA256</ID>
    <ID>MaxLineLength:SecureHash.kt$SecureHash.Companion$else -&gt; throw IllegalArgumentException("Provided string is ${it.size} bytes not 32 bytes in hex: $str")</ID>
    <ID>MaxLineLength:SelfIssueTest.kt$diffString += "${node.propertyPath}: simulated[${node.canonicalGet(previousState.vaultsSelfIssued)}], actual[${node.canonicalGet(selfIssueVaults)}]\n"</ID>
    <ID>MaxLineLength:SellerFlow.kt$SellerFlow$serviceHub.vaultService.queryBy(CommercialPaper.State::class.java) .states</ID>
    <ID>MaxLineLength:SellerFlow.kt$SellerFlow.Companion$SELF_ISSUING : Step</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow$@Suspendable protected open</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow$getInputTransactions(serviceHub.validatedTransactions.getTransaction(stateAndRef.ref.txhash)!!) + stateAndRef.ref.txhash</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow$is NotarisationPayload -&gt; TransactionAuthorisationFilter().addAuthorised(getInputTransactions(payload.signedTransaction))</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow${ // The first payload will be the transaction data, subsequent payload will be the transaction/attachment/network parameters data. var payload = payload // Depending on who called this flow, the type of the initial payload is different. // The authorisation logic is to maintain a dynamic list of transactions that the caller is authorised to make based on the transactions that were made already. // Each time an authorised transaction is requested, the input transactions are added to the list. // Once a transaction has been requested, it will be removed from the authorised list. This means that it is a protocol violation to request a transaction twice. val authorisedTransactions = when (payload) { is NotarisationPayload -&gt; TransactionAuthorisationFilter().addAuthorised(getInputTransactions(payload.signedTransaction)) is SignedTransaction -&gt; TransactionAuthorisationFilter().addAuthorised(getInputTransactions(payload)) is RetrieveAnyTransactionPayload -&gt; TransactionAuthorisationFilter(acceptAll = true) is List&lt;*&gt; -&gt; TransactionAuthorisationFilter().addAuthorised(payload.flatMap { stateAndRef -&gt; if (stateAndRef is StateAndRef&lt;*&gt;) { getInputTransactions(serviceHub.validatedTransactions.getTransaction(stateAndRef.ref.txhash)!!) + stateAndRef.ref.txhash } else { throw Exception("Unknown payload type: ${stateAndRef!!::class.java} ?") } }.toSet()) else -&gt; throw Exception("Unknown payload type: ${payload::class.java} ?") } // This loop will receive [FetchDataFlow.Request] continuously until the `otherSideSession` has all the data they need // to resolve the transaction, a [FetchDataFlow.EndRequest] will be sent from the `otherSideSession` to indicate end of // data request. while (true) { val dataRequest = sendPayloadAndReceiveDataRequest(otherSideSession, payload).unwrap { request -&gt; when (request) { is FetchDataFlow.Request.Data -&gt; { // Security TODO: Check for abnormally large or malformed data requests verifyDataRequest(request) request } FetchDataFlow.Request.End -&gt; return null } } payload = when (dataRequest.dataType) { FetchDataFlow.DataType.TRANSACTION -&gt; dataRequest.hashes.map { txId -&gt; if (!authorisedTransactions.isAuthorised(txId)) { throw FetchDataFlow.IllegalTransactionRequest(txId) } val tx = serviceHub.validatedTransactions.getTransaction(txId) ?: throw FetchDataFlow.HashNotFound(txId) authorisedTransactions.removeAuthorised(tx.id) authorisedTransactions.addAuthorised(getInputTransactions(tx)) tx } FetchDataFlow.DataType.ATTACHMENT -&gt; dataRequest.hashes.map { serviceHub.attachments.openAttachment(it)?.open()?.readFully() ?: throw FetchDataFlow.HashNotFound(it) } FetchDataFlow.DataType.PARAMETERS -&gt; dataRequest.hashes.map { (serviceHub.networkParametersService as NetworkParametersStorage).lookupSigned(it) ?: throw FetchDataFlow.MissingNetworkParameters(it) } } } }</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$SendStateAndRefFlow : DataVendingFlow</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$SendStateAndRefFlow$open</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$SendTransactionFlow : DataVendingFlow</ID>
    <ID>MaxLineLength:SerDeserCarpentryTest.kt$SerDeserCarpentryTest$val data = readTestResource().deserialize&lt;AInterface&gt;(context = SerializationFactory.defaultFactory.defaultContext.withLenientCarpenter())</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationContext$ fun withPreferredSerializationVersion(magic: SerializationMagic): SerializationContext</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationContext$/** * A whitelist that determines (mostly for security purposes) whether a particular encoding may be used when deserializing. */ val encodingWhitelist: EncodingWhitelist</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationContext$/** * If true the carpenter will happily synthesis classes that implement interfaces containing methods that are not * getters for any AMQP fields. Invoking these methods will throw an [AbstractMethodError]. If false then an exception * will be thrown during deserialization instead. * * The default is false. */ val lenientCarpenterEnabled: Boolean</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationContext$/** * If true the serialization evolver will fail if the binary to be deserialized contains more fields then the current object from * the classpath. * * The default is false. */ val preventDataLoss: Boolean</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory$ abstract fun &lt;T : Any&gt; serialize(obj: T, context: SerializationContext): SerializedBytes&lt;T&gt;</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory$ fun &lt;T&gt; asCurrent(block: SerializationFactory.() -&gt; T): T</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory$/** * A context to use as a default if you do not require a specially configured context. It will be the current context * if the use is somehow nested (see [currentContext]). */ val defaultContext: SerializationContext get() = currentContext ?: effectiveSerializationEnv.p2pContext</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory$/** * If there is a need to nest serialization/deserialization with a modified context during serialization or deserialization, * this will return the current context used to start serialization/deserialization. */ val currentContext: SerializationContext? get() = _currentContext.get()</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory.Companion$/** * A default factory for serialization/deserialization, taking into account the [currentFactory] if set. */ val defaultFactory: SerializationFactory get() = currentFactory ?: effectiveSerializationEnv.serializationFactory</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory.Companion$/** * If there is a need to nest serialization/deserialization with a modified context during serialization or deserialization, * this will return the current factory used to start serialization/deserialization. */ val currentFactory: SerializationFactory? get() = _currentFactory.get()</ID>
    <ID>MaxLineLength:SerializationAnnotations.kt$CordaSerializable</ID>
    <ID>MaxLineLength:SerializationCompatibilityTests.kt$SerializationCompatibilityTests$assertThat(factory.get(Exception::class.java).typeDescriptor.toString()).isEqualTo("net.corda:ApZ2a/36VVskaoDZMbiZ8A==")</ID>
    <ID>MaxLineLength:SerializationEnvironment.kt$"Expected exactly 1 of {${serializationEnvFields.joinToString(", ") { it.name }}} but got: {${it.joinToString(", ") { it.first }}}"</ID>
    <ID>MaxLineLength:SerializationEnvironment.kt$(e.className == "java.util.concurrent.ForkJoinPool\$DefaultForkJoinWorkerThreadFactory" &amp;&amp; e.methodName == "newThread")</ID>
    <ID>MaxLineLength:SerializationEnvironment.kt$private val serializationEnvFields = listOf(_nodeSerializationEnv, _driverSerializationEnv, _contextSerializationEnv, _inheritableContextSerializationEnv)</ID>
    <ID>MaxLineLength:SerializationEnvironment.kt$val _inheritableContextSerializationEnv = InheritableThreadLocalToggleField&lt;SerializationEnvironment&gt;("inheritableContextSerializationEnv") { stack -&gt; stack.fold(false) { isAGlobalThreadBeingCreated, e -&gt; isAGlobalThreadBeingCreated || (e.className == "io.netty.util.concurrent.GlobalEventExecutor" &amp;&amp; e.methodName == "startThread") || (e.className == "java.util.concurrent.ForkJoinPool\$DefaultForkJoinWorkerThreadFactory" &amp;&amp; e.methodName == "newThread") } }</ID>
    <ID>MaxLineLength:SerializationEnvironmentRule.kt$SerializationEnvironmentRule.Companion$Executors.newCachedThreadPool(testThreadFactory(true)) // Close enough to what InVMConnector makes normally.</ID>
    <ID>MaxLineLength:SerializationEnvironmentRule.kt$SerializationEnvironmentRule.Companion$InVMConnector::class.staticField&lt;ExecutorService&gt;("threadPoolExecutor").value</ID>
    <ID>MaxLineLength:SerializationFactory.kt$SerializationFactory$ abstract fun &lt;T : Any&gt; serialize(obj: T, context: SerializationContext): SerializedBytes&lt;T&gt;</ID>
    <ID>MaxLineLength:SerializationFactory.kt$SerializationFactory$ fun &lt;T&gt; asCurrent(block: SerializationFactory.() -&gt; T): T</ID>
    <ID>MaxLineLength:SerializationFactory.kt$SerializationFactory$/** * A context to use as a default if you do not require a specially configured context. It will be the current context * if the use is somehow nested (see [currentContext]). */ val defaultContext: SerializationContext get() = currentContext ?: effectiveSerializationEnv.p2pContext</ID>
    <ID>MaxLineLength:SerializationFactory.kt$SerializationFactory$/** * If there is a need to nest serialization/deserialization with a modified context during serialization or deserialization, * this will return the current context used to start serialization/deserialization. */ val currentContext: SerializationContext? get() = _currentContext</ID>
    <ID>MaxLineLength:SerializationFactory.kt$SerializationFactory.Companion$/** * A default factory for serialization/deserialization, taking into account the [currentFactory] if set. */ val defaultFactory: SerializationFactory get() = currentFactory ?: effectiveSerializationEnv.serializationFactory</ID>
    <ID>MaxLineLength:SerializationFactory.kt$SerializationFactory.Companion$/** * If there is a need to nest serialization/deserialization with a modified context during serialization or deserialization, * this will return the current factory used to start serialization/deserialization. */ val currentFactory: SerializationFactory? get() = _currentFactory</ID>
    <ID>MaxLineLength:SerializationFormat.kt$FlushAverseOutputStream : OutputStream</ID>
    <ID>MaxLineLength:SerializationFormat.kt$SectionId$DATA_AND_STOP</ID>
    <ID>MaxLineLength:SerializationFormat.kt$SectionId$ENCODING</ID>
    <ID>MaxLineLength:SerializationHelper.kt$CommonPropertyNames</ID>
    <ID>MaxLineLength:SerializationOutput.kt$SerializationOutput$ @Throws(NotSerializableException::class) fun &lt;T : Any&gt; serialize(obj: T, context: SerializationContext): SerializedBytes&lt;T&gt;</ID>
    <ID>MaxLineLength:SerializationOutput.kt$SerializationOutput$writeObject(obj, data, if (type == TypeIdentifier.UnknownType.getLocalType()) obj.javaClass else type, context, debugIndent)</ID>
    <ID>MaxLineLength:SerializationOutput.kt$SerializationOutput${ serializer.writeObject(obj, data, type, this, context, debugIndent) // Important to do it after serialization such that dependent object will have preceding reference numbers // assigned to them first as they will be first read from the stream on receiving end. // Skip for primitive types as they are too small and overhead of referencing them will be much higher than their content if (suitableForObjectReference(obj.javaClass)) { objectHistory[obj] = objectHistory.size } }</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$assertArrayEquals(data, DeserializationInput(factory).deserialize(compressed, testSerializationContext.withEncodingWhitelist(encodingWhitelist)))</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$assertThat(des.deserialize(OpaqueBytes(copy), NonZeroByte::class.java, testSerializationContext.withEncodingWhitelist(encodingWhitelist)).value).isEqualTo(3)</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$catchThrowable { input.deserialize(compressed, testSerializationContext.withEncodingWhitelist(encodingWhitelist)) }</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$des.deserialize(OpaqueBytes(copy), NonZeroByte::class.java, testSerializationContext.withEncodingWhitelist(encodingWhitelist))</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$return SerializationFactory.defaultFactory.asCurrent { withCurrentContext(newContext) { serdes(t, factory, factory2, expectedEqual) } }</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$t.suppressed.zip(desThrowable.suppressed).forEach { (before, after) -&gt; assertSerializedThrowableEquivalent(before, after) }</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$val crlHolder = builder.build(ContentSignerBuilder.build(Crypto.RSA_SHA256, Crypto.generateKeyPair(Crypto.RSA_SHA256).private, provider))</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$val desObj2 = des2.deserialize(ser2.serialize(obj, compression), testSerializationContext.withEncodingWhitelist(encodingWhitelist))</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$val newContext = SerializationFactory.defaultFactory.defaultContext.withProperty(CommonPropertyNames.IncludeInternalInfo, true)</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$val obj = WrapFooListArray(arrayOf(listOf(Foo("Fred", 1), Foo("Ginger", 2)), listOf(Foo("Rogers", 3), Foo("Hammerstein", 4))))</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests${ val ser = SerializationOutput(SerializerFactoryBuilder.build(AllWhitelist, ClassCarpenterImpl(AllWhitelist, ClassLoader.getSystemClassLoader()) )) val obj = ByteArray(20000) val uncompressedSize = ser.serialize(obj).bytes.size val compressedSize = ser.serialize(obj, CordaSerializationEncoding.SNAPPY).bytes.size // Ordinarily this might be considered high maintenance, but we promised wire compatibility, so they'd better not change! assertEquals(20059, uncompressedSize) assertEquals(1018, compressedSize) }</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests.GenericSubclass$override fun equals(other: Any?): Boolean</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationContextImpl$override</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationContextImpl$override fun withEncodingWhitelist(encodingWhitelist: EncodingWhitelist)</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationContextImpl$override fun withPreferredSerializationVersion(magic: SerializationMagic)</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$private</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$private val registeredSchemes: MutableCollection&lt;SerializationScheme&gt; = Collections.synchronizedCollection(mutableListOf())</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$registeredSchemes.filter { it.canDeserializeVersion(magic, target) }.forEach { return@computeIfAbsent it }</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$return asCurrent { withCurrentContext(context) { schemeFor(byteSequence, context.useCase).first.deserialize(byteSequence, clazz, context) } }</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$return asCurrent { withCurrentContext(context) { schemeFor(context.preferredSerializationVersion, context.useCase).first.serialize(obj, context) } }</ID>
    <ID>MaxLineLength:SerializationToken.kt$SingletonSerializationToken$fun registerWithContext(context: SerializeAsTokenContext, toBeTokenized: SerializeAsToken)</ID>
    <ID>MaxLineLength:SerializationToken.kt$SingletonSerializationToken.Companion$fun &lt;T : SerializeAsToken&gt; singletonSerializationToken(toBeTokenized: Class&lt;T&gt;)</ID>
    <ID>MaxLineLength:SerializationToken.kt$SingletonSerializeAsToken : SerializeAsToken</ID>
    <ID>MaxLineLength:SerializationTokenTest.kt$SerializationTokenTest$context = testCheckpointSerialization.checkpointSerializationContext.withWhitelisted(SingletonSerializationToken::class.java)</ID>
    <ID>MaxLineLength:SerializationTokenTest.kt$SerializationTokenTest$private fun serializeAsTokenContext(toBeTokenized: Any)</ID>
    <ID>MaxLineLength:SerializationTokenTest.kt$SerializationTokenTest$val serializedBytes = tokenizableBefore.toToken(serializeAsTokenContext(emptyList&lt;Any&gt;())).checkpointSerialize(testContext)</ID>
    <ID>MaxLineLength:SerializationWhitelist.kt$SerializationWhitelist$/** * Optionally whitelist types for use in object serialization, as we lock down the types that can be serialized. * * For example, if you add a new [net.corda.core.contracts.ContractState] it needs to be whitelisted. You can do that * either by adding the [net.corda.core.serialization.CordaSerializable] annotation or via this method. */ val whitelist: List&lt;Class&lt;*&gt;&gt;</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$CheckpointSerializeAsTokenContextImpl : SerializeAsTokenContext</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$CheckpointSerializeAsTokenContextImpl$throw UnsupportedOperationException("Attempt to write token for lazy registered $className. All tokens should be registered during context construction.")</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$SerializeAsTokenContextImpl : SerializeAsTokenContext</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$SerializeAsTokenContextImpl$throw UnsupportedOperationException("Attempt to write token for lazy registered $className. All tokens should be registered during context construction.")</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$fun CheckpointSerializationContext.withTokenContext(serializationContext: SerializeAsTokenContext): CheckpointSerializationContext</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$fun SerializationContext.withTokenContext(serializationContext: SerializeAsTokenContext): SerializationContext</ID>
    <ID>MaxLineLength:SerializeAsTokenSerializer.kt$SerializeAsTokenSerializer$?:</ID>
    <ID>MaxLineLength:SerializerFactoryBuilder.kt$NoEvolutionSerializerFactory$override</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun addSignature(signedTransaction: SignedTransaction): SignedTransaction</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun addSignature(signedTransaction: SignedTransaction, publicKey: PublicKey): SignedTransaction</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun createSignature(filteredTransaction: FilteredTransaction): TransactionSignature</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun createSignature(filteredTransaction: FilteredTransaction, publicKey: PublicKey)</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun createSignature(signedTransaction: SignedTransaction, publicKey: PublicKey)</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun signInitialTransaction(builder: TransactionBuilder): SignedTransaction</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun signInitialTransaction(builder: TransactionBuilder, publicKey: PublicKey)</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$/** * A network map contains lists of nodes on the network along with information about their identity keys, services * they provide and host names or IP addresses where they can be connected to. The cache wraps around a map fetched * from an authoritative service, and adds easy lookup of the data stored within it. Generally it would be initialised * with a specified network map service, which it fetches data from and then subscribes to updates of. */ val networkMapCache: NetworkMapCache</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$createSignature(filteredTransaction, publicKey, SignatureMetadata(myInfo.platformVersion, Crypto.findSignatureScheme(publicKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$createSignature(signedTransaction, publicKey, SignatureMetadata(myInfo.platformVersion, Crypto.findSignatureScheme(publicKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$signInitialTransaction(builder, publicKey, SignatureMetadata(myInfo.platformVersion, Crypto.findSignatureScheme(publicKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$val stx = validatedTransactions.getTransaction(stateRef.txhash) ?: throw TransactionResolutionException(stateRef.txhash)</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServicesForResolution$ // TODO: future implementation to use a Vault state ref -&gt; contract state BLOB table and perform single query bulk load // as the existing transaction store will become encrypted at some point @Throws(TransactionResolutionException::class) fun loadStates(stateRefs: Set&lt;StateRef&gt;): Set&lt;StateAndRef&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:ServiceHub.kt$StatesToRecord$ONLY_RELEVANT</ID>
    <ID>MaxLineLength:ServiceHubCoreInternal.kt$ServiceHubCoreInternal : ServiceHub</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$ServiceHubInternal$TopologicalSort</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$ServiceHubInternal$override fun createTransactionsResolver(flow: ResolveTransactionsFlow): TransactionsResolver</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$ServiceHubInternal$txs as? Collection ?: txs.toList()</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$ServiceHubInternal.Companion$require(txs.isNotEmpty()) { "No transactions passed in for recording" } val orderedTxs = topologicalSort(txs) // Divide transactions into those seen before and those that are new to this node if ALL_VISIBLE states are being recorded. // This allows the node to re-record transactions that have previously only been seen at the ONLY_RELEVANT level. Note that // for transactions being recorded at ONLY_RELEVANT, if this transaction has been seen before its outputs should already // have been recorded at ONLY_RELEVANT, so there shouldn't be anything to re-record here. val (recordedTransactions, previouslySeenTxs) = if (statesToRecord != StatesToRecord.ALL_VISIBLE) { orderedTxs.filter(validatedTransactions::addTransaction) to emptyList() } else { orderedTxs.partition(validatedTransactions::addTransaction) } val stateMachineRunId = FlowStateMachineImpl.currentStateMachine()?.id if (stateMachineRunId != null) { recordedTransactions.forEach { stateMachineRecordedTransactionMapping.addMapping(stateMachineRunId, it.id) } } else { log.warn("Transactions recorded from outside of a state machine") } // When the user has requested StatesToRecord.ALL we may end up recording and relationally mapping states // that do not involve us and that we cannot sign for. This will break coin selection and thus a warning // is present in the documentation for this feature (see the "Observer nodes" tutorial on docs.corda.net). // // The reason for this is three-fold: // // 1) We are putting in place the observer mode feature relatively quickly to meet specific customer // launch target dates. // // 2) The right design for vaults which mix observations and relevant states isn't entirely clear yet. // // 3) If we get the design wrong it could create security problems and business confusions. // // Back in the bitcoinj days I did add support for "watching addresses" to the wallet code, which is the // Bitcoin equivalent of observer nodes: // // https://bitcoinj.github.io/working-with-the-wallet#watching-wallets // // The ability to have a wallet containing both irrelevant and relevant states complicated everything quite // dramatically, even methods as basic as the getBalance() API which required additional modes to let you // query "balance I can spend" vs "balance I am observing". In the end it might have been better to just // require the user to create an entirely separate wallet for observing with. // // In Corda we don't support a single node having multiple vaults (at the time of writing), and it's not // clear that's the right way to go: perhaps adding an "origin" column to the VAULT_STATES table is a better // solution. Then you could select subsets of states depending on where the report came from. // // The risk of doing this is that apps/developers may use 'canned SQL queries' not written by us that forget // to add a WHERE clause for the origin column. Those queries will seem to work most of the time until // they're run on an observer node and mix in irrelevant data. In the worst case this may result in // erroneous data being reported to the user, which could cause security problems. // // Because the primary use case for recording irrelevant states is observer/regulator nodes, who are unlikely // to make writes to the ledger very often or at all, we choose to punt this issue for the time being. vaultService.notifyAll(statesToRecord, recordedTransactions.map { it.coreTransaction }, previouslySeenTxs.map { it.coreTransaction })</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$ServiceHubInternal.Companion$vaultService.notifyAll(statesToRecord, recordedTransactions.map { it.coreTransaction }, previouslySeenTxs.map { it.coreTransaction })</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$ServiceHubInternal.TopologicalSort$// Note that we use a LinkedHashSet here to make the traversal deterministic (as long as the input list is). forwardGraph.computeIfAbsent(it) { LinkedHashSet() }.add(stx)</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$WritableTransactionStorage$ // TODO: Throw an exception if trying to add a transaction with fewer signatures than an existing entry. fun addTransaction(transaction: SignedTransaction): Boolean</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$WritableTransactionStorage$ fun getTransactionInternal(id: SecureHash): Pair&lt;SignedTransaction, Boolean&gt;?</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$else -&gt; throw UnsupportedOperationException("Attempting to resolve attachment for index ${stateRef.index} of a ${ctx.javaClass} transaction. This is not supported.")</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$if (attachment is ContractAttachment &amp;&amp; (forContractClassName ?: transactionState.contract) in attachment.allContracts) { return attachment }</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$override</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$return attachments.openAttachment(ctx.upgradedContractAttachmentId) ?: throw AttachmentResolutionException(stateRef.txhash)</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$return ctx.inputs.map { inner(it, transactionState.contract) }.firstOrNull() ?: throw AttachmentResolutionException(stateRef.txhash)</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$val stx = validatedTransactions.getTransaction(stateRef.txhash) ?: throw TransactionResolutionException(stateRef.txhash)</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$val transactionState = SerializedStateAndRef(resolveStateRefBinaryComponent(stateRef, this)!!, stateRef).toStateAndRef().state</ID>
    <ID>MaxLineLength:SessionMessage.kt$ErrorSessionMessage : ExistingSessionMessagePayload</ID>
    <ID>MaxLineLength:SessionRejectException.kt$SessionRejectException$NotRegistered : SessionRejectException</ID>
    <ID>MaxLineLength:SessionRejectException.kt$SessionRejectException$UnknownClass : SessionRejectException</ID>
    <ID>MaxLineLength:SetsSerializationTest.kt$net.corda.serialization.internal.SetsSerializationTest.kt</ID>
    <ID>MaxLineLength:Settings.kt$Settings$clientPane.disableProperty() .map { if (!it) FontAwesomeIconView(FontAwesomeIcon.TIMES) else FontAwesomeIconView(FontAwesomeIcon.EDIT) }</ID>
    <ID>MaxLineLength:SharedMemoryIncremental.kt$SharedMemoryIncremental$mb = backingFile.channel.map(FileChannel.MapMode.READ_WRITE, 0, 16)</ID>
    <ID>MaxLineLength:ShellCmdLineOptions.kt$ShellCmdLineOptions$description = ["The path to the directory containing CorDapp JARs, CorDapps are required when starting flows."]</ID>
    <ID>MaxLineLength:ShellCmdLineOptions.kt$ShellCmdLineOptions$description = ["The path to the shell configuration file, used instead of providing the rest of command line options."]</ID>
    <ID>MaxLineLength:ShellCmdLineOptions.kt$ShellConfigurationFile.ShellConfigFile$sshHostKeyDirectory = extensions?.sshd?.let { if (it.enabled &amp;&amp; it.hostkeypath != null) Paths.get(it.hostkeypath) else null }</ID>
    <ID>MaxLineLength:ShutdownManager.kt$ShutdownManager${ isShutdown = true val result = ArrayList(registeredShutdowns) // It is important to clear `registeredShutdowns` that has been actioned upon as more than 1 driver can be created per test. // Given that `ShutdownManager` is reachable from `ApplicationShutdownHooks`, everything that was scheduled for shutdown // during 1st driver launch will not be eligible for GC during second driver launch therefore retained in memory. registeredShutdowns.clear() result }</ID>
    <ID>MaxLineLength:SignableData.kt$SignableData</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$"The AutomaticPlaceholderConstraint of the second state should become the same HashConstraint used in other state"</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$"The constraint from the issuance transaction should be the same constraint used in the consuming transaction"</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$@Test fun `HashConstraint cannot be migrated to SignatureConstraint if a HashConstraint is specified for one state and another uses an AutomaticPlaceholderConstraint`()</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$it.proxy.startFlow(::ConsumeMessage, result!!, defaultNotaryIdentity, false, false).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$val nodeHandle = startNode(NodeParameters(rpcUsers = listOf(user), additionalCordapps = listOf(oldCordapp))).getOrThrow()</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$var result: StateAndRef&lt;MessageState&gt;? = CordaRPCClient(nodeHandle.rpcAddress).start(user.username, user.password).use { val page = it.proxy.vaultQuery(MessageState::class.java) page.states.singleOrNull() }</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$"The constraint from the issuance transaction should be the same constraint used in the consuming transaction for the first state"</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$@Test fun `auto migration from WhitelistConstraint to SignatureConstraint will only transition states that do not have a constraint specified`()</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$Assertions.assertThatExceptionOfType(CordaRuntimeException::class.java).isThrownBy { upgradeCorDappBetweenTransactions( cordapp = oldUnsignedCordapp, newCordapp = newCordapp, whiteListedCordapps = mapOf(TEST_MESSAGE_CONTRACT_PROGRAM_ID to emptyList()), systemProperties = emptyMap(), startNodesInProcess = true ) } .withMessageContaining("Selected output constraint: $WhitelistedByZoneAttachmentConstraint not satisfying")</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$Assume.assumeFalse(System.getProperty("os.name").toLowerCase().startsWith("win"))</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$it.proxy.startFlow(::ConsumeMessage, result!!, defaultNotaryIdentity, false, false).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$val nodeHandle = startNode(NodeParameters(rpcUsers = listOf(user), additionalCordapps = listOf(oldCordapp))).getOrThrow()</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$var result: StateAndRef&lt;MessageState&gt;? = CordaRPCClient(nodeHandle.rpcAddress).start(user.username, user.password).use { val page = it.proxy.vaultQuery(MessageState::class.java) page.states.singleOrNull() }</ID>
    <ID>MaxLineLength:SignatureConstraintVersioningTests.kt$SignatureConstraintVersioningTests$private</ID>
    <ID>MaxLineLength:SignatureConstraintVersioningTests.kt$SignatureConstraintVersioningTests$private val baseUnsigned = cordappWithPackages(MessageState::class.packageName, DummyMessageContract::class.packageName)</ID>
    <ID>MaxLineLength:SignatureConstraintVersioningTests.kt$SignatureConstraintVersioningTests$val user = User("mark", "dadada", setOf(startFlow&lt;CreateMessage&gt;(), startFlow&lt;ConsumeMessage&gt;(), invokeRpc("vaultQuery")))</ID>
    <ID>MaxLineLength:SignatureMetadata.kt$SignatureMetadata</ID>
    <ID>MaxLineLength:SignatureScheme.kt$SignatureScheme</ID>
    <ID>MaxLineLength:SignedNodeInfo.kt$NodeInfoAndSigned$constructor(nodeInfo: NodeInfo, signer: (PublicKey, SerializedBytes&lt;NodeInfo&gt;) -&gt; DigitalSignature) : this(nodeInfo, nodeInfo.sign(signer))</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction : TransactionWithSignatures</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ @DeleteForDJVM fun resolveNotaryChangeTransaction(services: ServiceHub)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ @DeleteForDJVM private fun verifyContractUpgradeTransaction(services: ServicesForResolution, checkSufficientSignatures: Boolean)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ @DeleteForDJVM private fun verifyNotaryChangeTransaction(services: ServiceHub, checkSufficientSignatures: Boolean)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ private fun copyWithCache(sigList: Iterable&lt;TransactionSignature&gt;): SignedTransaction</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ |If you wish to verify this transaction, please contact the originator of the transaction and install the provided missing JAR.</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$"""Transaction $ltx is incorrectly formed. Most likely it was created during version 3 of Corda when the verification logic was more lenient. |Attempted to find local dependency for class: $missingClass, but could not find one. |If you wish to verify this transaction, please contact the originator of the transaction and install the provided missing JAR. |You can install it using the RPC command: `uploadAttachment` without restarting the node. |"""</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$(services.transactionVerifierService as TransactionVerifierServiceInternal).verify(ltx, listOf(attachment)).getOrThrow()</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$/** Cache the deserialized form of the transaction. This is useful when building a transaction or collecting signatures. */ @Volatile @Transient private var cachedTransaction: CoreTransaction? = null</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$/** Returns the contained [WireTransaction], or throws if this is a notary change or contract upgrade transaction. */ val tx: WireTransaction get() = coreTransaction as WireTransaction</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$?:</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$@Throws(SignatureException::class, AttachmentResolutionException::class, TransactionResolutionException::class, TransactionVerificationException::class)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$if (e.cause is NotSerializableException &amp;&amp; e.cause.cause is ClassNotFoundException &amp;&amp; e.cause.cause!!.message != null) { verifyWithExtraDependency(e.cause.cause!!.message!!.replace(".", "/"), ltx, services, e) } else { throw e }</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$is FilteredTransaction -&gt; throw IllegalStateException("Persistence of filtered transactions is not supported.")</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$require(sigs.isNotEmpty()) { "Tried to instantiate a ${SignedTransaction::class.java.simpleName} without any signatures " }</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$throw TransactionVerificationException.TransactionNetworkParameterOrderingException(id, entry.value.first(), txNetworkParameters, params)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction${ // If that transaction was created with and after Corda 4 then just fail. // The lenient dependency verification is only supported for Corda 3 transactions. // To detect if the transaction was created before Corda 4 we check if the transaction has the NetworkParameters component group. if (this.networkParametersHash != null) { throw exception } val attachment = requireNotNull(services.attachments.internalFindTrustedAttachmentForClass(missingClass)) { """Transaction $ltx is incorrectly formed. Most likely it was created during version 3 of Corda when the verification logic was more lenient. |Attempted to find local dependency for class: $missingClass, but could not find one. |If you wish to verify this transaction, please contact the originator of the transaction and install the provided missing JAR. |You can install it using the RPC command: `uploadAttachment` without restarting the node. |""".trimMargin() } log.warn("""Detected that transaction ${this.id} does not contain all cordapp dependencies. |This may be the result of a bug in a previous version of Corda. |Attempting to verify using the additional trusted dependency: $attachment for class $missingClass. |Please check with the originator that this is a valid transaction.""".trimMargin()) (services.transactionVerifierService as TransactionVerifierServiceInternal).verify(ltx, listOf(attachment)).getOrThrow() }</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction.SignaturesMissingException$NamedByHash, SignatureException(missingSignatureMsg(missing, descriptions, id)), CordaThrowable by CordaException(missingSignatureMsg(missing, descriptions, id))</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$ @Suspendable private fun agreeValuation(portfolio: Portfolio, asOf: LocalDate, valuer: Party): PortfolioValuation</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val PVs = OGTrades.map { it.info.id.get().value to pricer.presentValue(it.product, combinedRatesProvider).toCordaCompatible() }.toMap()</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val calculatorTotal = RwamBimmNotProductClassesCalculator(fxRateProvider, Currency.EUR, IsdaConfiguration.INSTANCE)</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val imBatch = analyticsEngine.calculateMarginBatch(sensBatch, combinedRatesProvider, fxRateProvider, cordaMargin)</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val margin = BimmAnalysisUtils.computeMargin(combinedRatesProvider, normalizer, calculatorTotal, sensitivities.first, sensitivities.second)</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val portfolio = serviceHub.vaultService.queryBy&lt;IRSState&gt;(VaultQueryCriteria(stateRefs = stateRef.state.data.portfolio)).states.toPortfolio()</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val valuer = serviceHub.identityService.wellKnownPartyFromAnonymous(stateRef.state.data.valuer) ?: throw IllegalStateException("Unknown valuer party ${stateRef.state.data.valuer}")</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$notary = serviceHub.networkMapCache.notaryIdentities.first()</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$otherPartySession.sendAndReceive&lt;Ack&gt;(OfferMessage(notary, stateAndRef.state.data, existing?.ref, valuationDate))</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$val PVs = OGTrades.map { it.info.id.get().value to pricer.presentValue(it.product, combinedRatesProvider).toCordaCompatible() }.toMap()</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$val calculatorTotal = RwamBimmNotProductClassesCalculator(fxRateProvider, Currency.EUR, IsdaConfiguration.INSTANCE)</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$val imBatch = analyticsEngine.calculateMarginBatch(sensBatch, combinedRatesProvider, fxRateProvider, cordaMargin)</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$val margin = BimmAnalysisUtils.computeMargin(combinedRatesProvider, normalizer, calculatorTotal, sensitivities.first, sensitivities.second)</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$val portfolio = serviceHub.vaultService.queryBy&lt;IRSState&gt;(VaultQueryCriteria(stateRefs = state.portfolio)).states.toPortfolio()</ID>
    <ID>MaxLineLength:SimmRevaluation.kt$SimmRevaluation.Initiator$val stateAndRef = serviceHub.vaultService.queryBy&lt;PortfolioState&gt;(VaultQueryCriteria(stateRefs = listOf(curStateRef))).states.single()</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$cordappsForAllNodes = listOf(findCordapp("net.corda.vega.flows"), findCordapp("net.corda.vega.contracts"), findCordapp("net.corda.confidential")) + FINANCE_CORDAPPS</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$partyApi.postJson("${counterparty.id}/portfolio/valuations/calculate", PortfolioApi.ValuationCreationParams(valuationDate))</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$startNodesInProcess = false</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$val logConfigFile = projectRootDir / "samples" / "simm-valuation-demo" / "src" / "main" / "resources" / "log4j2.xml"</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$val nodeAApi = HttpApi.fromHostAndPort(nodeAWebServerFuture.getOrThrow().listenAddress, "api/simmvaluationdemo")</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$val nodeBApi = HttpApi.fromHostAndPort(nodeBWebServerFuture.getOrThrow().listenAddress, "api/simmvaluationdemo")</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$valuationDate</ID>
    <ID>MaxLineLength:SimpleMQClient.kt$SimpleMQClient$session = sessionFactory.createSession(username, password, false, true, true, locator.isPreAcknowledge, locator.ackBatchSize)</ID>
    <ID>MaxLineLength:SimpleNotaryService.kt$SimpleNotaryService : SinglePartyNotaryService</ID>
    <ID>MaxLineLength:SimpleNotaryService.kt$SimpleNotaryService$?:</ID>
    <ID>MaxLineLength:SimpleNotaryService.kt$SimpleNotaryService$override val uniquenessProvider = PersistentUniquenessProvider(services.clock, services.database, services.cacheFactory)</ID>
    <ID>MaxLineLength:SinglePartyNotaryService.kt$SinglePartyNotaryService$val signableData = SignableData(txId, SignatureMetadata(services.myInfo.platformVersion, Crypto.findSignatureScheme(notaryIdentityKey).schemeNumberID))</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$ #See https://docs.corda.net/head/testing.html#running-tests-in-intellij - 'Fiber classes not instrumented' for more details.</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$ override fun stop(allowedUnsuspendedFiberCount: Int)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$"""Missing the '-javaagent' JVM argument. Make sure you run the tests with the Quasar java agent attached to your JVM. #See https://docs.corda.net/head/testing.html#running-tests-in-intellij - 'Fiber classes not instrumented' for more details."""</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$CheckpointSerializeAsTokenContextImpl(tokenizableServices, CheckpointSerializationDefaults.CHECKPOINT_SERIALIZER, CheckpointSerializationDefaults.CHECKPOINT_CONTEXT, serviceHub)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$DataFeed(flows.values.map { it.fiber.logic }, changesPublisher.bufferUntilSubscribed().wrapWithDatabaseTransaction(database))</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$changesPublisher.onNext(StateMachineManager.Change.Removed(lastState.flowLogic, Try.Failure&lt;Nothing&gt;(exception)))</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$changesPublisher.onNext(StateMachineManager.Change.Removed(lastState.flowLogic, Try.Success(removalReason.flowReturnValue)))</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$check(!foundUnrestorableFibers) { "Unrestorable checkpoints were created, please check the logs for details." }</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$errorAndTerminate("Caught unrecoverable error from flow. Forcibly terminating the JVM, this might leave resources open, and most likely will.", throwable)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$is ExistingSessionMessage -&gt; onExistingSessionMessage(sessionMessage, event.deduplicationHandler, sender)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$is InitiatedFlowFactory.CorDapp -&gt; FlowInfo(initiatedFlowFactory.flowVersion, initiatedFlowFactory.appName)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$logger.debug { "Ignoring request to set time-out on timed flow $flowId to $timeoutSeconds seconds which is shorter than default of ${serviceHub.configuration.flowTimeout.timeout.seconds} seconds." }</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$logger.debug("Unable to kill a flow unknown to physical node. Might be processed by another physical node.")</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$logger.error("Unable to deserialize database checkpoint for flow $flowId. Something is very wrong. The flow will not retry.")</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$logger.error("Unable to find database checkpoint for flow $flowId. Something is very wrong. The flow will not retry.")</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private val fiberDeserializationChecker = if (serviceHub.configuration.shouldCheckCheckpoints()) FiberDeserializationChecker() else null</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$require(allowedUnsuspendedFiberCount &gt;= 0) { "allowedUnsuspendedFiberCount must be greater than or equal to zero" }</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$require(lastState.pendingDeduplicationHandlers.isEmpty()) { "Flow cannot be removed until all pending deduplications have completed" }</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$return serviceHub.getFlowFactory(initiatorFlowClass) ?: throw SessionRejectException.NotRegistered(initiatorFlowClass)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$startInitiatedFlow(flowLogic, event.deduplicationHandler, senderSession, initiatedSessionId, sessionMessage, senderCoreFlowVersion, initiatedFlowInfo)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$val externalEvents = currentState.pendingDeduplicationHandlers.map { it.externalCause } + unprocessedExternalEvents</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$val flowCorDappVersion = createSubFlowVersion(serviceHub.cordappProvider.getCordappForFlow(flowLogic), serviceHub.myInfo.platformVersion)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$val flowStart = FlowStart.Initiated(peerSession, initiatedSessionId, initiatingMessage, senderCoreFlowVersion, initiatedFlowInfo)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$val frozenFlowLogic = (flowLogic as FlowLogic&lt;*&gt;).checkpointSerialize(context = checkpointSerializationContext!!)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$val future = startFlow(event.flowLogic, event.context, ourIdentity = null, deduplicationHandler = event.deduplicationHandler)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$val timeoutDelaySeconds = timeout.seconds * Math.pow(backoffBase, min(retryCount, maxRestartCount).toDouble()).toLong()</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager${ val flowId = StateMachineRunId.createRandom() // Before we construct the state machine state by freezing the FlowLogic we need to make sure that lazy properties // have access to the fiber (and thereby the service hub) val flowStateMachineImpl = FlowStateMachineImpl(flowId, flowLogic, scheduler) val resultFuture = openFuture&lt;Any?&gt;() flowStateMachineImpl.transientValues = TransientReference(createTransientValues(flowId, resultFuture)) flowLogic.stateMachine = flowStateMachineImpl val frozenFlowLogic = (flowLogic as FlowLogic&lt;*&gt;).checkpointSerialize(context = checkpointSerializationContext!!) val flowCorDappVersion = createSubFlowVersion(serviceHub.cordappProvider.getCordappForFlow(flowLogic), serviceHub.myInfo.platformVersion) val initialCheckpoint = Checkpoint.create( invocationContext, flowStart, flowLogic.javaClass, frozenFlowLogic, ourIdentity, flowCorDappVersion, flowLogic.isEnabledTimedFlow() ).getOrThrow() val startedFuture = openFuture&lt;Unit&gt;() val initialState = StateMachineState( checkpoint = initialCheckpoint, pendingDeduplicationHandlers = deduplicationHandler?.let { listOf(it) } ?: emptyList(), isFlowResumed = false, isTransactionTracked = false, isAnyCheckpointPersisted = false, isStartIdempotent = isStartIdempotent, isRemoved = false, flowLogic = flowLogic, senderUUID = ourSenderUUID ) flowStateMachineImpl.transientState = TransientReference(initialState) mutex.locked { startedFutures[flowId] = startedFuture } totalStartedFlows.inc() addAndStartFlow(flowId, Flow(flowStateMachineImpl, resultFuture)) return startedFuture.map { flowStateMachineImpl as FlowStateMachine&lt;A&gt; } }</ID>
    <ID>MaxLineLength:SingletonSerializer.kt$SingletonSerializer : AMQPSerializer</ID>
    <ID>MaxLineLength:SingletonSerializer.kt$SingletonSerializer$internal val typeNotation: TypeNotation = RestrictedType(type.typeName, "Singleton", generateProvides(), "boolean", Descriptor(typeDescriptor), emptyList())</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; Valid&lt;MAPPED&gt;): PropertyDelegate.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl$override fun optional(): PropertyDelegate.Optional&lt;List&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl.&lt;no name provided&gt;$override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Configuration.Property.Definition.RequiredList&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$OptionalPropertyDelegateImpl$override fun withDefaultValue(defaultValue: TYPE): PropertyDelegate&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$OptionalPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$OptionalPropertyDelegateImpl.&lt;no name provided&gt;$override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Configuration.Property.Definition.Optional&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$OptionalWithDefaultPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate$operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$( key: String?, prefix: String?, enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit )</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$( key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit )</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$( schema: Configuration.Schema?, key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit )</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Optional$operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Optional&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Required$operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Required&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.RequiredList$fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; MAPPED): Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.RequiredList$override operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.RequiredList&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Single$operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Single&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Standard$fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (TYPE) -&gt; MAPPED): Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Standard$override operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Standard&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (TYPE) -&gt; Valid&lt;MAPPED&gt;): PropertyDelegate.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override fun list(): PropertyDelegate.RequiredList&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override fun optional(): PropertyDelegate.Optional&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl.&lt;no name provided&gt;$override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Configuration.Property.Definition.Standard&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$RequiredPropertyDelegateImpl$override fun optional(): PropertyDelegate.Optional&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$RequiredPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$RequiredPropertyDelegateImpl.&lt;no name provided&gt;$override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Configuration.Property.Definition.Required&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest$assertThat(result.errors.first())</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest$assertThat(rpcSettings.errors.first())</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest$val addressesValue = configObject("principal" to "${principalAddressValue.host}:${principalAddressValue.port}", "admin" to "${adminAddressValue.host}:${adminAddressValue.port}")</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest$val addressesValue = configObject("principal" to "${principalAddressValue.host}:-10", "admin" to "${adminAddressValue.host}:${adminAddressValue.port}")</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest.RpcSettingsSpec$override fun parseValid(configuration: Config)</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest.RpcSettingsSpec.AddressesSpec$override fun parseValid(configuration: Config)</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest.RpcSettingsSpec.AddressesSpec$return Address.validFromRawValue(rawValue) { error -&gt; Configuration.Validation.Error.BadValue.of(error) }</ID>
    <ID>MaxLineLength:SpringDriver.kt$SpringBootDriverDSL$ fun startSpringBootWebapp(clazz: Class&lt;*&gt;, handle: NodeHandle, checkUrl: String): CordaFuture&lt;WebserverHandle&gt;</ID>
    <ID>MaxLineLength:SpringDriver.kt$SpringBootDriverDSL$val client = OkHttpClient.Builder().connectTimeout(5, TimeUnit.SECONDS).readTimeout(10, TimeUnit.SECONDS).build()</ID>
    <ID>MaxLineLength:SpringDriver.kt$SpringBootDriverDSL$val webReadyFuture = addressMustBeBoundFuture(driverDSL.executorService, (handle as NodeHandleInternal).webAddress, process)</ID>
    <ID>MaxLineLength:SslConfiguration.kt$SslConfiguration.Companion$fun mutual(keyStore: FileBasedCertificateStoreSupplier, trustStore: FileBasedCertificateStoreSupplier): MutualSslConfiguration</ID>
    <ID>MaxLineLength:StabilityTest.kt$StabilityTest$SelfIssueCommand(IssueAndPaymentRequest(Amount(100000, USD), OpaqueBytes.of(0), issuer.mainIdentity, notaryIdentity, anonymous = true), issuer)</ID>
    <ID>MaxLineLength:StabilityTest.kt$StabilityTest$is IssueAndPaymentRequest -&gt; command.node.proxy.startFlow(::CashIssueAndPaymentFlow, request).returnValue</ID>
    <ID>MaxLineLength:StabilityTest.kt$StabilityTest$simpleNodes.flatMap { payer -&gt; simpleNodes.map { payer to it } } .filter { it.first != it.second } .map { (payer, payee) -&gt; CrossCashCommand(PaymentRequest(Amount(1, USD), payee.mainIdentity, anonymous = true), payer) }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$ fun dropSessionInit(id: UUID): Boolean</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$"the UUID $id (from the node shell you can run 'flow kill $id'). BE VERY CAUTIOUS OF THIS SECOND APPROACH AS THE "</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$flowMessaging.sendSessionMessage(sender, replyError, SenderDeduplicationId(DeduplicationId.createRandom(secureRandom), ourSenderUUID))</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$log</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$log.info("Flow error discharged from hospital (delay ${backOff.seconds}s) by ${report.by} (error was ${report.error.message})")</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$log.info("Flow error kept for overnight observation by ${report.by} (error was ${report.error.message})")</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$val diagnoses: Map&lt;Diagnosis, List&lt;Staff&gt;&gt; = staff.groupBy { it.consult(flowFiber, currentState, error, medicalHistory) }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$val record = MedicalRecord.Flow(time, flowFiber.id, currentState.checkpoint.numberOfSuspends, errors, report.by, outcome)</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$val record = sessionMessage.run { MedicalRecord.SessionInit(id, time, outcome, initiatorFlowClassName, flowVersion, appName, sender, error) }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$val snapshot = (flowPatients.values.flatMap { it.records } + treatableSessionInits.values.map { it.publicRecord }).sortedBy { it.time }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital${ log.info("Flow error kept for overnight observation by ${report.by} (error was ${report.error.message})") // We don't schedule a next event for the flow - it will automatically retry from its checkpoint on node restart Triple(Outcome.OVERNIGHT_OBSERVATION, null, 0.seconds) }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital${ private companion object { private val log = contextLogger() private val staff = listOf( DeadlockNurse, DuplicateInsertSpecialist, DoctorTimeout, FinalityDoctor, TransientConnectionCardiologist ) } private val mutex = ThreadBox(object { val flowPatients = HashMap&lt;StateMachineRunId, FlowMedicalHistory&gt;() val treatableSessionInits = HashMap&lt;UUID, InternalSessionInitRecord&gt;() val recordsPublisher = PublishSubject.create&lt;MedicalRecord&gt;() }) private val secureRandom = newSecureRandom() private val delayedDischargeTimer = Timer("FlowHospitalDelayedDischargeTimer", true) /** * The node was unable to initiate the [InitialSessionMessage] from [sender]. */ fun sessionInitErrored( sessionMessage: InitialSessionMessage, sender: Party, event: ExternalEvent.ExternalMessageEvent, error: Throwable ) { val time = Instant.now() val id = UUID.randomUUID() val outcome = if (error is SessionRejectException.UnknownClass) { // We probably don't have the CorDapp installed so let's pause the message in the hopes that the CorDapp is // installed on restart, at which point the message will be able proceed as normal. If not then it will need // to be dropped manually. Outcome.OVERNIGHT_OBSERVATION } else { Outcome.UNTREATABLE } val record = sessionMessage.run { MedicalRecord.SessionInit(id, time, outcome, initiatorFlowClassName, flowVersion, appName, sender, error) } mutex.locked { if (outcome != Outcome.UNTREATABLE) { treatableSessionInits[id] = InternalSessionInitRecord(sessionMessage, event, record) log.warn("$sender has sent a flow request for an unknown flow ${sessionMessage.initiatorFlowClassName}. Install the missing " + "CorDapp this flow belongs to and restart.") log.warn("If you know it's safe to ignore this flow request then it can be deleted permanently using the killFlow RPC and " + "the UUID $id (from the node shell you can run 'flow kill $id'). BE VERY CAUTIOUS OF THIS SECOND APPROACH AS THE " + "REQUEST MAY CONTAIN A NOTARISED TRANSACTION THAT NEEDS TO BE RECORDED IN YOUR VAULT.") } recordsPublisher.onNext(record) } if (outcome == Outcome.UNTREATABLE) { sendBackError(error, sessionMessage, sender, event) } } private fun sendBackError( error: Throwable, sessionMessage: InitialSessionMessage, sender: Party, event: ExternalEvent.ExternalMessageEvent ) { val message = (error as? SessionRejectException)?.message ?: "Unable to establish session" val payload = RejectSessionMessage(message, secureRandom.nextLong()) val replyError = ExistingSessionMessage(sessionMessage.initiatorSessionId, payload) flowMessaging.sendSessionMessage(sender, replyError, SenderDeduplicationId(DeduplicationId.createRandom(secureRandom), ourSenderUUID)) event.deduplicationHandler.afterDatabaseTransaction() } /** * Drop the errored session-init message with the given ID ([MedicalRecord.SessionInit.id]). This will cause the node * to send back the relevant session error to the initiator party and acknowledge its receipt from the message broker * so that it never gets redelivered. */ fun dropSessionInit(id: UUID): Boolean { val (sessionMessage, event, publicRecord) = mutex.locked { treatableSessionInits.remove(id) ?: return false } log.info("Errored session-init permanently dropped: $publicRecord") sendBackError(publicRecord.error, sessionMessage, publicRecord.sender, event) return true } /** * The flow running in [flowFiber] has errored. */ fun flowErrored(flowFiber: FlowFiber, currentState: StateMachineState, errors: List&lt;Throwable&gt;) { val time = Instant.now() log.info("Flow ${flowFiber.id} admitted to hospital in state $currentState") val (event, backOffForChronicCondition) = mutex.locked { val medicalHistory = flowPatients.computeIfAbsent(flowFiber.id) { FlowMedicalHistory() } val report = consultStaff(flowFiber, currentState, errors, medicalHistory) val (outcome, event, backOffForChronicCondition) = when (report.diagnosis) { Diagnosis.DISCHARGE -&gt; { val backOff = calculateBackOffForChronicCondition(report, medicalHistory, currentState) log.info("Flow error discharged from hospital (delay ${backOff.seconds}s) by ${report.by} (error was ${report.error.message})") Triple(Outcome.DISCHARGE, Event.RetryFlowFromSafePoint, backOff) } Diagnosis.OVERNIGHT_OBSERVATION -&gt; { log.info("Flow error kept for overnight observation by ${report.by} (error was ${report.error.message})") // We don't schedule a next event for the flow - it will automatically retry from its checkpoint on node restart Triple(Outcome.OVERNIGHT_OBSERVATION, null, 0.seconds) } Diagnosis.NOT_MY_SPECIALTY -&gt; { // None of the staff care for these errors so we let them propagate log.info("Flow error allowed to propagate", report.error) Triple(Outcome.UNTREATABLE, Event.StartErrorPropagation, 0.seconds) } } val record = MedicalRecord.Flow(time, flowFiber.id, currentState.checkpoint.numberOfSuspends, errors, report.by, outcome) medicalHistory.records += record recordsPublisher.onNext(record) Pair(event, backOffForChronicCondition) } if (event != null) { if (backOffForChronicCondition.isZero) { flowFiber.scheduleEvent(event) } else { delayedDischargeTimer.schedule(object : TimerTask() { override fun run() { flowFiber.scheduleEvent(event) } }, backOffForChronicCondition.toMillis()) } } } private fun calculateBackOffForChronicCondition( report: ConsultationReport, medicalHistory: FlowMedicalHistory, currentState: StateMachineState ): Duration { return report.by.firstOrNull { it is Chronic }?.let { chronicStaff -&gt; return medicalHistory.timesDischargedForTheSameThing(chronicStaff, currentState).let { if (it == 0) { 0.seconds } else { maxOf(10, (10 + (Math.random()) * (10 * 1.5.pow(it)) / 2).toInt()).seconds } } } ?: 0.seconds } private fun consultStaff( flowFiber: FlowFiber, currentState: StateMachineState, errors: List&lt;Throwable&gt;, medicalHistory: FlowMedicalHistory ): ConsultationReport { return errors .asSequence() .mapIndexed { index, error -&gt; // Rely on the logging context to print details of the flow ID. log.info("Error ${index + 1} of ${errors.size}:", error) val diagnoses: Map&lt;Diagnosis, List&lt;Staff&gt;&gt; = staff.groupBy { it.consult(flowFiber, currentState, error, medicalHistory) } // We're only interested in the highest priority diagnosis for the error val (diagnosis, by) = diagnoses.entries.minBy { it.key }!! ConsultationReport(error, diagnosis, by) } // And we're only interested in the error with the highest priority diagnosis .minBy { it.diagnosis }!! } private data class ConsultationReport(val error: Throwable, val diagnosis: Diagnosis, val by: List&lt;Staff&gt;) /** * The flow has been removed from the state machine. */ fun flowRemoved(flowId: StateMachineRunId) { mutex.locked { flowPatients.remove(flowId) } } // TODO MedicalRecord subtypes can expose the Staff class, something which we probably don't want when wiring this method to RPC /** Returns a stream of medical records as flows pass through the hospital. */ fun track(): DataFeed&lt;List&lt;MedicalRecord&gt;, MedicalRecord&gt; { return mutex.locked { val snapshot = (flowPatients.values.flatMap { it.records } + treatableSessionInits.values.map { it.publicRecord }).sortedBy { it.time } DataFeed(snapshot, recordsPublisher.bufferUntilSubscribed()) } } operator fun contains(flowId: StateMachineRunId) = mutex.locked { flowId in flowPatients } class FlowMedicalHistory { internal val records: MutableList&lt;MedicalRecord.Flow&gt; = mutableListOf() fun notDischargedForTheSameThingMoreThan(max: Int, by: Staff, currentState: StateMachineState): Boolean { return timesDischargedForTheSameThing(by, currentState) &lt;= max } fun timesDischargedForTheSameThing(by: Staff, currentState: StateMachineState): Int { val lastAdmittanceSuspendCount = currentState.checkpoint.numberOfSuspends return records.count { it.outcome == Outcome.DISCHARGE &amp;&amp; by in it.by &amp;&amp; it.suspendCount == lastAdmittanceSuspendCount } } override fun toString(): String = "${this.javaClass.simpleName}(records = $records)" } private data class InternalSessionInitRecord( val sessionMessage: InitialSessionMessage, val event: ExternalEvent.ExternalMessageEvent, val publicRecord: MedicalRecord.SessionInit ) sealed class MedicalRecord { abstract val time: Instant abstract val outcome: Outcome abstract val errors: List&lt;Throwable&gt; /** Medical record for a flow that has errored. */ data class Flow( override val time: Instant, val flowId: StateMachineRunId, val suspendCount: Int, override val errors: List&lt;Throwable&gt;, val by: List&lt;Staff&gt;, override val outcome: Outcome ) : MedicalRecord() /** Medical record for a session initiation that was unsuccessful. */ data class SessionInit( val id: UUID, override val time: Instant, override val outcome: Outcome, val initiatorFlowClassName: String, val flowVersion: Int, val appName: String, val sender: Party, val error: Throwable ) : MedicalRecord() { override val errors: List&lt;Throwable&gt; get() = listOf(error) } } enum class Outcome { DISCHARGE, OVERNIGHT_OBSERVATION, UNTREATABLE } /** The order of the enum values are in priority order. */ enum class Diagnosis { /** Retry from last safe point. */ DISCHARGE, /** Park and await intervention. */ OVERNIGHT_OBSERVATION, /** Please try another member of staff. */ NOT_MY_SPECIALTY } interface Staff { fun consult( flowFiber: FlowFiber, currentState: StateMachineState, newError: Throwable, history: FlowMedicalHistory ): Diagnosis } interface Chronic /** * SQL Deadlock detection. */ object DeadlockNurse : Staff, Chronic { override fun consult( flowFiber: FlowFiber, currentState: StateMachineState, newError: Throwable, history: FlowMedicalHistory ): Diagnosis { return if (mentionsDeadlock(newError)) { Diagnosis.DISCHARGE } else { Diagnosis.NOT_MY_SPECIALTY } } private fun mentionsDeadlock(exception: Throwable?): Boolean { return exception.mentionsThrowable(SQLException::class.java, "deadlock") } } /** * Primary key violation detection for duplicate inserts. Will detect other constraint violations too. */ object DuplicateInsertSpecialist : Staff { override fun consult( flowFiber: FlowFiber, currentState: StateMachineState, newError: Throwable, history: FlowMedicalHistory ): Diagnosis { return if (newError.mentionsThrowable(ConstraintViolationException::class.java) &amp;&amp; history.notDischargedForTheSameThingMoreThan(3, this, currentState)) { Diagnosis.DISCHARGE } else { Diagnosis.NOT_MY_SPECIALTY } } } /** * Restarts [TimedFlow], keeping track of the number of retries and making sure it does not * exceed the limit specified by the [FlowTimeoutException]. */ object DoctorTimeout : Staff { override fun consult( flowFiber: FlowFiber, currentState: StateMachineState, newError: Throwable, history: FlowMedicalHistory ): Diagnosis { if (newError is FlowTimeoutException) { return Diagnosis.DISCHARGE } return Diagnosis.NOT_MY_SPECIALTY } } object FinalityDoctor : Staff { override fun consult( flowFiber: FlowFiber, currentState: StateMachineState, newError: Throwable, history: FlowMedicalHistory ): Diagnosis { return if (currentState.flowLogic is FinalityHandler || isFromReceiveFinalityFlow(newError)) { log.warn("Flow ${flowFiber.id} failed to be finalised. Manual intervention may be required before retrying " + "the flow by re-starting the node. State machine state: $currentState", newError) Diagnosis.OVERNIGHT_OBSERVATION } else { Diagnosis.NOT_MY_SPECIALTY } } private fun isFromReceiveFinalityFlow(throwable: Throwable): Boolean { return throwable.stackTrace.any { it.className == ReceiveFinalityFlow::class.java.name } } } /** * [SQLTransientConnectionException] detection that arise from failing to connect the underlying database/datasource */ object TransientConnectionCardiologist : Staff { override fun consult( flowFiber: FlowFiber, currentState: StateMachineState, newError: Throwable, history: FlowMedicalHistory ): Diagnosis { return if (mentionsTransientConnection(newError)) { if (history.notDischargedForTheSameThingMoreThan(2, this, currentState)) { Diagnosis.DISCHARGE } else { Diagnosis.OVERNIGHT_OBSERVATION } } else { Diagnosis.NOT_MY_SPECIALTY } } private fun mentionsTransientConnection(exception: Throwable?): Boolean { return exception.mentionsThrowable(SQLTransientConnectionException::class.java, "connection is not available") } } }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.DuplicateInsertSpecialist$return if (newError.mentionsThrowable(ConstraintViolationException::class.java) &amp;&amp; history.notDischargedForTheSameThingMoreThan(3, this, currentState)) { Diagnosis.DISCHARGE } else { Diagnosis.NOT_MY_SPECIALTY }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.FinalityDoctor$log</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.FlowMedicalHistory$return records.count { it.outcome == Outcome.DISCHARGE &amp;&amp; by in it.by &amp;&amp; it.suspendCount == lastAdmittanceSuspendCount }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.TransientConnectionCardiologist$return exception.mentionsThrowable(SQLTransientConnectionException::class.java, "connection is not available")</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$private</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$return (exceptionType.isAssignableFrom(this::class.java) &amp;&amp; containsMessage) || cause.mentionsThrowable(exceptionType, errorMessage)</ID>
    <ID>MaxLineLength:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$rpcProxy.startFlow(::CashPaymentFlow, 100.POUNDS, notaryNodeIdentity, true, notaryNodeIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$val sorting = Sort(setOf(Sort.SortColumn(SortAttribute.Standard(Sort.VaultStateAttribute.RECORDED_TIME), Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:StandaloneShell.kt$StandaloneShell$Ansi.ansi().fgBrightRed().a( """ ______ __""").newline().a( """ / ____/ _________/ /___ _""").newline().a( """ / / __ / ___/ __ / __ `/ """).newline().fgBrightRed().a( """/ /___ /_/ / / / /_/ / /_/ /""").newline().fgBrightRed().a( """\____/ /_/ \__,_/\__,_/""").reset().fgBrightDefault().bold() .newline()</ID>
    <ID>MaxLineLength:StandaloneShell.kt$StandaloneShell$if (System.console() != null) System.console().readPassword(format, *args) else this.readLine(format, *args).toCharArray()</ID>
    <ID>MaxLineLength:StandaloneShell.kt$StandaloneShell$it.filter { it.isRegularFile() &amp;&amp; it.toString().endsWith(".jar") }.map { it.toUri().toURL() }.toList()</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$internal fun &lt;RESULT&gt; badValue(message: String)</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$internal fun toCordaX500Name(rawValue: String)</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$internal fun toNetworkHostAndPort(rawValue: String)</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$internal fun toPrincipal(rawValue: String)</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$internal inline fun &lt;reified RESULT, reified ERROR : Exception&gt; attempt(action: () -&gt; RESULT)</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$private fun Config.toProperties()</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$private inline</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$actions.add(Action.SendExisting(existingSessionState.peerParty, existingMessage, SenderDeduplicationId(deduplicationId, startingState.senderUUID)))</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$actions.add(Action.SendInitial(existingSessionState.destination, initialMessage, SenderDeduplicationId(deduplicationId, startingState.senderUUID)))</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$actions.add(Action.SendInitial(sessionState.destination, initialMessage, SenderDeduplicationId(deduplicationId, startingState.senderUUID)))</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$collectErroredSessionErrors(sessionIds, checkpoint) + collectEndedEmptySessionErrors(sessionIds, checkpoint)</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$newSessionMessages[sessionId] = sessionState.copy(receivedMessages = messages.subList(1, messages.size).toList())</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$private</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$return freshErrorTransition(IllegalStateException("Tried to send to ended session $sourceSessionId"))</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$val initialMessage = createInitialSessionMessage(existingSessionState.initiatingSubFlow, sourceSessionId, existingSessionState.additionalEntropy, message)</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$val initialMessage = createInitialSessionMessage(sessionState.initiatingSubFlow, sourceSessionId, sessionState.additionalEntropy, null)</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$val newBufferedMessages = existingSessionState.bufferedMessages + Pair(deduplicationId, sessionMessage)</ID>
    <ID>MaxLineLength:StateMachineManager.kt$StateMachineManager</ID>
    <ID>MaxLineLength:StateMachineManager.kt$StateMachineManager$ fun deliverExternalEvent(event: ExternalEvent)</ID>
    <ID>MaxLineLength:StateMachineManager.kt$StateMachineManager$ fun killFlow(id: StateMachineRunId): Boolean</ID>
    <ID>MaxLineLength:StateMachineManagerUtils.kt$ // TODO: instead of replacing the progress tracker after constructing the flow logic, we should inject it during fiber deserialization fun StateMachineManagerInternal.injectOldProgressTracker(oldTracker: ProgressTracker?, newFlowLogic: FlowLogic&lt;*&gt;)</ID>
    <ID>MaxLineLength:StateMachineState.kt$StateMachineState</ID>
    <ID>MaxLineLength:StateMachineState.kt$SubFlowVersion$CorDappFlow : SubFlowVersion</ID>
    <ID>MaxLineLength:StatePointer.kt$LinearPointer$// Here either one of two things has happened: // 1. The pointed-to state has not been seen by the resolver node. It is unlikely that this is the case. // The state can probably be obtained via subscribing to the data distribution group which created and // and maintains this data. // 2. Uh oh... The pointed-to state has been exited from the ledger! // It is unlikely this would ever happen as most reference data states will be created such that they cannot // be exited from the ledger. At this point there are two options; use an old consumed version of the state, // or don't use it at all. "The LinearState with ID ${pointer.id} is unknown to this node or it has been exited from the ledger."</ID>
    <ID>MaxLineLength:StatePointer.kt$LinearPointer&lt;T : LinearState&gt; : StatePointer</ID>
    <ID>MaxLineLength:StatePointer.kt$StaticPointer&lt;T : ContractState&gt; : StatePointer</ID>
    <ID>MaxLineLength:StateRevisionFlow.kt$StateRevisionFlow.Receiver$open</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun &lt;P : Any&gt; Iterable&lt;ContractState&gt;.sumObligations(): Amount&lt;Issued&lt;Obligation.Terms&lt;P&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun &lt;P : Any&gt; Iterable&lt;ContractState&gt;.sumObligationsOrNull(): Amount&lt;Issued&lt;Obligation.Terms&lt;P&gt;&gt;&gt;?</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun &lt;P : Any&gt; Iterable&lt;ContractState&gt;.sumObligationsOrZero(issuanceDef: Issued&lt;Obligation.Terms&lt;P&gt;&gt;): Amount&lt;Issued&lt;Obligation.Terms&lt;P&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun Iterable&lt;ContractState&gt;.sumCash(): Amount&lt;Issued&lt;Currency&gt;&gt;</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun Iterable&lt;ContractState&gt;.sumCashBy(owner: AbstractParty): Amount&lt;Issued&lt;Currency&gt;&gt;</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun Iterable&lt;ContractState&gt;.sumCashOrNull(): Amount&lt;Issued&lt;Currency&gt;&gt;?</ID>
    <ID>MaxLineLength:StaticInitialisationOfSerializedObjectTest.kt$StaticInitialisationOfSerializedObjectTest$val url = EvolvabilityTests::class.java.getResource("StaticInitialisationOfSerializedObjectTest.deserializeTest")</ID>
    <ID>MaxLineLength:StaticInitialisationOfSerializedObjectTest.kt$StaticInitialisationOfSerializedObjectTest$val url = EvolvabilityTests::class.java.getResource("StaticInitialisationOfSerializedObjectTest.deserializeTest2")</ID>
    <ID>MaxLineLength:StatusTransitions.kt$StatusTransitions$?:</ID>
    <ID>MaxLineLength:StatusTransitions.kt$StatusTransitions$if (options.isEmpty()) throw IllegalStateException("Transition [$input -(${command.javaClass.simpleName})-&gt; $output] not allowed")</ID>
    <ID>MaxLineLength:StatusTransitions.kt$StatusTransitions$require(relevantCmds.isNotEmpty()) { "Transaction must have at least one Command relevant to its defined transitions" }</ID>
    <ID>MaxLineLength:StatusTransitions.kt$StatusTransitions${ // which state determines who is the signer? by default the input, unless it's the initial transition val state = (inp ?: outp)!! val signerParty = state.roleToParty(signer) if (!cmd.signers.contains(signerParty.owningKey)) throw IllegalStateException("Command ${cmd.value.javaClass} must be signed by $signer") }</ID>
    <ID>MaxLineLength:StatusTransitions.kt$StatusTransitions&lt;out S, in R, T : StatusTrackingContractState&lt;S, R&gt;&gt;</ID>
    <ID>MaxLineLength:StatusTransitions.kt$TransitionDef&lt;out S, out R&gt;</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser$/** A map of method name to parameter names for the target type. */ val methodParamNames: Map&lt;String, List&lt;String&gt;&gt; = targetType.declaredMethods.filterNot(Method::isSynthetic).mapNotNull { try { it.name to paramNamesFromMethod(it) } catch (e: KotlinReflectionInternalError) { // Kotlin reflection doesn't support every method that can exist on an object (in particular, reified // inline methods) so we just ignore those here. null } }.toMap()</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser$kf != null -&gt; kf.parameters[index + 1].name ?: throw UnparseableCallException.ReflectionDataMissing(method.name, index)</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser$kf != null -&gt; kf.parameters[index].name ?: throw UnparseableCallException.ReflectionDataMissing("&lt;init&gt;", index)</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser$private</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser$when { param.isNamePresent -&gt; param.name // index + 1 because the first Kotlin reflection param is 'this', but that doesn't match Java reflection. kf != null -&gt; kf.parameters[index + 1].name ?: throw UnparseableCallException.ReflectionDataMissing(method.name, index) else -&gt; throw UnparseableCallException.ReflectionDataMissing(method.name, index) }</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser.Companion$for ((key, value) in clazz.methods.filterNot { it.isSynthetic &amp;&amp; it.name !in ignoredNames }.map { it.name to it }) { result.put(key, value) }</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser.UnparseableCallException$MissingParameter : UnparseableCallException</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser.UnparseableCallException$ReflectionDataMissing : UnparseableCallException</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser.UnparseableCallException$TooManyParameters : UnparseableCallException</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser.UnparseableCallException$open</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser&lt;in T : Any&gt;</ID>
    <ID>MaxLineLength:StringToMethodCallParserTest.kt$StringToMethodCallParserTest$"twoStrings a: Some words, b: ' and some words, like, Kirk, would, speak'" to "Some words and some words, like, Kirk, would, speak"</ID>
    <ID>MaxLineLength:StringToMethodCallParserTest.kt$StringToMethodCallParserTest$val args: Array&lt;Any?&gt; = parser.parseArguments(clazz.name, names.zip(ctor.parameterTypes), "alternativeWord: Foo bar!")</ID>
    <ID>MaxLineLength:StringToMethodCallParserTest.kt$StringToMethodCallParserTest$val args: Array&lt;Any?&gt; = parser.parseArguments(clazz.name, names.zip(ctor.parameterTypes), "someWord: Blah blah blah, aDifferentThing: 12")</ID>
    <ID>MaxLineLength:Structures.kt$Command$private fun commandDataToString()</ID>
    <ID>MaxLineLength:Structures.kt$CommandWithParties$@Deprecated("Should not be used in contract verification code as it is non-deterministic, will be disabled for some future target platform version onwards and will take effect only for CorDapps targeting those versions.")</ID>
    <ID>MaxLineLength:Structures.kt$Contract</ID>
    <ID>MaxLineLength:Structures.kt$Issued$require(issuer.reference.size &lt;= MAX_ISSUER_REF_SIZE) { "Maximum issuer reference size is $MAX_ISSUER_REF_SIZE." }</ID>
    <ID>MaxLineLength:Structures.kt$OwnableState$ fun withNewOwner(newOwner: AbstractParty): CommandAndState</ID>
    <ID>MaxLineLength:Structures.kt$PrivacySalt : OpaqueBytes</ID>
    <ID>MaxLineLength:Structures.kt$SchedulableState$ @DeleteForDJVM fun nextScheduledActivity(thisStateRef: StateRef, flowLogicRefFactory: FlowLogicRefFactory): ScheduledActivity?</ID>
    <ID>MaxLineLength:Structures.kt$UpgradedContract&lt;in OldState : ContractState, out NewState : ContractState&gt; : Contract</ID>
    <ID>MaxLineLength:Structures.kt$UpgradedContractWithLegacyConstraint&lt;in OldState : ContractState, out NewState : ContractState&gt; : UpgradedContract</ID>
    <ID>MaxLineLength:Structures.kt$return mapNotNull { if (it.state.data is T) StateAndRef(TransactionState(it.state.data, it.state.contract, it.state.notary), it.ref) else null }</ID>
    <ID>MaxLineLength:SubFlow.kt$SubFlow.Companion$Try.Success(Initiating(flowClass, initiatingAnnotation.first, flowContext, subFlowVersion, isEnabledTimedFlow))</ID>
    <ID>MaxLineLength:SubFlow.kt$SubFlow.Companion$fun create(flowClass: Class&lt;FlowLogic&lt;*&gt;&gt;, subFlowVersion: SubFlowVersion, isEnabledTimedFlow: Boolean): Try&lt;SubFlow&gt;</ID>
    <ID>MaxLineLength:SubFlow.kt$SubFlow.Companion$private</ID>
    <ID>MaxLineLength:SupportedTransforms.kt$SupportedTransform</ID>
    <ID>MaxLineLength:SwapData.kt$SwapData$return getSwapConvention(convention).createTrade(startDate, Tenor.TENOR_4Y, buySell, notional.toDouble(), fixedRate.toDouble(), ReferenceData.standard()) .toBuilder() .info(tradeInfo) .build()</ID>
    <ID>MaxLineLength:SwapDataModel.kt$SwapDataModel$Pair("swap", id)</ID>
    <ID>MaxLineLength:SwapExample.kt$SwapExample$val resolvedTrades = trades.stream().map({ trade -&gt; trade.resolve(ReferenceData.standard()) }).collect(toList&lt;ResolvedSwapTrade&gt;())</ID>
    <ID>MaxLineLength:SwapExample.kt$SwapExample$val resolvedTrades = trades1.stream().map({ trade -&gt; trade.resolve(ReferenceData.standard()) }).collect(toList&lt;ResolvedSwapTrade&gt;())</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesException : FlowException</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow : FlowLogic</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$@Deprecated("It is unsafe to use this constructor as it requires nodes to automatically vend anonymous identities without first " + "checking if they should. Instead, use the constructor that takes in an existing FlowSession.")</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$@Deprecated("It is unsafe to use this constructor as it requires nodes to automatically vend anonymous identities without first " + "checking if they should. Instead, use the constructor that takes in an existing FlowSession.") constructor(otherParty: Party, revocationEnabled: Boolean, progressTracker: ProgressTracker) : this(null, otherParty, progressTracker)</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$@JvmOverloads constructor(otherSideSession: FlowSession, progressTracker: ProgressTracker = tracker()) : this(otherSideSession, null, progressTracker)</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$logger</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$val theirAnonymousIdentity = session.sendAndReceive&lt;IdentityWithSignature&gt;(ourIdentWithSig).unwrap { theirIdentWithSig -&gt; progressTracker.currentStep = VERIFYING_IDENTITY validateAndRegisterIdentity(serviceHub, session.counterparty, theirIdentWithSig.identity.deserialize(), theirIdentWithSig.signature) }</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$validateAndRegisterIdentity(serviceHub, session.counterparty, theirIdentWithSig.identity.deserialize(), theirIdentWithSig.signature)</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion$@JvmStatic fun tracker(): ProgressTracker</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion${ if (theirAnonymousIdentity.name != otherSide.name) { throw SwapIdentitiesException("Certificate subject must match counterparty's well known identity.") } try { theirAnonymousIdentity.owningKey.verify(buildDataToSign(theirAnonymousIdentity), signature) } catch (ex: SignatureException) { throw SwapIdentitiesException("Signature does not match the expected identity ownership assertion.", ex) } // Validate then store their identity so that we can prove the key in the transaction is owned by the counterparty. serviceHub.identityService.verifyAndRegisterIdentity(theirAnonymousIdentity) return theirAnonymousIdentity }</ID>
    <ID>MaxLineLength:SwapIdentitiesFlowTests.kt$SwapIdentitiesFlowTests$private</ID>
    <ID>MaxLineLength:SwapIdentitiesFlowTests.kt$SwapIdentitiesFlowTests.&lt;no name provided&gt;$ is resolved by </ID>
    <ID>MaxLineLength:SwapIdentitiesFlowTests.kt$SwapIdentitiesFlowTests.HoldsOwningKeyMatcher$private data</ID>
    <ID>MaxLineLength:SwapIdentitiesHandler.kt$SwapIdentitiesHandler : FlowLogic</ID>
    <ID>MaxLineLength:SwapIdentitiesHandler.kt$SwapIdentitiesHandler$logger.warnOnce("Insecure API to swap anonymous identities was used by ${otherSide.counterparty} (${otherSide.getCounterpartyFlowInfo()})")</ID>
    <ID>MaxLineLength:Swaption.kt$Swaption$val floating = interest(notional, "act/365", fix("LIBOR", start, Tenor("3M")), start, end)</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$arrayOf("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$arrayOf("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256")</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$clientParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$private</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$serverParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$serverParams.needClientAuth = true</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$testConnect(serverSocket, clientSocket, "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$testConnect(serverSocket, clientSocket, "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$val serverSocket = serverSocketFactory.createServerSocket(serverPort) as SSLServerSocket // use 0 to get first free socket.</ID>
    <ID>MaxLineLength:TenorDateParameterMetadataSerializer.kt$TenorDateParameterMetadataSerializer$override fun fromProxy(proxy: Proxy): TenorDateParameterMetadata</ID>
    <ID>MaxLineLength:TestClock.kt$TestClock$ @Synchronized fun setTo(newInstant: Instant)</ID>
    <ID>MaxLineLength:TestCommonUtils.kt$inline fun &lt;reified TYPE : Throwable&gt; AbstractThrowableAssert&lt;*, *&gt;.isInstanceOf(): AbstractThrowableAssert&lt;*, *&gt;</ID>
    <ID>MaxLineLength:TestCommsFlow.kt$TestCommsFlowInitiator$tx.addOutputState(CommsTestState(responses, serviceHub.myInfo.legalIdentities.first()), CommsTestContract::class.java.name)</ID>
    <ID>MaxLineLength:TestConstants.kt$ fun dummyCommand(vararg signers: PublicKey = arrayOf(generateKeyPair().public))</ID>
    <ID>MaxLineLength:TestCordapp.kt$TestCordapp</ID>
    <ID>MaxLineLength:TestCordapp.kt$TestCordapp.Companion$ @JvmStatic fun findCordapp(scanPackage: String): TestCordapp</ID>
    <ID>MaxLineLength:TestCordappImpl.kt$TestCordappImpl : TestCordappInternal</ID>
    <ID>MaxLineLength:TestCordappImpl.kt$TestCordappImpl$0</ID>
    <ID>MaxLineLength:TestCordappImpl.kt$TestCordappImpl$else -&gt; throw IllegalArgumentException("There is more than one CorDapp containing the package $scanPackage on the classpath " + "$jars. Specify a package name which is unique to the CorDapp.")</ID>
    <ID>MaxLineLength:TestCordappInternal.kt$TestCordappInternal : TestCordapp</ID>
    <ID>MaxLineLength:TestCordappInternal.kt$TestCordappInternal.Companion$cordappsWithoutMeta.forEach { require(it.value.size == 1) { "Conflicting CorDapps specified: ${it.value}" } }</ID>
    <ID>MaxLineLength:TestCordappInternal.kt$TestCordappInternal.Companion$val allCordapps = nodeSpecificCordapps + generalCordapps.filter { it.withOnlyJarContents() !in nodeSpecificCordappsWithoutMeta }</ID>
    <ID>MaxLineLength:TestCordappInternal.kt$TestCordappInternal.Companion${ // Ignore if the node already has the same CorDapp jar. This can happen if the node is being restarted. }</ID>
    <ID>MaxLineLength:TestDSL.kt$AttachmentResolutionException : FlowException</ID>
    <ID>MaxLineLength:TestDSL.kt$DoubleSpentInputs : FlowException</ID>
    <ID>MaxLineLength:TestDSL.kt$TestLedgerDSLInterpreter$( transactionLabel: String?, transactionBuilder: TransactionBuilder, dsl: TestTransactionDSLInterpreter.() -&gt; Unit )</ID>
    <ID>MaxLineLength:TestDSL.kt$TestLedgerDSLInterpreter$throw IllegalStateException("A transaction-DSL block that is part of a test ledger must return a valid transaction.", e)</ID>
    <ID>MaxLineLength:TestDSL.kt$TestLedgerDSLInterpreter$val transactionsUnverified: List&lt;WireTransaction&gt; get() = nonVerifiedTransactionWithLocations.values.map { it.transaction }</ID>
    <ID>MaxLineLength:TestDSL.kt$TestTransactionDSLInterpreter$attachment((services.cordappProvider as MockCordappProvider).addMockCordapp(contractClassName, services.attachments as MockAttachmentStorage))</ID>
    <ID>MaxLineLength:TestDSL.kt$TestTransactionDSLInterpreter$attachment((services.cordappProvider as MockCordappProvider).addMockCordapp(contractClassName, services.attachments as MockAttachmentStorage, attachmentId, signers))</ID>
    <ID>MaxLineLength:TestDSL.kt$TestTransactionDSLInterpreter$attachment((services.cordappProvider as MockCordappProvider).addMockCordapp(contractClassName, services.attachments as MockAttachmentStorage, attachmentId, signers, jarManifestAttributes))</ID>
    <ID>MaxLineLength:TestDSL.kt$TestTransactionDSLInterpreter$override</ID>
    <ID>MaxLineLength:TestDSL.kt$net.corda.testing.dsl.TestDSL.kt</ID>
    <ID>MaxLineLength:TestDatabaseContext.kt$TestDatabaseContext : CloseableResource</ID>
    <ID>MaxLineLength:TestDatabaseContext.kt$TestDatabaseContext$ fun afterClass(teardownSql: List&lt;String&gt;)</ID>
    <ID>MaxLineLength:TestDatabaseContext.kt$TestDatabaseContext$ fun afterTest(teardownSql: List&lt;String&gt;)</ID>
    <ID>MaxLineLength:TestDatabaseContext.kt$TestDatabaseContext$ fun beforeClass(setupSql: List&lt;String&gt;)</ID>
    <ID>MaxLineLength:TestDatabaseContext.kt$TestDatabaseContext$ fun beforeTest(setupSql: List&lt;String&gt;)</ID>
    <ID>MaxLineLength:TestDatabaseContext.kt$TestDatabaseContext$ fun initialize(groupName: String)</ID>
    <ID>MaxLineLength:TestNoSecurityDataVendingFlow.kt$TestNoSecurityDataVendingFlow : DataVendingFlow</ID>
    <ID>MaxLineLength:TestNoSecurityDataVendingFlow.kt$TestNoSecurityDataVendingFlow$@Suspendable override</ID>
    <ID>MaxLineLength:TestNodeInfoBuilder.kt$TestNodeInfoBuilder$listOf(NetworkHostAndPort("my.${identitiesAndPrivateKeys[0].first.party.name.organisation.replace(' ', '-')}.com", 1234))</ID>
    <ID>MaxLineLength:TestNodeInfoBuilder.kt$TestNodeInfoBuilder$private val intermediateAndRoot: Pair&lt;CertificateAndKeyPair, X509Certificate&gt; = DEV_INTERMEDIATE_CA to DEV_ROOT_CA.certificate</ID>
    <ID>MaxLineLength:TestNodeInfoBuilder.kt$fun createNodeInfoAndSigned(vararg names: CordaX500Name, serial: Long = 1, platformVersion: Int = 1): NodeInfoAndSigned</ID>
    <ID>MaxLineLength:TestNotaryFlow.kt$TestNotaryFlow$issueBuilder.addOutputState(NotaryTestState(notary.name.toString(), myIdentity), NotaryTestContract::class.java.name)</ID>
    <ID>MaxLineLength:TestResponseFlowInIsolation.kt$TestResponseFlowInIsolation$private val network: MockNetwork = MockNetwork(MockNetworkParameters(cordappsForAllNodes = cordappsForPackages("com.template")))</ID>
    <ID>MaxLineLength:TestResponseFlowInIsolation.kt$TestResponseFlowInIsolation$val initiatedResponderFlowFuture = b.registerInitiatedFlow(BadInitiator::class.java, Responder::class.java).toFuture()</ID>
    <ID>MaxLineLength:TestUtils.kt$@Deprecated("Returned port is not guaranteed to be free when used, which can result in flaky tests. Instead use a port " + "range that's unlikely to be used by the rest of the system, such as PortAllocation.Incremental(10000).")</ID>
    <ID>MaxLineLength:TestUtils.kt$TestIdentity.Companion$ @JvmStatic @JvmOverloads fun fresh(organisation: String, signatureScheme: SignatureScheme = Crypto.DEFAULT_SIGNATURE_SCHEME): TestIdentity</ID>
    <ID>MaxLineLength:TestUtils.kt$internal fun &lt;VALUE&gt; extractValueWithErrors(errors: Set&lt;Configuration.Validation.Error&gt;)</ID>
    <ID>MaxLineLength:TestUtils.kt$net.corda.testing.core.TestUtils.kt</ID>
    <ID>MaxLineLength:TestingNamedCacheFactory.kt$TestingNamedCacheFactory$override</ID>
    <ID>MaxLineLength:TestingNamedCacheFactory.kt$TestingNamedCacheFactory$override fun bindWithConfig(nodeConfiguration: NodeConfiguration): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:TestingNamedCacheFactory.kt$TestingNamedCacheFactory$override fun bindWithMetrics(metricRegistry: MetricRegistry): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:ThreadContextAdjustingRpcOpsProxy.kt$ThreadContextAdjustingRpcOpsProxy : InternalCordaRPCOps</ID>
    <ID>MaxLineLength:ThreadContextAdjustingRpcOpsProxy.kt$ThreadContextAdjustingRpcOpsProxy.Companion$return Proxy.newProxyInstance(delegate::class.java.classLoader, arrayOf(InternalCordaRPCOps::class.java), handler) as InternalCordaRPCOps</ID>
    <ID>MaxLineLength:ThreadContextAdjustingRpcOpsProxy.kt$ThreadContextAdjustingRpcOpsProxy.Companion$val handler = ThreadContextAdjustingRpcOpsProxy.ThreadContextAdjustingInvocationHandler(delegate, classLoader)</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$StackTraceElementSerializer : Proxy</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$StackTraceElementSerializer$override fun fromProxy(proxy: StackTraceElementProxy): StackTraceElement</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$StackTraceElementSerializer$override fun toProxy(obj: StackTraceElement): StackTraceElementProxy</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$ThrowableSerializer : Proxy</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$ThrowableSerializer$if (this.javaClass.name != proxy.exceptionClass) this.originalExceptionClassName = proxy.exceptionClass</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$ThrowableSerializer$logger.warn("Unexpected exception de-serializing throwable: ${proxy.exceptionClass}. Converting to CordaRuntimeException.", e)</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$ThrowableSerializer$override val additionalSerializers: Iterable&lt;CustomSerializer&lt;out Any&gt;&gt; = listOf(StackTraceElementSerializer(factory))</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$ThrowableSerializer$return ThrowableProxy(obj.javaClass.name, message, stackTraceToInclude, obj.cause, obj.suppressed, extraProperties)</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$ThrowableSerializer${ try { // TODO: This will need reworking when we have multiple class loaders val clazz = Class.forName(proxy.exceptionClass, false, factory.classloader) // If it is CordaException or CordaRuntimeException, we can seek any constructor and then set the properties // Otherwise we just make a CordaRuntimeException if (CordaThrowable::class.java.isAssignableFrom(clazz) &amp;&amp; Throwable::class.java.isAssignableFrom(clazz)) { val typeInformation = factory.getTypeInformation(clazz) val constructor = typeInformation.constructor val params = constructor.parameters.map { parameter -&gt; proxy.additionalProperties[parameter.name] ?: proxy.additionalProperties[parameter.name.capitalize()] } val throwable = constructor.observedMethod.newInstance(*params.toTypedArray()) (throwable as CordaThrowable).apply { if (this.javaClass.name != proxy.exceptionClass) this.originalExceptionClassName = proxy.exceptionClass this.setMessage(proxy.message) this.setCause(proxy.cause) this.addSuppressed(proxy.suppressed) } return (throwable as Throwable).apply { this.stackTrace = proxy.stackTrace } } } catch (e: Exception) { logger.warn("Unexpected exception de-serializing throwable: ${proxy.exceptionClass}. Converting to CordaRuntimeException.", e) } // If the criteria are not met or we experience an exception constructing the exception, we fall back to our own unchecked exception. return CordaRuntimeException(proxy.exceptionClass, null, null).apply { this.setMessage(proxy.message) this.setCause(proxy.cause) this.stackTrace = proxy.stackTrace this.addSuppressed(proxy.suppressed) } }</ID>
    <ID>MaxLineLength:TimeWindow.kt$TimeWindow.Companion$ @JvmStatic fun fromOnly(fromTime: Instant): TimeWindow</ID>
    <ID>MaxLineLength:TimeWindow.kt$TimeWindow.Companion$ @JvmStatic fun fromStartAndDuration(fromTime: Instant, duration: Duration): TimeWindow</ID>
    <ID>MaxLineLength:TimeWindow.kt$TimeWindow.Companion$ @JvmStatic fun untilOnly(untilTime: Instant): TimeWindow</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests$TestNotaryService : SinglePartyNotaryService</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests$addOutputState(DummyContract.SingleOwnerState(owner = info.singleIdentity()), DummyContract.PROGRAM_ID, AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests$private</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests.Companion$/** The notary nodes don't run any consensus protocol, so 2 nodes are sufficient for the purpose of this test. */ private const val CLUSTER_SIZE = 2</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests.Companion$defaultParameters = MockNetworkParameters().withServicePeerAllocationStrategy(InMemoryMessagingNetwork.ServicePeerAllocationStrategy.RoundRobin())</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests.Companion$val networkParameters = NetworkParametersCopier(testNetworkParameters(listOf(NotaryInfo(notaryIdentity, false))))</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests.Companion${ val replicaIds = (0 until CLUSTER_SIZE) val serviceLegalName = CordaX500Name("Custom Notary", "Zurich", "CH") val notaryIdentity = DevIdentityGenerator.generateDistributedNotaryCompositeIdentity( replicaIds.map { mockNet.baseDirectory(mockNet.nextNodeId + it) }, serviceLegalName) val networkParameters = NetworkParametersCopier(testNetworkParameters(listOf(NotaryInfo(notaryIdentity, false)))) val notaryConfig = mock&lt;NotaryConfig&gt; { whenever(it.serviceLegalName).thenReturn(serviceLegalName) whenever(it.validating).thenReturn(false) whenever(it.className).thenReturn(TestNotaryService::class.java.name) } val notaryNodes = (0 until CLUSTER_SIZE).map { mockNet.createUnstartedNode(InternalMockNodeParameters(configOverrides = { doReturn(notaryConfig).whenever(it).notary })) } val aliceNode = mockNet.createUnstartedNode( InternalMockNodeParameters( legalName = CordaX500Name("Alice", "AliceCorp", "GB"), configOverrides = { conf: NodeConfiguration -&gt; val retryConfig = FlowTimeoutConfiguration(1.seconds, 3, 1.0) doReturn(retryConfig).whenever(conf).flowTimeout } ) ) val patientNode = mockNet.createUnstartedNode( InternalMockNodeParameters( legalName = CordaX500Name("Bob", "BobCorp", "GB"), configOverrides = { conf: NodeConfiguration -&gt; val retryConfig = FlowTimeoutConfiguration(10.seconds, 3, 1.0) doReturn(retryConfig).whenever(conf).flowTimeout } ) ) // MockNetwork doesn't support notary clusters, so we create all the nodes we need unstarted, and then install the // network-parameters in their directories before they're started. val nodes = (notaryNodes + aliceNode + patientNode).map { node -&gt; networkParameters.install(mockNet.baseDirectory(node.id)) node.start() } return Triple(notaryIdentity, nodes[nodes.lastIndex - 1], nodes.last()) }</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests.TestNotaryService$override fun createServiceFlow(otherPartySession: FlowSession): FlowLogic&lt;Void?&gt;</ID>
    <ID>MaxLineLength:TimedFlowUtils.kt$ internal fun FlowLogic&lt;*&gt;.isEnabledTimedFlow(): Boolean</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$clientParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$logger.info("Testing: ServerAlgo: $serverAlgo, ClientAlgo: $clientAlgo, Suites: $cipherSuites, Server protocols: $serverProtocols, Client protocols: $clientProtocols, Should fail: $shouldFail")</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$serverParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$val clientKeyStore = CertificateStore.fromResource("net/corda/nodeapi/internal/crypto/keystores/bridge_$clientAlgo.jks", "bridgepass", "bridgepass")</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$val clientParams = SSLParameters(cipherSuites.algos, clientProtocols.versions) clientParams.endpointIdentificationAlgorithm = null // Reconfirm default no server name indication, use our own validator. // SNI Client setup clientParams.serverNames = listOf(SNIHostName(sniServerName)) sslParameters = clientParams useClientMode = true // We need to specify this explicitly because by default the client binds to 'localhost' and we want it to bind // to whatever &lt;hostname&gt; resolves to(as that's what the server binds to). In particular on Debian &lt;hostname&gt; // resolves to 127.0.1.1 instead of the external address of the interface, so the ssl handshake fails. bind(InetSocketAddress(InetAddress.getLocalHost(), 0))</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$val serverKeyStore = CertificateStore.fromResource("net/corda/nodeapi/internal/crypto/keystores/float_$serverAlgo.jks", "floatpass", "floatpass")</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$val trustStore = CertificateStore.fromResource("net/corda/nodeapi/internal/crypto/keystores/trust.jks", "trustpass", "trustpass")</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$@Parameterized.Parameters(name = "ServerAlgo: {0}, ClientAlgo: {1}, CipherSuites: {2}, Should fail: {3}, ServerProtocols: {4}, ClientProtocols: {5}")</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$arrayOf(serverAlgo, clientAlgo, Companion.CipherSuites.CIPHER_SUITES_ALL, false, Companion.TlsProtocols.BOTH, Companion.TlsProtocols.BOTH)</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$arrayOf(serverAlgo, clientAlgo, Companion.CipherSuites.CIPHER_SUITES_ALL, false, Companion.TlsProtocols.BOTH, Companion.TlsProtocols.ONE_2)</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$arrayOf(serverAlgo, clientAlgo, Companion.CipherSuites.CIPHER_SUITES_ALL, false, Companion.TlsProtocols.ONE_2, Companion.TlsProtocols.BOTH)</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$arrayOf(serverAlgo, clientAlgo, Companion.CipherSuites.CIPHER_SUITES_ALL, false, Companion.TlsProtocols.ONE_3, Companion.TlsProtocols.ONE_3)</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$arrayOf(serverAlgo, clientAlgo, Companion.CipherSuites.CIPHER_SUITES_ALL, true, Companion.TlsProtocols.ONE_3, Companion.TlsProtocols.ONE_2)</ID>
    <ID>MaxLineLength:ToggleField.kt$InheritableThreadLocalToggleField.&lt;no name provided&gt;$override</ID>
    <ID>MaxLineLength:ToggleField.kt$ThreadLeakException : RuntimeException</ID>
    <ID>MaxLineLength:ToggleFieldTest.kt$ToggleFieldTest$// If ThreadLeakException is seen in practice, these warnings form a trail of where the holder has been: verify(log).warn(argThat { contains(leakedThreadName) &amp;&amp; contains("hello") }) val newThreadName = fork { Thread.currentThread().name }.getOrThrow() val future = fork(field::get) assertThatThrownBy { future.getOrThrow() } .isInstanceOf(ThreadLeakException::class.java) .hasMessageContaining(newThreadName) .hasMessageContaining("hello") fork { verifyNoMoreInteractions(log) withSingleThreadExecutor { verify(log).warn(argThat { contains(newThreadName) &amp;&amp; contains("hello") }) } }.getOrThrow()</ID>
    <ID>MaxLineLength:ToggleFieldTest.kt$ToggleFieldTest$isAGlobalThreadBeingCreated || (e.className == companionName &amp;&amp; e.methodName == "globalThreadCreationMethod")</ID>
    <ID>MaxLineLength:ToggleFieldTest.kt$ToggleFieldTest$listOf(SimpleToggleField&lt;String&gt;("simple"), ThreadLocalToggleField&lt;String&gt;("local"), inheritableThreadLocalToggleField())</ID>
    <ID>MaxLineLength:ToggleFieldTest.kt$ToggleFieldTest$private</ID>
    <ID>MaxLineLength:TopLevelTransition.kt$TopLevelTransition$Action.PersistCheckpoint(context.id, newCheckpoint, isCheckpointUpdate = currentState.isAnyCheckpointPersisted)</ID>
    <ID>MaxLineLength:TopLevelTransition.kt$TopLevelTransition$Action.RemoveFlow(context.id, FlowRemovalReason.OrderlyFinish(event.returnValue), currentState)</ID>
    <ID>MaxLineLength:TopLevelTransition.kt$TopLevelTransition$Action.SendExisting(state.peerParty, message, SenderDeduplicationId(deduplicationId, currentState.senderUUID))</ID>
    <ID>MaxLineLength:TopLevelTransition.kt$TopLevelTransition$freshErrorTransition(IllegalStateException("Tried to initiate in a flow not annotated with @${InitiatingFlow::class.java.simpleName}"))</ID>
    <ID>MaxLineLength:TopLevelTransition.kt$TopLevelTransition$is Event.DeliverSessionMessage -&gt; DeliverSessionMessageTransition(context, startingState, event).transition()</ID>
    <ID>MaxLineLength:TopLevelTransition.kt$TopLevelTransition$val newSessions = checkpoint.sessions + (sourceSessionId to SessionState.Uninitiated(event.destination, initiatingSubFlow, sourceSessionId, context.secureRandom.nextLong()))</ID>
    <ID>MaxLineLength:Trace.kt$Trace.Companion$ @DeleteForDJVM @JvmStatic fun newInstance( invocationId: InvocationId = InvocationId.newInstance(), sessionId: SessionId = SessionId(invocationId.value, invocationId.timestamp) )</ID>
    <ID>MaxLineLength:Trace.kt$Trace.InvocationId.Companion$ @DeleteForDJVM @JvmStatic fun newInstance(value: String = UuidGenerator.next().toString(), timestamp: Instant = Instant.now())</ID>
    <ID>MaxLineLength:Trace.kt$Trace.SessionId.Companion$ @DeleteForDJVM @JvmStatic fun newInstance(value: String = UuidGenerator.next().toString(), timestamp: Instant = Instant.now())</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$EventSinkDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$EventStreamDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObjectPropertyDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObservableDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObservableListDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObservableValueDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObserverDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$SubjectDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$WritableValueDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TraderDemoClientApi.kt$TraderDemoClientApi$println("Sale completed - we have a happy customer!\n\nFinal transaction is:\n\n${Emoji.renderIfSupported(stx.tx)}")</ID>
    <ID>MaxLineLength:TraderDemoClientApi.kt$TraderDemoClientApi$val otherParty = rpc.wellKnownPartyFromX500Name(buyerName) ?: throw IllegalStateException("Don't know $buyerName")</ID>
    <ID>MaxLineLength:TraderDemoTest.kt$TraderDemoTest$TraderDemoClientApi(bank.rpc).runIssuer(amount = 100.DOLLARS, buyerName = DUMMY_BANK_A_NAME, sellerName = DUMMY_BANK_B_NAME)</ID>
    <ID>MaxLineLength:TraderDemoTest.kt$TraderDemoTest$clientBank.runIssuer(amount = 100.DOLLARS, buyerName = nodeA.services.myInfo.singleIdentity().name, sellerName = nodeB.services.myInfo.singleIdentity().name)</ID>
    <ID>MaxLineLength:TraderDemoTest.kt$TraderDemoTest$val buyer2 = startNode(providedName = DUMMY_BANK_A_NAME, customOverrides = mapOf("p2pAddress" to buyer.p2pAddress.toString())).getOrThrow()</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ @BelongsToContract, and does not have an enclosing class which implements Contract. Either annotate </ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ @Throws(MissingContractAttachments::class) fun toWireTransaction(services: ServicesForResolution): WireTransaction</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ Please contact the developer of the CorDapp and install the latest version, as this approach might be insecure.</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ fun setTimeWindow(time: Instant, timeTolerance: Duration)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun attachmentConstraintsTransition( constraints: Set&lt;AttachmentConstraint&gt;, attachmentToUse: ContractAttachment, services: ServicesForResolution ): AttachmentConstraint</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun handleContract( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, outputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, explicitContractAttachment: AttachmentId?, services: ServicesForResolution ): Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun selectAttachmentConstraint( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, attachmentToUse: ContractAttachment, services: ServicesForResolution ): AttachmentConstraint</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun selectContractAttachmentsAndOutputStateConstraints( services: ServicesForResolution, serializationContext: SerializationContext? ): Pair&lt;Collection&lt;SecureHash&gt;, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$"An attachment has been explicitly set for contract $contractClassName in the transaction builder which conflicts with the HashConstraint of a state."</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$"Transaction was built with $contractClassName states with multiple HashConstraints. This is illegal, because it makes it impossible to validate with a single version of the contract code."</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$(allContractAttachments + attachments).toSortedSet().toList()</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$?:</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$@Throws(AttachmentResolutionException::class, TransactionResolutionException::class, TransactionVerificationException::class)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$checkNotNull(notary) { "Need to specify a notary for the state, or set a default one on TransactionBuilder initialisation" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$constraints.any { it is WhitelistedByZoneAttachmentConstraint } &amp;&amp; attachmentToUse.isSigned &amp;&amp; services.networkParameters.minimumPlatformVersion &gt;= 4 -&gt; transitionToSignatureConstraint(constraints, attachmentToUse)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$handleContract(ctr, inputContractGroups[ctr], outputContractGroups[ctr], explicitAttachmentContractsMap[ctr], services)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$if ((attachment as ContractAttachment).isSigned &amp;&amp; (explicitContractAttachment == null || explicitContractAttachment == attachment.id)) { val signatureConstraint = makeSignatureAttachmentConstraint(attachment.signerKeys) require(signatureConstraint.isSatisfiedBy(attachment)) { "Selected output constraint: $signatureConstraint not satisfying ${attachment.id}" } val resolvedOutputStates = outputStates?.map { if (it.constraint in automaticConstraints) { it.copy(constraint = signatureConstraint) } else { it } } return attachment.id to resolvedOutputStates }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$if (attachment == null || attachment !is ContractAttachment || !isUploaderTrusted(attachment.uploader)) { // This should never happen because these are input states that should have been validated already. throw MissingContractAttachments(listOf(state)) }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$inputStates != null -&gt; attachmentConstraintsTransition(inputStates.groupBy { it.constraint }.keys, attachmentToUse, services)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$is CommandData -&gt; throw IllegalArgumentException("You passed an instance of CommandData, but that lacks the pubkey. You need to wrap it in a Command object first.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$is ContractState -&gt; throw UnsupportedOperationException("Removed as of V1: please use a StateAndContract instead")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$log</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$log.warnOnce("Signature constraints not available on network requiring a minimum platform version of 4. Current is: ${services.networkParameters.minimumPlatformVersion}.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$private</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(automaticConstraintPropagation) { "Contract $contractClassName was marked with @NoConstraintPropagation, which means the constraint of the output states has to be set explicitly." }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(defaultOutputConstraint.isSatisfiedBy(constraintAttachment)) { "Selected output constraint: $defaultOutputConstraint not satisfying $selectedAttachmentId" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(explicitAttachmentContracts.isEmpty() || explicitAttachmentContracts.groupBy { (ctr, _) -&gt; ctr }.all { (_, groups) -&gt; groups.size == 1 }) { "Multiple attachments set for the same contract." }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(outputConstraint.canBeTransitionedFrom(input.constraint, attachmentToUse)) { "Output state constraint $outputConstraint cannot be transitioned from ${input.constraint}" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(outputConstraint.isSatisfiedBy(constraintAttachment)) { "Output state constraint check fails. $outputConstraint" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(signatureConstraint.isSatisfiedBy(attachment)) { "Selected output constraint: $signatureConstraint not satisfying ${attachment.id}" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$rootError is ClassNotFoundException -&gt; addMissingAttachment((rootError.message ?: throw e).replace(".", "/"), services, e)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$throw IllegalArgumentException("Attempting to create an illegal transaction. Please install the latest signed version for the $attachmentToUse Cordapp.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$throw IllegalArgumentException("Can't mix the AlwaysAcceptAttachmentConstraint with a secure constraint in the same transaction. This can be used to hide insecure transitions.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$throw IllegalArgumentException("Cannot mix SignatureAttachmentConstraints signed by different parties in the same transaction.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$useWhitelistedByZoneAttachmentConstraint(contractClassName, services.networkParameters) -&gt; WhitelistedByZoneAttachmentConstraint</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val (allContractAttachments: Collection&lt;SecureHash&gt;, resolvedOutputs: List&lt;TransactionState&lt;ContractState&gt;&gt;) = selectContractAttachmentsAndOutputStateConstraints(services, serializationContext)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val attachment = services.attachments.openAttachment((state.constraint as HashAttachmentConstraint).attachmentId)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val attachmentToUse = services.attachments.openAttachment(selectedAttachmentId)?.let { it as ContractAttachment } ?: throw IllegalArgumentException("Contract attachment $selectedAttachmentId for $contractClassName is missing.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val attachments: Collection&lt;AttachmentId&gt; = contractAttachmentsAndResolvedOutputStates.map { it.first } + refStateContractAttachments</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val automaticConstraintPropagation = contractClassName.contractHasAutomaticConstraintPropagation(inputsAndOutputs.first().data::class.java.classLoader)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val constraintAttachment = AttachmentWithContext(attachmentToUse, contractClassName, services.networkParameters.whitelistedContractImplementations)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val contractAttachmentsAndResolvedOutputStates: List&lt;Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;&gt; = allContracts.toSet() .map { ctr -&gt; handleContract(ctr, inputContractGroups[ctr], outputContractGroups[ctr], explicitAttachmentContractsMap[ctr], services) }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val defaultOutputConstraint = selectAttachmentConstraint(contractClassName, inputStates, attachmentToUse, services)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val inputContractGroups: Map&lt;ContractClassName, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt; = inputsWithTransactionState.map { it.state } .groupBy { it.contract }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val outputContractGroups: Map&lt;ContractClassName, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt; = outputs.groupBy { it.contract }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val referenceStateGroups: Map&lt;ContractClassName, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt; = referencesWithTransactionState.groupBy { it.contract }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val resolvedOutputStatesInTheOriginalOrder: List&lt;TransactionState&lt;ContractState&gt;&gt; = outputStates().map { os -&gt; resolvedStates.find { rs -&gt; rs.data == os.data &amp;&amp; rs.encumbrance == os.encumbrance }!! }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val resolvedStates: List&lt;TransactionState&lt;ContractState&gt;&gt; = contractAttachmentsAndResolvedOutputStates.mapNotNull { it.second } .flatten()</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val signatureConstraint = constraints.singleOrNull { it is SignatureAttachmentConstraint } as? SignatureAttachmentConstraint</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$when { // Sanity check. constraints.isEmpty() -&gt; throw IllegalArgumentException("Cannot transition from no constraints.") // Fail when combining the insecure AlwaysAcceptAttachmentConstraint with something else. constraints.size &gt; 1 &amp;&amp; constraints.any { it is AlwaysAcceptAttachmentConstraint } -&gt; throw IllegalArgumentException("Can't mix the AlwaysAcceptAttachmentConstraint with a secure constraint in the same transaction. This can be used to hide insecure transitions.") // Multiple states with Hash constraints with different hashes. This should not happen as we checked already. constraints.size &gt; 1 &amp;&amp; constraints.all { it is HashAttachmentConstraint } -&gt; throw IllegalArgumentException("Cannot mix HashConstraints with different hashes in the same transaction.") // The HashAttachmentConstraint is the strongest constraint, so it wins when mixed with anything. As long as the actual constraints pass. // Migration from HashAttachmentConstraint to SignatureAttachmentConstraint is handled in [TransactionBuilder.handleContract] // If we have reached this point, then no migration is possible and the existing HashAttachmentConstraint must be used constraints.any { it is HashAttachmentConstraint } -&gt; constraints.find { it is HashAttachmentConstraint }!! // TODO, we don't currently support mixing signature constraints with different signers. This will change once we introduce third party signers. constraints.count { it is SignatureAttachmentConstraint } &gt; 1 -&gt; throw IllegalArgumentException("Cannot mix SignatureAttachmentConstraints signed by different parties in the same transaction.") // This ensures a smooth migration from a Whitelist Constraint to a Signature Constraint constraints.any { it is WhitelistedByZoneAttachmentConstraint } &amp;&amp; attachmentToUse.isSigned &amp;&amp; services.networkParameters.minimumPlatformVersion &gt;= 4 -&gt; transitionToSignatureConstraint(constraints, attachmentToUse) // This condition is hit when the current node has not installed the latest signed version but has already received states that have been migrated constraints.any { it is SignatureAttachmentConstraint } &amp;&amp; !attachmentToUse.isSigned -&gt; throw IllegalArgumentException("Attempting to create an illegal transaction. Please install the latest signed version for the $attachmentToUse Cordapp.") // When all input states have the same constraint. constraints.size == 1 -&gt; constraints.single() else -&gt; throw IllegalArgumentException("Unexpected constraints $constraints.") }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder${ // If the constraint on the output state is already set, and is not a valid transition or can't be transitioned, then fail early. inputStates?.forEach { input -&gt; require(outputConstraint.canBeTransitionedFrom(input.constraint, attachmentToUse)) { "Output state constraint $outputConstraint cannot be transitioned from ${input.constraint}" } } require(outputConstraint.isSatisfiedBy(constraintAttachment)) { "Output state constraint check fails. $outputConstraint" } it }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder${ // This should never happen because these are input states that should have been validated already. throw MissingContractAttachments(listOf(state)) }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder${ val inputsAndOutputs = (inputStates ?: emptyList()) + (outputStates ?: emptyList()) fun selectAttachment() = getInstalledContractAttachmentId( contractClassName, inputsAndOutputs.filterNot { it.constraint in automaticConstraints }, services ) /* This block handles the very specific code path where a [HashAttachmentConstraint] can migrate to a [SignatureAttachmentConstraint]. If all the criteria is met, this function will return early as the rest of the logic is no longer required. This can only happen in a private network where all nodes have started with a system parameter that disables the hash constraint check. */ if (canMigrateFromHashToSignatureConstraint(inputStates, outputStates, services)) { val attachmentId = selectAttachment() val attachment = services.attachments.openAttachment(attachmentId) require(attachment != null) { "Contract attachment $attachmentId for $contractClassName is missing." } if ((attachment as ContractAttachment).isSigned &amp;&amp; (explicitContractAttachment == null || explicitContractAttachment == attachment.id)) { val signatureConstraint = makeSignatureAttachmentConstraint(attachment.signerKeys) require(signatureConstraint.isSatisfiedBy(attachment)) { "Selected output constraint: $signatureConstraint not satisfying ${attachment.id}" } val resolvedOutputStates = outputStates?.map { if (it.constraint in automaticConstraints) { it.copy(constraint = signatureConstraint) } else { it } } return attachment.id to resolvedOutputStates } } // Determine if there are any HashConstraints that pin the version of a contract. If there are, check if we trust them. val hashAttachments = inputsAndOutputs .filter { it.constraint is HashAttachmentConstraint } .map { state -&gt; val attachment = services.attachments.openAttachment((state.constraint as HashAttachmentConstraint).attachmentId) if (attachment == null || attachment !is ContractAttachment || !isUploaderTrusted(attachment.uploader)) { // This should never happen because these are input states that should have been validated already. throw MissingContractAttachments(listOf(state)) } attachment }.toSet() // Check that states with the HashConstraint don't conflict between themselves or with an explicitly set attachment. require(hashAttachments.size &lt;= 1) { "Transaction was built with $contractClassName states with multiple HashConstraints. This is illegal, because it makes it impossible to validate with a single version of the contract code." } if (explicitContractAttachment != null &amp;&amp; hashAttachments.singleOrNull() != null) { require(explicitContractAttachment == (hashAttachments.single() as ContractAttachment).attachment.id) { "An attachment has been explicitly set for contract $contractClassName in the transaction builder which conflicts with the HashConstraint of a state." } } // This will contain the hash of the JAR that *has* to be used by this Transaction, because it is explicit. Or null if none. val forcedAttachmentId = explicitContractAttachment ?: hashAttachments.singleOrNull()?.id // This will contain the hash of the JAR that will be used by this Transaction. val selectedAttachmentId = forcedAttachmentId ?: selectAttachment() val attachmentToUse = services.attachments.openAttachment(selectedAttachmentId)?.let { it as ContractAttachment } ?: throw IllegalArgumentException("Contract attachment $selectedAttachmentId for $contractClassName is missing.") // For Exit transactions (no output states) there is no need to resolve the output constraints. if (outputStates == null) { return Pair(selectedAttachmentId, null) } // If there are no automatic constraints, there is nothing to resolve. if (outputStates.none { it.constraint in automaticConstraints }) { return Pair(selectedAttachmentId, outputStates) } // The final step is to resolve AutomaticPlaceholderConstraint. val automaticConstraintPropagation = contractClassName.contractHasAutomaticConstraintPropagation(inputsAndOutputs.first().data::class.java.classLoader) // When automaticConstraintPropagation is disabled for a contract, output states must an explicit Constraint. require(automaticConstraintPropagation) { "Contract $contractClassName was marked with @NoConstraintPropagation, which means the constraint of the output states has to be set explicitly." } // This is the logic to determine the constraint which will replace the AutomaticPlaceholderConstraint. val defaultOutputConstraint = selectAttachmentConstraint(contractClassName, inputStates, attachmentToUse, services) // Sanity check that the selected attachment actually passes. val constraintAttachment = AttachmentWithContext(attachmentToUse, contractClassName, services.networkParameters.whitelistedContractImplementations) require(defaultOutputConstraint.isSatisfiedBy(constraintAttachment)) { "Selected output constraint: $defaultOutputConstraint not satisfying $selectedAttachmentId" } val resolvedOutputStates = outputStates.map { val outputConstraint = it.constraint if (outputConstraint in automaticConstraints) { it.copy(constraint = defaultOutputConstraint) } else { // If the constraint on the output state is already set, and is not a valid transition or can't be transitioned, then fail early. inputStates?.forEach { input -&gt; require(outputConstraint.canBeTransitionedFrom(input.constraint, attachmentToUse)) { "Output state constraint $outputConstraint cannot be transitioned from ${input.constraint}" } } require(outputConstraint.isSatisfiedBy(constraintAttachment)) { "Output state constraint check fails. $outputConstraint" } it } } return Pair(selectedAttachmentId, resolvedOutputStates) }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder${ val signatureConstraint = constraints.singleOrNull { it is SignatureAttachmentConstraint } as? SignatureAttachmentConstraint // If there were states transitioned already used in the current transaction use that signature constraint, otherwise create a new one. return when { signatureConstraint != null -&gt; signatureConstraint else -&gt; makeSignatureAttachmentConstraint(attachmentToUse.signerKeys) } }</ID>
    <ID>MaxLineLength:TransactionBuilderTest.kt$TransactionBuilderTest$assertThat(wtx.outputs).containsOnly(outputState.copy(constraint = HashAttachmentConstraint(contractAttachmentId)))</ID>
    <ID>MaxLineLength:TransactionBuilderTest.kt$TransactionBuilderTest$private</ID>
    <ID>MaxLineLength:TransactionDSLInterpreter.kt$TransactionDSL$ fun input(stateLabel: String)</ID>
    <ID>MaxLineLength:TransactionDSLInterpreter.kt$TransactionDSL$ fun reference(stateLabel: String)</ID>
    <ID>MaxLineLength:TransactionDSLInterpreter.kt$TransactionDSL$fun attachment(contractClassName: ContractClassName, attachmentId: AttachmentId)</ID>
    <ID>MaxLineLength:TransactionDSLInterpreter.kt$TransactionDSL&lt;out T : TransactionDSLInterpreter&gt; : TransactionDSLInterpreter</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 0, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 0, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 0, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 2, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 0, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 0, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 2, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 0, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$assertThatExceptionOfType(TransactionVerificationException.TransactionNotaryMismatchEncumbranceException::class.java)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$assertThatExceptionOfType(TransactionVerificationException.TransactionNotaryMismatchEncumbranceException::class.java) .isThrownBy { TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 0, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 2, AutomaticPlaceholderConstraint) .addCommand(Cash.Commands.Issue(), MEGA_CORP.owningKey) .toLedgerTransaction(ledgerServices) .verify() } .withMessageContaining("index 2 is assigned to notary [O=Notary Service, L=Zurich, C=CH], while its encumbrance with " + "index 3 is assigned to notary [O=Notary Service2, L=Zurich, C=CH]")</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$assertThatExceptionOfType(TransactionVerificationException.TransactionNotaryMismatchEncumbranceException::class.java) .isThrownBy { TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 0, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 2, AutomaticPlaceholderConstraint) .addCommand(Cash.Commands.Issue(), MEGA_CORP.owningKey) .toLedgerTransaction(ledgerServices) .verify() } .withMessageContaining("index 3 is assigned to notary [O=Notary Service, L=Zurich, C=CH], while its encumbrance with " + "index 2 is assigned to notary [O=Notary Service2, L=Zurich, C=CH]")</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by 5pm time-lock A", encumbrance = 2, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by 5pm time-lock A", encumbrance = 3, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by 5pm time-lock B", encumbrance = 3, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by 5pm time-lock B", encumbrance = 4, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by 5pm time-lock C", encumbrance = 5, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by 5pm time-lock", encumbrance = 1, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by itself", encumbrance = 0, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by state 0", encumbrance = 0, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by state 1", encumbrance = 1, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by state 2", encumbrance = 2, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by state 3 again", encumbrance = 3, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by state 3", encumbrance = 3, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(TEST_TIMELOCK_ID, "state encumbered by state 2 which does not exist", encumbrance = 2, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests${ // Single encumbrance with different notaries. assertFailsWith&lt;TransactionVerificationException.TransactionNotaryMismatchEncumbranceException&gt; { TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 0, AutomaticPlaceholderConstraint) .addCommand(Cash.Commands.Issue(), MEGA_CORP.owningKey) .toLedgerTransaction(ledgerServices) .verify() } // More complex encumbrance (full cycle of size 4) where one of the encumbered states is assigned to a different notary. // 0 -&gt; 1, 1 -&gt; 3, 3 -&gt; 2, 2 -&gt; 0 // We expect that state at index 3 cannot be encumbered with the state at index 2, due to mismatched notaries. assertThatExceptionOfType(TransactionVerificationException.TransactionNotaryMismatchEncumbranceException::class.java) .isThrownBy { TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 0, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 2, AutomaticPlaceholderConstraint) .addCommand(Cash.Commands.Issue(), MEGA_CORP.owningKey) .toLedgerTransaction(ledgerServices) .verify() } .withMessageContaining("index 3 is assigned to notary [O=Notary Service, L=Zurich, C=CH], while its encumbrance with " + "index 2 is assigned to notary [O=Notary Service2, L=Zurich, C=CH]") // Two different encumbrance chains, where only one fails due to mismatched notary. // 0 -&gt; 1, 1 -&gt; 0, 2 -&gt; 3, 3 -&gt; 2 where encumbered states with indices 2 and 3, respectively, are assigned // to different notaries. assertThatExceptionOfType(TransactionVerificationException.TransactionNotaryMismatchEncumbranceException::class.java) .isThrownBy { TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 0, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 2, AutomaticPlaceholderConstraint) .addCommand(Cash.Commands.Issue(), MEGA_CORP.owningKey) .toLedgerTransaction(ledgerServices) .verify() } .withMessageContaining("index 2 is assigned to notary [O=Notary Service, L=Zurich, C=CH], while its encumbrance with " + "index 3 is assigned to notary [O=Notary Service2, L=Zurich, C=CH]") }</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests.Companion$val DUMMY_NOTARY2 = TestIdentity(DUMMY_NOTARY_NAME.copy(organisation = "${DUMMY_NOTARY_NAME.organisation}2"), 30).party</ID>
    <ID>MaxLineLength:TransactionGenerator.kt$TransactionGenerator$output(PROGRAM_ID, "c1", State(1000.POUNDS `issued by` DUMMY_CASH_ISSUER, AnonymousParty(MEGA_CORP_PUBKEY)))</ID>
    <ID>MaxLineLength:TransactionGenerator.kt$TransactionGenerator$output(PROGRAM_ID, "c2", State(2000.POUNDS `issued by` DUMMY_CASH_ISSUER, AnonymousParty(MEGA_CORP_PUBKEY)))</ID>
    <ID>MaxLineLength:TransactionGenerator.kt$TransactionGenerator$output(PROGRAM_ID, "c3", State(3000.POUNDS `issued by` DUMMY_CASH_ISSUER, AnonymousParty(MINI_CORP_PUBKEY)))</ID>
    <ID>MaxLineLength:TransactionGenerator.kt$TransactionGenerator$private val DUMMY_CASH_ISSUER_IDENTITY = getTestPartyAndCertificate(Party(CordaX500Name("Snake Oil Issuer", "London", "GB"), DUMMY_CASH_ISSUER_KEY.public))</ID>
    <ID>MaxLineLength:TransactionGenerator.kt$TransactionGenerator$val contractAttachment = MockContractAttachment(interpreter.services.cordappProvider.getContractAttachmentID(PROGRAM_ID)!!, PROGRAM_ID)</ID>
    <ID>MaxLineLength:TransactionGraphSearch.kt$TransactionGraphSearch$Query</ID>
    <ID>MaxLineLength:TransactionGraphSearch.kt$TransactionGraphSearch$val unvisitedInputTxs: Map&lt;SecureHash, SignedTransaction&gt; = inputsLeadingToUnvisitedTx.map { it.txhash }.toHashSet().mapNotNull { transactions.getTransaction(it) }.associateBy { it.id }</ID>
    <ID>MaxLineLength:TransactionGraphSearch.kt$TransactionGraphSearch$val unvisitedInputTxsWithInputIndex: Iterable&lt;Pair&lt;SignedTransaction, Int&gt;&gt; = inputsLeadingToUnvisitedTx.filter { it.txhash in unvisitedInputTxs.keys }.map { Pair(unvisitedInputTxs[it.txhash]!!, it.index) }</ID>
    <ID>MaxLineLength:TransactionGraphSearchTests.kt$TransactionGraphSearchTests$GraphTransactionStorage : MockTransactionStorage</ID>
    <ID>MaxLineLength:TransactionGraphSearchTests.kt$TransactionGraphSearchTests$val megaCorpServices = MockServices(listOf("net.corda.testing.contracts"), megaCorp, rigorousMock&lt;IdentityService&gt;())</ID>
    <ID>MaxLineLength:TransactionGraphSearchTests.kt$TransactionGraphSearchTests$val notaryServices = MockServices(listOf("net.corda.testing.contracts"), dummyNotary, rigorousMock&lt;IdentityService&gt;())</ID>
    <ID>MaxLineLength:TransactionGraphSearchTests.kt$TransactionGraphSearchTests$val search = TransactionGraphSearch(storage, listOf(storage.inputTx.tx), TransactionGraphSearch.Query(DummyContract.Commands.Create::class.java))</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$inputState = StateAndRef(TransactionState(TestCash.State(depositRef, 100.POUNDS, MEGA_CORP), TEST_CASH_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), fakeStateRef)</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$tx = TransactionBuilder(DUMMY_NOTARY).withItems(inputState, outputState, changeState, Command(TestCash.Commands.Move(), arrayListOf(MEGA_CORP.owningKey)))</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$val changeState = TransactionState(TestCash.State(depositRef, 400.POUNDS, MEGA_CORP), TEST_CASH_PROGRAM_ID, DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$val fakeTx = megaCorpServices.signInitialTransaction(TransactionBuilder(DUMMY_NOTARY).withItems(outputState, Command(TestCash.Commands.Issue(), arrayListOf(MEGA_CORP.owningKey))))</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$val megaCorpServices = object : MockServices(listOf("net.corda.coretests.serialization"), MEGA_CORP.name, mock(), testNetworkParameters(notaries = listOf(NotaryInfo(DUMMY_NOTARY, true))), MEGA_CORP_KEY) { // override mock implementation with a real one override fun loadContractAttachment(stateRef: StateRef): Attachment = servicesForResolution.loadContractAttachment(stateRef) }</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$val notaryServices = MockServices(listOf("net.corda.coretests.serialization"), DUMMY_NOTARY.name, rigorousMock(), DUMMY_NOTARY_KEY)</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$val outputState = TransactionState(TestCash.State(depositRef, 600.POUNDS, MEGA_CORP), TEST_CASH_PROGRAM_ID, DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$val signatures = listOf(TransactionSignature(ByteArray(1), MEGA_CORP_KEY.public, SignatureMetadata(1, Crypto.findSignatureScheme(MEGA_CORP_KEY.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests.&lt;no name provided&gt;$override</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests.TestCash.State$override fun withNewOwner(newOwner: AbstractParty)</ID>
    <ID>MaxLineLength:TransactionSignature.kt$TransactionSignature$ @Throws(InvalidKeyException::class, SignatureException::class) fun verify(txId: SecureHash)</ID>
    <ID>MaxLineLength:TransactionSignature.kt$TransactionSignature$/** * Construct a [TransactionSignature] with [partialMerkleTree] set to null. * This is the recommended constructor when signing over a single transaction. * */ constructor(bytes: ByteArray, by: PublicKey, signatureMetadata: SignatureMetadata) : this(bytes, by, signatureMetadata, null)</ID>
    <ID>MaxLineLength:TransactionSignatureTest.kt$TransactionSignatureTest$val signableData = SignableData(testBytes.sha256(), SignatureMetadata(1, Crypto.findSignatureScheme(keyPair.public).schemeNumberID))</ID>
    <ID>MaxLineLength:TransactionSignatureTest.kt$TransactionSignatureTest$val signableData = SignableData(txId, SignatureMetadata(3, Crypto.findSignatureScheme(keyPair.public).schemeNumberID))</ID>
    <ID>MaxLineLength:TransactionSignatureTest.kt$TransactionSignatureTest$val txSignatureWithFullTree = TransactionSignature(txSignature.bytes, txSignature.by, txSignature.signatureMetadata, pmtFull)</ID>
    <ID>MaxLineLength:TransactionSignatureTest.kt$TransactionSignatureTest$val txSignatureWithTree = TransactionSignature(txSignature.bytes, txSignature.by, txSignature.signatureMetadata, pmt)</ID>
    <ID>MaxLineLength:TransactionSignatureTest.kt$TransactionSignatureTest${ val keyPair = Crypto.deriveKeyPairFromEntropy(Crypto.EDDSA_ED25519_SHA512, BigInteger.valueOf(1234567890L)) val txId = "aTransaction".toByteArray().sha256() // One-tx signature. val txSignature = signOneTx(txId, keyPair) // partialMerkleTree should be null. assertNull(txSignature.partialMerkleTree) // Verify the corresponding txId with every possible way. assertTrue(Crypto.doVerify(txId, txSignature)) assertTrue(txSignature.verify(txId)) assertTrue(Crypto.isValid(txId, txSignature)) assertTrue(txSignature.isValid(txId)) // We signed the txId itself, not its hash (because it was a signature over one tx only and no partial tree has been received). assertFailsWith&lt;SignatureException&gt; { Crypto.doVerify(txId.sha256(), txSignature) } }</ID>
    <ID>MaxLineLength:TransactionSignatureTest.kt$TransactionSignatureTest${ val txId = "aTransaction".toByteArray().sha256() // One-tx signature. val txSignature = try { signOneTx(txId, keyPair) } catch (e: Throwable) { e.cause?.printStackTrace() throw e } // partialMerkleTree should be null. assertNull(txSignature.partialMerkleTree) // Verify the corresponding txId with every possible way. assertTrue(Crypto.doVerify(txId, txSignature)) assertTrue(txSignature.verify(txId)) assertTrue(Crypto.isValid(txId, txSignature)) assertTrue(txSignature.isValid(txId)) // We signed the txId itself, not its hash (because it was a signature over one tx only and no partial tree has been received). assertFailsWith&lt;SignatureException&gt; { Crypto.doVerify(txId.sha256(), txSignature) } }</ID>
    <ID>MaxLineLength:TransactionState.kt$TransactionState$ @BelongsToContract, and does not have an enclosing class which implements Contract. Either annotate </ID>
    <ID>MaxLineLength:TransactionState.kt$TransactionState$/** * All contract states may be _encumbered_ by up to one other state. * * The encumbrance state, if present, forces additional controls over the encumbered state, since the platform checks * that the encumbrance state is present as an input in the same transaction that consumes the encumbered state, and * the contract code and rules of the encumbrance state will also be verified during the execution of the transaction. * For example, a cash contract state could be encumbered with a time-lock contract state; the cash state is then only * processable in a transaction that verifies that the time specified in the encumbrance time-lock has passed. * * The encumbered state refers to another by index, and the referred encumbrance state * is an output state in a particular position on the same transaction that created the encumbered state. An alternative * implementation would be encumbering by reference to a [StateRef], which would allow the specification of encumbrance * by a state created in a prior transaction. * * Note that an encumbered state that is being consumed must have its encumbrance consumed in the same transaction, * otherwise the transaction is not valid. */ val encumbrance: Int? = null</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$assertFailsWith&lt;SignedTransaction.SignaturesMissingException&gt; { makeSigned(wtx, DUMMY_CASH_ISSUER_KEY).verifySignaturesExcept(DUMMY_KEY_1.public) }.missing</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$assertFailsWith&lt;SignedTransaction.SignaturesMissingException&gt; { makeSigned(wtx, DUMMY_KEY_1).verifyRequiredSignatures() }.missing</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$assertFailsWith&lt;SignedTransaction.SignaturesMissingException&gt; { makeSigned(wtx, DUMMY_KEY_1, ak).verifyRequiredSignatures() }.missing</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$assertFailsWith&lt;SignedTransaction.SignaturesMissingException&gt; { makeSigned(wtx, DUMMY_KEY_2).verifyRequiredSignatures() }.missing</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$assertFailsWith&lt;TransactionVerificationException.NotaryChangeInWrongTransactionType&gt; { buildTransaction().verify() }</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$keySigs + DUMMY_NOTARY_KEY.sign(SignableData(wtx.id, SignatureMetadata(1, Crypto.findSignatureScheme(DUMMY_NOTARY_KEY.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$makeSigned(wtx, DUMMY_KEY_1, ak).verifySignaturesExcept(compKey, DUMMY_KEY_2.public)</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$val baseOutState = TransactionState(DummyContract.SingleOwnerState(0, ALICE), DummyContract.PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$val keySigs = keys.map { it.sign(SignableData(wtx.id, SignatureMetadata(1, Crypto.findSignatureScheme(it.public).schemeNumberID))) }</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$val outputState = TransactionState(DummyContract.SingleOwnerState(0, ALICE), DummyContract.PROGRAM_ID, DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:TransactionUtils.kt$ fun &lt;T : Any&gt; deserialiseComponentGroup( componentGroups: List&lt;ComponentGroup&gt;, clazz: KClass&lt;T&gt;, groupEnum: ComponentGroupEnum, forceDeserialize: Boolean = false, factory: SerializationFactory = SerializationFactory.defaultFactory, context: SerializationContext = factory.defaultContext ): List&lt;T&gt;</ID>
    <ID>MaxLineLength:TransactionUtils.kt$ fun isAttachmentTrusted(attachment: Attachment, service: AttachmentStorage?): Boolean</ID>
    <ID>MaxLineLength:TransactionUtils.kt$"Invalid Transaction. Sizes of CommandData (${commandDataList.size}) and Signers (${signersList.size}) do not match"</ID>
    <ID>MaxLineLength:TransactionUtils.kt$ContractUpgradeTransactionBuilder$val components = listOf(inputs, notary, legacyContractAttachmentId, upgradedContractClassName, upgradedContractAttachmentId, networkParametersHash).map { it.serialize() }</ID>
    <ID>MaxLineLength:TransactionUtils.kt$check(leafIndices.max()!! &lt; signersList.size) { "Invalid Transaction. A command with no corresponding signer detected" }</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (attachments.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.ATTACHMENTS_GROUP.ordinal, attachments.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (commands.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.COMMANDS_GROUP.ordinal, commands.map { it.value }.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (commands.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.SIGNERS_GROUP.ordinal, commands.map { it.signers }.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (inputs.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.INPUTS_GROUP.ordinal, inputs.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (networkParametersHash != null) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.PARAMETERS_GROUP.ordinal, listOf(networkParametersHash.serialize())))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (notary != null) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.NOTARY_GROUP.ordinal, listOf(notary).lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (outputs.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.OUTPUTS_GROUP.ordinal, outputs.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (references.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.REFERENCES_GROUP.ordinal, references.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (timeWindow != null) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.TIMEWINDOW_GROUP.ordinal, listOf(timeWindow).lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$serviceHub.networkParametersService.lookup(networkParametersHash) ?: throw IllegalArgumentException("Transaction for notarisation contains unknown parameters hash: $networkParametersHash")</ID>
    <ID>MaxLineLength:TransactionUtils.kt$val commandDataList: List&lt;CommandData&gt; = deserialiseComponentGroup(componentGroups, CommandData::class, ComponentGroupEnum.COMMANDS_GROUP, forceDeserialize)</ID>
    <ID>MaxLineLength:TransactionUtils.kt$val componentHashes = group.components.mapIndexed { index, component -&gt; componentHash(group.nonces[index], component) }</ID>
    <ID>MaxLineLength:TransactionUtils.kt$val signersList: List&lt;List&lt;PublicKey&gt;&gt; = uncheckedCast(deserialiseComponentGroup(componentGroups, List::class, ComponentGroupEnum.SIGNERS_GROUP, forceDeserialize))</ID>
    <ID>MaxLineLength:TransactionUtils.kt${ // Transactions created on Corda 3.x or below do not contain network parameters, // so no checking is done until the minimum platform version is at least 4. if (networkParametersHash == null) { if (serviceHub.networkParameters.minimumPlatformVersion &lt; 4) return else throw IllegalArgumentException("Transaction for notarisation doesn't contain network parameters hash.") } else { serviceHub.networkParametersService.lookup(networkParametersHash) ?: throw IllegalArgumentException("Transaction for notarisation contains unknown parameters hash: $networkParametersHash") } // TODO: [ENT-2666] Implement network parameters fuzzy checking. By design in Corda network we have propagation time delay. // We will never end up in perfect synchronization with all the nodes. However, network parameters update process // lets us predict what is the reasonable time window for changing parameters on most of the nodes. // For now we don't check whether the attached network parameters match the current ones. }</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$ConstraintPropagationRejection : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$Direction</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$InvalidAttachmentException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$MissingNetworkParametersException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$OverlappingAttachmentsException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$PackageOwnershipException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$SignersMissing : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$TransactionNetworkParameterOrderingException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$UntrustedAttachmentsException : CordaException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException${ /** * Indicates that one of the [Contract.verify] methods selected by the contract constraints and attachments * rejected the transaction by throwing an exception. * * @property contractClass The fully qualified class name of the failing contract. */ @KeepForDJVM class ContractRejection internal constructor( txId: SecureHash, val contractClass: String, cause: Throwable?, message: String ) : TransactionVerificationException(txId, "Contract verification failed: $message, contract: $contractClass", cause) { internal constructor(txId: SecureHash, contract: Contract, cause: Throwable) : this(txId, contract.javaClass.name, cause, cause.message ?: "") } /** * This exception happens when a transaction was not built correctly. * When a contract is not annotated with [NoConstraintPropagation], then the platform ensures that the constraints of output states transition correctly from input states. * * @property txId The transaction. * @property contractClass The fully qualified class name of the failing contract. * @property inputConstraint The constraint of the input state. * @property outputConstraint The constraint of the outputs state. */ @KeepForDJVM class ConstraintPropagationRejection( txId: SecureHash, val contractClass: String, inputConstraint: AttachmentConstraint, outputConstraint: AttachmentConstraint ) : TransactionVerificationException(txId, "Contract constraints for $contractClass are not propagated correctly. The outputConstraint: $outputConstraint is not a valid transition from the input constraint: $inputConstraint.", null) /** * The transaction attachment that contains the [contractClass] class didn't meet the constraints specified by * the [TransactionState.constraint] object. This usually implies a version mismatch of some kind. * * @property contractClass The fully qualified class name of the failing contract. */ @KeepForDJVM class ContractConstraintRejection(txId: SecureHash, val contractClass: String) : TransactionVerificationException(txId, "Contract constraints failed for $contractClass", null) /** * A state requested a contract class via its [TransactionState.contract] field that didn't appear in any attached * JAR at all. This usually implies the attachments were forgotten or a version mismatch. * * @property contractClass The fully qualified class name of the failing contract. */ @KeepForDJVM class MissingAttachmentRejection(txId: SecureHash, val contractClass: String) : TransactionVerificationException(txId, "Contract constraints failed, could not find attachment for: $contractClass", null) /** * Indicates this transaction violates the "no overlap" rule: two attachments are trying to provide the same file * path. Whereas Java classpaths would normally allow that with the first class taking precedence, this is not * allowed in transactions for security reasons. This usually indicates that two separate apps share a dependency, * in which case you could try 'shading the fat jars' to rename classes of dependencies. Or you could manually * attach dependency JARs when building the transaction. * * @property contractClass The fully qualified class name of the failing contract. */ @KeepForDJVM class ConflictingAttachmentsRejection(txId: SecureHash, val contractClass: String) : TransactionVerificationException(txId, "Contract constraints failed for: $contractClass, because multiple attachments providing this contract were attached.", null) /** * Indicates that the same attachment has been added multiple times to a transaction. */ @KeepForDJVM class DuplicateAttachmentsRejection(txId: SecureHash, val attachmentId: Attachment) : TransactionVerificationException(txId, "The attachment: $attachmentId was added multiple times.", null) /** * A [Contract] class named by a state could not be constructed. Most likely you do not have a no-argument * constructor, or the class doesn't subclass [Contract]. * * @property contractClass The fully qualified class name of the failing contract. */ @KeepForDJVM class ContractCreationError internal constructor( txId: SecureHash, val contractClass: String, cause: Throwable?, message: String ) : TransactionVerificationException(txId, "Contract verification failed: $message, could not create contract class: $contractClass", cause) { internal constructor(txId: SecureHash, contractClass: String, cause: Throwable) : this(txId, contractClass, cause, cause.message ?: "") } /** * An output state has a notary that doesn't match the transaction's notary field. It must! * * @property txNotary the [Party] specified by the transaction header. * @property outputNotary the [Party] specified by the errant state. */ @KeepForDJVM class NotaryChangeInWrongTransactionType(txId: SecureHash, val txNotary: Party, val outputNotary: Party) : TransactionVerificationException(txId, "Found unexpected notary change in transaction. Tx notary: $txNotary, found: $outputNotary", null) /** * If a state is encumbered (the [TransactionState.encumbrance] field is set) then its encumbrance must be used * as an input to any transaction that uses it. In this way states can be tied together in chains, thus composing * logic. Note that encumbrances aren't fully supported by all aspects of the platform at this time so if you use * them, you may find transactions created by the platform don't always respect the encumbrance rule. * * @property missing the index of the state missing the encumbrance. * @property inOut whether the issue exists in the input list or output list. */ @KeepForDJVM class TransactionMissingEncumbranceException(txId: SecureHash, val missing: Int, val inOut: Direction) : TransactionVerificationException(txId, "Missing required encumbrance $missing in $inOut", null) /** * If two or more states refer to another state (as their encumbrance), then the bi-directionality property cannot * be satisfied. */ @KeepForDJVM class TransactionDuplicateEncumbranceException(txId: SecureHash, index: Int) : TransactionVerificationException(txId, "The bi-directionality property of encumbered output states " + "is not satisfied. Index $index is referenced more than once", null) /** * An encumbered state should also be referenced as the encumbrance of another state in order to satisfy the * bi-directionality property (a full cycle should be present). */ @KeepForDJVM class TransactionNonMatchingEncumbranceException(txId: SecureHash, nonMatching: Collection&lt;Int&gt;) : TransactionVerificationException(txId, "The bi-directionality property of encumbered output states " + "is not satisfied. Encumbered states should also be referenced as an encumbrance of another state to form " + "a full cycle. Offending indices $nonMatching", null) /** * All encumbered states should be assigned to the same notary. This is due to the fact that multi-notary * transactions are not supported and thus two encumbered states with different notaries cannot be consumed * in the same transaction. */ @KeepForDJVM class TransactionNotaryMismatchEncumbranceException( txId: SecureHash, encumberedIndex: Int, encumbranceIndex: Int, encumberedNotary: Party, encumbranceNotary: Party ) : TransactionVerificationException(txId, "Encumbered output states assigned to different notaries found. " + "Output state with index $encumberedIndex is assigned to notary [$encumberedNotary], while its encumbrance with index $encumbranceIndex is assigned to notary [$encumbranceNotary]", null) /** * If a state is identified as belonging to a contract, either because the state class is defined as an inner class * of the contract class or because the state class is annotated with [BelongsToContract], then it must not be * bundled in a [TransactionState] with a different contract. * * @param state The [TransactionState] whose bundled state and contract are in conflict. * @param requiredContractClassName The class name of the contract to which the state belongs. */ @KeepForDJVM class TransactionContractConflictException( txId: SecureHash, state: TransactionState&lt;ContractState&gt;, requiredContractClassName: String ) : TransactionVerificationException(txId, """ State of class ${state.data::class.java.typeName} belongs to contract $requiredContractClassName, but is bundled in TransactionState with ${state.contract}. For details see: https://docs.corda.net/api-contract-constraints.html#contract-state-agreement """.trimIndent().replace('\n', ' '), null) // TODO: add reference to documentation @KeepForDJVM class TransactionRequiredContractUnspecifiedException(txId: SecureHash, state: TransactionState&lt;ContractState&gt;) : TransactionVerificationException(txId, """ State of class ${state.data::class.java.typeName} does not have a specified owning contract. Add the @BelongsToContract annotation to this class to ensure that it can only be bundled in a TransactionState with the correct contract. For details see: https://docs.corda.net/api-contract-constraints.html#contract-state-agreement """.trimIndent(), null) /** * If the network parameters associated with an input or reference state in a transaction are more recent than the network parameters of the new transaction itself. */ @KeepForDJVM class TransactionNetworkParameterOrderingException( txId: SecureHash, inputStateRef: StateRef, txnNetworkParameters: NetworkParameters, inputNetworkParameters: NetworkParameters ) : TransactionVerificationException(txId, "The network parameters epoch (${txnNetworkParameters.epoch}) of this transaction " + "is older than the epoch (${inputNetworkParameters.epoch}) of input state: $inputStateRef", null) /** * Thrown when the network parameters with hash: missingNetworkParametersHash is not available at this node. Usually all the parameters * that are in the resolution chain for transaction with txId should be fetched from peer via [FetchParametersFlow] or from network map. * * @param txId Id of the transaction that has missing parameters hash in the resolution chain * @param missingNetworkParametersHash Missing hash of the network parameters associated to this transaction */ @KeepForDJVM class MissingNetworkParametersException(txId: SecureHash, missingNetworkParametersHash: SecureHash) : TransactionVerificationException(txId, "Couldn't find network parameters with hash: $missingNetworkParametersHash related to this transaction: $txId", null) /** Whether the inputs or outputs list contains an encumbrance issue, see [TransactionMissingEncumbranceException]. */ @CordaSerializable @KeepForDJVM enum class Direction { /** Issue in the inputs list. */ INPUT, /** Issue in the outputs list. */ OUTPUT } // We could revisit and throw this more appropriate type in a future release that uses targetVersion to // avoid the compatibility break, because IllegalStateException isn't ideal for this. Or we could use this // as a cause. /** @suppress This class is not used: duplicate inputs throw a [IllegalStateException] instead. */ @Deprecated("This class is not used: duplicate inputs throw a [IllegalStateException] instead.") @DeleteForDJVM class DuplicateInputStates(txId: SecureHash, val duplicates: NonEmptySet&lt;StateRef&gt;) : TransactionVerificationException(txId, "Duplicate inputs: ${duplicates.joinToString()}", null) /** @suppress This class is obsolete and nothing has ever used it. */ @Deprecated("This class is obsolete and nothing has ever used it.") @DeleteForDJVM class MoreThanOneNotary(txId: SecureHash) : TransactionVerificationException(txId, "More than one notary", null) /** @suppress This class is obsolete and nothing has ever used it. */ @Deprecated("This class is obsolete and nothing has ever used it.") @DeleteForDJVM class SignersMissing(txId: SecureHash, val missing: List&lt;PublicKey&gt;) : TransactionVerificationException(txId, "Signers missing: ${missing.joinToString()}", null) /** @suppress This class is obsolete and nothing has ever used it. */ @Deprecated("This class is obsolete and nothing has ever used it.") @DeleteForDJVM class InvalidNotaryChange(txId: SecureHash) : TransactionVerificationException(txId, "Detected a notary change. Outputs must use the same notary as inputs", null) /** * Thrown when multiple attachments provide the same file when building the AttachmentsClassloader for a transaction. */ @KeepForDJVM class OverlappingAttachmentsException(txId: SecureHash, val path: String) : TransactionVerificationException(txId, "Multiple attachments define a file at $path.", null) /** * Thrown to indicate that a contract attachment is not signed by the network-wide package owner. Please note that * the [txId] will always be [SecureHash.zeroHash] because package ownership is an error with a particular attachment, * and because attachment classloaders are reused this is independent of any particular transaction. */ class PackageOwnershipException( txId: SecureHash, @Suppress("unused") val attachmentHash: AttachmentId, @Suppress("unused") val invalidClassName: String, val packageName: String ) : TransactionVerificationException(txId, """The attachment JAR: $attachmentHash containing the class: $invalidClassName is not signed by the owner of package $packageName specified in the network parameters. Please check the source of this attachment and if it is malicious contact your zone operator to report this incident. For details see: https://docs.corda.net/network-map.html#network-parameters""".trimIndent(), null) class InvalidAttachmentException(txId: SecureHash, @Suppress("unused") val attachmentHash: AttachmentId) : TransactionVerificationException(txId, "The attachment $attachmentHash is not a valid ZIP or JAR file.".trimIndent(), null) // TODO: Make this descend from TransactionVerificationException so that untrusted attachments cause flows to be hospitalized. /** Thrown during classloading upon encountering an untrusted attachment (eg. not in the [TRUSTED_UPLOADERS] list) */ @KeepForDJVM class UntrustedAttachmentsException(val txId: SecureHash, val ids: List&lt;SecureHash&gt;) : CordaException("Attempting to load untrusted transaction attachments: $ids. " + "At this time these are not loadable because the DJVM sandbox has not yet been integrated. " + "You will need to manually install the CorDapp to whitelist it for use. " + "Please follow the operational steps outlined in https://docs.corda.net/cordapp-build-systems.html#cordapp-contract-attachments to learn more and continue.") /* If you add a new class extending [TransactionVerificationException], please add a test in `TransactionVerificationExceptionSerializationTests` proving that it can actually be serialised. As a rule, exceptions intended to be serialised _must_ have a corresponding readable property for every named constructor parameter - so make your constructor parameters `val`s even if nothing other than the serializer is ever going to read them. */ }</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.ConflictingAttachmentsRejection$TransactionVerificationException(txId, "Contract constraints failed for: $contractClass, because multiple attachments providing this contract were attached.", null)</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.ConstraintPropagationRejection$TransactionVerificationException(txId, "Contract constraints for $contractClass are not propagated correctly. The outputConstraint: $outputConstraint is not a valid transition from the input constraint: $inputConstraint.", null)</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.ContractCreationError$TransactionVerificationException(txId, "Contract verification failed: $message, could not create contract class: $contractClass", cause)</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.ContractCreationError$internal constructor(txId: SecureHash, contractClass: String, cause: Throwable) : this(txId, contractClass, cause, cause.message ?: "")</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.ContractRejection$( txId: SecureHash, val contractClass: String, cause: Throwable?, message: String )</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.ContractRejection$internal constructor(txId: SecureHash, contract: Contract, cause: Throwable) : this(txId, contract.javaClass.name, cause, cause.message ?: "")</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.InvalidNotaryChange$TransactionVerificationException(txId, "Detected a notary change. Outputs must use the same notary as inputs", null)</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.MissingAttachmentRejection$TransactionVerificationException(txId, "Contract constraints failed, could not find attachment for: $contractClass", null)</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.MissingNetworkParametersException$TransactionVerificationException(txId, "Couldn't find network parameters with hash: $missingNetworkParametersHash related to this transaction: $txId", null)</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.NotaryChangeInWrongTransactionType$TransactionVerificationException(txId, "Found unexpected notary change in transaction. Tx notary: $txNotary, found: $outputNotary", null)</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.PackageOwnershipException$ Please check the source of this attachment and if it is malicious contact your zone operator to report this incident.</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.PackageOwnershipException$"""The attachment JAR: $attachmentHash containing the class: $invalidClassName is not signed by the owner of package $packageName specified in the network parameters. Please check the source of this attachment and if it is malicious contact your zone operator to report this incident. For details see: https://docs.corda.net/network-map.html#network-parameters"""</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.TransactionNetworkParameterOrderingException$TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.TransactionNonMatchingEncumbranceException$"is not satisfied. Encumbered states should also be referenced as an encumbrance of another state to form "</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.TransactionNotaryMismatchEncumbranceException$"Output state with index $encumberedIndex is assigned to notary [$encumberedNotary], while its encumbrance with index $encumbranceIndex is assigned to notary [$encumbranceNotary]"</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.TransactionRequiredContractUnspecifiedException$ Add the @BelongsToContract annotation to this class to ensure that it can only be bundled in a TransactionState</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.UntrustedAttachmentsException$"Please follow the operational steps outlined in https://docs.corda.net/cordapp-build-systems.html#cordapp-contract-attachments to learn more and continue."</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$net.corda.core.contracts.TransactionVerificationException.kt</ID>
    <ID>MaxLineLength:TransactionVerificationExceptionSerialisationTests.kt$TransactionVerificationExceptionSerialisationTests$val exception = TransactionVerificationException.NotaryChangeInWrongTransactionType(txid, dummyBankA, dummyNotary)</ID>
    <ID>MaxLineLength:TransactionVerificationRequest.kt$TransactionVerificationRequest$@Suppress("MemberVisibilityCanBePrivate") // TODO the use of deprecated toLedgerTransaction need to be revisited as resolveContractAttachment requires attachments of the transactions which created input states... // TODO ...to check contract version non downgrade rule, curretly dummy Attachment if not fund is used which sets contract version to '1' @CordaSerializable</ID>
    <ID>MaxLineLength:TransactionVerificationRequest.kt$TransactionVerificationRequest$attachments .mapNotNull { it as? MockContractAttachment } .associateBy(Attachment::id) { ContractAttachment(it, it.contract, uploader = DEPLOYED_CORDAPP_UPLOADER) }</ID>
    <ID>MaxLineLength:TransactionVerifierService.kt$TransactionVerifierService$ fun verify(transaction: LedgerTransaction): CordaFuture&lt;*&gt;</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$ State of class </ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$ private fun validateStatesAgainstContract()</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyConstraints(contractAttachmentsByContract: Map&lt;ContractClassName, ContractAttachment&gt;)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyConstraintsValidity(contractAttachmentsByContract: Map&lt;ContractClassName, ContractAttachment&gt;)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$// Using basic graph theory, a full cycle of encumbered (co-dependent) states should exist to achieve bi-directional // encumbrances. This property is important to ensure that no states involved in an encumbrance-relationship // can be spent on their own. Briefly, if any of the states is having more than one encumbrance references by // other states, a full cycle detection will fail. As a result, all of the encumbered states must be present // as "from" and "to" only once (or zero times if no encumbrance takes place). For instance, // a -&gt; b // c -&gt; b and a -&gt; b // b -&gt; a b -&gt; c // do not satisfy the bi-directionality (full cycle) property. // // In the first example "b" appears twice in encumbrance ("to") list and "c" exists in the encumbered ("from") list only. // Due the above, one could consume "a" and "b" in the same transaction and then, because "b" is already consumed, "c" cannot be spent. // // Similarly, the second example does not form a full cycle because "a" and "c" exist in one of the lists only. // As a result, one can consume "b" and "c" in the same transactions, which will make "a" impossible to be spent. // // On other hand the following are valid constructions: // a -&gt; b a -&gt; c // b -&gt; c and c -&gt; b // c -&gt; a b -&gt; a // and form a full cycle, meaning that the bi-directionality property is satisfied. private fun checkBidirectionalOutputEncumbrances(statesAndEncumbrance: List&lt;Pair&lt;Int, Int&gt;&gt;)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$?:</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$checkMinimumPlatformVersion(ltx.networkParameters?.minimumPlatformVersion ?: 1, 4, "Signature constraints")</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$contractAttachmentsPerContract .groupBy { it.first } // Group by contract. .filter { (_, attachments) -&gt; attachments.size &gt; 1 }</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$if (contractWithMultipleAttachments != null) throw TransactionVerificationException.ConflictingAttachmentsRejection(ltx.id, contractWithMultipleAttachments)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$if (ltx.attachments.size != ltx.attachments.toSet().size) throw TransactionVerificationException.DuplicateAttachmentsRejection(ltx.id, ltx.attachments.groupBy { it }.filterValues { it.size &gt; 1 }.keys.first())</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$if (result.keys != contractClasses) throw TransactionVerificationException.MissingAttachmentRejection(ltx.id, contractClasses.minus(result.keys).first())</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$throw TransactionVerificationException.NotaryChangeInWrongTransactionType(ltx.id, ltx.notary, it.notary)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$throw TransactionVerificationException.TransactionNonMatchingEncumbranceException(ltx.id, symmetricDifference)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$val constraintAttachment = AttachmentWithContext(contractAttachment, contract, ltx.networkParameters!!.whitelistedContractImplementations)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$val inputConstraints = (inputContractGroups[contractClassName] ?: emptyList()).map { it.state.constraint }.toSet()</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$val outputConstraints = (outputContractGroups[contractClassName] ?: emptyList()).map { it.constraint }.toSet()</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier${ // checkNoNotaryChange and checkEncumbrancesValid are called here, and not in the c'tor, as they need access to the "outputs" // list, the contents of which need to be deserialized under the correct classloader. checkNoNotaryChange() checkEncumbrancesValid() // The following checks ensure the integrity of the current transaction and also of the future chain. // See: https://docs.corda.net/head/api-contract-constraints.html // A transaction contains both the data and the code that must be executed to validate the transition of the data. // Transactions can be created by malicious adversaries, who can try to use code that allows them to create transactions that appear valid but are not. // 1. Check that there is one and only one attachment for each relevant contract. val contractAttachmentsByContract = getUniqueContractAttachmentsByContract() // 2. Check that the attachments satisfy the constraints of the states. (The contract verification code is correct.) verifyConstraints(contractAttachmentsByContract) // 3. Check that the actual state constraints are correct. This is necessary because transactions can be built by potentially malicious nodes // who can create output states with a weaker constraint which can be exploited in a future transaction. verifyConstraintsValidity(contractAttachmentsByContract) // 4. Check that the [TransactionState] objects are correctly formed. validateStatesAgainstContract() // 5. Final step is to run the contract code. After the first 4 steps we are now sure that we are running the correct code. verifyContracts() }</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier${ if (!contractClassName.contractHasAutomaticConstraintPropagation(transactionClassLoader)) { contractClassName.warnContractWithoutConstraintPropagation() continue } val contractAttachment = contractAttachmentsByContract[contractClassName]!! // Verify that the constraints of output states have at least the same level of restriction as the constraints of the // corresponding input states. val inputConstraints = (inputContractGroups[contractClassName] ?: emptyList()).map { it.state.constraint }.toSet() val outputConstraints = (outputContractGroups[contractClassName] ?: emptyList()).map { it.constraint }.toSet() outputConstraints.forEach { outputConstraint -&gt; inputConstraints.forEach { inputConstraint -&gt; if (!(outputConstraint.canBeTransitionedFrom(inputConstraint, contractAttachment))) { throw TransactionVerificationException.ConstraintPropagationRejection( ltx.id, contractClassName, inputConstraint, outputConstraint) } } } }</ID>
    <ID>MaxLineLength:TransactionViewer.kt$ private fun calculateTotalEquiv( myIdentity: Party?, reportingCurrencyExchange: Pair&lt;Currency, (Amount&lt;Currency&gt;) -&gt; Amount&lt;Currency&gt;&gt;, inputs: List&lt;ContractState&gt;, outputs: List&lt;ContractState&gt; ): AmountDiff&lt;Currency&gt;</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$"Input Party" to { tx, s -&gt; tx.inputParties.any { it.any { it.value?.name?.organisation?.contains(s, true) == true } } }</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$"Output Party" to { tx, s -&gt; tx.outputParties.any { it.any { it.value?.name?.organisation?.contains(s, true) == true } } }</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$// Column stays the same size, but we don't violate column restricted resize policy for the whole table view. // It removes that irritating column at the end of table that does nothing. minWidth = 26.0 maxWidth = 26.0</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$Transaction</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$private fun ObservableList&lt;StateAndRef&lt;ContractState&gt;&gt;.getParties()</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$private fun ObservableList&lt;StateAndRef&lt;ContractState&gt;&gt;.toText()</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$val commands = if (it.transaction.coreTransaction is WireTransaction) it.transaction.tx.commands else emptyList()</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer.ContractStatesView$copyableLabel(party.map { "${signature.toStringShort()} (${it?.let { PartyNameFormatter.short.format(it.name) } ?: "Anonymous"})" })</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer.ContractStatesView$label</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer.ContractStatesView$val issuer: AbstractParty = anonymousIssuer.owningKey.toKnownParty().value ?: anonymousIssuer</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer.TransactionWidget$private val partiallyResolvedTransactions by observableListReadOnly(TransactionDataModel::partiallyResolvedTransactions)</ID>
    <ID>MaxLineLength:TransactionViewer.kt$outputs.mapNotNull { it as? Cash.State } .filter { it.amount.token.issuer.party.owningKey.toKnownParty().value == myIdentity &amp;&amp; it.owner.owningKey.toKnownParty().value != myIdentity }</ID>
    <ID>MaxLineLength:TransactionWithSignatures.kt$TransactionWithSignatures${ val sigKeys = sigs.map { it.by }.toSet() // TODO Problem is that we can get single PublicKey wrapped as CompositeKey in allowedToBeMissing/mustSign // equals on CompositeKey won't catch this case (do we want to single PublicKey be equal to the same key wrapped in CompositeKey with threshold 1?) return requiredSigningKeys.filter { !it.isFulfilledBy(sigKeys) }.toSet() }</ID>
    <ID>MaxLineLength:TransformsSchema.kt$TransformsAnnotationProcessor</ID>
    <ID>MaxLineLength:TransitionBuilder.kt$CannotFindSessionException : IllegalStateException</ID>
    <ID>MaxLineLength:TransitionExecutor.kt$TransitionExecutor$ fun forceRemoveFlow(id: StateMachineRunId)</ID>
    <ID>MaxLineLength:TransitionExecutorImpl.kt$TransitionExecutorImpl$log.warn("Error while executing $action during transition to errored state, aborting transition", exception)</ID>
    <ID>MaxLineLength:TransitionExecutorImpl.kt$TransitionExecutorImpl${ // If we errored while transitioning to an error state then we cannot record the additional // error as that may result in an infinite loop, e.g. error propagation fails -&gt; record error -&gt; propagate fails again. // Instead we just keep around the old error state and wait for a new schedule, perhaps // triggered from a flow hospital log.warn("Error while executing $action during transition to errored state, aborting transition", exception) return Pair(FlowContinuation.Abort, previousState.copy(isFlowResumed = false)) }</ID>
    <ID>MaxLineLength:Try.kt$Try$ fun doOnFailure(action: Consumer&lt;Throwable&gt;): Try&lt;A&gt;</ID>
    <ID>MaxLineLength:Try.kt$Try$ fun doOnSuccess(action: Consumer&lt;in A&gt;): Try&lt;A&gt;</ID>
    <ID>MaxLineLength:Try.kt$Try$ inline fun &lt;B&gt; flatMap(function: (A) -&gt; Try&lt;B&gt;): Try&lt;B&gt;</ID>
    <ID>MaxLineLength:Try.kt$Try.Companion$ @JvmStatic inline fun &lt;T&gt; on(body: () -&gt; T): Try&lt;T&gt;</ID>
    <ID>MaxLineLength:TutorialContract.kt$CommercialPaper$"output states are issued by a command signer" using (output.issuance.party.owningKey in command.signers)</ID>
    <ID>MaxLineLength:TutorialContract.kt$CommercialPaper$"the transaction is signed by the owner of the CP" using (input.owner.owningKey in command.signers)</ID>
    <ID>MaxLineLength:TutorialContract.kt$CommercialPaper$return TransactionBuilder(notary = notary).withItems(stateAndContract, Command(Commands.Issue(), issuance.party.owningKey))</ID>
    <ID>MaxLineLength:TutorialContract.kt$State$override fun withNewOwner(newOwner: AbstractParty)</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Acceptor$override</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Acceptor$return Triple(ptx, arrayListOf(deal.participants.single { it is Party &amp;&amp; serviceHub.myInfo.isLegalIdentity(it) }.owningKey), emptyList())</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Primary$abstract</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$@Suspendable protected abstract</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$abstract</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$require(wellKnownMe == ourIdentity) { "Well known party for handshake identity ${it.secondaryIdentity} does not match ourIdentity" }</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$require(wellKnownOtherParty == otherSideSession.counterparty) { "Well known party for handshake identity ${it.primaryIdentity} does not match counterparty" }</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$serviceHub.signInitialTransaction(utx, additionalSigningPubKeys).withAdditionalSignatures(additionalSignatures)</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$val ptxSignedByOtherSide = ptx + subFlow(CollectSignatureFlow(ptx, otherSideSession, otherSideSession.counterparty.owningKey))</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$val sessionsForOtherSigners = excludeNotary(groupPublicKeysByWellKnownParty(serviceHub, ptxSignedByOtherSide.getMissingSigners()), ptxSignedByOtherSide).map { initiateFlow(it.key) }</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$val stx = subFlow(CollectSignaturesFlow(ptxSignedByOtherSide, sessionsForOtherSigners, additionalSigningPubKeys))</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow${ // TODO: Common elements in multi-party transaction consensus and signing should be refactored into a superclass of this // and [AbstractStateReplacementFlow]. class UnacceptablePriceException(givenPrice: Amount&lt;Currency&gt;) : FlowException("Unacceptable price: $givenPrice") class AssetMismatchException(val expectedTypeName: String, val typeName: String) : FlowException() { override fun toString() = "The submitted asset didn't match the expected type: $expectedTypeName vs $typeName" } /** * This object is serialised to the network and is the first flow message the seller sends to the buyer. * * @param payToIdentity anonymous identity of the seller, for payment to be sent to. */ @CordaSerializable data class SellerTradeInfo( val price: Amount&lt;Currency&gt;, val payToIdentity: PartyAndCertificate ) open class Seller( private val otherSideSession: FlowSession, private val assetToSell: StateAndRef&lt;OwnableState&gt;, private val price: Amount&lt;Currency&gt;, private val myParty: PartyAndCertificate, // TODO Left because in tests it's used to pass anonymous party. override val progressTracker: ProgressTracker = Seller.tracker() ) : FlowLogic&lt;SignedTransaction&gt;() { companion object { object AWAITING_PROPOSAL : ProgressTracker.Step("Awaiting transaction proposal") // DOCSTART 3 object VERIFYING_AND_SIGNING : ProgressTracker.Step("Verifying and signing transaction proposal") { override fun childProgressTracker() = SignTransactionFlow.tracker() } // DOCEND 3 fun tracker() = ProgressTracker(AWAITING_PROPOSAL, VERIFYING_AND_SIGNING) } // DOCSTART 4 @Suspendable override fun call(): SignedTransaction { progressTracker.currentStep = AWAITING_PROPOSAL // Make the first message we'll send to kick off the flow. val hello = SellerTradeInfo(price, myParty) // What we get back from the other side is a transaction that *might* be valid and acceptable to us, // but we must check it out thoroughly before we sign! // SendTransactionFlow allows seller to access our data to resolve the transaction. subFlow(SendStateAndRefFlow(otherSideSession, listOf(assetToSell))) otherSideSession.send(hello) // Verify and sign the transaction. progressTracker.currentStep = VERIFYING_AND_SIGNING // DOCSTART 07 // Sync identities to ensure we know all of the identities involved in the transaction we're about to // be asked to sign subFlow(IdentitySyncFlow.Receive(otherSideSession)) // DOCEND 07 // DOCSTART 5 val signTransactionFlow = object : SignTransactionFlow(otherSideSession, VERIFYING_AND_SIGNING.childProgressTracker()) { override fun checkTransaction(stx: SignedTransaction) { // Verify that we know who all the participants in the transaction are val states: Iterable&lt;ContractState&gt; = serviceHub.loadStates(stx.tx.inputs.toSet()).map { it.state.data } + stx.tx.outputs.map { it.data } states.forEach { state -&gt; state.participants.forEach { anon -&gt; require(serviceHub.identityService.wellKnownPartyFromAnonymous(anon) != null) { "Transaction state $state involves unknown participant $anon" } } } if (stx.tx.outputStates.sumCashBy(myParty.party).withoutIssuer() != price) throw FlowException("Transaction is not sending us the right amount of cash") } } val txId = subFlow(signTransactionFlow).id // DOCEND 5 return subFlow(ReceiveFinalityFlow(otherSideSession, expectedTxId = txId)) } // DOCEND 4 // Following comment moved here so that it doesn't appear in the docsite: // There are all sorts of funny games a malicious secondary might play with it sends maybeSTX, // we should fix them: // // - This tx may attempt to send some assets we aren't intending to sell to the secondary, if // we're reusing keys! So don't reuse keys! // - This tx may include output states that impose odd conditions on the movement of the cash, // once we implement state pairing. // // but the goal of this code is not to be fully secure (yet), but rather, just to find good ways to // express flow state machines on top of the messaging layer. } open class Buyer( private val sellerSession: FlowSession, private val notary: Party, private val acceptablePrice: Amount&lt;Currency&gt;, private val typeToBuy: Class&lt;out OwnableState&gt;, private val anonymous: Boolean ) : FlowLogic&lt;SignedTransaction&gt;() { constructor( otherSideSession: FlowSession, notary: Party, acceptablePrice: Amount&lt;Currency&gt;, typeToBuy: Class&lt;out OwnableState&gt; ) : this(otherSideSession, notary, acceptablePrice, typeToBuy, true) // DOCSTART 2 object RECEIVING : ProgressTracker.Step("Waiting for seller trading info") object VERIFYING : ProgressTracker.Step("Verifying seller assets") object SIGNING : ProgressTracker.Step("Generating and signing transaction proposal") object COLLECTING_SIGNATURES : ProgressTracker.Step("Collecting signatures from other parties") { override fun childProgressTracker() = CollectSignaturesFlow.tracker() } object RECORDING : ProgressTracker.Step("Recording completed transaction") { // TODO: Currently triggers a race condition on Team City. See https://github.com/corda/corda/issues/733. // override fun childProgressTracker() = FinalityFlow.tracker() } override val progressTracker = ProgressTracker(RECEIVING, VERIFYING, SIGNING, COLLECTING_SIGNATURES, RECORDING) // DOCEND 2 // DOCSTART 1 @Suspendable override fun call(): SignedTransaction { // Wait for a trade request to come in from the other party. progressTracker.currentStep = RECEIVING val (assetForSale, tradeRequest) = receiveAndValidateTradeRequest() // Create the identity we'll be paying to, and send the counterparty proof we own the identity val buyerAnonymousIdentity = if (anonymous) serviceHub.keyManagementService.freshKeyAndCert(ourIdentityAndCert, false) else ourIdentityAndCert // Put together a proposed transaction that performs the trade, and sign it. progressTracker.currentStep = SIGNING val (ptx, cashSigningPubKeys) = assembleSharedTX(assetForSale, tradeRequest, buyerAnonymousIdentity) // DOCSTART 6 // Now sign the transaction with whatever keys we need to move the cash. val partSignedTx = serviceHub.signInitialTransaction(ptx, cashSigningPubKeys) // Sync up confidential identities in the transaction with our counterparty subFlow(IdentitySyncFlow.Send(sellerSession, ptx.toWireTransaction(serviceHub))) // Send the signed transaction to the seller, who must then sign it themselves and commit // it to the ledger by sending it to the notary. progressTracker.currentStep = COLLECTING_SIGNATURES val sellerSignature = subFlow(CollectSignatureFlow(partSignedTx, sellerSession, sellerSession.counterparty.owningKey)) val twiceSignedTx = partSignedTx + sellerSignature // DOCEND 6 // Notarise and record the transaction. progressTracker.currentStep = RECORDING return subFlow(FinalityFlow(twiceSignedTx, sellerSession)) } @Suspendable private fun receiveAndValidateTradeRequest(): Pair&lt;StateAndRef&lt;OwnableState&gt;, SellerTradeInfo&gt; { val assetForSale = subFlow(ReceiveStateAndRefFlow&lt;OwnableState&gt;(sellerSession)).single() return assetForSale to sellerSession.receive&lt;SellerTradeInfo&gt;().unwrap { progressTracker.currentStep = VERIFYING // What is the seller trying to sell us? val asset = assetForSale.state.data val assetTypeName = asset.javaClass.name // The asset must either be owned by the well known identity of the counterparty, or we must be able to // prove the owner is a confidential identity of the counterparty. val assetForSaleIdentity = serviceHub.identityService.wellKnownPartyFromAnonymous(asset.owner) require(assetForSaleIdentity == sellerSession.counterparty) { "Well known identity lookup returned identity that does not match counterparty" } // Register the identity we're about to send payment to. This shouldn't be the same as the asset owner // identity, so that anonymity is enforced. val wellKnownPayToIdentity = serviceHub.identityService.verifyAndRegisterIdentity(it.payToIdentity) ?: it.payToIdentity require(wellKnownPayToIdentity.party == sellerSession.counterparty) { "Well known identity to pay to must match counterparty identity" } if (it.price &gt; acceptablePrice) throw UnacceptablePriceException(it.price) if (!typeToBuy.isInstance(asset)) throw AssetMismatchException(typeToBuy.name, assetTypeName) it } } @Suspendable private fun assembleSharedTX( assetForSale: StateAndRef&lt;OwnableState&gt;, tradeRequest: SellerTradeInfo, buyerAnonymousIdentity: PartyAndCertificate ): SharedTx { val ptx = TransactionBuilder(notary) // Add input and output states for the movement of cash, by using the Cash contract to generate the states val (tx, cashSigningPubKeys) = CashUtils.generateSpend(serviceHub, ptx, tradeRequest.price, ourIdentityAndCert, tradeRequest.payToIdentity.party) // Add inputs/outputs/a command for the movement of the asset. tx.addInputState(assetForSale) val (command, state) = assetForSale.state.data.withNewOwner(buyerAnonymousIdentity.party) tx.addOutputState(state, assetForSale.state.contract, assetForSale.state.notary) tx.addCommand(command, assetForSale.state.data.owner.owningKey) // We set the transaction's time-window: it may be that none of the contracts need this! // But it can't hurt to have one. val currentTime = serviceHub.clock.instant() tx.setTimeWindow(currentTime, 30.seconds) return SharedTx(tx, cashSigningPubKeys) } // DOCEND 1 data class SharedTx(val tx: TransactionBuilder, val cashSigningPubKeys: List&lt;PublicKey&gt;) } }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$require(assetForSaleIdentity == sellerSession.counterparty) { "Well known identity lookup returned identity that does not match counterparty" }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$require(wellKnownPayToIdentity.party == sellerSession.counterparty) { "Well known identity to pay to must match counterparty identity" }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$val (tx, cashSigningPubKeys) = CashUtils.generateSpend(serviceHub, ptx, tradeRequest.price, ourIdentityAndCert, tradeRequest.payToIdentity.party)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$val sellerSignature = subFlow(CollectSignatureFlow(partSignedTx, sellerSession, sellerSession.counterparty.owningKey))</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$val wellKnownPayToIdentity = serviceHub.identityService.verifyAndRegisterIdentity(it.payToIdentity) ?: it.payToIdentity</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller$val signTransactionFlow = object : SignTransactionFlow(otherSideSession, VERIFYING_AND_SIGNING.childProgressTracker()) { override fun checkTransaction(stx: SignedTransaction) { // Verify that we know who all the participants in the transaction are val states: Iterable&lt;ContractState&gt; = serviceHub.loadStates(stx.tx.inputs.toSet()).map { it.state.data } + stx.tx.outputs.map { it.data } states.forEach { state -&gt; state.participants.forEach { anon -&gt; require(serviceHub.identityService.wellKnownPartyFromAnonymous(anon) != null) { "Transaction state $state involves unknown participant $anon" } } } if (stx.tx.outputStates.sumCashBy(myParty.party).withoutIssuer() != price) throw FlowException("Transaction is not sending us the right amount of cash") } }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller.&lt;no name provided&gt;$val states: Iterable&lt;ContractState&gt; = serviceHub.loadStates(stx.tx.inputs.toSet()).map { it.state.data } + stx.tx.outputs.map { it.data }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$( // Buyer Bob is told about Alice's commercial paper, but doesn't know it .. expect(TxRecord.Get(alicesFakePaper[0].id)), // He asks and gets the tx, validates it, sees it's a self issue with no dependencies, stores. expect(TxRecord.Add(alicesSignedTxns.values.first())), // Alice gets Bob's proposed transaction and doesn't know his two cash states. She asks, Bob answers. expect(TxRecord.Get(bobsFakeCash[1].id)), expect(TxRecord.Get(bobsFakeCash[2].id)), // Alice notices that Bob's cash txns depend on a third tx she also doesn't know. She asks, Bob answers. expect(TxRecord.Get(bobsFakeCash[0].id)) )</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$( // Seller Alice sends her seller info to Bob, who wants to check the asset for sale. // He requests, Alice looks up in her DB to send the tx to Bob expect(TxRecord.Get(alicesFakePaper[0].id)), // Seller Alice gets a proposed tx which depends on Bob's two cash txns and her own tx. expect(TxRecord.Get(bobsFakeCash[1].id)), expect(TxRecord.Get(bobsFakeCash[2].id)), expect(TxRecord.Get(alicesFakePaper[0].id)), // Alice notices that Bob's cash txns depend on a third tx she also doesn't know. expect(TxRecord.Get(bobsFakeCash[0].id)), // Bob answers with the transactions that are now all verifiable, as Alice bottomed out. // Bob's transactions are valid, so she commits to the database // expect(TxRecord.Add(bobsSignedTxns[bobsFakeCash[0].id]!!)), //TODO investigate missing event after introduction of signature constraints non-downgrade rule expect(TxRecord.Get(bobsFakeCash[0].id)), // Verify expect(TxRecord.Add(bobsSignedTxns[bobsFakeCash[2].id]!!)), expect(TxRecord.Get(bobsFakeCash[0].id)), // Verify expect(TxRecord.Add(bobsSignedTxns[bobsFakeCash[1].id]!!)), // Now she verifies the transaction is contract-valid (not signature valid) which means // looking up the states again. expect(TxRecord.Get(bobsFakeCash[1].id)), expect(TxRecord.Get(bobsFakeCash[2].id)), expect(TxRecord.Get(alicesFakePaper[0].id)), // Alice needs to look up the input states to find out which Notary they point to expect(TxRecord.Get(bobsFakeCash[1].id)), expect(TxRecord.Get(bobsFakeCash[2].id)), expect(TxRecord.Get(alicesFakePaper[0].id)) )</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$// Insert a prospectus type attachment into the commercial paper transaction. val stream = ByteArrayOutputStream() JarOutputStream(stream).use { it.putNextEntry(ZipEntry("Prospectus.txt")) it.write("Our commercial paper is top notch stuff".toByteArray()) it.closeEntry() } val attachmentID = aliceNode.database.transaction { attachment(stream.toByteArray().inputStream()) } val bobsKey = bobNode.services.keyManagementService.keys.single() val bobsFakeCash = bobNode.database.transaction { fillUpForBuyerAndInsertFakeTransactions(false, issuer, AnonymousParty(bobsKey), notary, bobNode, bob, notaryNode, bankNode) }.second val alicesFakePaper = aliceNode.database.transaction { fillUpForSeller(false, issuer, alice, 1200.DOLLARS `issued by` bank.ref(0), attachmentID, notary).second } insertFakeTransactions(alicesFakePaper, aliceNode, alice, notaryNode, bankNode) val aliceTxStream = aliceNode.services.validatedTransactions.track().updates val aliceTxMappings = with(aliceNode) { database.transaction { services.stateMachineRecordedTransactionMapping.track().updates } } val aliceSmId = runBuyerAndSeller(notary, bob, aliceNode, bobNode, "alice's paper".outputStateAndRef()).sellerId mockNet.runNetwork() // We need to declare this here, if we do it inside [expectEvents] kotlin throws an internal compiler error(!). val aliceTxExpectations = sequence( expect { tx: SignedTransaction -&gt; require(tx.id == bobsFakeCash[0].id) }, expect { tx: SignedTransaction -&gt; require(tx.id == bobsFakeCash[2].id) }, expect { tx: SignedTransaction -&gt; require(tx.id == bobsFakeCash[1].id) } ) aliceTxStream.expectEvents { aliceTxExpectations } val aliceMappingExpectations = sequence( expect&lt;StateMachineTransactionMapping&gt; { (stateMachineRunId, transactionId) -&gt; require(stateMachineRunId == aliceSmId) require(transactionId == bobsFakeCash[0].id) }, expect&lt;StateMachineTransactionMapping&gt; { (stateMachineRunId, transactionId) -&gt; require(stateMachineRunId == aliceSmId) require(transactionId == bobsFakeCash[2].id) }, expect { (stateMachineRunId, transactionId) -&gt; require(stateMachineRunId == aliceSmId) require(transactionId == bobsFakeCash[1].id) } ) aliceTxMappings.expectEvents { aliceMappingExpectations }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$SignableData(id, SignatureMetadata(1, Crypto.findSignatureScheme(notaryParty.owningKey).schemeNumberID))</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$VaultFiller(bobNode.services, dummyNotary, notary, ::Random).fillWithSomeTestCash(2000.DOLLARS, bankNode.services, 3, 10, cashIssuer)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$VaultFiller(bobNode.services, dummyNotary, notary, ::Random).fillWithSomeTestCash(2000.DOLLARS, bankNode.services, 3, 10, issuer)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$VaultFiller(bobNode.services, dummyNotary, notary, ::Random).fillWithSomeTestCash(2000.DOLLARS, bankNode.services, 3, issuer)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$fillUpForBuyerAndInsertFakeTransactions(bobError, issuer, bob, notary, bobNode, bob, notaryNode, bankNode).second</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$fillUpForBuyerAndInsertFakeTransactions(false, issuer, AnonymousParty(bob.owningKey), notary, bobNode, bob, notaryNode, bankNode)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$fillUpForBuyerAndInsertFakeTransactions(false, issuer, AnonymousParty(bobsKey), notary, bobNode, bob, notaryNode, bankNode)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$output(Cash.PROGRAM_ID, "bob cash 1", notary = notary, contractState = 800.DOLLARS.CASH issuedBy issuer ownedBy owner)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$output(Cash.PROGRAM_ID, "bob cash 2", notary = notary, contractState = 300.DOLLARS.CASH issuedBy issuer ownedBy owner)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$output(Cash.PROGRAM_ID, "elbonian money 1", notary = notary, contractState = 800.DOLLARS.CASH issuedBy issuer ownedBy interimOwner)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$output(Cash.PROGRAM_ID, "elbonian money 2", notary = notary, contractState = 1000.DOLLARS.CASH issuedBy issuer ownedBy interimOwner)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$output(Cash.PROGRAM_ID, notary = notary, contractState = 700.DOLLARS.CASH issuedBy issuer ownedBy interimOwner)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$private</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$val (bobStateMachine, aliceResult) = runBuyerAndSeller(notary, bob, aliceNode, bobNode, "alice's paper".outputStateAndRef())</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$val aliceFuture = runBuyerAndSeller(notary, bob, aliceNode, bobNode, "alice's paper".outputStateAndRef()).sellerResult</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$val aliceNode = mockNet.createPartyNode(ALICE_NAME) var bobNode = mockNet.createPartyNode(BOB_NAME) val bankNode = mockNet.createPartyNode(BOC_NAME) aliceNode.internals.disableDBCloseOnStop() bobNode.internals.disableDBCloseOnStop() val bobAddr = bobNode.network.myAddress mockNet.runNetwork() // Clear network map registration messages val alice = aliceNode.info.singleIdentity() val bank = bankNode.info.singleIdentity() val bob = bobNode.info.singleIdentity() val issuer = bank.ref(1, 2, 3) bobNode.database.transaction { VaultFiller(bobNode.services, dummyNotary, notary, ::Random).fillWithSomeTestCash(2000.DOLLARS, bankNode.services, 3, 10, issuer) } val alicesFakePaper = aliceNode.database.transaction { fillUpForSeller(false, issuer, alice, 1200.DOLLARS `issued by` bank.ref(0), null, notary).second } insertFakeTransactions(alicesFakePaper, aliceNode, alice, notaryNode, bankNode) val aliceFuture = runBuyerAndSeller(notary, bob, aliceNode, bobNode, "alice's paper".outputStateAndRef()).sellerResult // Everything is on this thread so we can now step through the flow one step at a time. // Seller Alice already sent a message to Buyer Bob. Pump once: bobNode.pumpReceive() // Bob sends a couple of queries for the dependencies back to Alice. Alice reponds. aliceNode.pumpReceive() bobNode.pumpReceive() aliceNode.pumpReceive() bobNode.pumpReceive() aliceNode.pumpReceive() bobNode.pumpReceive() // OK, now Bob has sent the partial transaction back to Alice and is waiting for Alice's signature. bobNode.database.transaction { assertThat(bobNode.internals.checkpointStorage.checkpoints()).hasSize(1) } val storage = bobNode.services.validatedTransactions val bobTransactionsBeforeCrash = bobNode.database.transaction { (storage as DBTransactionStorage).transactions } assertThat(bobTransactionsBeforeCrash).isNotEmpty // .. and let's imagine that Bob's computer has a power cut. He now has nothing now beyond what was on disk. bobNode.dispose() // Alice doesn't know that and carries on: she wants to know about the cash transactions he's trying to use. // She will wait around until Bob comes back. assertThat(aliceNode.pumpReceive()).isNotNull() // FIXME: Knowledge of confidential identities is lost on node shutdown, so Bob's node now refuses to sign the // transaction because it has no idea who the parties are. // ... bring the node back up ... the act of constructing the SMM will re-register the message handlers // that Bob was waiting on before the reboot occurred. bobNode = mockNet.createNode(InternalMockNodeParameters(bobAddr.id, BOB_NAME)) // Find the future representing the result of this state machine again. val bobFuture = bobNode.smm.findStateMachines(BuyerAcceptor::class.java).single().second // And off we go again. mockNet.runNetwork() // Bob is now finished and has the same transaction as Alice. assertThat(bobFuture.getOrThrow()).isEqualTo(aliceFuture.getOrThrow()) assertThat(bobNode.smm.findStateMachines(Buyer::class.java)).isEmpty() bobNode.database.transaction { assertThat(bobNode.internals.checkpointStorage.checkpoints()).isEmpty() } aliceNode.database.transaction { assertThat(aliceNode.internals.checkpointStorage.checkpoints()).isEmpty() } bobNode.database.transaction { val restoredBobTransactions = bobTransactionsBeforeCrash.filter { bobNode.services.validatedTransactions.getTransaction(it.id) != null } assertThat(restoredBobTransactions).containsAll(bobTransactionsBeforeCrash) } aliceNode.internals.manuallyCloseDB() bobNode.internals.manuallyCloseDB()</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests.&lt;no name provided&gt;$return RecordingTransactionStorage(database, super.makeTransactionStorage(transactionCacheSizeBytes))</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests.BuyerAcceptor$require(serviceHub.networkMapCache.isNotary(it.notaryIdentity)) { "${it.notaryIdentity} is not a notary" }</ID>
    <ID>MaxLineLength:TypeIdentifier.kt$TypeIdentifier.Companion$ fun forGenericType(type: Type, resolutionContext: Type = type): TypeIdentifier</ID>
    <ID>MaxLineLength:TypeIdentifier.kt$TypeIdentifier.Companion$is GenericArrayType -&gt; ArrayOf(forGenericType(type.genericComponentType.resolveAgainst(resolutionContext)))</ID>
    <ID>MaxLineLength:TypeLoader.kt$ClassCarpentingTypeLoader : TypeLoader</ID>
    <ID>MaxLineLength:TypeLoader.kt$TypeLoader$ fun load(remoteTypeInformation: Collection&lt;RemoteTypeInformation&gt;, context: SerializationContext): Map&lt;TypeIdentifier, Type&gt;</ID>
    <ID>MaxLineLength:TypeModellingFingerPrinter.kt$FingerPrintingState$writer.writeAlreadySeen()</ID>
    <ID>MaxLineLength:TypeParameterUtils.kt$private</ID>
    <ID>MaxLineLength:TypeParameterUtils.kt${ if (declaredClass == actualClass) { return null } if (actualClass.typeParameters.isEmpty()) { return actualClass } // The actual class can never have type variables resolved, due to the JVM's use of type erasure, so let's try and resolve them // Search for declared type in the inheritance hierarchy and then see if that fills in all the variables val implementationChain: List&lt;Type&gt; = findPathToDeclared(actualClass, declaredType)?.toList() ?: throw AMQPNotSerializableException( declaredType, "No inheritance path between actual $actualClass and declared $declaredType.") val start = implementationChain.last() val rest = implementationChain.dropLast(1).drop(1) val resolver = rest.reversed().fold(TypeResolver().where(start, declaredType)) { resolved, chainEntry -&gt; val newResolved = resolved.resolveType(chainEntry) TypeResolver().where(chainEntry, newResolved) } // The end type is a special case as it is a Class, so we need to fake up a ParameterizedType for it to get the TypeResolver to do anything. val endType = actualClass.asParameterizedType() return resolver.resolveType(endType) }</ID>
    <ID>MaxLineLength:TypesafeCordappConfigTests.kt$TypesafeCordappConfigTests$val config = ConfigFactory.parseString("string=string\nint=1\nfloat=1.0\ndouble=1.0\nnumber=2\ndouble=1.01\nbool=false")</ID>
    <ID>MaxLineLength:UniqueDummyFungibleContract.kt$UniqueDummyFungibleContract.State$override fun withNewOwnerAndAmount(newAmount: Amount&lt;Issued&lt;Currency&gt;&gt;, newOwner: AbstractParty): FungibleAsset&lt;Currency&gt;</ID>
    <ID>MaxLineLength:UniqueDummyFungibleContract.kt$UniqueDummyFungibleContract.State$return UniqueDummyFungibleStateSchema.UniquePersistentDummyFungibleState(currency = amount.token.product.currencyCode)</ID>
    <ID>MaxLineLength:UniqueDummyFungibleContract.kt$UniqueDummyFungibleStateSchema : MappedSchema</ID>
    <ID>MaxLineLength:UniqueDummyLinearContract.kt$UniqueDummyLinearStateSchema : MappedSchema</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$PersistentUniquenessProviderFactory$database = configureDatabase(makeTestDataSourceProperties(), DatabaseConfig(), { null }, { null }, NodeSchemaService(extraSchemas = setOf(NodeNotarySchemaV1)))</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$RaftUniquenessProviderFactory$database = configureDatabase(makeTestDataSourceProperties(), DatabaseConfig(), { null }, { null }, NodeSchemaService(extraSchemas = setOf(RaftNotarySchemaV1)))</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$private val requestSignature = NotarisationRequestSignature(DigitalSignature.WithKey(NullKeys.NullPublicKey, ByteArray(32)), 0)</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val response: UniquenessProvider.Result = uniquenessProvider.commit(inputs, secondTxId, identity, requestSignature).get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val response: UniquenessProvider.Result = uniquenessProvider.commit(inputs, secondTxId, identity, requestSignature, invalidTimeWindow) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val response: UniquenessProvider.Result = uniquenessProvider.commit(inputs, secondTxId, identity, requestSignature, timeWindow) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(emptyList(), firstTxId, identity, requestSignature, invalidTimeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(emptyList(), firstTxId, identity, requestSignature, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(emptyList(), firstTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(listOf(inputState), firstTxId, identity, requestSignature, references = emptyList()).get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(listOf(inputState), firstTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(listOf(inputState), txID, identity, requestSignature, invalidTimeWindow).get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(listOf(inputState1), firstTxId, identity, requestSignature, invalidTimeWindow).get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(listOf(inputState1), firstTxId, identity, requestSignature, timeWindow).get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(listOf(referenceState), firstTxId, identity, requestSignature, references = emptyList()) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(emptyList(), firstTxId, identity, requestSignature, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(emptyList(), secondTxId, identity, requestSignature, invalidTimeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(emptyList(), secondTxId, identity, requestSignature, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(emptyList(), secondTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(listOf(inputState), firstTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(listOf(inputState), secondTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(listOf(inputState1), firstTxId, identity, requestSignature, timeWindow).get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(listOf(referenceState), SecureHash.randomSHA256(), identity, requestSignature, timeWindow) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result3 = uniquenessProvider.commit(emptyList(), firstTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$"action must have a time-window" using (tx.timeWindow != null) // "action must be authorized" by (cmd.signers.any { action.actors.any { party -&gt; party.owningKey == it } }) // todo perhaps merge these two requirements? "condition must be met" using evalBoolean(tx, action.condition)</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$"the transaction is signed by all liable parties" using (liableParties(outState.details).all { it in cmd.signers })</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$Action(arr.name, replaceFixing(tx, arr.condition, fixings, unusedFixings), replaceFixing(tx, arr.arrangement, fixings, unusedFixings))</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$if (dt != null &amp;&amp; fixings.containsKey(FixOf(perceivable.source, dt.toLocalDate(), perceivable.tenor))) { unusedFixings.remove(FixOf(perceivable.source, dt.toLocalDate(), perceivable.tenor)) uncheckedCast(Const(fixings[FixOf(perceivable.source, dt.toLocalDate(), perceivable.tenor)]!!)) } else perceivable</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Actions -&gt; Actions(arr.actions.map { Action(it.name, it.condition, replaceFixing(tx, it.arrangement, fixings, unusedFixings)) }.toSet())</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Actions -&gt; Actions(arrangement.actions.map { Action(it.name, it.condition, removeNext(it.arrangement)) }.toSet())</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Actions -&gt; Actions(arrangement.actions.map { Action(it.name, it.condition, replaceNext(it.arrangement, nextReplacement)) }.toSet())</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Actions -&gt; Actions(arrangement.actions.map { Action(it.name, replaceStartEnd(it.condition, start, end), replaceStartEnd(it.arrangement, start, end)) }.toSet())</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Interest -&gt; uncheckedCast(Interest(replaceStartEnd(p.amount, start, end), p.dayCountConvention, replaceStartEnd(p.interest, start, end), replaceStartEnd(p.start, start, end), replaceStartEnd(p.end, start, end)))</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Obligation -&gt; Obligation(replaceFixing(tx, arr.amount, fixings, unusedFixings), arr.currency, arr.from, arr.to)</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Obligation -&gt; Obligation(replaceStartEnd(arrangement.amount, start, end), arrangement.currency, arrangement.from, arrangement.to)</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is PerceivableAnd -&gt; uncheckedCast(replaceStartEnd(p.left, start, end) and replaceStartEnd(p.right, start, end))</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is PerceivableOperation</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is PerceivableOperation -&gt; PerceivableOperation(replaceStartEnd(p.left, start, end), p.op, replaceStartEnd(p.right, start, end))</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is PerceivableOr -&gt; uncheckedCast(replaceStartEnd(p.left, start, end) or replaceStartEnd(p.right, start, end))</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is RollOut -&gt; RollOut(arr.startDate, arr.endDate, arr.frequency, replaceFixing(tx, arr.template, fixings, unusedFixings))</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$val action = actions[value.name] ?: throw IllegalArgumentException("Failed requirement: action must be defined")</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$val schedule = BusinessCalendar.createGenericSchedule(start, rollOut.frequency, noOfAdditionalPeriods = 1, endDate = end)</ID>
    <ID>MaxLineLength:UnstartedFlowTransition.kt$UnstartedFlowTransition$Action.PersistCheckpoint(context.id, currentState.checkpoint, isCheckpointUpdate = currentState.isAnyCheckpointPersisted)</ID>
    <ID>MaxLineLength:UnstartedFlowTransition.kt$UnstartedFlowTransition$SenderDeduplicationId(DeduplicationId.createForNormal(currentState.checkpoint, 0, initiatedState), currentState.senderUUID)</ID>
    <ID>MaxLineLength:UnstartedFlowTransition.kt$UnstartedFlowTransition$deduplicationSeed = "D-${initiatingMessage.initiatorSessionId.toLong}-${initiatingMessage.initiationEntropy}"</ID>
    <ID>MaxLineLength:Util.kt$arrangement.actions.fold(ImmutableSet.builder&lt;Party&gt;(), { builder, k -&gt; builder.addAll(involvedPartiesVisitor(k)) }).build()</ID>
    <ID>MaxLineLength:Util.kt$arrangement.actions.fold(ImmutableSet.builder&lt;PublicKey&gt;(), { builder, k -&gt; builder.addAll(liablePartiesVisitor(k)) }).build()</ID>
    <ID>MaxLineLength:Util.kt$arrangement.arrangements.fold(ImmutableSet.builder&lt;Party&gt;(), { builder, k -&gt; builder.addAll(involvedPartiesVisitor(k)) }).build()</ID>
    <ID>MaxLineLength:Util.kt$arrangement.arrangements.fold(ImmutableSet.builder&lt;PublicKey&gt;(), { builder, k -&gt; builder.addAll(liablePartiesVisitor(k)) }).build()</ID>
    <ID>MaxLineLength:Util.kt$is PerceivableAnd -&gt; Sets.union(signingParties(perceivable.left), signingParties(perceivable.right)).immutableCopy()</ID>
    <ID>MaxLineLength:Util.kt$is PerceivableOr -&gt; Sets.union(signingParties(perceivable.left), signingParties(perceivable.right)).immutableCopy()</ID>
    <ID>MaxLineLength:Util.kt$net.corda.finance.contracts.universal.Util.kt</ID>
    <ID>MaxLineLength:Utils.kt$ fun &lt;SNAPSHOT, ELEMENT&gt; DataFeed&lt;SNAPSHOT, ELEMENT&gt;.doOnError(action: (Throwable) -&gt; Unit): DataFeed&lt;SNAPSHOT, ELEMENT&gt;</ID>
    <ID>MaxLineLength:Utils.kt$ fun &lt;SNAPSHOT, ELEMENT&gt; DataFeed&lt;SNAPSHOT, ELEMENT&gt;.mapErrors(transform: (Throwable) -&gt; Throwable): DataFeed&lt;SNAPSHOT, ELEMENT&gt;</ID>
    <ID>MaxLineLength:Utils.kt$ fun &lt;T&gt; Observable&lt;T&gt;.notUsed()</ID>
    <ID>MaxLineLength:Utils.kt$ fun TransactionBuilder.addAttachmentOnce(att: SecureHash?): TransactionBuilder</ID>
    <ID>MaxLineLength:Utils.kt$( specification: Configuration.Specification&lt;NESTED&gt;, key: String? = null, sensitive: Boolean = false )</ID>
    <ID>MaxLineLength:Utils.kt$@Suppress("UNCHECKED_CAST") inline</ID>
    <ID>MaxLineLength:Utils.kt$StateRefHere</ID>
    <ID>MaxLineLength:Utils.kt$fun &lt;TYPE&gt; Configuration.Property.Definition.Single&lt;TYPE&gt;.listOrEmpty(): Configuration.Property.Definition&lt;List&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Utils.kt$fun &lt;TYPE&gt; PropertyDelegate.Single&lt;TYPE&gt;.listOrEmpty(): PropertyDelegate&lt;List&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; PropertyDelegate.RequiredList&lt;TYPE&gt;.map(noinline convert: (List&lt;TYPE&gt;) -&gt; MAPPED): PropertyDelegate.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; PropertyDelegate.Standard&lt;TYPE&gt;.map(noinline convert: (TYPE) -&gt; MAPPED): PropertyDelegate.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; PropertyDelegate.Standard&lt;TYPE&gt;.mapValid(noinline convert: (TYPE) -&gt; Valid&lt;MAPPED&gt;): PropertyDelegate.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$return requireNotNull(getDeclaredAnnotation(A::class.java)) { "$name needs to be annotated with ${A::class.java.name}" }</ID>
    <ID>MaxLineLength:Utils.kt$return results.states.firstOrNull() ?: throw IllegalArgumentException("State (type=${T::class}) corresponding to the reference $ref not found (or is spent).")</ID>
    <ID>MaxLineLength:UtilsTest.kt$UtilsTest$rawConfiguration += "key1.key2" to configObject("key3" to "value2", "key4" to configObject("key5" to -2.0, "key6" to false))</ID>
    <ID>MaxLineLength:UtilsTest.kt$UtilsTest$rawConfiguration += "key7" to listOf("Hey!", true, 17, 0.0, configObject("key8" to listOf(-12.0, "HH", false), "key9" to "blah"))</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$flowMonitorSuspensionLoggingThresholdMillis = configuration[flowMonitorSuspensionLoggingThresholdMillis]</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val additionalNodeInfoPollingFrequencyMsec by long().optional().withDefaultValue(Defaults.additionalNodeInfoPollingFrequencyMsec)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val additionalP2PAddresses by string().mapValid(::toNetworkHostAndPort).list().optional().withDefaultValue(Defaults.additionalP2PAddresses)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val certificateChainCheckPolicies by nested(CertChainPolicyConfigSpec).list().optional().withDefaultValue(Defaults.certificateChainCheckPolicies)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val cordappSignerKeyFingerprintBlacklist by string().list().optional().withDefaultValue(Defaults.cordappSignerKeyFingerprintBlacklist)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val extraNetworkMapKeys by string().mapValid(::toUUID).list().optional().withDefaultValue(Defaults.extraNetworkMapKeys)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val flowMonitorSuspensionLoggingThresholdMillis by duration().optional().withDefaultValue(Defaults.flowMonitorSuspensionLoggingThresholdMillis)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$return result.mapValid { conf -&gt; Validated.withResult(conf as NodeConfiguration, conf.validate().map(::toError).toSet()) }</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$val messagingServerExternal = configuration[messagingServerExternal] ?: Defaults.messagingServerExternal(configuration[messagingServerAddress])</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$private fun toError(validationErrorMessage: String): Configuration.Validation.Error</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli$internal</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli$return cmdLineOptions.parseConfiguration(rawConfig).doIfValid { logRawConfig(rawConfig) }.doOnErrors(::logConfigurationErrors).optional?.let { ExitCodes.SUCCESS } ?: ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli$val rawConfig = cmdLineOptions.rawConfiguration().doOnErrors(cmdLineOptions::logRawConfigurationErrors).optional ?: return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli.Companion$internal fun logRawConfig(config: Config)</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli.Companion$logger.error(errors.joinToString(System.lineSeparator(), "Error(s) while parsing node configuration:${System.lineSeparator()}") { error -&gt; "\t- ${error.description()}" })</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli.Companion$private val configRenderingOptions = ConfigRenderOptions.defaults().setFormatted(true).setComments(false).setOriginComments(false)</ID>
    <ID>MaxLineLength:Validated.kt$Validated$ fun &lt;MAPPED&gt; map(convert: (TARGET) -&gt; MAPPED): Validated&lt;MAPPED, ERROR&gt;</ID>
    <ID>MaxLineLength:Validated.kt$Validated$ fun &lt;MAPPED&gt; mapValid(convert: (TARGET) -&gt; Validated&lt;MAPPED, ERROR&gt;): Validated&lt;MAPPED, ERROR&gt;</ID>
    <ID>MaxLineLength:Validated.kt$Validated$ fun &lt;MAPPED_ERROR&gt; mapErrors(convertError: (ERROR) -&gt; MAPPED_ERROR): Validated&lt;TARGET, MAPPED_ERROR&gt;</ID>
    <ID>MaxLineLength:Validated.kt$Validated$ fun value( exceptionOnErrors: (Set&lt;ERROR&gt;) -&gt; Exception = { errors -&gt; IllegalStateException(errors.joinToString(System.lineSeparator())) } ): TARGET</ID>
    <ID>MaxLineLength:Validated.kt$Validated$/** * Returns the underlying value as optional, with a null result instead of an exception if validation rules were violated. */ val optional: TARGET? get() = if (isValid) value() else null</ID>
    <ID>MaxLineLength:Validated.kt$Validated$exceptionOnErrors: (Set&lt;ERROR&gt;) -&gt; Exception = { errors -&gt; IllegalStateException(errors.joinToString(System.lineSeparator())) }</ID>
    <ID>MaxLineLength:Validated.kt$Validated.Companion$ fun &lt;T, E&gt; withResult(target: T, errors: Set&lt;E&gt;): Validated&lt;T, E&gt;</ID>
    <ID>MaxLineLength:Validated.kt$Validated.Result$Unsuccessful&lt;TARGET, ERROR&gt; : ResultValidated</ID>
    <ID>MaxLineLength:Validated.kt$Validated.Result.Successful$override</ID>
    <ID>MaxLineLength:Validated.kt$Validated.Result.Unsuccessful$override</ID>
    <ID>MaxLineLength:ValidatingNotaryFlow.kt$ValidatingNotaryFlow : NotaryServiceFlow</ID>
    <ID>MaxLineLength:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$SignableData(wtx.id, SignatureMetadata(1, Crypto.findSignatureScheme(alice.owningKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$assertThat(notaryError.cause).hasMessageContaining("Transaction for notarisation doesn't contain network parameters hash.")</ID>
    <ID>MaxLineLength:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$private</ID>
    <ID>MaxLineLength:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$val modifiedSignature = NotarisationRequestSignature(randomKeyPair.sign(bytesToSign), aliceNode.services.myInfo.platformVersion)</ID>
    <ID>MaxLineLength:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests.&lt;no name provided&gt;$val alteredMessage = InMemoryMessage(message.topic, OpaqueBytes(alteredMessageData.serialize().bytes), message.uniqueMessageId)</ID>
    <ID>MaxLineLength:Validator.kt$Validator$ fun validate(target: TARGET, options: OPTIONS): Validated&lt;TARGET, ERROR&gt;</ID>
    <ID>MaxLineLength:VaultFiller.kt$CommodityState$override</ID>
    <ID>MaxLineLength:VaultFiller.kt$CommodityState$override fun withNewOwner(newOwner: AbstractParty)</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$ // TODO: need to make all FungibleAsset commands (issue, move, exit) generic fun fillWithSomeTestCommodity(amount: Amount&lt;Commodity&gt;, issuerServices: ServiceHub, issuedBy: PartyAndReference): Vault&lt;CommodityState&gt;</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$ fun fillWithSomeTestCash( howMuch: Amount&lt;Currency&gt;, issuerServices: ServiceHub, atLeastThisManyStates: Int, atMostThisManyStates: Int, issuedBy: PartyAndReference, owner: AbstractParty? = null, rng: Random? = null, statesToRecord: StatesToRecord = StatesToRecord.ONLY_RELEVANT ): Vault&lt;Cash.State&gt;</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$( howMuch: Amount&lt;Currency&gt;, issuerServices: ServiceHub, thisManyStates: Int, issuedBy: PartyAndReference, owner: AbstractParty? = null, rng: Random? = null, statesToRecord: StatesToRecord = StatesToRecord.ONLY_RELEVANT )</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$OnLedgerAsset.generateIssue(tx, TransactionState(CommodityState(amount, owner), Obligation.PROGRAM_ID, notary), Obligation.Commands.Issue())</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$addOutputState(DummyDealContract.State(ref = "test ref", participants = participants.plus(me)), DUMMY_DEAL_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$addOutputState(DummyDealContract.State(ref = it, participants = participantsToUse), DUMMY_DEAL_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$cash.generateIssue(issuance, Amount(pennies, Issued(issuedBy, howMuch.token)), owner ?: services.myInfo.singleIdentity(), altNotary)</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$fun evolveLinearState(linearState: StateAndRef&lt;LinearState&gt;): StateAndRef&lt;LinearState&gt;</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$val amounts = calculateRandomlySizedAmounts(howMuch, atLeastThisManyStates, atMostThisManyStates, rng ?: rngFactory())</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$val signatureMetadata = SignatureMetadata(services.myInfo.platformVersion, Crypto.findSignatureScheme(issuerKey.public).schemeNumberID)</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller.Companion${ val numSlots = min + Math.floor(rng.nextDouble() * (max - min)).toInt() val baseSize = howMuch.quantity / numSlots check(baseSize &gt; 0) { baseSize } val amounts = LongArray(numSlots) { baseSize } var distanceFromGoal = 0L // If we want 10 slots then max adjust is 0.1, so even if all random numbers come out to the largest downward // adjustment possible, the last slot ends at zero. With 20 slots, max adjust is 0.05 etc. val maxAdjust = 1.0 / numSlots for (i in amounts.indices) { if (i != amounts.lastIndex) { val adjustBy = rng.nextDouble() * maxAdjust - (maxAdjust / 2) val adjustment = (1 + adjustBy) val adjustTo = (amounts[i] * adjustment).toLong() amounts[i] = adjustTo distanceFromGoal += baseSize - adjustTo } else { amounts[i] += distanceFromGoal } } // The desired amount may not have divided equally to start with, so adjust the first value to make up. amounts[0] += howMuch.quantity - amounts.sum() return amounts }</ID>
    <ID>MaxLineLength:VaultFlowTest.kt$VaultFlowTest.Initiator$addOutputState(UniqueDummyLinearContract.State(participants, "Dummy linear id"), UNIQUE_DUMMY_LINEAR_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultFlowTest.kt$VaultFlowTest.Initiator$val stx = serviceHub.signInitialTransaction(TransactionBuilder(serviceHub.networkMapCache.notaryIdentities.first()).apply { addOutputState(UniqueDummyLinearContract.State(participants, "Dummy linear id"), UNIQUE_DUMMY_LINEAR_CONTRACT_PROGRAM_ID) addOutputState(DummyDealContract.State(participants, "linear id"), DUMMY_DEAL_PROGRAM_ID) addCommand(DummyCommandData, listOf(ourIdentity.owningKey)) })</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestRule$(notaryServices.myInfo.legalIdentitiesAndCerts + BOC_IDENTITY + CASH_NOTARY_IDENTITY + MINI_CORP_IDENTITY + MEGA_CORP_IDENTITY)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestRule$makeTestIdentityService(MEGA_CORP_IDENTITY, MINI_CORP_IDENTITY, dummyCashIssuer.identity, dummyNotary.identity)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestRule$notaryServices = MockServices(cordappPackages, dummyNotary, mock(), dummyCashIssuer.keyPair, BOC_KEY, MEGA_CORP_KEY)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTests$require(produced.filter { ContractState::class.java.isAssignableFrom(it.state.data::class.java) }.size == 20) {}</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTests$require(produced.filter { DealState::class.java.isAssignableFrom(it.state.data::class.java) }.size == 10) {}</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTests$require(produced.filter { DummyDealContract.State::class.java.isAssignableFrom(it.state.data::class.java) }.size == 10) {}</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$/** * Query result returns a [Vault.Page] which contains: * 1) actual states as a list of [StateAndRef] * 2) state reference and associated vault metadata as a list of [Vault.StateMetadata] * 3) [PageSpecification] used to delimit the size of items returned in the result set (defaults to [DEFAULT_PAGE_SIZE]) * 4) Total number of items available (to aid further pagination if required) */ val states = result.states</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$// Beware: do not use `MyContractClass::class.qualifiedName` as this returns a fully qualified name using "dot" notation for enclosed class val MYCONTRACT_ID = "net.corda.node.services.vault.VaultQueryTestsBase\$MyContractClass"</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$@Suppress("EXPECTED_CONDITION") val pagingSpec = PageSpecification(DEFAULT_PAGE_NUM, @Suppress("INTEGER_OVERFLOW") Integer.MAX_VALUE + 1) // overflow = -2147483648</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `logical operator NOT LIKE does not return results containing the same characters as the case insensitive string`()</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `logical operator case insensitive NOT IN does not return results containing the same characters as the case insensitive strings`()</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `logical operator case insensitive NOT_EQUAL does not return results containing the same characters as the case insensitive string`()</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$CashSchemaV1.PersistentCashState::pennies</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$CommercialPaperUtils.generateIssue(issuance, faceValue, TEST_TX_TIME + 30.days, DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$CommercialPaperUtils.generateIssue(issuance, faceValue2, TEST_TX_TIME + 30.days, DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$MyState : BaseState</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$QueryCriteria.TimeInstantType.CONSUMED</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$Sort.Direction.ASC -&gt; assertThat(allStates.sortedBy { it.ref.txhash }.sortedBy { it.ref.index }).isEqualTo(allStates)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$Sort.Direction.ASC -&gt; assertThat(allStates.sortedBy { it.state.data.linearNumber }.sortedBy { it.ref.txhash }.sortedBy { it.ref.index }).isEqualTo(allStates)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$Sort.Direction.DESC -&gt; assertThat(allStates.sortedByDescending { it.ref.txhash }.sortedByDescending { it.ref.index }).isEqualTo(allStates)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$Sort.Direction.DESC -&gt; assertThat(allStates.sortedByDescending { it.state.data.linearNumber }.sortedBy { it.ref.txhash }.sortedBy { it.ref.index }).isEqualTo(allStates)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(constraintResults.states.map { it.state.constraint }).containsAll(listOf(constraintHash, constraintSignature, constraintSignatureCompositeKey))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(constraintResults4.states.map { it.state.constraint }).containsAll(listOf(constraintSignature, constraintSignatureCompositeKey))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(enrichedResults.map { it.state.constraint }).containsAll(listOf(constraintSignature, alwaysAcceptConstraint))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(fungibleStateCountUnconsumed.toInt()).isEqualTo(10 - cashUpdates.consumed.size + cashUpdates.produced.size)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(metadata.last().contractStateClassName).isEqualTo("net.corda.finance.contracts.asset.Cash\$State")</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(results.states).hasSize(1)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(results.states).hasSize(2)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$groupByColumns = listOf(SampleCashSchemaV2.PersistentCashState::currency, SampleCashSchemaV2.PersistentCashState::stateRef)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$listOf(10.DOLLARS, 25.POUNDS, 50.POUNDS, 100.SWISS_FRANCS).zip(listOf(3, 1, 1, 3))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$listOf(100.DOLLARS, 200.DOLLARS, 300.DOLLARS, 400.POUNDS, 500.SWISS_FRANCS).zip(1..5)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$listOf(100.DOLLARS, 200.DOLLARS, 300.POUNDS, 400.POUNDS, 500.SWISS_FRANCS, 600.SWISS_FRANCS).zip(1..6)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$softLockingCondition = QueryCriteria.SoftLockingCondition(QueryCriteria.SoftLockingType.UNLOCKED_AND_SPECIFIED, listOf(UUID.randomUUID()))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val allStates = vaultService.queryBy&lt;DummyLinearContract.State&gt;(sorting = sorting, criteria = criteria).states</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val alwaysAcceptConstraint = vaultFiller.fillWithSomeTestLinearStates(1, constraint = AlwaysAcceptAttachmentConstraint).states.first().state.constraint</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val avg = builder { CashSchemaV1.PersistentCashState::pennies.avg(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val baseCriteria = VaultQueryCriteria(constraints = setOf(Vault.ConstraintInfo(AlwaysAcceptAttachmentConstraint)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val ccyIndex = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val ccyIndex = builder { CommercialPaperSchemaV1.PersistentCommercialPaperState::currency.equal(USD.currencyCode) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val chfCashIssuerName = CordaX500Name(organisation = "Swiss Francs Cash Issuer", locality = "Zurich", country = "CH")</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val compositeKey = CompositeKey.Builder().addKeys(alice.publicKey, bob.publicKey, charlie.publicKey, bankOfCorda.publicKey, bigCorp.publicKey, megaCorp.publicKey, miniCorp.publicKey, cashNotary.publicKey, dummyNotary.publicKey, dummyCashIssuer.publicKey).build()</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val constraintCriteria1 = VaultQueryCriteria(constraints = setOf(Vault.ConstraintInfo(AlwaysAcceptAttachmentConstraint)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val constraintCriteria3 = VaultQueryCriteria(constraints = setOf(Vault.ConstraintInfo(constraintSignatureCompositeKey)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val constraintSignature = linearStateSignature.states.first().state.constraint as SignatureAttachmentConstraint</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val constraintSignatureCompositeKey = linearStateSignatureCompositeKey.states.first().state.constraint as SignatureAttachmentConstraint</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaByLockId = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(lockId1)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaByLockIds = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(lockId1, lockId2)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaExclusive = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_ONLY))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaLockedOnly = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.LOCKED_ONLY))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaMissingLockId = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_AND_SPECIFIED))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaUnlockedAndByLockId = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_AND_SPECIFIED, listOf(lockId2)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val database = configureDatabase(makePersistentDataSourceProperties(), DatabaseConfig(), identitySvc::wellKnownPartyFromX500Name, identitySvc::wellKnownPartyFromAnonymous)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val dealStateCountConsumed = vaultService.queryBy&lt;DealState&gt;(countCriteriaConsumed).otherResults.single() as Long</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val dealStateCountUnconsumed = vaultService.queryBy&lt;DealState&gt;(countCriteriaUnconsumed).otherResults.single() as Long</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val externalIds = listOf(linearState1.states.first().state.data.linearId.externalId!!, linearState3.states.first().state.data.linearId.externalId!!)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val faceValueIndex = CommercialPaperSchemaV1.PersistentCommercialPaperState::faceValue.greaterThanOrEqual(10000L)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val fungibleAssetStateCriteria = FungibleAssetQueryCriteria(participants = listOf(services.myInfo.singleIdentity()))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val fungibleStateCountConsumed = vaultService.queryBy&lt;FungibleAsset&lt;*&gt;&gt;(countCriteriaConsumed).otherResults.single() as Long</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val fungibleStateCountUnconsumed = vaultService.queryBy&lt;FungibleAsset&lt;*&gt;&gt;(countCriteriaUnconsumed).otherResults.single() as Long</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val gbpCashIssuerName = CordaX500Name(organisation = "British Pounds Cash Issuer", locality = "London", country = "GB")</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val issuedStates = vaultFillerCashNotary.fillWithSomeTestCash(100.DOLLARS, notaryServices, 10, DUMMY_CASH_ISSUER).states.toList()</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearIds = listOf(linearState1.states.first().state.data.linearId, linearState3.states.first().state.data.linearId)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearState2 = vaultFiller.evolveLinearState(linearState) // consume current and produce new state reference</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearState3 = vaultFiller.evolveLinearState(linearState2) // consume current and produce new state reference</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateCountConsumed = vaultService.queryBy&lt;LinearState&gt;(countCriteriaConsumed).otherResults.single() as Long</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateCountUnconsumed = vaultService.queryBy&lt;LinearState&gt;(countCriteriaUnconsumed).otherResults.single() as Long</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateCriteria = LinearStateQueryCriteria(linearId = listOf(linearId), status = Vault.StateStatus.ALL)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateCriteria = LinearStateQueryCriteria(linearId = txns.states.map { it.state.data.linearId }, status = Vault.StateStatus.CONSUMED)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateCriteria = LinearStateQueryCriteria(uuid = linearStates.map { it.state.data.linearId.id }, status = Vault.StateStatus.ALL)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateHash = vaultFiller.fillWithSomeTestLinearStates(1, constraint = AutomaticPlaceholderConstraint) // defaults to the HashConstraint</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateHash = vaultFiller.fillWithSomeTestLinearStates(1, constraint = AutomaticPlaceholderConstraint) // defaults to the hash constraint.</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateSignature = vaultFiller.fillWithSomeTestLinearStates(1, constraint = SignatureAttachmentConstraint(alice.publicKey))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateSignatureCompositeKey = vaultFiller.fillWithSomeTestLinearStates(1, constraint = SignatureAttachmentConstraint(compositeKey))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStates = vaultFiller.fillWithSomeTestLinearStates(2, "TEST") // create 2 states with same externalId</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val logicalExpression = builder { CashSchemaV1.PersistentCashState::pennies.`in`(listOf(10000L, 20000L), false) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val logicalExpression = builder { CashSchemaV1.PersistentCashState::pennies.notIn(listOf(10000L, 20000L), false) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val maturityIndex = CommercialPaperSchemaV1.PersistentCommercialPaperState::maturity.greaterThanOrEqual(TEST_TX_TIME + 30.days)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val max = builder { CashSchemaV1.PersistentCashState::pennies.max(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val max = builder { CashSchemaV1.PersistentCashState::pennies.max(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency), orderBy = Sort.Direction.DESC) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val min = builder { CashSchemaV1.PersistentCashState::pennies.min(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val min = builder { CashSchemaV1.PersistentCashState::pennies.min(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency), orderBy = Sort.Direction.DESC) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val newAllStates = vaultService.queryBy&lt;DummyLinearContract.State&gt;(sorting = sorting, criteria = criteria).states</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val page = vaultService.queryBy&lt;DummyLinearContract.State&gt;(sorting = sorting, paging = paging, criteria = criteria)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val result = vaultService.queryBy&lt;ContractState&gt;(VaultQueryCriteria(status = Vault.StateStatus.ALL), sorting = sorting)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val results = services.vaultService.queryBy&lt;FungibleAsset&lt;*&gt;&gt;(baseCriteria and enrichedCriteria, sorter).states</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val results = vaultService.queryBy&lt;Cash.State&gt;(criteria, Sort(setOf(Sort.SortColumn(sortAttribute, Sort.Direction.ASC))))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val results = vaultService.queryBy&lt;DummyLinearContract.State&gt;(criteria, Sort(setOf(Sort.SortColumn(sortAttribute, Sort.Direction.ASC))))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val resultsComposite = vaultService.queryBy&lt;ContractState&gt;(linearStateCriteria.or(fungibleAssetStateCriteria))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val resultsCompositeAnd = vaultService.queryBy&lt;ContractState&gt;(fungibleAssetStateCriteria.and(linearStateCriteria))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val resultsCompositeOr = vaultService.queryBy&lt;ContractState&gt;(fungibleAssetStateCriteria.or(linearStateCriteria))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val signatureMetadata = SignatureMetadata(services.myInfo.platformVersion, Crypto.findSignatureScheme(issuerKey.public).schemeNumberID)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val signedStatesExitingTx = services.signInitialTransaction(statesExitingTx).withAdditionalSignature(issuerKey, signatureMetadata)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sortAttribute = SortAttribute.Custom(DummyLinearStateSchemaV1.PersistentDummyLinearState::class.java, "linearNumber")</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sortAttribute = SortAttribute.Custom(DummyLinearStateSchemaV1.PersistentDummyLinearState::class.java, "stateRef")</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sortCol1 = Sort.SortColumn(SortAttribute.Standard(Sort.VaultStateAttribute.CONTRACT_STATE_TYPE), Sort.Direction.DESC)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sortCol2 = Sort.SortColumn(SortAttribute.Standard(Sort.VaultStateAttribute.STATE_STATUS), Sort.Direction.ASC)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sortCol3 = Sort.SortColumn(SortAttribute.Standard(Sort.VaultStateAttribute.CONSUMED_TIME), Sort.Direction.DESC)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sorting = Sort(setOf(Sort.SortColumn(SortAttribute.Custom(DummyLinearStateSchemaV1.PersistentDummyLinearState::class.java, "linearString"), Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sorting = Sort(setOf(Sort.SortColumn(SortAttribute.Standard(Sort.LinearStateAttribute.EXTERNAL_ID), Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sorting = Sort(setOf(Sort.SortColumn(SortAttribute.Standard(Sort.LinearStateAttribute.UUID), Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val statesExitingTx = TransactionBuilder(notary.party).withItems(*states.toList().toTypedArray()).addCommand(dummyCommand())</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency), orderBy = Sort.Direction.DESC) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val usdCashIssuerName = CordaX500Name(organisation = "US Dollars Cash Issuer", locality = "New York", country = "US")</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val utx = TransactionBuilder(notary = notaryServices.myInfo.singleIdentity()).withItems(stateAndContract).withItems(dummyCommand())</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFiller.fillWithSomeTestCash(100.DOLLARS, notaryServices, 1, BOC.ref(0), MINI_CORP)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFiller.fillWithSomeTestCash(100.DOLLARS, notaryServices, 1, DUMMY_CASH_ISSUER, services.myInfo.singleIdentity())</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFiller.fillWithSomeTestCommodity(Amount(100, Commodity.getInstance("FCOJ")!!), notaryServices, DUMMY_OBLIGATION_ISSUER.ref(1))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFiller.fillWithSomeTestLinearStates(1, "TEST1") vaultFiller.fillWithSomeTestDeals(listOf("123")) vaultFiller.fillWithSomeTestCash(100.DOLLARS, notaryServices, 1, DUMMY_CASH_ISSUER, services.myInfo.singleIdentity()) vaultFiller.fillWithSomeTestCommodity(Amount(100, Commodity.getInstance("FCOJ")!!), notaryServices, DUMMY_OBLIGATION_ISSUER.ref(1)) vaultFiller.fillWithDummyState() // all contract states query val results = vaultService.queryBy&lt;ContractState&gt;() assertThat(results.states).hasSize(5) // linear states only query val linearStateCriteria = LinearStateQueryCriteria() val resultsLSC = vaultService.queryBy&lt;ContractState&gt;(linearStateCriteria) assertThat(resultsLSC.states).hasSize(2) // fungible asset states only query val fungibleAssetStateCriteria = FungibleAssetQueryCriteria() val resultsFASC = vaultService.queryBy&lt;ContractState&gt;(fungibleAssetStateCriteria) assertThat(resultsFASC.states).hasSize(2) // composite OR query for both linear and fungible asset states (eg. all states in either Fungible and Linear states tables) val resultsCompositeOr = vaultService.queryBy&lt;ContractState&gt;(fungibleAssetStateCriteria.or(linearStateCriteria)) assertThat(resultsCompositeOr.states).hasSize(4) // composite AND query for both linear and fungible asset states (eg. all states in both Fungible and Linear states tables) val resultsCompositeAnd = vaultService.queryBy&lt;ContractState&gt;(fungibleAssetStateCriteria.and(linearStateCriteria)) assertThat(resultsCompositeAnd.states).hasSize(0)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFiller.fillWithSomeTestLinearStates(1, constraint = AlwaysAcceptAttachmentConstraint).states.first().state.constraint</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFiller.fillWithSomeTestLinearStates(1, constraint = AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFiller.fillWithSomeTestLinearStates(1, constraint = WhitelistedByZoneAttachmentConstraint).states.first().state.constraint</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFillerCashNotary.fillWithSomeTestCash(100.DOLLARS, notaryServices, 10, DUMMY_CASH_ISSUER, charlie.party, statesToRecord = StatesToRecord.ALL_VISIBLE)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFillerCashNotary.fillWithSomeTestCash(100.DOLLARS, notaryServices, 10, DUMMY_CASH_ISSUER, statesToRecord = StatesToRecord.ALL_VISIBLE)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultService.softLockReserve(UUID.randomUUID(), NonEmptySet.of(issuedStates[1].ref, issuedStates[2].ref, issuedStates[3].ref))</ID>
    <ID>MaxLineLength:VaultRestartTest.kt$VaultRestartTest$val node = startNode(providedName = DUMMY_BANK_A_NAME, customOverrides = mapOf("p2pAddress" to "localhost:30000")).getOrThrow()</ID>
    <ID>MaxLineLength:VaultRestartTest.kt$VaultRestartTest$val restartedNode = startNode(providedName = DUMMY_BANK_A_NAME, customOverrides = mapOf("p2pAddress" to "localhost:30000")).getOrThrow()</ID>
    <ID>MaxLineLength:VaultSchema.kt$VaultSchemaV1.VaultLinearStates$@Table(name = "vault_linear_states", indexes = [Index(name = "external_id_index", columnList = "external_id"), Index(name = "uuid_index", columnList = "uuid")])</ID>
    <ID>MaxLineLength:VaultSchema.kt$VaultSchemaV1.VaultStates$@Table(name = "vault_states", indexes = [Index(name = "state_status_idx", columnList = "state_status"), Index(name = "lock_id_idx", columnList = "lock_id, state_status")])</ID>
    <ID>MaxLineLength:VaultSchema.kt$VaultSchemaV1.VaultTxnNote$@Table(name = "vault_transaction_notes", indexes = [Index(name = "seq_no_index", columnList = "seq_no"), Index(name = "transaction_id_index", columnList = "transaction_id")])</ID>
    <ID>MaxLineLength:VaultService.kt$StatesNotAvailableException : FlowException</ID>
    <ID>MaxLineLength:VaultService.kt$Vault$Update&lt;U : ContractState&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Companion$@Deprecated("No longer used. The vault does not emit empty updates") val NoNotaryUpdate = Vault.Update(emptySet(), emptySet(), type = Vault.UpdateType.NOTARY_CHANGE, references = emptySet())</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.StateMetadata$return StateMetadata(ref, contractStateClassName, recordedTime, consumedTime, status, notary, lockId, lockUpdateTime, null)</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.StateMetadata$return StateMetadata(ref, contractStateClassName, recordedTime, consumedTime, status, notary, lockId, lockUpdateTime, relevancyStatus, ConstraintInfo(AlwaysAcceptAttachmentConstraint))</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update$ operator fun plus(rhs: Update&lt;U&gt;): Update&lt;U&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update$inline</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update$return copy(consumed = combinedConsumed, produced = combinedProduced, references = references + rhs.references)</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update${ require(rhs.type == type) { "Cannot combine updates of different types" } val combinedConsumed = consumed + (rhs.consumed - produced) // The ordering below matters to preserve ordering of consumed/produced Sets when they are insertion order dependent implementations. val combinedProduced = produced.filter { it !in rhs.consumed }.toSet() + rhs.produced return copy(consumed = combinedConsumed, produced = combinedProduced, references = references + rhs.references) }</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$ @Suspendable @Throws(StatesNotAvailableException::class) fun &lt;T : FungibleState&lt;*&gt;&gt; tryLockFungibleStatesForSpending( lockId: UUID, eligibleStatesQuery: QueryCriteria, amount: Amount&lt;*&gt;, contractStateType: Class&lt;out T&gt; ): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$ @Throws(VaultQueryException::class) fun &lt;T : ContractState&gt; _queryBy( criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt; ): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$/** * Prefer the use of [updates] unless you know why you want to use this instead. * * Get a synchronous [Observable] of updates. When observations are pushed to the Observer, the [Vault] will already * incorporate the update, and the database transaction associated with the update will still be open and current. * If for some reason the processing crosses outside of the database transaction (for example, the update is pushed * outside the current JVM or across to another [Thread], which is executing in a different database transaction), * then the [Vault] may not incorporate the update due to racing with committing the current database transaction. */ val rawUpdates: Observable&lt;Vault.Update&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$doneFuture(Vault.Update(consumed = setOf(snapshot.single()), produced = emptySet(), references = emptySet()))</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; queryBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; queryBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, sorting: Sort): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, sorting: Sort): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, paging: PageSpecification): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$inline</ID>
    <ID>MaxLineLength:VaultServiceInternal.kt$VaultServiceInternal$ fun notify(statesToRecord: StatesToRecord, tx: CoreTransaction)</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$NodePair$internals.disableDBCloseOnStop() // Otherwise the in-memory database may disappear (taking the checkpoint with it) while we reboot the client.</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$NodePair$server.registerCoreFlowFactory(AbstractClientLogic::class.java, ServerLogic::class.java, { ServerLogic(it, serverRunning) }, false)</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$NodePair.ServerLogic$private</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest$ClientLogic : AbstractClientLogic</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest$private</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest${ assertEquals(emptyList(), fsm.resultFuture.getOrThrow()) // In this case we don't want softLockRelease called so that we avoid its expensive query, even after restore from checkpoint. }</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest.&lt;no name provided&gt;.&lt;no name provided&gt;$mockVault.softLockRelease(lockId, stateRefs)</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest.ClientLogic$return serviceHub.vaultService.queryBy&lt;ContractState&gt;(VaultQueryCriteria(softLockingCondition = SoftLockingCondition(LOCKED_ONLY))).states.map { it.state.data }</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest.FungibleAssetImpl$@BelongsToContract(ContractImpl::class) private</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest.FungibleAssetImpl$override fun withNewOwnerAndAmount(newAmount: Amount&lt;Issued&lt;Unit&gt;&gt;, newOwner: AbstractParty)</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultMigrationSchema</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator : Iterator</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator$// The rest of this class is an attempt at multithreading that was ultimately scuppered by liquibase not providing a connection pool. // This may be useful as a starting point for improving performance of the migration, so is left here. To start using it, remove the // serialization environment changes in the execute function in the migration, and change forEach -&gt; parallelForEach. private val pool = ForkJoinPool.commonPool()</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator$criteriaBuilder</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator$logger.debug("Loaded page $pageNumber of ${(numStates - 1 / pageNumber.toLong()) + 1}. Current page has ${result.size} vault states")</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator${ endTransaction() transaction = database.newTransaction() val query = createVaultStatesQuery(VaultSchemaV1.VaultStates::class.java) { it } // The above query excludes states that have entries in the state party table. As the iteration proceeds, each state has entries // added to this table. The result is that when the next page is retrieved, any results that were in the previous page are not in // the query at all! As such, the next set of states that need processing start at the first result. query.firstResult = 0 query.maxResults = pageSize pageNumber++ val result = query.resultList logger.debug("Loaded page $pageNumber of ${(numStates - 1 / pageNumber.toLong()) + 1}. Current page has ${result.size} vault states") return result }</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator.Companion$effectiveSerializationEnv.serializationFactory</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator.Companion.AMQPInspectorSerializationScheme$override</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator.Companion.AMQPInspectorSerializationScheme$override fun rpcClientSerializerFactory(context: SerializationContext)</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator.Companion.AMQPInspectorSerializationScheme$override fun rpcServerSerializerFactory(context: SerializationContext)</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator.VaultPageTask$effectiveSerializationEnv.serializationFactory</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator.VaultPageTask$return listOf(VaultPageTask(database, page.subList(0, pageSize / 2), block), VaultPageTask(database, page.subList(pageSize / 2, pageSize), block))</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration$logger</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration$logger.info("Finished performing vault state data migration for ${persistentStates.numStates - statesSkipped} states")</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration$throw VaultStateMigrationException("Cannot add state parties for state ${stateAndRef.ref} as state class is not on the " + "classpath and participants cannot be synthesised")</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration$throw VaultStateMigrationException("Cannot migrate vault states as liquibase failed to provide a suitable database connection")</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration$throw VaultStateMigrationException("Failed to migrate $statesSkipped states in the vault. Check the logs for details of the " + "error for each state.")</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration$val myKeys = identityService.stripNotOurKeys(stateAndRef.state.data.participants.map { participant -&gt; participant.owningKey }).toSet()</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration${ // This should only happen if there was no attachment that could be used to deserialise the output states, and the state was // serialised such that the participants list cannot be accessed (participants is calculated and not marked as a // SerializableCalculatedProperty. throw VaultStateMigrationException("Cannot add state parties for state ${stateAndRef.ref} as state class is not on the " + "classpath and participants cannot be synthesised") }</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration${ val stateAndRef = getStateAndRef(it) addStateParties(session, stateAndRef) // Can get away without checking for AbstractMethodErrors here as these will have already occurred when trying to add // state parties. val myKeys = identityService.stripNotOurKeys(stateAndRef.state.data.participants.map { participant -&gt; participant.owningKey }).toSet() if (!NodeVaultService.isRelevant(stateAndRef.state.data, myKeys)) { it.relevancyStatus = Vault.RelevancyStatus.NOT_RELEVANT } }</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$OnLedgerAsset.generateIssue(txBuilder, TransactionState(CommodityState(amount, owner), Obligation.PROGRAM_ID, dummyNotary.party), Obligation.Commands.Issue())</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$cordaDB = configureDatabase(makePersistentDataSourceProperties(), DatabaseConfig(), notaryServices.identityService::wellKnownPartyFromX500Name, notaryServices.identityService::wellKnownPartyFromAnonymous)</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$createCommodityTransaction(Amount(it.toLong(), Issued(bankOfCorda.ref(2), Commodity.getInstance("FCOJ")!!)), owner)</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$createVaultStatesFromNotaryChangeTransaction(notaryTx, cashTx.coreTransaction.outputs + cashTx2.coreTransaction.outputs)</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$criteriaQuery.where(criteriaBuilder.equal(queryRootStates.get&lt;Vault.RelevancyStatus&gt;("relevancyStatus"), relevancyStatus))</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$val notaryTx = createNotaryChangeTransaction(listOf(StateRef(cashTx.id, 0), StateRef(cashTx2.id, 0)), SecureHash.allOnesHash)</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$val persistentIDs = certs.map { PersistentIdentityService.PersistentPublicKeyHashToCertificate(it.owningKey.toStringShort(), it.certPath.encoded) }</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$val persistentName = PersistentIdentityService.PersistentPartyToPublicKeyHash(name.toString(), certs.first().owningKey.toStringShort())</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$val signableData = SignableData(notaryTx.id, SignatureMetadata(3, Crypto.findSignatureScheme(notaryKey).schemeNumberID))</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest${ // Liquibase automatically closes the database connection when doing an actual migration. This test ensures the custom migration // leaves it open. addCashStates(12, ALICE) val migration = VaultStateMigration() migration.execute(liquibaseDB) assertFalse(cordaDB.dataSource.connection.isClosed) }</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest${ // This test is a little bit of a hack - it checks that these states are migrated correctly by looking at params in the database, // but these will not be there for V3 nodes. Handling for this must be tested manually. val cashTx = createCashTransaction(Cash(), 5.DOLLARS, BOB) val cashTx2 = createCashTransaction(Cash(), 10.DOLLARS, BOB) val notaryTx = createNotaryChangeTransaction(listOf(StateRef(cashTx.id, 0), StateRef(cashTx2.id, 0)), SecureHash.allOnesHash) createVaultStatesFromTransaction(cashTx, stateStatus = Vault.StateStatus.CONSUMED) createVaultStatesFromTransaction(cashTx2, stateStatus = Vault.StateStatus.CONSUMED) createVaultStatesFromNotaryChangeTransaction(notaryTx, cashTx.coreTransaction.outputs + cashTx2.coreTransaction.outputs) storeTransaction(cashTx) storeTransaction(cashTx2) storeTransaction(notaryTx) val migration = VaultStateMigration() migration.execute(liquibaseDB) assertEquals(2, getStatePartyCount()) }</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest${ val cashStatesToAdd = 1000 val linearStatesToAdd = 0 val commodityStatesToAdd = 0 val stateMultiplier = 10 cordaDB = configureDatabase(makePersistentDataSourceProperties(), DatabaseConfig(), notaryServices.identityService::wellKnownPartyFromX500Name, notaryServices.identityService::wellKnownPartyFromAnonymous) // Starting the database this way runs the migration under test. This is fine for the unit tests (as the changelog table is ignored), // but when starting an actual node using these databases the migration will be skipped, as it has an entry in the changelog table. // This must therefore be removed. cordaDB.dataSource.connection.createStatement().use { it.execute("DELETE FROM DATABASECHANGELOG WHERE FILENAME IN ('migration/vault-schema.changelog-v9.xml')") } for (i in 1..stateMultiplier) { addCashStates(cashStatesToAdd, BOB) addLinearStates(linearStatesToAdd, listOf(BOB, ALICE)) addCommodityStates(commodityStatesToAdd, BOB) } saveOurKeys(listOf(bob.keyPair)) saveAllIdentities(listOf(BOB_IDENTITY, ALICE_IDENTITY, BOC_IDENTITY, dummyNotary.identity)) cordaDB.close() }</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$@Test fun `something plus consume states 0 and 1, and produce state 4, is something without state 0 and 1 outputs and only state 4 output`()</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$private val stateAndRef0 = StateAndRef(TransactionState(DummyState(), DUMMY_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), stateRef0)</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$private val stateAndRef1 = StateAndRef(TransactionState(DummyState(), DUMMY_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), stateRef1)</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$private val stateAndRef2 = StateAndRef(TransactionState(DummyState(), DUMMY_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), stateRef2)</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$private val stateAndRef3 = StateAndRef(TransactionState(DummyState(), DUMMY_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), stateRef3)</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$private val stateAndRef4 = StateAndRef(TransactionState(DummyState(), DUMMY_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), stateRef4)</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$val expected = Vault.Update&lt;ContractState&gt;(setOf(stateAndRef2, stateAndRef3), setOf(stateAndRef0, stateAndRef1, stateAndRef4))</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$val notaryChangeUpdate = Vault.Update&lt;ContractState&gt;(setOf(stateAndRef2, stateAndRef3), setOf(stateAndRef0, stateAndRef1), type = Vault.UpdateType.NOTARY_CHANGE)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$Cash().generateIssue(usefulBuilder, 100.DOLLARS `issued by` MEGA_CORP.ref(1), AnonymousParty(freshKey), DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$CashUtils.generateSpend(services, spendTXBuilder, 80.DOLLARS, services.myInfo.legalIdentitiesAndCerts.single(), BOB)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$CashUtils.generateSpend(services, txn1Builder, 60.DOLLARS, services.myInfo.legalIdentitiesAndCerts.single(), BOB)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$CashUtils.generateSpend(services, txn2Builder, 80.DOLLARS, services.myInfo.legalIdentitiesAndCerts.single(), BOB)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$TransactionBuilder(notary = DUMMY_NOTARY) .addOutputState(DummyLinearContract.State(linearId = linearId, participants = listOf(freshIdentity)), DUMMY_LINEAR_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$addOutputState(DummyDealContract.State(ref = "999", participants = listOf(freshIdentity)), DUMMY_DEAL_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$addOutputState(DummyLinearContract.State(linearId = linearId, participants = listOf(freshIdentity)), DUMMY_LINEAR_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$addOutputState(DummyLinearContract.State(participants = listOf(freshIdentity)), DUMMY_LINEAR_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$makeTestIdentityService(MEGA_CORP_IDENTITY, MINI_CORP_IDENTITY, dummyCashIssuer.identity, dummyNotary.identity)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$services.validatedTransactions.getTransaction(deals.first().ref.txhash)?.apply { notaryServices.recordTransactions(this) }</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$services.validatedTransactions.getTransaction(linearStates.first().ref.txhash)?.apply { notaryServices.recordTransactions(this) }</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$val consumedStates = vaultService.queryBy&lt;ContractState&gt;(VaultQueryCriteria(status = Vault.StateStatus.CONSUMED)).states</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$val consumedStates1 = vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(status = Vault.StateStatus.CONSUMED))</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$val consumedStates2 = vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(status = Vault.StateStatus.CONSUMED))</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$val criteriaLocked = VaultQueryCriteria(softLockingCondition = QueryCriteria.SoftLockingCondition(QueryCriteria.SoftLockingType.LOCKED_ONLY))</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$vaultFiller.fillWithSomeTestCash(100.DOLLARS, issuerServices, 10, MEGA_CORP.ref(1), AnonymousParty(freshKey))</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$vaultFiller.fillWithSomeTestCash(100.DOLLARS, issuerServices, 3, DUMMY_CASH_ISSUER, AnonymousParty(freshKey))</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest.Companion$val cordappPackages = listOf("net.corda.testing.internal.vault", "net.corda.finance.contracts.asset", CashSchemaV1::class.packageName, "net.corda.core.contracts")</ID>
    <ID>MaxLineLength:VersionExtractor.kt$VersionExtractor.Spec$private</ID>
    <ID>MaxLineLength:VersionExtractorTest.kt$VersionExtractorTest$val rawConfiguration = configObject("configuration" to configObject("metadata" to configObject("version" to null), "node" to configObject("p2pAddress" to "localhost:8080"))).toConfig()</ID>
    <ID>MaxLineLength:VersionExtractorTest.kt$VersionExtractorTest$val rawConfiguration = configObject("configuration" to configObject("metadata" to configObject("version" to versionValue), "node" to configObject("p2pAddress" to "localhost:8080"))).toConfig()</ID>
    <ID>MaxLineLength:VersionExtractorTest.kt$VersionExtractorTest$val rawConfiguration = configObject("configuration" to configObject("metadata" to configObject(), "node" to configObject("p2pAddress" to "localhost:8080"))).toConfig()</ID>
    <ID>MaxLineLength:VersionExtractorTest.kt$VersionExtractorTest$val rawConfiguration = configObject("configuration" to configObject("node" to configObject("p2pAddress" to "localhost:8080"))).toConfig()</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val addressesValue = configObject("principal" to "${principalAddressValue.host}:${principalAddressValue.port}", "admin" to "${adminAddressValue.host}:${adminAddressValue.port}")</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val configurationV1 = configObject("configuration.metadata.version" to 1, "principalHost" to principalAddressValue.host, "principalPort" to principalAddressValue.port, "adminHost" to adminAddressValue.host, "adminPort" to adminAddressValue.port).toConfig().also { println(it.serialize()) }</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val configurationV2 = configObject("configuration.metadata.version" to 2, "configuration.value.addresses" to addressesValue).toConfig().also { println(it.serialize()) }</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val configurationV2 = configObject("configuration.value.addresses" to addressesValue).toConfig().also { println(it.serialize()) }</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val parseConfiguration = VersionedSpecificationRegistry.mapping(extractVersion, 1 to RpcSettingsSpec.V1, 2 to RpcSettingsSpec.V2)</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val rpcSettingsFromVersion1Conf = parseConfiguration.invoke(configurationV1).mapValid { it.parse(configurationV1) }</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val rpcSettingsFromVersion2Conf = parseConfiguration.invoke(configurationV2).mapValid { it.parse(configurationV2) }</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest.RpcSettingsSpec$return Validated.invalid(Configuration.Validation.Error.BadValue.of(host, Address::class.java.simpleName, "Value must be of format \"host(String):port(Int &gt; 0)\" e.g., \"127.0.0.1:8080\""))</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest.RpcSettingsSpec.V2.AddressesSpec$override fun parseValid(configuration: Config)</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest.RpcSettingsSpec.V2.AddressesSpec$return Address.validFromRawValue(rawValue) { error -&gt; Configuration.Validation.Error.BadValue.of(error) }</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry$value?.let { valid(it) } ?: invalid&lt;Configuration.Specification&lt;VALUE&gt;, Configuration.Validation.Error&gt;(Configuration.Validation.Error.UnsupportedVersion.of(version))</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry.Companion$fun &lt;V&gt; mapping(versionParser: (Config) -&gt; Valid&lt;Int&gt;, specifications: Map&lt;Int, Configuration.Specification&lt;V&gt;&gt;)</ID>
    <ID>MaxLineLength:VirtualCordapps.kt$VirtualCordapp$info = Cordapp.Info.Default("corda-core", versionInfo.vendor, versionInfo.releaseVersion, "Open Source (Apache 2)")</ID>
    <ID>MaxLineLength:VirtualCordapps.kt$VirtualCordapp$info = Cordapp.Info.Default("corda-notary", versionInfo.vendor, versionInfo.releaseVersion, "Open Source (Apache 2)")</ID>
    <ID>MaxLineLength:VirtualCordapps.kt$VirtualCordapp$info = Cordapp.Info.Default("corda-notary-bft-smart", versionInfo.vendor, versionInfo.releaseVersion, "Open Source (Apache 2)")</ID>
    <ID>MaxLineLength:VirtualCordapps.kt$VirtualCordapp$info = Cordapp.Info.Default("corda-notary-raft", versionInfo.vendor, versionInfo.releaseVersion, "Open Source (Apache 2)")</ID>
    <ID>MaxLineLength:Volume.kt$Volume$nodeInfoFile.readBytes().deserialize&lt;SignedNodeInfo&gt;().verified().let { NotaryInfo(it.legalIdentities.first(), validating) }</ID>
    <ID>MaxLineLength:Volume.kt$Volume$val validating = ConfigFactory.parseFile(configFile).getConfig("notary").getBooleanCaseInsensitive("validating")</ID>
    <ID>MaxLineLength:WebArgsParser.kt$ArgsParser$// The intent of allowing a command line configurable directory and config path is to allow deployment flexibility. // Other general configuration should live inside the config file unless we regularly need temporary overrides on the command line private val baseDirectoryArg = optionParser .accepts("base-directory", "The node working directory where all the files are kept") .withRequiredArg() .defaultsTo(".")</ID>
    <ID>MaxLineLength:WebArgsParser.kt$ArgsParser$private val logToConsoleArg = optionParser.accepts("log-to-console", "If set, prints logging to the console as well as to a file.")</ID>
    <ID>MaxLineLength:WebServerPluginRegistry.kt$WebServerPluginRegistry</ID>
    <ID>MaxLineLength:WebServerPluginRegistry.kt$WebServerPluginRegistry$/** * Map of static serving endpoints to the matching resource directory. All endpoints will be prefixed with "/web" and postfixed with "\*. * Resource directories can be either on disk directories (especially when debugging) in the form "a/b/c". Serving from a JAR can * be specified with: javaClass.getResource("&lt;folder-in-jar&gt;").toExternalForm() */ val staticServeDirs: Map&lt;String, String&gt; get() = emptyMap()</ID>
    <ID>MaxLineLength:WhitelistGenerator.kt$logger.info("Include contracts from $INCLUDE_WHITELIST_FILE_NAME: ${includeContracts.joinToString()} present in JARs: $optionalCordappJars.")</ID>
    <ID>MaxLineLength:WhitelistGenerator.kt$private fun readAllLines(path: Path): List&lt;String&gt;</ID>
    <ID>MaxLineLength:WhitelistGeneratorTest.kt$WhitelistGeneratorTest$val newWhitelist = generateWhitelist(existingWhitelist, emptyList(), listOf(TestContractsJar(contractClassNames = emptyList())))</ID>
    <ID>MaxLineLength:WhitelistGeneratorTest.kt$WhitelistGeneratorTest$val whitelist = generateWhitelist(emptyMap(), emptyList(), listOf(TestContractsJar(contractClassNames = emptyList())))</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction : TraversableTransaction</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$( inputs: List&lt;StateRef&gt;, attachments: List&lt;SecureHash&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt = PrivacySalt() )</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$( resolveIdentity, resolveAttachment, { stateRef -&gt; resolveStateRef(stateRef)?.serialize() }, { null }, // Returning a dummy `missingAttachment` Attachment allows this deprecated method to work and it disables "contract version no downgrade rule" as a dummy Attachment returns version 1 { resolveAttachment(it.txhash) ?: missingAttachment }, { isAttachmentTrusted(it, null) } )</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$/** * Builds whole Merkle tree for a transaction. * Briefly, each component group has its own sub Merkle tree and all of the roots of these trees are used as leaves * in a top level Merkle tree. * Note that ordering of elements inside a [ComponentGroup] matters when computing the Merkle root. * On the other hand, insertion group ordering does not affect the top level Merkle tree construction, as it is * actually an ordered Merkle tree, where its leaves are ordered based on the group ordinal in [ComponentGroupEnum]. * If any of the groups is an empty list or a null object, then [SecureHash.allOnesHash] is used as its hash. * Also, [privacySalt] is not a Merkle tree leaf, because it is already "inherently" included via the component nonces. */ val merkleTree: MerkleTree by lazy { MerkleTree.getMerkleTree(groupHashes) }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$/** * Calculate nonces for every transaction component, including new fields (due to backwards compatibility support) we cannot process. * Nonce are computed in the following way: * nonce1 = H(salt || path_for_1st_component) * nonce2 = H(salt || path_for_2nd_component) * etc. * Thus, all of the nonces are "independent" in the sense that knowing one or some of them, you can learn * nothing about the rest. */ internal val availableComponentNonces: Map&lt;Int, List&lt;SecureHash&gt;&gt; by lazy { componentGroups.map { Pair(it.groupIndex, it.components.mapIndexed { internalIndex, internalIt -&gt; componentHash(internalIt, privacySalt, it.groupIndex, internalIndex) }) }.toMap() }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$/** * The leaves (group hashes) of the top level Merkle tree. * If a group's Merkle root is allOnesHash, it is a flag that denotes this group is empty (if list) or null (if single object) * in the wire transaction. */ internal val groupHashes: List&lt;SecureHash&gt; by lazy { val listOfLeaves = mutableListOf&lt;SecureHash&gt;() // Even if empty and not used, we should at least send oneHashes for each known // or received but unknown (thus, bigger than known ordinal) component groups. for (i in 0..componentGroups.map { it.groupIndex }.max()!!) { val root = groupsMerkleRoots[i] ?: SecureHash.allOnesHash listOfLeaves.add(root) } listOfLeaves }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$// This calculates a value that is slightly lower than the actual re-serialized version. But it is stable and does not depend on the classloader. fun componentGroupSize(componentGroup: ComponentGroupEnum): Int</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$ReplaceWith("WireTransaction(val componentGroups: List&lt;ComponentGroup&gt;, override val privacySalt: PrivacySalt)")</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$SerializedStateAndRef(resolveStateRefAsSerialized(ref) ?: throw TransactionResolutionException(ref.txhash), ref)</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$check(componentGroups.map { it.groupIndex }.toSet().size == componentGroups.size) { "Duplicated component groups detected" }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$check(inputs.isNotEmpty() || outputs.isNotEmpty()) { "A transaction must contain at least one input or output state" }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$checkTransactionSize(ltx, resolvedNetworkParameters.maxTransactionSize, serializedResolvedInputs, serializedResolvedReferences)</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$componentGroups.map { Pair(it.groupIndex, it.components.mapIndexed { internalIndex, internalIt -&gt; componentHash(availableComponentNonces[it.groupIndex]!![internalIndex], internalIt) }) }.toMap()</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$componentGroups.map { Pair(it.groupIndex, it.components.mapIndexed { internalIndex, internalIt -&gt; componentHash(internalIt, privacySalt, it.groupIndex, internalIndex) }) }.toMap()</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$require(remainingTransactionSize &gt; size) { "Transaction exceeded network's maximum transaction size limit : $maxTransactionSize bytes." }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$return this.componentGroups.firstOrNull { it.groupIndex == componentGroup.ordinal }?.let { cg -&gt; cg.components.sumBy { it.size } + 4 } ?: 0</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$val resolvedAttachments = attachments.lazyMapped { att, _ -&gt; resolveAttachment(att) ?: throw AttachmentResolutionException(att) }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$val resolvedNetworkParameters = resolveParameters(networkParametersHash) ?: throw TransactionResolutionException.UnknownParametersException(id, networkParametersHash!!)</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction${ var remainingTransactionSize = maxTransactionSize fun minus(size: Int) { require(remainingTransactionSize &gt; size) { "Transaction exceeded network's maximum transaction size limit : $maxTransactionSize bytes." } remainingTransactionSize -= size } // This calculates a value that is slightly lower than the actual re-serialized version. But it is stable and does not depend on the classloader. fun componentGroupSize(componentGroup: ComponentGroupEnum): Int { return this.componentGroups.firstOrNull { it.groupIndex == componentGroup.ordinal }?.let { cg -&gt; cg.components.sumBy { it.size } + 4 } ?: 0 } // Check attachments size first as they are most likely to go over the limit. With ContractAttachment instances // it's likely that the same underlying Attachment CorDapp will occur more than once so we dedup on the attachment id. ltx.attachments.distinctBy { it.id }.forEach { minus(it.size) } minus(resolvedSerializedInputs.sumBy { it.serializedState.size }) minus(resolvedSerializedReferences.sumBy { it.serializedState.size }) // For Commands and outputs we can use the component groups as they are already serialized. minus(componentGroupSize(COMMANDS_GROUP)) minus(componentGroupSize(OUTPUTS_GROUP)) }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction.Companion$ @CordaInternal fun resolveStateRefBinaryComponent(stateRef: StateRef, services: ServicesForResolution): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction.Companion$?:</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction.Companion$else -&gt; throw UnsupportedOperationException("Attempting to resolve input ${stateRef.index} of a ${coreTransaction.javaClass} transaction. This is not supported.")</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction.Companion$is ContractUpgradeWireTransaction -&gt; coreTransaction.resolveOutputComponent(services, stateRef, params)</ID>
    <ID>MaxLineLength:WithFinality.kt$WithFinality$//region Operations fun TestStartedNode.finalise(stx: SignedTransaction, vararg recipients: Party): FlowStateMachine&lt;SignedTransaction&gt;</ID>
    <ID>MaxLineLength:WithReferencedStatesFlow.kt$WithReferencedStatesFlow&lt;T : Any&gt; : FlowLogic</ID>
    <ID>MaxLineLength:WorkflowTransactionBuildTutorial.kt$SubmitCompletionFlow : FlowLogic</ID>
    <ID>MaxLineLength:WorkflowTransactionBuildTutorial.kt$TradeApprovalContract$"Completed command requires the counterparty as signer" using (command.signers.contains(before.counterparty.owningKey))</ID>
    <ID>MaxLineLength:WorkflowTransactionBuildTutorial.kt$TradeApprovalContract$"Completed command requires the source Party as signer" using (command.signers.contains(before.source.owningKey))</ID>
    <ID>MaxLineLength:WorkflowTransactionBuildTutorial.kt$TradeApprovalContract$"Issue requires the source Party as signer" using (command.signers.contains(issued.source.owningKey))</ID>
    <ID>MaxLineLength:WorkflowTransactionBuildTutorial.kt$TradeApprovalContract$"Output must be a final state" using (after.state in setOf(WorkflowState.APPROVED, WorkflowState.REJECTED))</ID>
    <ID>MaxLineLength:WritablePublicKeyToOwningIdentityCache.kt$WritablePublicKeyToOwningIdentityCache : PublicKeyToOwningIdentityCache</ID>
    <ID>MaxLineLength:X500Utils.kt$ fun X500Principal.toAttributesMap(supportedAttributes: Set&lt;ASN1ObjectIdentifier&gt; = emptySet()): Map&lt;ASN1ObjectIdentifier, String&gt;</ID>
    <ID>MaxLineLength:X509KeyStore.kt$X509KeyStore$val certArray = requireNotNull(internal.getCertificateChain(alias)) { "No certificate chain under the alias $alias" }</ID>
    <ID>MaxLineLength:X509KeyStore.kt$X509KeyStore.Companion$val internal: KeyStore = if (createNew) loadOrCreateKeyStore(keyStoreFile, storePassword) else loadKeyStore(keyStoreFile, storePassword)</ID>
    <ID>MaxLineLength:X509NameConstraintsTest.kt$X509NameConstraintsTest$private</ID>
    <ID>MaxLineLength:X509NameConstraintsTest.kt$X509NameConstraintsTest$setPrivateKey(X509Utilities.CORDA_CLIENT_TLS, tlsKeyPair.private, listOf(tlsCert, nodeCaCert, intermediateCa.certificate, rootCa.certificate), keyPassword)</ID>
    <ID>MaxLineLength:X509NameConstraintsTest.kt$X509NameConstraintsTest$val (keystore, trustStore) = makeKeyStores(X500Name("CN=Bank A TLS, UID=, E=me@email.com, C=GB"), nameConstraints)</ID>
    <ID>MaxLineLength:X509NameConstraintsTest.kt$X509NameConstraintsTest$val (keystore, trustStore) = makeKeyStores(X500Name("O=Bank A, UID=, E=me@email.com, C=GB"), nameConstraints)</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$ @JvmStatic fun createCertificate( certificateType: CertificateType, issuerCertificate: X509Certificate, issuerKeyPair: KeyPair, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Duration, Duration&gt; = DEFAULT_VALIDITY_WINDOW, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null ): X509Certificate</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$ @JvmStatic fun saveCertificateAsPEMFile(certificate: X509Certificate, file: Path)</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$ fun getCertificateValidityWindow(before: Duration, after: Duration, parent: X509Certificate? = null): Pair&lt;Date, Date&gt;</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$JcaX509v3CertificateBuilder(issuer, serial, validityWindow.first, validityWindow.second, subject, subjectPublicKey) .addExtension(Extension.subjectKeyIdentifier, false, BcX509ExtensionUtils().createSubjectKeyIdentifier(subjectPublicKeyInfo))</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$JcaX509v3CertificateBuilder(issuer, serial, validityWindow.first, validityWindow.second, subject, subjectPublicKey) .addExtension(Extension.subjectKeyIdentifier, false, BcX509ExtensionUtils().createSubjectKeyIdentifier(subjectPublicKeyInfo)) .addExtension(Extension.basicConstraints, true, BasicConstraints(certificateType.isCA)) .addExtension(Extension.keyUsage, false, certificateType.keyUsage) .addExtension(Extension.extendedKeyUsage, false, keyPurposes) .addExtension(Extension.authorityKeyIdentifier, false, JcaX509ExtensionUtils().createAuthorityKeyIdentifier(issuerPublicKey))</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$require(isSignatureValid(JcaContentVerifierProviderBuilder().build(issuerKeyPair.public))) { "Invalid signature" }</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$val builder = JcaX509v3CertificateBuilder(issuer, serial, validityWindow.first, validityWindow.second, subject, subjectPublicKey) .addExtension(Extension.subjectKeyIdentifier, false, BcX509ExtensionUtils().createSubjectKeyIdentifier(subjectPublicKeyInfo)) .addExtension(Extension.basicConstraints, true, BasicConstraints(certificateType.isCA)) .addExtension(Extension.keyUsage, false, certificateType.keyUsage) .addExtension(Extension.extendedKeyUsage, false, keyPurposes) .addExtension(Extension.authorityKeyIdentifier, false, JcaX509ExtensionUtils().createAuthorityKeyIdentifier(issuerPublicKey))</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$val builder = createPartialCertificate(certificateType, issuer, issuerPublicKey, subject, subjectPublicKey, validityWindow, nameConstraints, crlDistPoint, crlIssuer)</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$val distPointName = DistributionPointName(GeneralNames(GeneralName(GeneralName.uniformResourceIdentifier, crlDistPoint)))</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$val signer = ContentSignerBuilder.build(signatureScheme, keyPair.private, Crypto.findProvider(signatureScheme.providerName))</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities${ val distPointName = DistributionPointName(GeneralNames(GeneralName(GeneralName.uniformResourceIdentifier, crlDistPoint))) val crlIssuerGeneralNames = crlIssuer?.let { GeneralNames(GeneralName(crlIssuer)) } // The second argument is flag that allows you to define what reason of certificate revocation is served by this distribution point see [ReasonFlags]. // The idea is that you have different revocation per revocation reason. Since we won't go into such a granularity, we can skip that parameter. // The third argument allows you to specify the name of the CRL issuer, it needs to be consistent with the crl (IssuingDistributionPoint) extension and the idp argument. // If idp == true, set it, if idp == false, leave it null as done here. val distPoint = DistributionPoint(distPointName, null, crlIssuerGeneralNames) builder.addExtension(Extension.cRLDistributionPoints, false, CRLDistPoint(arrayOf(distPoint))) }</ID>
    <ID>MaxLineLength:X509Utilities.kt$val Certificate.x509: X509Certificate get() = requireNotNull(this as? X509Certificate) { "Not an X.509 certificate: $this" }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$Crypto.supportedSignatureSchemes().filter { it != COMPOSITE_KEY }.forEach { serializeDeserializeX509CertPath(it) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$assertFalse { keyUsage.hasUsages(5) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$assertTrue { Crypto.isValid(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME, serverCert.publicKey, signature, testData) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$clientParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$p2pSslConfig.keyStore.get(createNew = true).also { it.registerDevP2pCertificates(MEGA_CORP.name, rootCa.certificate, intermediateCa, nodeCa) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$private</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$serverParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$signingCertStore.get(createNew = true).also { it.installDevNodeCaCertPath(MEGA_CORP.name, rootCa.certificate, intermediateCa, nodeCa) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val (_, caCert, childKeyPair, childCert) = genCaAndChildKeysCertsAndSubjects(signatureSchemeRoot, signatureSchemeChild)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val (serverCert, serverKeyPair) = serverKeyStore.getCertificateAndKeyPair(X509Utilities.CORDA_CLIENT_CA, certStore.entryPassword)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val (sslCert) = sslKeyStoreReloaded.query { getCertificateAndKeyPair(X509Utilities.CORDA_CLIENT_TLS, sslKeyStoreReloaded.entryPassword) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val caCert = X509Utilities.createSelfSignedCACertificate(X500Principal("CN=Test CA Cert,O=R3 Ltd,L=London,C=GB"), caKey)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val caCert = X509Utilities.createSelfSignedCACertificate(X500Principal("CN=Test Cert,O=R3 Ltd,L=London,C=GB"), caKey)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val caSubjectKeyIdentifier = SubjectKeyIdentifier.getInstance(caCert.toBc().getExtension(Extension.subjectKeyIdentifier).parsedValue)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val certCaAuthorityKeyIdentifier = AuthorityKeyIdentifier.getInstance(getExtension(Extension.authorityKeyIdentifier).parsedValue)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val certificate = X509Utilities.createCertificate(CertificateType.TLS, rootCACert, rootCAKey, BOB_NAME.x500Principal, BOB.publicKey)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val childCert = X509Utilities.createCertificate(CertificateType.TLS, caCert, caKeyPair, childSubject, childKeyPair.public)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val expected = X509Utilities.createSelfSignedCACertificate(ALICE.name.x500Principal, generateKeyPair(signatureScheme))</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val p2pSslConfig = CertificateStoreStubs.P2P.withCertificatesDirectory(certificatesDirectory, keyStorePassword = "serverstorepass")</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val serverSocket = serverSocketFactory.createServerSocket(0) as SSLServerSocket // use 0 to get first free socket</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val signingCertStore = CertificateStoreStubs.Signing.withCertificatesDirectory(certificatesDirectory, "serverstorepass")</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val sslConfig = CertificateStoreStubs.P2P.withCertificatesDirectory(tempFolder.root.toPath(), keyStorePassword = "serverstorepass")</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest.Companion$// We ensure that all of the algorithms are both used (at least once) as first and second in the following [Pair]s. // We also add [DEFAULT_TLS_SIGNATURE_SCHEME] and [DEFAULT_IDENTITY_SIGNATURE_SCHEME] combinations for consistency. val certChainSchemeCombinations = listOf( Pair(DEFAULT_TLS_SIGNATURE_SCHEME, DEFAULT_TLS_SIGNATURE_SCHEME), Pair(DEFAULT_IDENTITY_SIGNATURE_SCHEME, DEFAULT_IDENTITY_SIGNATURE_SCHEME), Pair(DEFAULT_TLS_SIGNATURE_SCHEME, DEFAULT_IDENTITY_SIGNATURE_SCHEME), Pair(ECDSA_SECP256R1_SHA256, SPHINCS256_SHA256), Pair(ECDSA_SECP256K1_SHA256, RSA_SHA256), Pair(EDDSA_ED25519_SHA512, ECDSA_SECP256K1_SHA256), Pair(RSA_SHA256, EDDSA_ED25519_SHA512), Pair(SPHINCS256_SHA256, ECDSA_SECP256R1_SHA256) )</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest.Companion$Triple(ECDSA_SECP256K1_SHA256, java.security.interfaces.ECPrivateKey::class.java, org.bouncycastle.jce.interfaces.ECPrivateKey::class.java)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest.Companion$Triple(ECDSA_SECP256R1_SHA256, java.security.interfaces.ECPrivateKey::class.java, org.bouncycastle.jce.interfaces.ECPrivateKey::class.java)</ID>
    <ID>MaxLineLength:YearMonthSerializer.kt$YearMonthSerializer : Proxy</ID>
    <ID>MaxLineLength:YearSerializer.kt$YearSerializer : Proxy</ID>
    <ID>MaxLineLength:ZoneIdSerializer.kt$ZoneIdSerializer : Proxy</ID>
    <ID>MaxLineLength:ZonedDateTimeSerializer.kt$ZonedDateTimeSerializer : Proxy</ID>
    <ID>MaxLineLength:ZonedDateTimeSerializer.kt$ZonedDateTimeSerializer$override fun fromProxy(proxy: ZonedDateTimeProxy): ZonedDateTime</ID>
    <ID>MaxLineLength:ZonedDateTimeSerializer.kt$ZonedDateTimeSerializer$override fun toProxy(obj: ZonedDateTime): ZonedDateTimeProxy</ID>
    <ID>MaxLineLength:ZonedDateTimeSerializer.kt$ZonedDateTimeSerializer$override val additionalSerializers: Iterable&lt;CustomSerializer&lt;out Any&gt;&gt; = listOf(LocalDateTimeSerializer(factory), ZoneIdSerializer(factory))</ID>
    <ID>MaxLineLength:ZonedDateTimeSerializer.kt$ZonedDateTimeSerializer.Companion$val ofLenient: Method = ZonedDateTime::class.java.getDeclaredMethod("ofLenient", LocalDateTime::class.java, ZoneOffset::class.java, ZoneId::class.java)</ID>
    <ID>MaxLineLength:internalAccessTestHelpers.kt$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt, networkParameters: NetworkParameters, references: List&lt;StateAndRef&lt;ContractState&gt;&gt;, componentGroups: List&lt;ComponentGroup&gt;? = null, serializedInputs: List&lt;SerializedStateAndRef&gt;? = null, serializedReferences: List&lt;SerializedStateAndRef&gt;? = null, isAttachmentTrusted: (Attachment) -&gt; Boolean )</ID>
    <ID>MaxLineLength:internalAccessTestHelpers.kt$fun createContractCreationError(txId: SecureHash, contractClass: String, cause: Throwable)</ID>
    <ID>MaxLineLength:internalAccessTestHelpers.kt$fun createContractRejection(txId: SecureHash, contract: Contract, cause: Throwable)</ID>
    <ID>MaximumLineLength:</ID>
    <ID>ModifierOrdering:</ID>
    <ID>MultiLineIfElse:</ID>
    <ID>NestedBlockDepth:ANSIProgressRenderer.kt$ANSIProgressRenderer$// Returns number of lines rendered. private fun renderLevel(ansi: Ansi, error: Boolean): Int</ID>
    <ID>NestedBlockDepth:AbstractNode.kt$AbstractNode$private fun installCordaServices()</ID>
    <ID>NestedBlockDepth:AbstractNode.kt$AbstractNode$private fun registerCordappFlows()</ID>
    <ID>NestedBlockDepth:AggregatedList.kt$AggregatedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out E&gt;)</ID>
    <ID>NestedBlockDepth:AllButBlacklisted.kt$AllButBlacklisted$ override fun hasListed(type: Class&lt;*&gt;): Boolean</ID>
    <ID>NestedBlockDepth:Amount.kt$Amount.Companion$ @JvmStatic fun parseCurrency(input: String): Amount&lt;Currency&gt;</ID>
    <ID>NestedBlockDepth:AttachmentDemo.kt$@Suppress("DEPRECATION") // DOCSTART 1 fun recipient(rpc: CordaRPCOps, webPort: Int)</ID>
    <ID>NestedBlockDepth:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$override fun execute(database: Database?)</ID>
    <ID>NestedBlockDepth:AttachmentsClassLoader.kt$AttachmentsClassLoader$private fun checkAttachments(attachments: List&lt;Attachment&gt;)</ID>
    <ID>NestedBlockDepth:CheckpointAgent.kt$CheckpointAgent.Companion$fun parseArguments(argumentsString: String?)</ID>
    <ID>NestedBlockDepth:CheckpointAgent.kt$CheckpointHook$private fun instrumentClass(clazz: CtClass): CtClass?</ID>
    <ID>NestedBlockDepth:CheckpointVerifier.kt$CheckpointVerifier$ fun verifyCheckpointsCompatible( checkpointStorage: CheckpointStorage, currentCordapps: List&lt;Cordapp&gt;, platformVersion: Int, serviceHub: ServiceHub, tokenizableServices: List&lt;Any&gt; )</ID>
    <ID>NestedBlockDepth:ClassCarpenter.kt$ClassCarpenterImpl$ private fun validateSchema(schema: Schema)</ID>
    <ID>NestedBlockDepth:ConcatenatedList.kt$ConcatenatedList$// This is where we handle changes to the *source* list. override fun sourceChanged(change: ListChangeListener.Change&lt;out ObservableList&lt;A&gt;&gt;)</ID>
    <ID>NestedBlockDepth:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onConnectionFinal(event: Event)</ID>
    <ID>NestedBlockDepth:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onDelivery(event: Event)</ID>
    <ID>NestedBlockDepth:CordaPersistence.kt$CordaPersistence$private fun &lt;T&gt; inTopLevelTransaction(isolationLevel: TransactionIsolationLevel, recoverableFailureTolerance: Int, recoverAnyNestedSQLException: Boolean, statement: DatabaseTransaction.() -&gt; T): T</ID>
    <ID>NestedBlockDepth:DeserializationInput.kt$DeserializationInput$fun readObject(obj: Any, schemas: SerializationSchemas, type: Type, context: SerializationContext): Any</ID>
    <ID>NestedBlockDepth:FetchDataFlow.kt$FetchAttachmentsFlow$override fun maybeWriteToDisk(downloaded: List&lt;Attachment&gt;)</ID>
    <ID>NestedBlockDepth:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: CommonQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>NestedBlockDepth:InteractiveShell.kt$InteractiveShell$ @JvmStatic fun runFlowByNameFragment(nameFragment: String, inputData: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, ansiProgressRenderer: ANSIProgressRenderer, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps))</ID>
    <ID>NestedBlockDepth:InteractiveShell.kt$InteractiveShell$@JvmStatic fun gracefulShutdown(userSessionOut: RenderPrintWriter, cordaRPCOps: CordaRPCOps)</ID>
    <ID>NestedBlockDepth:InternalUtils.kt$ inline fun &lt;T&gt; Iterable&lt;T&gt;.noneOrSingle(predicate: (T) -&gt; Boolean): T?</ID>
    <ID>NestedBlockDepth:JarSignatureTestUtils.kt$JarSignatureTestUtils$fun Path.addManifest(fileName: String, vararg entry: Pair&lt;Attributes.Name, String&gt;)</ID>
    <ID>NestedBlockDepth:Main.kt$Node$fun avalancheLoop()</ID>
    <ID>NestedBlockDepth:NetworkBootstrapper.kt$CopyCordapps$protected fun List&lt;Path&gt;.copy(nodeDirs: List&lt;Path&gt;)</ID>
    <ID>NestedBlockDepth:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ private fun pollServerForCertificates(requestId: String): List&lt;X509Certificate&gt;</ID>
    <ID>NestedBlockDepth:Node.kt$Node$ override fun startDatabase()</ID>
    <ID>NestedBlockDepth:Node.kt$Node$ private fun tryDetectIfNotPublicHost(host: String): String?</ID>
    <ID>NestedBlockDepth:Node.kt$Node$private fun startLocalRpcBroker(securityManager: RPCSecurityManager): BrokerAddresses?</ID>
    <ID>NestedBlockDepth:NodeVaultService.kt$NodeVaultService$private fun recordUpdate(update: Vault.Update&lt;ContractState&gt;, previouslySeen: Boolean): Vault.Update&lt;ContractState&gt;</ID>
    <ID>NestedBlockDepth:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$override fun verifyTransaction(requestPayload: NotarisationPayload)</ID>
    <ID>NestedBlockDepth:ObjectDiffer.kt$ObjectDiffer$fun diff(a: Any?, b: Any?): DiffTree?</ID>
    <ID>NestedBlockDepth:Obligation.kt$Obligation$override fun verify(tx: LedgerTransaction)</ID>
    <ID>NestedBlockDepth:ProfileController.kt$ProfileController$ @Throws(IOException::class) fun openProfile(): List&lt;InstallConfig&gt;?</ID>
    <ID>NestedBlockDepth:ProfileController.kt$ProfileController$ @Throws(IOException::class) fun saveProfile(): Boolean</ID>
    <ID>NestedBlockDepth:QuasarInstrumentationHook.kt$PackageTree$ fun toGlobs(excludeTree: PackageTree): List&lt;Glob&gt;</ID>
    <ID>NestedBlockDepth:RPCClientProxyHandler.kt$RPCClientProxyHandler$// The handler for Artemis messages. private fun artemisMessageHandler(message: ClientMessage)</ID>
    <ID>NestedBlockDepth:ShutdownManager.kt$ShutdownManager$fun shutdown()</ID>
    <ID>NestedBlockDepth:SpringDriver.kt$SpringBootDriverDSL$private fun queryWebserver(handle: NodeHandle, process: Process, checkUrl: String): WebserverHandle</ID>
    <ID>NestedBlockDepth:StartedFlowTransition.kt$StartedFlowTransition$private fun TransitionBuilder.sendToSessionsTransition(sourceSessionIdToMessage: Map&lt;SessionId, SerializedBytes&lt;Any&gt;&gt;)</ID>
    <ID>NestedBlockDepth:StatusTransitions.kt$StatusTransitions$ fun verify(tx: LedgerTransaction)</ID>
    <ID>NestedBlockDepth:ThrowableSerializer.kt$ThrowableSerializer$override fun fromProxy(proxy: ThrowableProxy): Throwable</ID>
    <ID>NestedBlockDepth:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyConstraintsValidity(contractAttachmentsByContract: Map&lt;ContractClassName, ContractAttachment&gt;)</ID>
    <ID>NoBlankLineBeforeRbrace:</ID>
    <ID>NoConsecutiveBlankLines:</ID>
    <ID>NoEmptyClassBody:</ID>
    <ID>NoLineBreakBeforeAssignment:</ID>
    <ID>NoMultipleSpaces:</ID>
    <ID>NoSemicolons:</ID>
    <ID>NoTrailingSpaces:</ID>
    <ID>NoUnusedImports:</ID>
    <ID>NoWildcardImports:</ID>
    <ID>PackageNaming:MessageState.kt$package net.corda.testMessage</ID>
    <ID>PackageNaming:ScheduledState.kt$package net.corda.testMessage</ID>
    <ID>ParameterListWrapping:</ID>
    <ID>ReturnCount:AbstractPartyDescriptor.kt$AbstractPartyDescriptor$override fun &lt;X : Any&gt; unwrap(value: AbstractParty?, type: Class&lt;X&gt;, options: WrapperOptions): X?</ID>
    <ID>ReturnCount:AbstractPartyDescriptor.kt$AbstractPartyDescriptor$override fun &lt;X : Any&gt; wrap(value: X?, options: WrapperOptions): AbstractParty?</ID>
    <ID>ReturnCount:Address.kt$Address.Companion$fun &lt;ERROR&gt; validFromRawValue(rawValue: String, mapError: (String) -&gt; ERROR): Validated&lt;Address, ERROR&gt;</ID>
    <ID>ReturnCount:Amount.kt$Amount.Companion$ @JvmStatic fun getDisplayTokenSize(token: Any): BigDecimal</ID>
    <ID>ReturnCount:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$override fun execute(database: Database?)</ID>
    <ID>ReturnCount:AttachmentsClassLoader.kt$AttachmentsClassLoader$private fun containsClasses(attachment: Attachment): Boolean</ID>
    <ID>ReturnCount:BankOfCordaWebApi.kt$BankOfCordaWebApi$ @POST @Path("issue-asset-request") @Consumes(MediaType.APPLICATION_JSON) fun issueAssetRequest(params: IssueRequestParams): Response</ID>
    <ID>ReturnCount:BridgeControlListener.kt$BridgeControlListener$private fun processControlMessage(msg: ClientMessage)</ID>
    <ID>ReturnCount:ByteArrays.kt$fun hexToBin(ch: Char): Int</ID>
    <ID>ReturnCount:ByteBufferStreams.kt$ByteBufferInputStream$@Throws(IOException::class) override fun read(b: ByteArray, offset: Int, length: Int): Int</ID>
    <ID>ReturnCount:CheckpointAgent.kt$CheckpointHook$private fun &lt;T&gt; getArrayValue(clazz: Class&lt;T&gt;, value: Any?): String?</ID>
    <ID>ReturnCount:CheckpointAgent.kt$CheckpointHook$private fun instrumentClass(clazz: CtClass): CtClass?</ID>
    <ID>ReturnCount:CloseableTab.kt$CloseableTab$fun requestClose()</ID>
    <ID>ReturnCount:CordaAuthenticationPlugin.kt$CordaAuthenticationPlugin$override fun authenticate(username: String?, credential: String?): AuthInfo</ID>
    <ID>ReturnCount:CordaClassResolver.kt$CordaClassResolver$private fun checkClass(type: Class&lt;*&gt;): Registration?</ID>
    <ID>ReturnCount:Crypto.kt$Crypto$// Custom key pair generator from an entropy required for various tests. It is similar to deriveKeyPairECDSA, // but the accepted range of the input entropy is more relaxed: // 2 &lt;= entropy &lt; N, where N is the order of base-point G. private fun deriveECDSAKeyPairFromEntropy(signatureScheme: SignatureScheme, entropy: BigInteger): KeyPair</ID>
    <ID>ReturnCount:Crypto.kt$Crypto$// Given the domain parameters, this routine deterministically generates an ECDSA key pair // in accordance with X9.62 section 5.2.1 pages 26, 27. private fun deriveKeyPairECDSA(parameterSpec: ECParameterSpec, privateKey: PrivateKey, seed: ByteArray): KeyPair</ID>
    <ID>ReturnCount:DBRunnerExtension.kt$DBRunnerExtension$private fun getDatabaseContext(context: ExtensionContext?): TestDatabaseContext?</ID>
    <ID>ReturnCount:Emoji.kt$Emoji$fun renderIfSupported(obj: Any): String</ID>
    <ID>ReturnCount:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$private fun buildParams(constructor: KFunction&lt;FlowLogic&lt;*&gt;&gt;, args: Map&lt;String, Any?&gt;): HashMap&lt;KParameter, Any?&gt;?</ID>
    <ID>ReturnCount:FlowManager.kt$NodeFlowManager.FlowWeightComparator$override fun compare(o1: NodeFlowManager.RegisteredFlowContainer, o2: NodeFlowManager.RegisteredFlowContainer): Int</ID>
    <ID>ReturnCount:InteractiveShell.kt$InteractiveShell$ @JvmStatic fun runFlowByNameFragment( nameFragment: String, inputData: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, ansiProgressRenderer: ANSIProgressRenderer, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps) )</ID>
    <ID>ReturnCount:InteractiveShell.kt$InteractiveShell$@JvmStatic fun runRPCFromString( input: List&lt;String&gt;, out: RenderPrintWriter, context: InvocationContext&lt;out Any&gt;, cordaRPCOps: InternalCordaRPCOps, inputObjectMapper: ObjectMapper ): Any?</ID>
    <ID>ReturnCount:InteractiveShell.kt$InteractiveShell$private fun maybeFollow(response: Any?, printerFun: (Any?) -&gt; String, out: PrintWriter): CordaFuture&lt;Unit&gt;</ID>
    <ID>ReturnCount:Interpolators.kt$LinearInterpolator$override fun interpolate(x: Double): Double</ID>
    <ID>ReturnCount:JarScanningCordappLoader.kt$JarScanningCordappLoader$private fun parseCordappInfo(manifest: Manifest?, defaultName: String): Cordapp.Info</ID>
    <ID>ReturnCount:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$override fun get(actualClass: Class&lt;*&gt;, declaredType: Type): AMQPSerializer&lt;Any&gt;</ID>
    <ID>ReturnCount:LocalTypeInformationBuilder.kt$ private fun constructorForDeserialization(type: Type): KFunction&lt;Any&gt;?</ID>
    <ID>ReturnCount:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$ private fun buildNonAtomic( rawType: Class&lt;*&gt;, type: Type, typeIdentifier: TypeIdentifier, typeParameterInformation: List&lt;LocalTypeInformation&gt; ): LocalTypeInformation</ID>
    <ID>ReturnCount:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private fun makeConstructorPairedProperty( constructorIndex: Int, descriptor: PropertyDescriptor, constructorInformation: LocalConstructorInformation ): LocalPropertyInformation?</ID>
    <ID>ReturnCount:Main.kt$Node$fun isAccepted(tx: Transaction): Boolean</ID>
    <ID>ReturnCount:MockNodeMessagingService.kt$MockNodeMessagingService$ private fun getNextQueue(q: LinkedBlockingQueue&lt;InMemoryMessagingNetwork.MessageTransfer&gt;, block: Boolean): Pair&lt;InMemoryMessagingNetwork.MessageTransfer, List&lt;Handler&gt;&gt;?</ID>
    <ID>ReturnCount:NetworkRegistrationHelper.kt$NodeRegistrationHelper$override fun validateAndGetTlsCrlIssuerCert(): X509Certificate?</ID>
    <ID>ReturnCount:NodeConfigurationImpl.kt$NodeConfigurationImpl$private fun validateDevModeOptions(): List&lt;String&gt;</ID>
    <ID>ReturnCount:NodeSchemaService.kt$NodeSchemaService$// Because schema is always one supported by the state, just delegate. override fun generateMappedObject(state: ContractState, schema: MappedSchema): PersistentState</ID>
    <ID>ReturnCount:NodeStartup.kt$NodeStartup$fun initialiseAndRun( cmdLineOptions: SharedNodeCmdLineOptions, afterNodeInitialisation: RunAfterNodeInitialisation, requireCertificates: Boolean = false ): Int</ID>
    <ID>ReturnCount:NodeStartup.kt$NodeStartup$fun isNodeRunningAt(baseDirectory: Path): Boolean</ID>
    <ID>ReturnCount:NodeStartup.kt$NodeStartup$private fun canReadCertificatesDirectory(certDirectory: Path, devMode: Boolean): Boolean</ID>
    <ID>ReturnCount:NodeStartup.kt$fun CliWrapperBase.initLogging(baseDirectory: Path): Boolean</ID>
    <ID>ReturnCount:NodeVaultService.kt$NodeVaultService$@Suspendable @Throws(StatesNotAvailableException::class) override fun &lt;T : FungibleState&lt;*&gt;&gt; tryLockFungibleStatesForSpending( lockId: UUID, eligibleStatesQuery: QueryCriteria, amount: Amount&lt;*&gt;, contractStateType: Class&lt;out T&gt; ): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>ReturnCount:ObjectDiffer.kt$ObjectDiffer$fun diff(a: Any?, b: Any?): DiffTree?</ID>
    <ID>ReturnCount:PartialMerkleTree.kt$PartialMerkleTree$// Helper function to compute the path. False means go to the left and True to the right. // Because the path is updated recursively, the path is returned in reverse order. private fun leafIndexHelper(leaf: SecureHash, node: PartialTree, path: MutableList&lt;Boolean&gt;): Boolean</ID>
    <ID>ReturnCount:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$override fun getPartyInfo(party: Party): PartyInfo?</ID>
    <ID>ReturnCount:RPCClientProxyHandler.kt$RPCClientProxyHandler$// This is the general function that transforms a client side RPC to internal Artemis messages. override fun invoke(proxy: Any, method: Method, arguments: Array&lt;out Any?&gt;?): Any?</ID>
    <ID>ReturnCount:RPCSecurityManagerImpl.kt$RPCPermissionResolver$override fun resolvePermission(representation: String): Permission</ID>
    <ID>ReturnCount:RigorousMock.kt$SpectatorDefaultAnswer$override fun answerImpl(invocation: InvocationOnMock): Any?</ID>
    <ID>ReturnCount:SerialFilter.kt$SerialFilter$internal fun applyPredicate(acceptClass: (Class&lt;*&gt;) -&gt; Boolean, serialClass: Class&lt;*&gt;?): Boolean</ID>
    <ID>ReturnCount:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$// We may need to recursively chase transactions if there are notary changes. fun inner(stateRef: StateRef, forContractClassName: String?): Attachment</ID>
    <ID>ReturnCount:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$override fun retryFlowFromSafePoint(currentState: StateMachineState)</ID>
    <ID>ReturnCount:SpecificationTest.kt$SpecificationTest$fun parseMax(elements: List&lt;Long&gt;): Valid&lt;Long&gt;</ID>
    <ID>ReturnCount:StandaloneShell.kt$StandaloneShell$override fun runProgram(): Int</ID>
    <ID>ReturnCount:TransactionBuilder.kt$TransactionBuilder$ private fun handleContract( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, outputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, explicitContractAttachment: AttachmentId?, services: ServicesForResolution ): Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;</ID>
    <ID>ReturnCount:TransactionUtils.kt$ fun &lt;T : Any&gt; deserialiseComponentGroup( componentGroups: List&lt;ComponentGroup&gt;, clazz: KClass&lt;T&gt;, groupEnum: ComponentGroupEnum, forceDeserialize: Boolean = false, factory: SerializationFactory = SerializationFactory.defaultFactory, context: SerializationContext = factory.defaultContext ): List&lt;T&gt;</ID>
    <ID>ReturnCount:TransitionExecutorImpl.kt$TransitionExecutorImpl$@Suspendable override fun executeTransition( fiber: FlowFiber, previousState: StateMachineState, event: Event, transition: TransitionResult, actionExecutor: ActionExecutor ): Pair&lt;FlowContinuation, StateMachineState&gt;</ID>
    <ID>ReturnCount:TypeParameterUtils.kt$ private fun inferTypeVariables(actualClass: Class&lt;*&gt;, declaredClass: Class&lt;*&gt;, declaredType: ParameterizedType): Type?</ID>
    <ID>ReturnCount:Util.kt$fun &lt;T&gt; debugCompare(perLeft: Perceivable&lt;T&gt;, perRight: Perceivable&lt;T&gt;)</ID>
    <ID>ReturnCount:Util.kt$fun debugCompare(arrLeft: Arrangement, arrRight: Arrangement)</ID>
    <ID>SpacingAroundColon:</ID>
    <ID>SpacingAroundComma:</ID>
    <ID>SpacingAroundCurly:</ID>
    <ID>SpacingAroundDot:</ID>
    <ID>SpacingAroundKeyword:</ID>
    <ID>SpacingAroundOperators:</ID>
    <ID>SpacingAroundParens:</ID>
    <ID>SpacingAroundRangeOperator:</ID>
    <ID>SpreadOperator:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme$(*it.whitelist.toTypedArray())</ID>
    <ID>SpreadOperator:AbstractNode.kt$FlowStarterImpl$(logicType, *args)</ID>
    <ID>SpreadOperator:AbstractParty.kt$AbstractParty$(*bytes)</ID>
    <ID>SpreadOperator:AttachmentDemo.kt$(*args)</ID>
    <ID>SpreadOperator:AuthenticatedRpcOpsProxy.kt$(methodName, *(args.map(Class&lt;*&gt;::getName).toTypedArray()))</ID>
    <ID>SpreadOperator:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy$(logicType, *args)</ID>
    <ID>SpreadOperator:AzureInstantiator.kt$AzureInstantiator$(*portsToOpen.toIntArray())</ID>
    <ID>SpreadOperator:ByteArrays.kt$OpaqueBytes.Companion$(*b)</ID>
    <ID>SpreadOperator:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$(newNodeCert, INTERMEDIATE_CA.certificate, *nodeKeyStore.query { getCertificateChain(X509Utilities.CORDA_CLIENT_CA) }.drop(2).toTypedArray())</ID>
    <ID>SpreadOperator:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$(newTlsCert, newNodeCert, INTERMEDIATE_CA.certificate, *sslKeyStore.query { getCertificateChain(X509Utilities.CORDA_CLIENT_TLS) }.drop(3).toTypedArray())</ID>
    <ID>SpreadOperator:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.CrlServlet$( server, SIGNATURE_ALGORITHM, INTERMEDIATE_CA.certificate, INTERMEDIATE_CA.keyPair.private, NODE_CRL, false, *revokedNodeCerts.toTypedArray())</ID>
    <ID>SpreadOperator:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.CrlServlet$( server, SIGNATURE_ALGORITHM, ROOT_CA.certificate, ROOT_CA.keyPair.private, INTEMEDIATE_CRL, false, *revokedIntermediateCerts.toTypedArray())</ID>
    <ID>SpreadOperator:CertificateStore.kt$CertificateStore$(*options)</ID>
    <ID>SpreadOperator:CollectSignaturesFlow.kt$CollectSignatureFlow$(*signingKeys)</ID>
    <ID>SpreadOperator:CompositeKey.kt$CompositeKey.Builder$(*keys.toTypedArray())</ID>
    <ID>SpreadOperator:ConfigUtilities.kt$(*pairs)</ID>
    <ID>SpreadOperator:Configuration.kt$Configuration.Validation.Error$(*(containingPath.toList() + this.containingPath).toTypedArray())</ID>
    <ID>SpreadOperator:ContractJarTestUtils.kt$ContractJarTestUtils$(jarName, *contractNames.map { "${it.replace(".", "/")}.class" }.toTypedArray())</ID>
    <ID>SpreadOperator:CordaCliWrapper.kt$(RunLast().useOut(System.out).useAnsi(defaultAnsiMode), DefaultExceptionHandler&lt;List&lt;Any&gt;&gt;().useErr(System.err).useAnsi(defaultAnsiMode).andExit(ExitCodes.FAILURE), *args)</ID>
    <ID>SpreadOperator:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$(logicType, context(), *args)</ID>
    <ID>SpreadOperator:CordaX500Name.kt$CordaX500Name.Companion$(*Locale.getISOCountries(), unspecifiedCountry)</ID>
    <ID>SpreadOperator:CustomCordapp.kt$CustomCordapp$(*classes.map { it.name }.toTypedArray())</ID>
    <ID>SpreadOperator:CustomCordapp.kt$CustomCordapp$(*packages.map { it.replace('.', '/') }.toTypedArray())</ID>
    <ID>SpreadOperator:DemoBench.kt$DemoBench.Companion$(DemoBench::class.java, *args)</ID>
    <ID>SpreadOperator:DockerInstantiator.kt$DockerInstantiator$(*it.toTypedArray())</ID>
    <ID>SpreadOperator:DriverDSLImpl.kt$DriverDSLImpl$( config, quasarJarPath, debugPort, systemProperties, "512m", null, *extraCmdLineFlag )</ID>
    <ID>SpreadOperator:DummyContract.kt$DummyContract.Companion$( /* INPUTS */ *priors.toTypedArray(), /* COMMAND */ Command(cmd, priorState.owner.owningKey), /* OUTPUT */ StateAndContract(state, PROGRAM_ID) )</ID>
    <ID>SpreadOperator:DummyContract.kt$DummyContract.Companion$(*items)</ID>
    <ID>SpreadOperator:DummyContractV2.kt$DummyContractV2.Companion$( /* INPUTS */ *priors.toTypedArray(), /* COMMAND */ Command(cmd, priorState.owners.map { it.owningKey }), /* OUTPUT */ StateAndContract(state, DummyContractV2.PROGRAM_ID) )</ID>
    <ID>SpreadOperator:ExceptionsErrorCodeFunctions.kt$(*fields)</ID>
    <ID>SpreadOperator:ExceptionsErrorCodeFunctions.kt$(*fields, cause.staticLocationBasedHash(hashedFields, visited + cause))</ID>
    <ID>SpreadOperator:ExceptionsErrorCodeFunctions.kt$(*hashedFields.invoke(this))</ID>
    <ID>SpreadOperator:Expect.kt$(*Array(number) { expectation(it) })</ID>
    <ID>SpreadOperator:Expect.kt$(*expectations)</ID>
    <ID>SpreadOperator:Explorer.kt$ExplorerController$(explorerPath, *args)</ID>
    <ID>SpreadOperator:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$(flowClass, *args)</ID>
    <ID>SpreadOperator:FlowOverrideTests.kt$FlowOverrideTests$(*nodeAClasses.toTypedArray())</ID>
    <ID>SpreadOperator:FlowOverrideTests.kt$FlowOverrideTests$(*nodeBClasses.toTypedArray())</ID>
    <ID>SpreadOperator:FlowTestsUtils.kt$(*allSessions)</ID>
    <ID>SpreadOperator:FlowTestsUtils.kt$(session, *sessions)</ID>
    <ID>SpreadOperator:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$(*ourInputStates.toTypedArray())</ID>
    <ID>SpreadOperator:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$(*ourOutputState.map { StateAndContract(it, Cash.PROGRAM_ID) }.toTypedArray())</ID>
    <ID>SpreadOperator:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$(*theirInputStates.toTypedArray())</ID>
    <ID>SpreadOperator:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$(*theirOutputState.map { StateAndContract(it, Cash.PROGRAM_ID) }.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$(*leftPredicates.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$(*leftPredicates.toTypedArray(), *rightPredicates.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$(*rightPredicates.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$(*predicateSet.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$(*combinedPredicates.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$(*joinPredicates.toTypedArray())</ID>
    <ID>SpreadOperator:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$(*commandAndArgs)</ID>
    <ID>SpreadOperator:InteractiveShell.kt$InteractiveShell$(clazz, *args)</ID>
    <ID>SpreadOperator:InternalUtils.kt$(this, target, *options)</ID>
    <ID>SpreadOperator:InvocationHandlerTemplate.kt$InvocationHandlerTemplate$(delegate, *args)</ID>
    <ID>SpreadOperator:IrsDemoWebApplication.kt$IrsDemoWebApplication.Companion$(IrsDemoWebApplication::class.java, *args)</ID>
    <ID>SpreadOperator:IssueCash.kt$IssueCash$(*args)</ID>
    <ID>SpreadOperator:JVMConfig.kt$JVMConfig$(jarPath, *args)</ID>
    <ID>SpreadOperator:JVMConfig.kt$JVMConfig$(javaPath.toString(), "-jar", jarPath.toString(), *args)</ID>
    <ID>SpreadOperator:JarSignatureTestUtils.kt$JarSignatureTestUtils$((bin / command[0]).toString(), *command.sliceArray(1 until command.size))</ID>
    <ID>SpreadOperator:JarSignatureTestUtils.kt$JarSignatureTestUtils$(*(arrayOf("jar", "cvf", fileName) + contents))</ID>
    <ID>SpreadOperator:JarSignatureTestUtils.kt$JarSignatureTestUtils$(*(arrayOf("jar", "i", fileName)))</ID>
    <ID>SpreadOperator:JarSignatureTestUtils.kt$JarSignatureTestUtils$(*(arrayOf("jar", "uvf", fileName) + contents))</ID>
    <ID>SpreadOperator:Kryo.kt$ImmutableClassSerializer$(*args)</ID>
    <ID>SpreadOperator:LogHelper.kt$LogHelper$(*classes.map { "+" + it.packageName }.toTypedArray())</ID>
    <ID>SpreadOperator:LogHelper.kt$LogHelper$(*classes.map { it.packageName }.toTypedArray())</ID>
    <ID>SpreadOperator:Main.kt$(*args)</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$( identityService, *arrayOf(initialIdentity.keyPair) + moreKeys, pkToIdCache = MockPublicKeyToOwningIdentityCache() )</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$( listOf(getCallerPackage(MockServices::class)!!), firstIdentity, *moreIdentities )</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$( listOf(getCallerPackage(MockServices::class)!!), firstIdentity, networkParameters, *moreIdentities )</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$(*listOf(firstIdentity, *moreIdentities).map { it.identity }.toTypedArray())</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$(cordappPackages, TestIdentity(initialIdentityName, key), identityService, *moreKeys)</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$(firstIdentity, *moreIdentities)</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$(listOf(getCallerPackage(MockServices::class)!!), TestIdentity(initialIdentityName, key), identityService, *moreKeys)</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices.Companion$( identityService, *arrayOf(initialIdentity.keyPair) + moreKeys, pkToIdCache = MockPublicKeyToOwningIdentityCache() )</ID>
    <ID>SpreadOperator:NetworkBuilder.kt$(*this.toTypedArray())</ID>
    <ID>SpreadOperator:NetworkMapTest.kt$NetworkMapTest$(*nodes)</ID>
    <ID>SpreadOperator:NetworkMapUpdater.kt$NetworkMapUpdater$(*networkMapDownloadFutures)</ID>
    <ID>SpreadOperator:NetworkParametersCopier.kt$NetworkParametersCopier$(nodeDir / fileName, *copyOptions)</ID>
    <ID>SpreadOperator:NodeRegistrationTest.kt$NodeRegistrationTest$( pollInterval = 1.seconds, hostAndPort = portAllocation.nextHostAndPort(), myHostNameValue = "localhost", additionalServices = *arrayOf(registrationHandler))</ID>
    <ID>SpreadOperator:NodeVaultService.kt$NodeVaultService$(*commonPredicates)</ID>
    <ID>SpreadOperator:NodeVaultService.kt$NodeVaultService$(*commonPredicates, stateRefsPredicate)</ID>
    <ID>SpreadOperator:NodeVaultService.kt$NodeVaultService$(lockUpdateTime, lockIdPredicate, *commonPredicates)</ID>
    <ID>SpreadOperator:NodeVaultService.kt$NodeVaultService$(stateStatusPredication, lockIdPredicate, *commonPredicates)</ID>
    <ID>SpreadOperator:ObjectBuilder.kt$ConstructorCaller$(*parameters)</ID>
    <ID>SpreadOperator:ObligationUtils.kt$ObligationUtils$(*inputs)</ID>
    <ID>SpreadOperator:PathUtils.kt$(*options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(charset, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(parent / fileName, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, *attrs)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, BasicFileAttributes::class.java, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, bytes, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, charset, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, lines, charset, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, maxDepth, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, target, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, targetFile, *options)</ID>
    <ID>SpreadOperator:ProgressTracker.kt$ProgressTracker$(UNSTARTED, STARTING, *inputSteps, DONE)</ID>
    <ID>SpreadOperator:Properties.kt$FunctionalListProperty$(*error.containingPath(index).toTypedArray())</ID>
    <ID>SpreadOperator:Properties.kt$ListProperty$(*error.containingPath(index).toTypedArray())</ID>
    <ID>SpreadOperator:Properties.kt$StandardProperty$(*key.split(".").toTypedArray())</ID>
    <ID>SpreadOperator:RPCClient.kt$RPCClient$(*haPoolTransportConfigurations.toTypedArray())</ID>
    <ID>SpreadOperator:RPCDriver.kt$RandomRpcUser.Companion$(handle.proxy, *arguments.toTypedArray())</ID>
    <ID>SpreadOperator:RPCOpsWithContext.kt$(cordaRPCOps, *(args ?: arrayOf()))</ID>
    <ID>SpreadOperator:RPCServer.kt$RPCServer$(ops, *arguments.toTypedArray())</ID>
    <ID>SpreadOperator:ReactiveArtemisConsumer.kt$ReactiveArtemisConsumer.Companion$(queueName, *queueNames)</ID>
    <ID>SpreadOperator:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$(reconnectingRPCConnection.proxy, *(args ?: emptyArray()))</ID>
    <ID>SpreadOperator:ServiceHub.kt$ServiceHub$(first, *remaining)</ID>
    <ID>SpreadOperator:StandaloneShell.kt$StandaloneShell$(format, *args)</ID>
    <ID>SpreadOperator:StringToMethodCallParser.kt$StringToMethodCallParser.ParsedMethodCall$(target, *args)</ID>
    <ID>SpreadOperator:TestNodeInfoBuilder.kt$TestNodeInfoBuilder$(*certs, intermediateAndRoot.first.certificate, intermediateAndRoot.second)</ID>
    <ID>SpreadOperator:TestUtils.kt$TestIdentity$(*bytes)</ID>
    <ID>SpreadOperator:ThrowableSerializer.kt$ThrowableSerializer$(*params.toTypedArray())</ID>
    <ID>SpreadOperator:TraderDemo.kt$TraderDemo$(*args)</ID>
    <ID>SpreadOperator:TransactionBuilder.kt$TransactionBuilder$(*keys)</ID>
    <ID>SpreadOperator:TransactionBuilder.kt$TransactionBuilder$(*types)</ID>
    <ID>SpreadOperator:TransactionWithSignatures.kt$TransactionWithSignatures$(*allowedToBeMissing)</ID>
    <ID>SpreadOperator:WaitForStateConsumption.kt$WaitForStateConsumption$(*futures.toTypedArray())</ID>
    <ID>SpreadOperator:WebArgsParser.kt$ArgsParser$(*args)</ID>
    <ID>SpreadOperator:WebServer.kt$(*args)</ID>
    <ID>SpreadOperator:X509Utilities.kt$X509Utilities$(*certificates)</ID>
    <ID>StringTemplate:</ID>
    <ID>ThrowsCount:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser$// Make sure our inputs aren't designed to blow things up. private fun validate(typeString: String)</ID>
    <ID>ThrowsCount:AbstractNode.kt$fun CordaPersistence.startHikariPool( hikariProperties: Properties, databaseConfig: DatabaseConfig, schemas: Set&lt;MappedSchema&gt;, metricRegistry: MetricRegistry? = null, cordappLoader: CordappLoader? = null, currentDir: Path? = null, ourName: CordaX500Name )</ID>
    <ID>ThrowsCount:ArtemisMessagingServer.kt$ArtemisMessagingServer$// TODO: Maybe wrap [IOException] on a key store load error so that it's clearly splitting key store loading from // Artemis IO errors @Throws(IOException::class, AddressBindingException::class, KeyStoreException::class) private fun configureAndStartServer()</ID>
    <ID>ThrowsCount:BrokerJaasLoginModule.kt$BaseBrokerJaasLoginModule$protected fun getUsernamePasswordAndCerts(): Triple&lt;String, String, Array&lt;X509Certificate&gt;?&gt;</ID>
    <ID>ThrowsCount:CheckpointVerifier.kt$CheckpointVerifier$ fun verifyCheckpointsCompatible( checkpointStorage: CheckpointStorage, currentCordapps: List&lt;Cordapp&gt;, platformVersion: Int, serviceHub: ServiceHub, tokenizableServices: List&lt;Any&gt; )</ID>
    <ID>ThrowsCount:CheckpointVerifier.kt$CheckpointVerifier$// Throws exception when the flow is incompatible private fun checkFlowCompatible( subFlow: SubFlow, currentCordappsByHash: Map&lt;SecureHash.SHA256, Cordapp&gt;, platformVersion: Int )</ID>
    <ID>ThrowsCount:ClassCarpenter.kt$ClassCarpenterImpl$ private fun validateSchema(schema: Schema)</ID>
    <ID>ThrowsCount:ConnectionManager.kt$ fun setupJSchWithSshAgent(): JSch</ID>
    <ID>ThrowsCount:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$ fun resolve(services: ServicesForResolution, sigs: List&lt;TransactionSignature&gt;): ContractUpgradeLedgerTransaction</ID>
    <ID>ThrowsCount:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(signatureScheme: SignatureScheme, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>ThrowsCount:DeserializationInput.kt$DeserializationInput$@Throws( AMQPNotSerializableException::class, AMQPNoTypeNotSerializableException::class) private fun &lt;R&gt; des(generator: () -&gt; R): R</ID>
    <ID>ThrowsCount:DeserializationInput.kt$DeserializationInput$fun readObject(obj: Any, schemas: SerializationSchemas, type: Type, context: SerializationContext): Any</ID>
    <ID>ThrowsCount:EnumTransforms.kt$EnumTransforms$ private fun validateNoCycles(constants: Map&lt;String, Int&gt;)</ID>
    <ID>ThrowsCount:JacksonSupport.kt$JacksonSupport.PartyDeserializer$private fun lookupByNameSegment(mapper: PartyObjectMapper, parser: JsonParser): Party</ID>
    <ID>ThrowsCount:JarScanningCordappLoader.kt$JarScanningCordappLoader$private fun parseVersion(versionStr: String?, attributeName: String): Int</ID>
    <ID>ThrowsCount:LedgerDSLInterpreter.kt$Verifies$ fun failsWith(expectedMessage: String?): EnforceVerifyOrFail</ID>
    <ID>ThrowsCount:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$private fun validateCertificates(registeringPublicKey: PublicKey, certificates: List&lt;X509Certificate&gt;)</ID>
    <ID>ThrowsCount:NodeInfoFilesCopier.kt$NodeInfoFilesCopier$private fun atomicCopy(source: Path, destination: Path)</ID>
    <ID>ThrowsCount:NodeVaultService.kt$NodeVaultService$@Throws(VaultQueryException::class) private fun &lt;T : ContractState&gt; _queryBy( criteria: QueryCriteria, paging_: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;, skipPagingChecks: Boolean ): Vault.Page&lt;T&gt;</ID>
    <ID>ThrowsCount:NodeVaultService.kt$NodeVaultService$private fun makeUpdates(batch: Iterable&lt;CoreTransaction&gt;, statesToRecord: StatesToRecord, previouslySeen: Boolean): List&lt;Vault.Update&lt;ContractState&gt;&gt;</ID>
    <ID>ThrowsCount:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$ private fun checkNotaryWhitelisted(notary: Party, attachedParameterHash: SecureHash?)</ID>
    <ID>ThrowsCount:PropertyDescriptor.kt$PropertyDescriptor$ fun validate()</ID>
    <ID>ThrowsCount:RPCApi.kt$RPCApi.ServerToClient.Companion$fun fromClientMessage(context: SerializationContext, message: ClientMessage): ServerToClient</ID>
    <ID>ThrowsCount:RPCServer.kt$RPCServer$private fun invokeRpc(context: RpcAuthContext, methodName: String, arguments: List&lt;Any?&gt;): Try&lt;Any&gt;</ID>
    <ID>ThrowsCount:SchemaMigration.kt$SchemaMigration$private fun doRunMigration(run: Boolean, check: Boolean, existingCheckpoints: Boolean? = null)</ID>
    <ID>ThrowsCount:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$// We may need to recursively chase transactions if there are notary changes. fun inner(stateRef: StateRef, forContractClassName: String?): Attachment</ID>
    <ID>ThrowsCount:SignedNodeInfo.kt$SignedNodeInfo$// TODO Add root cert param (or TrustAnchor) to make sure all the identities belong to the same root fun verified(): NodeInfo</ID>
    <ID>ThrowsCount:SignedTransaction.kt$SignedTransaction$// TODO: Verify contract constraints here as well as in LedgerTransaction to ensure that anything being deserialised // from the attachment is trusted. This will require some partial serialisation work to not load the ContractState // objects from the TransactionState. @DeleteForDJVM private fun verifyRegularTransaction(services: ServiceHub, checkSufficientSignatures: Boolean)</ID>
    <ID>ThrowsCount:SignedTransaction.kt$SignedTransaction$@DeleteForDJVM private fun resolveAndCheckNetworkParameters(services: ServiceHub)</ID>
    <ID>ThrowsCount:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private fun getInitiatedFlowFactory(message: InitialSessionMessage): InitiatedFlowFactory&lt;*&gt;</ID>
    <ID>ThrowsCount:StringToMethodCallParser.kt$StringToMethodCallParser$ @Throws(UnparseableCallException::class) fun parse(target: T?, command: String): ParsedMethodCall</ID>
    <ID>ThrowsCount:StringToMethodCallParser.kt$StringToMethodCallParser$ @Throws(UnparseableCallException::class) fun parseArguments(methodNameHint: String, parameters: List&lt;Pair&lt;String, Type&gt;&gt;, args: String): Array&lt;Any?&gt;</ID>
    <ID>ThrowsCount:StructuresTests.kt$AttachmentTest$@Test fun `openAsJAR does not leak file handle if attachment has corrupted manifest`()</ID>
    <ID>ThrowsCount:TransactionBuilder.kt$TransactionBuilder$ fun withItems(vararg items: Any)</ID>
    <ID>ThrowsCount:TransactionBuilder.kt$TransactionBuilder$ private fun addMissingDependency(services: ServicesForResolution, wireTx: WireTransaction): Boolean</ID>
    <ID>ThrowsCount:TransactionBuilder.kt$TransactionBuilder$ private fun attachmentConstraintsTransition( constraints: Set&lt;AttachmentConstraint&gt;, attachmentToUse: ContractAttachment, services: ServicesForResolution ): AttachmentConstraint</ID>
    <ID>ThrowsCount:TransactionVerifierServiceInternal.kt$Verifier$ private fun getUniqueContractAttachmentsByContract(): Map&lt;ContractClassName, ContractAttachment&gt;</ID>
    <ID>ThrowsCount:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyContracts()</ID>
    <ID>ThrowsCount:TransactionVerifierServiceInternal.kt$Verifier$// Using basic graph theory, a full cycle of encumbered (co-dependent) states should exist to achieve bi-directional // encumbrances. This property is important to ensure that no states involved in an encumbrance-relationship // can be spent on their own. Briefly, if any of the states is having more than one encumbrance references by // other states, a full cycle detection will fail. As a result, all of the encumbered states must be present // as "from" and "to" only once (or zero times if no encumbrance takes place). For instance, // a -&gt; b // c -&gt; b and a -&gt; b // b -&gt; a b -&gt; c // do not satisfy the bi-directionality (full cycle) property. // // In the first example "b" appears twice in encumbrance ("to") list and "c" exists in the encumbered ("from") list only. // Due the above, one could consume "a" and "b" in the same transaction and then, because "b" is already consumed, "c" cannot be spent. // // Similarly, the second example does not form a full cycle because "a" and "c" exist in one of the lists only. // As a result, one can consume "b" and "c" in the same transactions, which will make "a" impossible to be spent. // // On other hand the following are valid constructions: // a -&gt; b a -&gt; c // b -&gt; c and c -&gt; b // c -&gt; a b -&gt; a // and form a full cycle, meaning that the bi-directionality property is satisfied. private fun checkBidirectionalOutputEncumbrances(statesAndEncumbrance: List&lt;Pair&lt;Int, Int&gt;&gt;)</ID>
    <ID>ThrowsCount:WireTransaction.kt$WireTransaction$private fun toLedgerTransactionInternal( resolveIdentity: (PublicKey) -&gt; Party?, resolveAttachment: (SecureHash) -&gt; Attachment?, resolveStateRefAsSerialized: (StateRef) -&gt; SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?, resolveParameters: (SecureHash?) -&gt; NetworkParameters?, resolveContractAttachment: (StateRef) -&gt; Attachment, isAttachmentTrusted: (Attachment) -&gt; Boolean ): LedgerTransaction</ID>
    <ID>ThrowsCount:WireTransaction.kt$WireTransaction.Companion$ @CordaInternal fun resolveStateRefBinaryComponent(stateRef: StateRef, services: ServicesForResolution): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?</ID>
    <ID>TooGenericExceptionCaught:AMQPChannelHandler.kt$AMQPChannelHandler$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:AMQPExceptions.kt$th: Throwable</ID>
    <ID>TooGenericExceptionCaught:AbstractNode.kt$AbstractNode$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AbstractNode.kt$AbstractNode.&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AbstractNode.kt$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:Amount.kt$Amount.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AttachmentDemo.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AttachmentLoadingTests.kt$AttachmentLoadingTests.ConsumeAndBroadcastResponderFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AzureSmbVolume.kt$AzureSmbVolume$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BCCryptoService.kt$BCCryptoService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BankOfCordaWebApi.kt$BankOfCordaWebApi$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BlobInspector.kt$BlobInspector$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BootstrapperView.kt$BootstrapperView$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BridgeControlListener.kt$BridgeControlListener$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CertRole.kt$CertRole.Companion$ex: ArrayIndexOutOfBoundsException</ID>
    <ID>TooGenericExceptionCaught:CheckpointAgent.kt$CheckpointAgent.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CheckpointAgent.kt$CheckpointHook$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:CheckpointDumper.kt$CheckpointDumper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CheckpointVerifier.kt$CheckpointVerifier$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CollectSignaturesFlow.kt$SignTransactionFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ConcurrencyUtils.kt$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:ConfigUtilities.kt$e:Exception</ID>
    <ID>TooGenericExceptionCaught:ConnectionStateMachine.kt$ConnectionStateMachine$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ContractAttachmentSerializer.kt$ContractAttachmentSerializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaAuthenticationPlugin.kt$CordaAuthenticationPlugin$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaClassResolver.kt$LoggingWhitelist.Companion$ioEx: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaFutureImpl.kt$CordaFutureImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaFutureImpl.kt$ValueOrException$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaFutureImpl.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaPersistence.kt$CordaPersistence$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaRPCClientTest.kt$CordaRPCClientTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DBNetworkParametersStorage.kt$DBNetworkParametersStorage$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DataUploadServlet.kt$DataUploadServlet$e: RuntimeException</ID>
    <ID>TooGenericExceptionCaught:DemoBenchView.kt$DemoBenchView$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DeserializationInput.kt$DeserializationInput$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DockerInstantiator.kt$DockerInstantiator$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DriverDSLImpl.kt$DriverDSLImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DriverDSLImpl.kt$exception: Throwable</ID>
    <ID>TooGenericExceptionCaught:DriverTests.kt$DriverTests$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ErrorCodeLoggingTests.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:EventProcessor.kt$EventProcessor$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:Eventually.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ExceptionMaskingRpcOpsProxy.kt$ExceptionMaskingRpcOpsProxy.ErrorObfuscatingInvocationHandler$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:ExceptionSerialisingRpcOpsProxy.kt$ExceptionSerialisingRpcOpsProxy.ErrorSerialisingInvocationHandler$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:Expect.kt$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:Explorer.kt$Explorer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FiberDeserializationCheckingInterceptor.kt$FiberDeserializationChecker$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:FinanceJSONSupport.kt$CalendarDeserializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowHandle.kt$FlowProgressHandleImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowMessaging.kt$FlowMessagingImpl$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowStateMachineImpl.kt$FlowStateMachineImpl$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowStateMachineImpl.kt$FlowStateMachineImpl$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:FutureMatchers.kt$&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:HibernateConfiguration.kt$HibernateConfiguration$e: Exception</ID>
    <ID>TooGenericExceptionCaught:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$e: Exception</ID>
    <ID>TooGenericExceptionCaught:IRSDemoTest.kt$IRSDemoTest.InterestRateSwapStateDeserializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InitialRegistrationCli.kt$InitialRegistration$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InitialRegistrationCli.kt$InitialRegistration.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Injectors.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:InteractiveShell.kt$InteractiveShell$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InteractiveShell.kt$InteractiveShell$e: IndexOutOfBoundsException</ID>
    <ID>TooGenericExceptionCaught:InterestSwapRestAPI.kt$InterestRateSwapAPI$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:InternalMockNetwork.kt$InternalMockNetwork$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:InternalTestUtils.kt$&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InternalUtils.kt$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:InternalUtils.kt$th: Throwable</ID>
    <ID>TooGenericExceptionCaught:IssueCash.kt$IssueCash$e: Exception</ID>
    <ID>TooGenericExceptionCaught:JacksonSupport.kt$JacksonSupport.PartyDeserializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:JacksonSupport.kt$JacksonSupport.PublicKeyDeserializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:JacksonSupport.kt$JacksonSupport.SecureHashDeserializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:JarScanningCordappLoader.kt$JarScanningCordappLoader$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Kryo.kt$ImmutableClassSerializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:LedgerDSLInterpreter.kt$Verifies$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:LoadTest.kt$LoadTest$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:LoginView.kt$LoginView$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Main.kt$Main$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MerkleTransaction.kt$FilteredTransaction$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MigrationServicesForResolution.kt$MigrationServicesForResolution$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MockAttachmentStorage.kt$MockAttachmentStorage$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MockCryptoService.kt$MockCryptoService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MockNodeMessagingService.kt$MockNodeMessagingService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MyCustomNotaryService.kt$MyValidatingNotaryFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkBootstrapper.kt$NetworkBootstrapper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkMapServer.kt$NetworkMapServer.InMemoryNetworkMapService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkMapUpdater.kt$NetworkMapUpdater$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkMapUpdater.kt$NetworkMapUpdater.&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkParameterOverridesSpec.kt$NetworkParameterOverridesSpec.PackageOwnershipSpec$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkParametersReader.kt$NetworkParametersReader$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeController.kt$NodeController$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeInfoWatcher.kt$NodeInfoWatcher$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeInterestRates.kt$NodeInterestRates$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeMonitorModel.kt$NodeMonitorModel$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeProcess.kt$NodeProcess.Factory$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeRPC.kt$NodeRPC$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeRPC.kt$NodeRPC.&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeSchedulerService.kt$NodeSchedulerService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeStartup.kt$NodeStartup$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeTerminalView.kt$NodeTerminalView$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeVaultService.kt$NodeVaultService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NotaryServiceFlow.kt$NotaryServiceFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NotaryUtils.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ObjectDiffer.kt$ObjectDiffer$throwable: Exception</ID>
    <ID>TooGenericExceptionCaught:P2PMessagingClient.kt$P2PMessagingClient$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PersistentIdentityMigrationNewTable.kt$PersistentIdentityMigrationNewTable$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PersistentUniquenessProvider.kt$PersistentUniquenessProvider$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ProfileController.kt$ProfileController$e: Exception</ID>
    <ID>TooGenericExceptionCaught:QuasarInstrumentationHook.kt$QuasarInstrumentationHook$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:R3Pty.kt$R3Pty$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCApi.kt$RPCApi.ServerToClient.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCClient.kt$RPCClient$exception: Throwable</ID>
    <ID>TooGenericExceptionCaught:RPCClientProxyHandler.kt$RPCClientProxyHandler$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCClientProxyHandler.kt$RPCClientProxyHandler$e: RuntimeException</ID>
    <ID>TooGenericExceptionCaught:RPCServer.kt$RPCServer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCServer.kt$RPCServer$exception: Throwable</ID>
    <ID>TooGenericExceptionCaught:RPCServer.kt$RPCServer$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:RPCStabilityTests.kt$RPCStabilityTests$e2: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCStabilityTests.kt$RPCStabilityTests$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RandomFailingProxy.kt$RandomFailingProxy$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ReceiveTransactionFlow.kt$ReceiveTransactionFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ReconnectingObservable.kt$ReconnectingObservable.ReconnectingSubscriber$e: Exception</ID>
    <ID>TooGenericExceptionCaught:SSLHelper.kt$LoggingTrustManagerWrapper$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ShutdownManager.kt$ShutdownManager$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:SimpleMQClient.kt$SimpleMQClient$e: Exception</ID>
    <ID>TooGenericExceptionCaught:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:StandaloneShell.kt$StandaloneShell$e: Exception</ID>
    <ID>TooGenericExceptionCaught:StandardConfigValueParsers.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:StringToMethodCallParser.kt$StringToMethodCallParser$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ThrowableSerializer.kt$ThrowableSerializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TraderDemo.kt$TraderDemo$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TransactionBuilder.kt$TransactionBuilder$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:TransactionUtils.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TransactionVerifierServiceInternal.kt$Verifier$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TransformTypes.kt$TransformTypes.Companion$e: IndexOutOfBoundsException</ID>
    <ID>TooGenericExceptionCaught:TransitionExecutorImpl.kt$TransitionExecutorImpl$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:Try.kt$Try.Companion$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:Utils.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ValidatingNotaryFlow.kt$ValidatingNotaryFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:VaultStateMigration.kt$VaultStateIterator$e: Exception</ID>
    <ID>TooGenericExceptionCaught:VaultStateMigration.kt$VaultStateMigration$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WebServer.kt$WebServer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WebServer.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WebServer.kt$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:X509EdDSAEngine.kt$X509EdDSAEngine$e: Exception</ID>
    <ID>TooGenericExceptionThrown:AMQPExceptionsTests.kt$AMQPExceptionsTests$throw Exception("FAILED")</ID>
    <ID>TooGenericExceptionThrown:AbstractNode.kt$AbstractNode$throw Error("Unable to locate agent jar file")</ID>
    <ID>TooGenericExceptionThrown:AzureBackend.kt$AzureBackend.Companion$throw RuntimeException(e)</ID>
    <ID>TooGenericExceptionThrown:ClassLoadingUtilsTest.kt$ClassLoadingUtilsTest$throw RuntimeException()</ID>
    <ID>TooGenericExceptionThrown:CommandParsers.kt$AzureParser.RegionConverter$throw Error("Unknown azure region: $value")</ID>
    <ID>TooGenericExceptionThrown:ContractHierarchyTest.kt$ContractHierarchyTest.IndirectContractParent$throw RuntimeException("Boom!")</ID>
    <ID>TooGenericExceptionThrown:CrossCashTest.kt$throw Exception( "Generated exit of ${request.amount} from $issuer, however there is no cash to exit!" )</ID>
    <ID>TooGenericExceptionThrown:CrossCashTest.kt$throw Exception( "Generated payment of ${request.amount} from $issuer, " + "however they only have $issuerQuantity!" )</ID>
    <ID>TooGenericExceptionThrown:CrossCashTest.kt$throw Exception( "Generated payment of ${request.amount} from ${node.mainIdentity}, " + "however there is no cash from $issuer!" )</ID>
    <ID>TooGenericExceptionThrown:CrossCashTest.kt$throw Exception( "Generated payment of ${request.amount} from ${node.mainIdentity}, " + "however they only have $senderQuantity!" )</ID>
    <ID>TooGenericExceptionThrown:FlowAsyncOperationTests.kt$FlowAsyncOperationTests.ErroredExecute$throw Exception()</ID>
    <ID>TooGenericExceptionThrown:FlowFrameworkTests.kt$FlowFrameworkTests$throw Exception("Error")</ID>
    <ID>TooGenericExceptionThrown:Generator.kt$Generator$throw Exception("Failed to generate", error)</ID>
    <ID>TooGenericExceptionThrown:MerkleTransaction.kt$FilteredTransaction$throw Exception("Malformed transaction, signers at index $internalIndex cannot be deserialised", e)</ID>
    <ID>TooGenericExceptionThrown:NodeConnection.kt$NodeConnection.ShellCommandOutput$throw Exception(diagnostic)</ID>
    <ID>TooGenericExceptionThrown:PhysicalLocationStructures.kt$CityDatabase$throw Exception("Could not parse line: $line")</ID>
    <ID>TooGenericExceptionThrown:RPCDriver.kt$RandomRpcUser.Companion$throw Exception("No generator for ${it.type}")</ID>
    <ID>TooGenericExceptionThrown:RpcServerObservableSerializerTests.kt$RpcServerObservableSerializerTests$throw Error("Observable serializer must be registerable with factory, unexpected exception - ${e.message}")</ID>
    <ID>TooGenericExceptionThrown:RpcServerObservableSerializerTests.kt$RpcServerObservableSerializerTests$throw Error("Serialization of observable should not throw - ${e.message}")</ID>
    <ID>TooGenericExceptionThrown:SelfIssueTest.kt$throw Exception( "Simulated state diverged from actual state" + "\nSimulated state:\n${previousState.vaultsSelfIssued}" + "\nActual state:\n$selfIssueVaults" + "\nDiff:\n$diffString" )</ID>
    <ID>TooGenericExceptionThrown:SendTransactionFlow.kt$DataVendingFlow$throw Exception("Unknown payload type: ${payload::class.java} ?")</ID>
    <ID>TooGenericExceptionThrown:SendTransactionFlow.kt$DataVendingFlow$throw Exception("Unknown payload type: ${stateAndRef!!::class.java} ?")</ID>
    <ID>TooGenericExceptionThrown:SerializationOutputTests.kt$SerializationOutputTests$throw Error("Deserializing serialized \$C should not throw")</ID>
    <ID>TooGenericExceptionThrown:SerializationOutputTests.kt$SerializationOutputTests.&lt;no name provided&gt;$throw Exception()</ID>
    <ID>TooGenericExceptionThrown:UniversalContract.kt$UniversalContract$throw Error("Unable to evaluate")</ID>
    <ID>TooGenericExceptionThrown:WebServerConfig.kt$WebServerConfig$throw Exception("Missing rpc address property. Either 'rpcSettings' or 'rpcAddress' must be specified.")</ID>
    <ID>TooManyFunctions:AMQPChannelHandler.kt$AMQPChannelHandler : ChannelDuplexHandler</ID>
    <ID>TooManyFunctions:ANSIProgressRenderer.kt$ANSIProgressRenderer</ID>
    <ID>TooManyFunctions:AbstractNode.kt$AbstractNode&lt;S&gt; : SingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:ActionExecutorImpl.kt$ActionExecutorImpl : ActionExecutor</ID>
    <ID>TooManyFunctions:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase&lt;K, V, E, out EK&gt;</ID>
    <ID>TooManyFunctions:ArtemisMessagingTest.kt$ArtemisMessagingTest</ID>
    <ID>TooManyFunctions:ArtemisTcpTransport.kt$ArtemisTcpTransport$Companion</ID>
    <ID>TooManyFunctions:BCCryptoService.kt$BCCryptoService : CryptoService</ID>
    <ID>TooManyFunctions:BFTSmart.kt$BFTSmart$Replica : DefaultRecoverable</ID>
    <ID>TooManyFunctions:BaseTransaction.kt$BaseTransaction : NamedByHash</ID>
    <ID>TooManyFunctions:ByteArrays.kt$ByteSequence : Comparable</ID>
    <ID>TooManyFunctions:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests</ID>
    <ID>TooManyFunctions:CertificateStore.kt$CertificateStore : Iterable</ID>
    <ID>TooManyFunctions:CheckpointAgent.kt$CheckpointHook : ClassFileTransformer</ID>
    <ID>TooManyFunctions:CheckpointDumper.kt$CheckpointDumper</ID>
    <ID>TooManyFunctions:ClassCarpenter.kt$ClassCarpenterImpl : ClassCarpenter</ID>
    <ID>TooManyFunctions:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker</ID>
    <ID>TooManyFunctions:CompositeKey.kt$CompositeKey : PublicKey</ID>
    <ID>TooManyFunctions:ConfigUtilities.kt$net.corda.nodeapi.internal.config.ConfigUtilities.kt</ID>
    <ID>TooManyFunctions:Configuration.kt$Configuration$Specification&lt;VALUE&gt; : SchemaParser</ID>
    <ID>TooManyFunctions:ConnectionStateMachine.kt$ConnectionStateMachine : BaseHandler</ID>
    <ID>TooManyFunctions:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction : FullTransactionTransactionWithSignatures</ID>
    <ID>TooManyFunctions:CordaFutureImpl.kt$net.corda.core.internal.concurrent.CordaFutureImpl.kt</ID>
    <ID>TooManyFunctions:CordaPersistence.kt$CordaPersistence : Closeable</ID>
    <ID>TooManyFunctions:CordaRPCClientTest.kt$CordaRPCClientTest : NodeBasedTest</ID>
    <ID>TooManyFunctions:CordaRPCOps.kt$CordaRPCOps : RPCOps</ID>
    <ID>TooManyFunctions:CordaRPCOps.kt$net.corda.core.messaging.CordaRPCOps.kt</ID>
    <ID>TooManyFunctions:CordaRPCOpsImpl.kt$CordaRPCOpsImpl : InternalCordaRPCOpsAutoCloseable</ID>
    <ID>TooManyFunctions:CordaUtils.kt$net.corda.core.internal.CordaUtils.kt</ID>
    <ID>TooManyFunctions:Crypto.kt$Crypto</ID>
    <ID>TooManyFunctions:CryptoUtils.kt$net.corda.core.crypto.CryptoUtils.kt</ID>
    <ID>TooManyFunctions:Currencies.kt$net.corda.finance.Currencies.kt</ID>
    <ID>TooManyFunctions:Driver.kt$DriverParameters</ID>
    <ID>TooManyFunctions:DriverDSLImpl.kt$DriverDSLImpl : InternalDriverDSL</ID>
    <ID>TooManyFunctions:DriverTests.kt$DriverTests</ID>
    <ID>TooManyFunctions:EncodingUtils.kt$net.corda.core.utilities.EncodingUtils.kt</ID>
    <ID>TooManyFunctions:EventProcessor.kt$EventProcessor : BaseHandler</ID>
    <ID>TooManyFunctions:ExceptionMaskingRpcOpsProxy.kt$ExceptionMaskingRpcOpsProxy$ErrorObfuscatingInvocationHandler : InvocationHandlerTemplate</ID>
    <ID>TooManyFunctions:Expect.kt$net.corda.testing.core.Expect.kt</ID>
    <ID>TooManyFunctions:FlowLogic.kt$FlowLogic&lt;out T&gt;</ID>
    <ID>TooManyFunctions:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl : SingletonSerializeAsTokenFlowLogicRefFactory</ID>
    <ID>TooManyFunctions:FlowSessionImpl.kt$FlowSessionImpl : FlowSession</ID>
    <ID>TooManyFunctions:FlowStateMachineImpl.kt$FlowStateMachineImpl&lt;R&gt; : FiberFlowStateMachineFlowFiber</ID>
    <ID>TooManyFunctions:Generator.kt$Generator$Companion</ID>
    <ID>TooManyFunctions:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser : AbstractQueryCriteriaParserIQueryCriteriaParser</ID>
    <ID>TooManyFunctions:HibernateStatistics.kt$DelegatingStatisticsService : StatisticsService</ID>
    <ID>TooManyFunctions:IRS.kt$InterestRateSwap : Contract</ID>
    <ID>TooManyFunctions:IRSDemoTest.kt$IRSDemoTest</ID>
    <ID>TooManyFunctions:IdentityService.kt$IdentityService</ID>
    <ID>TooManyFunctions:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork : SingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:InteractiveShell.kt$InteractiveShell</ID>
    <ID>TooManyFunctions:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest</ID>
    <ID>TooManyFunctions:InternalMockNetwork.kt$InternalMockNetwork : AutoCloseable</ID>
    <ID>TooManyFunctions:InternalMockNetwork.kt$InternalMockNetwork$MockNode : AbstractNode</ID>
    <ID>TooManyFunctions:InternalTestUtils.kt$net.corda.testing.internal.InternalTestUtils.kt</ID>
    <ID>TooManyFunctions:InternalTestUtils.kt$net.corda.testing.node.internal.InternalTestUtils.kt</ID>
    <ID>TooManyFunctions:InternalUtils.kt$net.corda.core.internal.InternalUtils.kt</ID>
    <ID>TooManyFunctions:JarScanningCordappLoader.kt$JarScanningCordappLoader : CordappLoaderTemplate</ID>
    <ID>TooManyFunctions:LedgerTransaction.kt$LedgerTransaction : FullTransaction</ID>
    <ID>TooManyFunctions:Literal.kt$ContractBuilder</ID>
    <ID>TooManyFunctions:LocalSerializerFactory.kt$DefaultLocalSerializerFactory : LocalSerializerFactory</ID>
    <ID>TooManyFunctions:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder</ID>
    <ID>TooManyFunctions:MQSecurityTest.kt$MQSecurityTest : NodeBasedTest</ID>
    <ID>TooManyFunctions:Main.kt$Node</ID>
    <ID>TooManyFunctions:Matchers.kt$net.corda.testing.internal.matchers.Matchers.kt</ID>
    <ID>TooManyFunctions:MockAttachmentStorage.kt$MockAttachmentStorage : AttachmentStorageSingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:MockNodeMessagingService.kt$MockNodeMessagingService : SingletonSerializeAsTokenMessagingService</ID>
    <ID>TooManyFunctions:MockServices.kt$MockServices : ServiceHub</ID>
    <ID>TooManyFunctions:NettyWritable.kt$NettyWritable : WritableBuffer</ID>
    <ID>TooManyFunctions:NetworkBootstrapper.kt$NetworkBootstrapper : NetworkBootstrapperWithOverridableParameters</ID>
    <ID>TooManyFunctions:NetworkBuilder.kt$NetworkBuilder</ID>
    <ID>TooManyFunctions:NetworkBuilder.kt$NetworkBuilderImpl : NetworkBuilder</ID>
    <ID>TooManyFunctions:NetworkMapCache.kt$NetworkMapCacheBase</ID>
    <ID>TooManyFunctions:Node.kt$Node : AbstractNode</ID>
    <ID>TooManyFunctions:NodeAttachmentService.kt$NodeAttachmentService : AttachmentStorageInternalSingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:NodeConnection.kt$NodeConnection : Closeable</ID>
    <ID>TooManyFunctions:NodeController.kt$NodeController : Controller</ID>
    <ID>TooManyFunctions:NodeParameters.kt$NodeParameters</ID>
    <ID>TooManyFunctions:NodeStartup.kt$NodeStartup : NodeStartupLogging</ID>
    <ID>TooManyFunctions:NodeTerminalView.kt$NodeTerminalView : Fragment</ID>
    <ID>TooManyFunctions:NodeVaultService.kt$NodeVaultService : SingletonSerializeAsTokenVaultServiceInternal</ID>
    <ID>TooManyFunctions:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction : FullTransactionTransactionWithSignatures</ID>
    <ID>TooManyFunctions:OGSwapPricingExample.kt$SwapPricingExample</ID>
    <ID>TooManyFunctions:ObservableUtilities.kt$net.corda.client.jfx.utils.ObservableUtilities.kt</ID>
    <ID>TooManyFunctions:P2PMessagingClient.kt$P2PMessagingClient : SingletonSerializeAsTokenMessagingServiceAddressToArtemisQueueResolver</ID>
    <ID>TooManyFunctions:PathUtils.kt$net.corda.core.internal.PathUtils.kt</ID>
    <ID>TooManyFunctions:Perceivable.kt$net.corda.finance.contracts.universal.Perceivable.kt</ID>
    <ID>TooManyFunctions:PersistentIdentityMigrationNewTable.kt$PersistentIdentityMigrationNewTable : CordaMigration</ID>
    <ID>TooManyFunctions:PersistentIdentityService.kt$PersistentIdentityService : SingletonSerializeAsTokenIdentityService</ID>
    <ID>TooManyFunctions:PersistentNetworkMapCache.kt$PersistentNetworkMapCache : NetworkMapCacheInternalSingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:PersistentUniquenessProvider.kt$PersistentUniquenessProvider : UniquenessProviderSingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:PortfolioApi.kt$PortfolioApi</ID>
    <ID>TooManyFunctions:ProgressTracker.kt$ProgressTracker</ID>
    <ID>TooManyFunctions:PropertyDescriptor.kt$net.corda.serialization.internal.amqp.PropertyDescriptor.kt</ID>
    <ID>TooManyFunctions:ProtonWrapperTests.kt$ProtonWrapperTests</ID>
    <ID>TooManyFunctions:QueryCriteria.kt$QueryCriteria$VaultQueryCriteria : CommonQueryCriteria</ID>
    <ID>TooManyFunctions:QueryCriteriaUtils.kt$Builder</ID>
    <ID>TooManyFunctions:RPCApi.kt$net.corda.nodeapi.RPCApi.kt</ID>
    <ID>TooManyFunctions:RPCClientProxyHandler.kt$RPCClientProxyHandler : InvocationHandler</ID>
    <ID>TooManyFunctions:RPCDriver.kt$RPCDriverDSL : InternalDriverDSL</ID>
    <ID>TooManyFunctions:RPCServer.kt$RPCServer</ID>
    <ID>TooManyFunctions:RPCStabilityTests.kt$RPCStabilityTests</ID>
    <ID>TooManyFunctions:ReadOnlyBackedObservableMapBase.kt$ReadOnlyBackedObservableMapBase&lt;K, A, B&gt; : ObservableMap</ID>
    <ID>TooManyFunctions:SerializationAPI.kt$SerializationContext</ID>
    <ID>TooManyFunctions:SerializationHelper.kt$net.corda.serialization.internal.amqp.SerializationHelper.kt</ID>
    <ID>TooManyFunctions:SerializationOutput.kt$SerializationOutput</ID>
    <ID>TooManyFunctions:SerializationScheme.kt$SerializationContextImpl : SerializationContext</ID>
    <ID>TooManyFunctions:ServiceHub.kt$ServiceHub : ServicesForResolution</ID>
    <ID>TooManyFunctions:SignedTransaction.kt$SignedTransaction : TransactionWithSignatures</ID>
    <ID>TooManyFunctions:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager : StateMachineManagerStateMachineManagerInternal</ID>
    <ID>TooManyFunctions:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest</ID>
    <ID>TooManyFunctions:StandardConfigValueParsers.kt$net.corda.node.services.config.schema.parsers.StandardConfigValueParsers.kt</ID>
    <ID>TooManyFunctions:StartedFlowTransition.kt$StartedFlowTransition : Transition</ID>
    <ID>TooManyFunctions:TestDSL.kt$TestLedgerDSLInterpreter : LedgerDSLInterpreter</ID>
    <ID>TooManyFunctions:TestDSL.kt$TestTransactionDSLInterpreter : TransactionDSLInterpreterOutputStateLookup</ID>
    <ID>TooManyFunctions:TopLevelTransition.kt$TopLevelTransition : Transition</ID>
    <ID>TooManyFunctions:TransactionBuilder.kt$TransactionBuilder</ID>
    <ID>TooManyFunctions:TransactionDSLInterpreter.kt$TransactionDSL&lt;out T : TransactionDSLInterpreter&gt; : TransactionDSLInterpreter</ID>
    <ID>TooManyFunctions:TransactionVerifierServiceInternal.kt$Verifier</ID>
    <ID>TooManyFunctions:TypeModellingFingerPrinter.kt$FingerPrintingState</ID>
    <ID>TooManyFunctions:UniversalContract.kt$UniversalContract : Contract</ID>
    <ID>TooManyFunctions:Util.kt$net.corda.finance.contracts.universal.Util.kt</ID>
    <ID>TooManyFunctions:Utils.kt$net.corda.common.configuration.parsing.internal.Utils.kt</ID>
    <ID>TooManyFunctions:VaultFiller.kt$VaultFiller</ID>
    <ID>TooManyFunctions:VaultService.kt$VaultService</ID>
    <ID>TooManyFunctions:VaultService.kt$net.corda.core.node.services.VaultService.kt</ID>
    <ID>TooManyFunctions:X509EdDSAEngine.kt$X509EdDSAEngine : Signature</ID>
    <ID>TooManyFunctions:X509KeyStore.kt$X509KeyStore</ID>
    <ID>TooManyFunctions:X509Utilities.kt$X509Utilities</ID>
    <ID>TopLevelPropertyNaming:AMQPSerializationScheme.kt$val AMQP_ENABLED get() = SerializationDefaults.P2P_CONTEXT.preferredSerializationVersion == amqpMagic</ID>
    <ID>TopLevelPropertyNaming:AbstractAttachment.kt$// We whitelist sources of transaction JARs for now as a temporary state until the DJVM and other security sandboxes // have been integrated, at which point we'll be able to run untrusted code downloaded over the network and this mechanism // can be removed. Because we ARE downloading attachments over the P2P network in anticipation of this upgrade, we // track the source of each attachment in our store. TestDSL is used by LedgerDSLInterpreter when custom attachments // are added in unit test code. val TRUSTED_UPLOADERS = listOf(DEPLOYED_CORDAPP_UPLOADER, RPC_UPLOADER, TESTDSL_UPLOADER)</ID>
    <ID>TopLevelPropertyNaming:BlobWriter.kt$val BLOB_WRITER_CONTEXT = SerializationContextImpl( amqpMagic, SerializationDefaults.javaClass.classLoader, AllWhitelist, emptyMap(), true, SerializationContext.UseCase.P2P, null )</ID>
    <ID>TopLevelPropertyNaming:Cash.kt$/** An extension property that lets you get a cash state from an issued token, under the [NULL_PARTY] */ val Amount&lt;Issued&lt;Currency&gt;&gt;.STATE: Cash.State get() = Cash.State(this, NULL_PARTY)</ID>
    <ID>TopLevelPropertyNaming:Cash.kt$/** An extension property that lets you write 100.DOLLARS.CASH */ val Amount&lt;Currency&gt;.CASH: Cash.State get() = Cash.State(Amount(quantity, Issued(NULL_PARTY.ref(1), token)), NULL_PARTY)</ID>
    <ID>TopLevelPropertyNaming:ClientContexts.kt$val AMQP_RPC_CLIENT_CONTEXT = SerializationContextImpl( amqpMagic, SerializationDefaults.javaClass.classLoader, GlobalTransientClassWhiteList(BuiltInExceptionsWhitelist()), emptyMap(), true, SerializationContext.UseCase.RPCClient, null, lenientCarpenterEnabled = true )</ID>
    <ID>TopLevelPropertyNaming:ConcurrencyUtils.kt$@VisibleForTesting internal const val shortCircuitedTaskFailedMessage = "Short-circuited task failed:"</ID>
    <ID>TopLevelPropertyNaming:CordaPersistence.kt$internal val _prohibitDatabaseAccess = ThreadLocal.withInitial { false }</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$@JvmField val CHF: Currency = Currency.getInstance("CHF")</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$@JvmField val EUR: Currency = Currency.getInstance("EUR")</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$@JvmField val GBP: Currency = Currency.getInstance("GBP")</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$@JvmField val JPY: Currency = Currency.getInstance("JPY")</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$@JvmField val RUB: Currency = Currency.getInstance("RUB")</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$@JvmField val USD: Currency = Currency.getInstance("USD")</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Double.DOLLARS: Amount&lt;Currency&gt; get() = DOLLARS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Double.POUNDS: Amount&lt;Currency&gt; get() = POUNDS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Double.SWISS_FRANCS: Amount&lt;Currency&gt; get() = SWISS_FRANCS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Int.DOLLARS: Amount&lt;Currency&gt; get() = DOLLARS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Int.POUNDS: Amount&lt;Currency&gt; get() = POUNDS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Int.SWISS_FRANCS: Amount&lt;Currency&gt; get() = SWISS_FRANCS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Long.DOLLARS: Amount&lt;Currency&gt; get() = DOLLARS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Long.POUNDS: Amount&lt;Currency&gt; get() = POUNDS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Long.SWISS_FRANCS: Amount&lt;Currency&gt; get() = SWISS_FRANCS(this)</ID>
    <ID>TopLevelPropertyNaming:FinanceWorkflowsUtils.kt$val TEST_CALENDAR_NAMES = listOf("London", "NewYork")</ID>
    <ID>TopLevelPropertyNaming:InternalMockNetwork.kt$val MOCK_VERSION_INFO = VersionInfo(PLATFORM_VERSION, "Mock release", "Mock revision", "Mock Vendor")</ID>
    <ID>TopLevelPropertyNaming:InternalTestConstants.kt$/** A dummy time at which we will be pretending test transactions are created. **/ @JvmField val TEST_TX_TIME: Instant = Instant.parse("2015-04-17T12:00:00.00Z")</ID>
    <ID>TopLevelPropertyNaming:InternalTestConstants.kt$val DEV_INTERMEDIATE_CA: CertificateAndKeyPair by lazy { net.corda.nodeapi.internal.DEV_INTERMEDIATE_CA }</ID>
    <ID>TopLevelPropertyNaming:InternalTestConstants.kt$val DEV_ROOT_CA: CertificateAndKeyPair by lazy { net.corda.nodeapi.internal.DEV_ROOT_CA }</ID>
    <ID>TopLevelPropertyNaming:InternalTestUtils.kt$/** * *Custom* CorDapp containing the contents of the `net.corda.testing.contracts` package, i.e. the dummy contracts. This is not a real CorDapp * in the way that [FINANCE_CONTRACTS_CORDAPP] and [FINANCE_WORKFLOWS_CORDAPP] are. */ @JvmField val DUMMY_CONTRACTS_CORDAPP: CustomCordapp = cordappWithPackages("net.corda.testing.contracts")</ID>
    <ID>TopLevelPropertyNaming:InternalTestUtils.kt$/** * Reference to the finance-contracts CorDapp in this repo. The metadata is taken directly from finance/contracts/build.gradle, including the * fact that the jar is signed. If you need an unsigned jar then use `cordappWithPackages("net.corda.finance.contracts")`. * * You will probably need to use [FINANCE_CORDAPPS] instead to get access to the flows as well. */ @JvmField val FINANCE_CONTRACTS_CORDAPP: TestCordappImpl = findCordapp("net.corda.finance.contracts")</ID>
    <ID>TopLevelPropertyNaming:InternalTestUtils.kt$/** * Reference to the finance-workflows CorDapp in this repo. The metadata is taken directly from finance/workflows/build.gradle, including the * fact that the jar is signed. If you need an unsigned jar then use `cordappWithPackages("net.corda.finance.flows")`. * * You will probably need to use [FINANCE_CORDAPPS] instead to get access to the contract classes as well. */ @JvmField val FINANCE_WORKFLOWS_CORDAPP: TestCordappImpl = findCordapp("net.corda.finance.workflows")</ID>
    <ID>TopLevelPropertyNaming:InternalTestUtils.kt$@JvmField val FINANCE_CORDAPPS: Set&lt;TestCordappImpl&gt; = setOf(FINANCE_CONTRACTS_CORDAPP, FINANCE_WORKFLOWS_CORDAPP)</ID>
    <ID>TopLevelPropertyNaming:InternalUtils.kt$val DEFAULT_HTTP_CONNECT_TIMEOUT = 30.seconds.toMillis()</ID>
    <ID>TopLevelPropertyNaming:InternalUtils.kt$val DEFAULT_HTTP_READ_TIMEOUT = 30.seconds.toMillis()</ID>
    <ID>TopLevelPropertyNaming:KeyStoreConfigHelpers.kt$val DEV_INTERMEDIATE_CA: CertificateAndKeyPair get() = DevCaHelper.loadDevCa(X509Utilities.CORDA_INTERMEDIATE_CA)</ID>
    <ID>TopLevelPropertyNaming:KeyStoreConfigHelpers.kt$val DEV_PUB_KEY_HASHES: List&lt;SecureHash.SHA256&gt; get() = listOf(DEV_INTERMEDIATE_CA.certificate, DEV_ROOT_CA.certificate).map { it.publicKey.hash.sha256() } + SecureHash.parse(DEV_CORDAPP_CODE_SIGNING_STR).sha256()</ID>
    <ID>TopLevelPropertyNaming:KeyStoreConfigHelpers.kt$val DEV_ROOT_CA: CertificateAndKeyPair get() = DevCaHelper.loadDevCa(X509Utilities.CORDA_ROOT_CA)</ID>
    <ID>TopLevelPropertyNaming:KryoCheckpointSerializer.kt$val KRYO_CHECKPOINT_CONTEXT = CheckpointSerializationContextImpl( SerializationDefaults.javaClass.classLoader, QuasarWhitelist, emptyMap(), true, null, AlwaysAcceptEncodingWhitelist )</ID>
    <ID>TopLevelPropertyNaming:Literal.kt$val Int.K: BigDecimal get() = BigDecimal(this) * BigDecimal(1000)</ID>
    <ID>TopLevelPropertyNaming:Literal.kt$val Int.M: BigDecimal get() = BigDecimal(this) * BigDecimal(1000000)</ID>
    <ID>TopLevelPropertyNaming:NodeConfiguration.kt$val Int.MB: Long get() = this * 1024L * 1024L</ID>
    <ID>TopLevelPropertyNaming:ProviderMap.kt$// OID taken from https://tools.ietf.org/html/draft-ietf-curdle-pkix-00 val `id-Curve25519ph` = ASN1ObjectIdentifier("1.3.101.112")</ID>
    <ID>TopLevelPropertyNaming:RPCServer.kt$// TODO replace this by creating a new CordaRPCImpl for each request, passing the context, after we fix Shell and WebServer @JvmField internal val CURRENT_RPC_CONTEXT: ThreadLocal&lt;RpcAuthContext&gt; = CurrentRpcContext()</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _allEnabledSerializationEnvs: List&lt;Pair&lt;String, SerializationEnvironment&gt;&gt; get() = serializationEnvFields.mapNotNull { it.get()?.let { env -&gt; Pair(it.name, env) } }</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _contextSerializationEnv = ThreadLocalToggleField&lt;SerializationEnvironment&gt;("contextSerializationEnv")</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _driverSerializationEnv = SimpleToggleField&lt;SerializationEnvironment&gt;("driverSerializationEnv")</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _inheritableContextSerializationEnv = InheritableThreadLocalToggleField&lt;SerializationEnvironment&gt;("inheritableContextSerializationEnv") { stack -&gt; stack.fold(false) { isAGlobalThreadBeingCreated, e -&gt; isAGlobalThreadBeingCreated || (e.className == "io.netty.util.concurrent.GlobalEventExecutor" &amp;&amp; e.methodName == "startThread") || (e.className == "java.util.concurrent.ForkJoinPool\$DefaultForkJoinWorkerThreadFactory" &amp;&amp; e.methodName == "newThread") } }</ID>
    <ID>TopLevelPropertyNaming:SerializationFormat.kt$const val encodingNotPermittedFormat = "Encoding not permitted: %s"</ID>
    <ID>TopLevelPropertyNaming:ServerContexts.kt$val AMQP_RPC_SERVER_CONTEXT = SerializationContextImpl( amqpMagic, SerializationDefaults.javaClass.classLoader, GlobalTransientClassWhiteList(BuiltInExceptionsWhitelist()), emptyMap(), true, SerializationContext.UseCase.RPCServer, null, lenientCarpenterEnabled = true )</ID>
    <ID>TopLevelPropertyNaming:ServerContexts.kt$val AMQP_STORAGE_CONTEXT = SerializationContextImpl( amqpMagic, SerializationDefaults.javaClass.classLoader, AllButBlacklisted, emptyMap(), true, SerializationContext.UseCase.Storage, null, AlwaysAcceptEncodingWhitelist )</ID>
    <ID>TopLevelPropertyNaming:SharedContexts.kt$val AMQP_P2P_CONTEXT = SerializationContextImpl( amqpMagic, SerializationDefaults.javaClass.classLoader, GlobalTransientClassWhiteList(BuiltInExceptionsWhitelist()), emptyMap(), true, SerializationContext.UseCase.P2P, null )</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test node name **/ @JvmField val ALICE_NAME = CordaX500Name("Alice Corp", "Madrid", "ES")</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test node name **/ @JvmField val BOB_NAME = CordaX500Name("Bob Plc", "Rome", "IT")</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test node name **/ @JvmField val BOC_NAME = CordaX500Name("BankOfCorda", "London", "GB")</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test node name **/ @JvmField val CHARLIE_NAME = CordaX500Name("Charlie Ltd", "Athens", "GR")</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test node name **/ @JvmField val DUMMY_BANK_A_NAME = CordaX500Name("Bank A", "London", "GB")</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test node name **/ @JvmField val DUMMY_BANK_B_NAME = CordaX500Name("Bank B", "New York", "US")</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test node name **/ @JvmField val DUMMY_BANK_C_NAME = CordaX500Name("Bank C", "Tokyo", "JP")</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test notary name **/ @JvmField val DUMMY_NOTARY_NAME = CordaX500Name("Notary Service", "Zurich", "CH")</ID>
    <ID>UnreachableCode:FlowRetryTest.kt$RetryFlow$throw ExceptionToCauseFiniteRetry()</ID>
    <ID>VariableNaming:AMQPBridgeTest.kt$AMQPBridgeTest$private val BOB = TestIdentity(BOB_NAME)</ID>
    <ID>VariableNaming:BootstrapperView.kt$BootstrapperView$val YAML_MAPPER = Constants.getContextMapper()</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$private lateinit var INTERMEDIATE_CA: CertificateAndKeyPair</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$private val ROOT_CA = DEV_ROOT_CA</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val ECDSA_ALGORITHM = "SHA256withECDSA"</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val EC_ALGORITHM = "EC"</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val EMPTY_CRL = "empty.crl"</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.CrlServlet$private val EMPTY_CRL = "empty.crl"</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.CrlServlet$private val INTEMEDIATE_CRL = "intermediate.crl"</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.CrlServlet$private val NODE_CRL = "node.crl"</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.CrlServlet$private val SIGNATURE_ALGORITHM = "SHA256withECDSA"</ID>
    <ID>VariableNaming:DummyContract.kt$DummyContract$val PROGRAM_ID = "net.corda.testing.contracts.DummyContract"</ID>
    <ID>VariableNaming:InternalMockNetwork.kt$MessagingServiceSpy$internal var _messagingService: MessagingService? = null set(value) { check(field == null) { "Spy has already been attached to a node" } field = value }</ID>
    <ID>VariableNaming:Literal.kt$ActionBuilder$val This = this</ID>
    <ID>VariableNaming:NodePerformanceTests.kt$NodePerformanceTests$val N = 10000</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDAPPS = listOf(FINANCE_CONTRACTS_CORDAPP, FINANCE_WORKFLOWS_CORDAPP)</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDAPP_CONTRACTS_NAME_REGEX = "corda-finance-contracts-$CORDA_VERSION_REGEX".toRegex()</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDAPP_LICENCE = "Open Source (Apache 2)"</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDAPP_SHORT_NAME = "Corda Finance Demo"</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDAPP_TYPES = setOf("Contract CorDapp", "Workflow CorDapp")</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDAPP_VENDOR = "R3"</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDAPP_WORKFLOWS_NAME_REGEX = "corda-finance-workflows-$CORDA_VERSION_REGEX".toRegex()</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDA_VENDOR = "Corda Open Source"</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDA_VERSION_REGEX = "\\d+(\\.\\d+)?(-\\w+)?".toRegex()</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val HEXADECIMAL_REGEX = "[0-9a-fA-F]+".toRegex()</ID>
    <ID>VariableNaming:NodeVaultService.kt$NodeVaultService.InnerState$val _rawUpdatesPublisher = PublishSubject.create&lt;Vault.Update&lt;ContractState&gt;&gt;()!!</ID>
    <ID>VariableNaming:NodeVaultService.kt$NodeVaultService.InnerState$val _updatesInDbTx = _updatesPublisher.wrapWithDatabaseTransaction().asObservable()!!</ID>
    <ID>VariableNaming:NodeVaultService.kt$NodeVaultService.InnerState$val _updatesPublisher = PublishSubject.create&lt;Vault.Update&lt;ContractState&gt;&gt;()!!</ID>
    <ID>VariableNaming:Notarise.kt$NotaryDemoClientApi$/** A dummy identity. */ private val BOB_NAME = CordaX500Name("Bob Plc", "Rome", "IT")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The curve group name. */ private val CURVE_GROUP_NAME_CCP1 = CurveGroupName.of("USD-DSCON-LIBOR3M")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The first counterparty. */ private val CCP1_ID = StandardId.of("example", "CCP-1")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The location of the curve calibration groups file for CCP1 and CCP2. */ private val GROUPS_RESOURCE_CCP1 = resourceLocator("example-calibration/curves/groups.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The location of the curve calibration nodes file for CCP1 and CCP2. */ private val CALIBRATION_RESOURCE_CCP1 = resourceLocator("example-calibration/curves/calibrations.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The location of the curve calibration settings file for CCP1 and CCP2. */ private val SETTINGS_RESOURCE_CCP1 = resourceLocator("example-calibration/curves/settings.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The location of the historical fixing file. */ private val FIXINGS_RESOURCE = resourceLocator("example-marketdata/historical-fixings/usd-libor-3m.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The location of the market quotes file for CCP1 and CCP2. */ private val QUOTES_RESOURCE_CCP1 = resourceLocator("example-calibration/quotes/quotes.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The second counterparty. */ private val CCP2_ID = StandardId.of("example", "CCP-2")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The valuation date. */ private val VAL_DATE = LocalDate.of(2015, 7, 21)</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$private val CALIBRATION_RESOURCE_CCP2 = resourceLocator("example-calibration/curves/calibrations-ccp2.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$private val CURVE_GROUP_NAME_CCP2 = CurveGroupName.of("USD-DSCON-LIBOR3M-CCP2")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$private val GROUPS_RESOURCE_CCP2 = resourceLocator("example-calibration/curves/groups-ccp2.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$private val QUOTES_RESOURCE_CCP2 = resourceLocator("example-calibration/quotes/quotes-ccp2.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$private val SETTINGS_RESOURCE_CCP2 = resourceLocator("example-calibration/curves/settings-ccp2.csv")</ID>
    <ID>VariableNaming:PortfolioApi.kt$PortfolioApi$var IMs: Map&lt;String, InitialMarginTriple&gt;? = null</ID>
    <ID>VariableNaming:PortfolioApi.kt$PortfolioApi$var PVs: Map&lt;String, MultiCurrencyAmount&gt;? = null</ID>
    <ID>VariableNaming:SSHServerTest.kt$FlowICanRun$private val HELLO_STEP = ProgressTracker.Step("Hello")</ID>
    <ID>VariableNaming:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$val N = 23</ID>
    <ID>VariableNaming:SearchField.kt$SearchField$private val ALL = "All"</ID>
    <ID>WildcardImport:AMQPClient.kt$import io.netty.channel.*</ID>
    <ID>WildcardImport:AMQPClientSerializationScheme.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:AMQPClientSerializationScheme.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:AMQPRemoteTypeModel.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:AMQPSerializationScheme.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:AMQPSerializationScheme.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:AMQPServerSerializationScheme.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:AMQPTypeIdentifierParser.kt$import org.apache.qpid.proton.amqp.*</ID>
    <ID>WildcardImport:AMQPTypeIdentifiers.kt$import org.apache.qpid.proton.amqp.*</ID>
    <ID>WildcardImport:AbstractCashFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:AbstractCashSelection.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.core.node.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.node.internal.cordapp.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.node.services.api.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.node.services.persistence.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.node.utilities.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.nodeapi.internal.persistence.*</ID>
    <ID>WildcardImport:ActionExecutorImpl.kt$import com.codahale.metrics.*</ID>
    <ID>WildcardImport:AdvancedExceptionDialog.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:AliasPrivateKey.kt$import org.bouncycastle.asn1.*</ID>
    <ID>WildcardImport:AllButBlacklisted.kt$import java.io.*</ID>
    <ID>WildcardImport:AllButBlacklisted.kt$import java.lang.invoke.*</ID>
    <ID>WildcardImport:AnotherDummyContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ArtemisMessagingClient.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:ArtemisMessagingServer.kt$import net.corda.node.internal.artemis.*</ID>
    <ID>WildcardImport:ArtemisRpcBroker.kt$import net.corda.node.internal.artemis.*</ID>
    <ID>WildcardImport:AttachmentDemoFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:AttachmentLoadingTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:AttachmentLoadingTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:AttachmentLoadingTests.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:AttachmentsClassLoader.kt$import java.net.*</ID>
    <ID>WildcardImport:AttachmentsClassLoader.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:AttachmentsClassLoader.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:AutoOfferFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:BFTSmart.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:BFTSmartNotaryService.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:BankOfCordaWebApi.kt$import javax.ws.rs.*</ID>
    <ID>WildcardImport:BaseTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:BasicHSMKeyManagementService.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:BasicHSMKeyManagementService.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:BlobInspector.kt$import picocli.CommandLine.*</ID>
    <ID>WildcardImport:BlobWriter.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:BootTests.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:BootstrapperView.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:BootstrapperView.kt$import net.corda.networkbuilder.nodes.*</ID>
    <ID>WildcardImport:BootstrapperView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:Cash.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CashExitFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CashPaymentFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CashSchemaV1.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:CashUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CashViewer.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:CashViewer.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:CashViewer.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:CashViewer.kt$import net.corda.explorer.ui.*</ID>
    <ID>WildcardImport:CashViewer.kt$import net.corda.explorer.views.*</ID>
    <ID>WildcardImport:CashViewer.kt$import tornadofx.*</ID>
    <ID>WildcardImport:CertificateRevocationListNodeTests.kt$import net.corda.nodeapi.internal.crypto.*</ID>
    <ID>WildcardImport:CertificateRevocationListNodeTests.kt$import org.bouncycastle.asn1.x509.*</ID>
    <ID>WildcardImport:CertificatesUtils.kt$import net.corda.nodeapi.internal.crypto.*</ID>
    <ID>WildcardImport:CheckpointDumper.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:CheckpointDumper.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CheckpointDumper.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:CheckpointSerializationAPI.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:ClassCarpenter.kt$import org.objectweb.asm.Opcodes.*</ID>
    <ID>WildcardImport:CloseableTab.kt$import tornadofx.*</ID>
    <ID>WildcardImport:CommercialPaper.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CommercialPaperIssueFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CommercialPaperUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CommonSchema.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ComposableTypePropertySerializer.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:CompositeKey.kt$import org.bouncycastle.asn1.*</ID>
    <ID>WildcardImport:CompositeKeyFactory.kt$import java.security.*</ID>
    <ID>WildcardImport:CompositeSignature.kt$import java.security.*</ID>
    <ID>WildcardImport:ConfigUtilities.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:Configuration.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:ConnectionStateMachine.kt$import org.apache.qpid.proton.amqp.messaging.*</ID>
    <ID>WildcardImport:ConnectionStateMachine.kt$import org.apache.qpid.proton.engine.*</ID>
    <ID>WildcardImport:Constants.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:ConstraintsUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractUpgradeFlow.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractUpgradeTransactions.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractUpgradeTransactions.kt$import net.corda.core.transactions.ContractUpgradeWireTransaction.Component.*</ID>
    <ID>WildcardImport:ContractUpgradeUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractsScanning.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CorDappInfoServlet.kt$import kotlinx.html.*</ID>
    <ID>WildcardImport:CordaClassResolver.kt$import com.esotericsoftware.kryo.*</ID>
    <ID>WildcardImport:CordaClassResolver.kt$import java.nio.file.StandardOpenOption.*</ID>
    <ID>WildcardImport:CordaCliWrapper.kt$import picocli.CommandLine.*</ID>
    <ID>WildcardImport:CordaInternal.kt$import kotlin.annotation.AnnotationTarget.*</ID>
    <ID>WildcardImport:CordaMigration.kt$import net.corda.node.services.persistence.*</ID>
    <ID>WildcardImport:CordaModule.kt$import com.fasterxml.jackson.annotation.*</ID>
    <ID>WildcardImport:CordaModule.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:CordaModule.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CordaModule.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:CordaModule.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:CordaModule.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:CordaRPCClientTest.kt$import net.corda.core.context.*</ID>
    <ID>WildcardImport:CordaRPCClientTest.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:CordaRPCClientTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:CordaRPCOps.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:CordaRPCOpsImpl.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:CordaRPCOpsImpl.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:CordaViewModel.kt$import tornadofx.*</ID>
    <ID>WildcardImport:Cordapp.kt$import net.corda.core.cordapp.Cordapp.Info.*</ID>
    <ID>WildcardImport:CordappConstraintsTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:CordappConstraintsTests.kt$import net.corda.testing.driver.*</ID>
    <ID>WildcardImport:CordappController.kt$import java.nio.file.StandardCopyOption.*</ID>
    <ID>WildcardImport:CordappController.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CordappController.kt$import tornadofx.*</ID>
    <ID>WildcardImport:CordappScanningDriverTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CordappSmokeTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CordappSmokeTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CoreFlowHandlers.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:Crypto.kt$import java.security.*</ID>
    <ID>WildcardImport:Crypto.kt$import net.corda.core.crypto.internal.*</ID>
    <ID>WildcardImport:CryptoUtils.kt$import java.security.*</ID>
    <ID>WildcardImport:CustomCordapp.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CustomVaultQuery.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CustomVaultQuery.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:DBNetworkParametersStorage.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:DBRunnerExtension.kt$import org.junit.jupiter.api.extension.*</ID>
    <ID>WildcardImport:DBTransactionStorage.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:DBTransactionStorage.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:DBTransactionStorage.kt$import net.corda.nodeapi.internal.persistence.*</ID>
    <ID>WildcardImport:DefaultKryoCustomizer.kt$import de.javakaffee.kryoserializers.guava.*</ID>
    <ID>WildcardImport:DefaultKryoCustomizer.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:DeleteForDJVM.kt$import kotlin.annotation.AnnotationTarget.*</ID>
    <ID>WildcardImport:DemoBench.kt$import tornadofx.*</ID>
    <ID>WildcardImport:DemoBenchNodeInfoFilesCopier.kt$import tornadofx.*</ID>
    <ID>WildcardImport:DemoBenchView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:DeserializationInput.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:DigitalSignatureWithCert.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:DistributedServiceTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:DoRemainingWorkTransition.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:DockerInstantiator.kt$import com.github.dockerjava.api.model.*</ID>
    <ID>WildcardImport:DriverDSLImpl.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:DriverDSLImpl.kt$import net.corda.core.internal.concurrent.*</ID>
    <ID>WildcardImport:DriverDSLImpl.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:DriverDSLImpl.kt$import net.corda.testing.driver.*</ID>
    <ID>WildcardImport:DriverTests.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:DriverTests.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:DummyContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:DummyContractV2.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:DummyContractV3.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:DummyDealStateSchemaV1.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:DummyLinearStateSchemaV1.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:DummyLinearStateSchemaV2.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:E2ETestKeyManagementService.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:ErrorFlowTransition.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:EventProcessor.kt$import org.apache.qpid.proton.engine.*</ID>
    <ID>WildcardImport:EvolutionSerializerFactory.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:ExceptionMaskingRpcOpsProxy.kt$import net.corda.core.*</ID>
    <ID>WildcardImport:ExceptionMaskingRpcOpsProxy.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:ExceptionSerialisingRpcOpsProxy.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:Explorer.kt$import tornadofx.*</ID>
    <ID>WildcardImport:FiberDeserializationCheckingInterceptor.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:FinalityFlowMigration.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FinanceJSONSupport.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:FixingFlow.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:FixingFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FixingFlow.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:FlowCheckpointVersionNodeStartupCheckTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowCheckpointVersionNodeStartupCheckTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:FlowCookbook.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:FlowCookbook.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowLogic.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:FlowLogicRefFactoryImpl.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowMatchers.kt$import net.corda.testing.internal.matchers.*</ID>
    <ID>WildcardImport:FlowOverrideTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowRetryTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowStackSnapshotTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowStateMachine.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowStateMachineImpl.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowStateMachineImpl.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:FlowsDrainingModeContentionTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FxTransactionBuildTutorial.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:FxTransactionBuildTutorial.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:Gui.kt$import tornadofx.*</ID>
    <ID>WildcardImport:GuiUtilities.kt$import tornadofx.*</ID>
    <ID>WildcardImport:HTTPNetworkRegistrationService.kt$import java.net.HttpURLConnection.*</ID>
    <ID>WildcardImport:HardRestartTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import javax.persistence.criteria.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.BinaryComparisonOperator.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.CollectionOperator.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.ColumnPredicate.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.EqualityComparisonOperator.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.LikenessOperator.*</ID>
    <ID>WildcardImport:HibernateStatistics.kt$import org.hibernate.stat.*</ID>
    <ID>WildcardImport:IOUContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:IOUFlowResponder.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:IRS.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:IRS.kt$import net.corda.finance.contracts.*</ID>
    <ID>WildcardImport:IRSState.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:IRSTradeFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:IdentityService.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:IdentityService.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:InMemoryIdentityService.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:InitialRegistrationCli.kt$import net.corda.node.internal.*</ID>
    <ID>WildcardImport:InputStreamSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:InstallFactory.kt$import tornadofx.*</ID>
    <ID>WildcardImport:InstallShellExtensionsParser.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:InteractiveShell.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:InteractiveShell.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:InteractiveShell.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:InteractiveShellIntegrationTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:InteractiveShellIntegrationTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:InterestRatesSwapDemoAPI.kt$import org.springframework.web.bind.annotation.*</ID>
    <ID>WildcardImport:InterestSwapRestAPI.kt$import org.springframework.web.bind.annotation.*</ID>
    <ID>WildcardImport:InternalMockNetwork.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:InternalMockNetwork.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:InternalMockNetwork.kt$import net.corda.testing.node.*</ID>
    <ID>WildcardImport:InternalSerializationTestHelpers.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:InternalTestUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:InternalUtils.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:InternalUtils.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:IssuerModel.kt$import tornadofx.*</ID>
    <ID>WildcardImport:JVMConfig.kt$import tornadofx.*</ID>
    <ID>WildcardImport:JacksonSupport.kt$import com.fasterxml.jackson.core.*</ID>
    <ID>WildcardImport:JacksonSupport.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:JacksonSupport.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:JacksonSupport.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:JacksonSupport.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:JacksonUtils.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:JarScanningCordappLoader.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:JarScanningCordappLoader.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:KeyStoreUtilities.kt$import java.security.*</ID>
    <ID>WildcardImport:KeyStoreUtilities.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:Kryo.kt$import com.esotericsoftware.kryo.*</ID>
    <ID>WildcardImport:Kryo.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:KryoCheckpointSerializer.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:KryoCheckpointSerializer.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:LargeTransactionsTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:LedgerTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:LedgerTransaction.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:LocalSerializationRule.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:LocalSerializationRule.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:LocalSerializerFactory.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:LocalSerializerFactory.kt$import net.corda.serialization.internal.model.TypeIdentifier.*</ID>
    <ID>WildcardImport:LocalTypeInformation.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:LocalTypeInformationBuilder.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:LocalTypeModel.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:LoginView.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:LoginView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:Main.kt$import net.corda.cliutils.*</ID>
    <ID>WildcardImport:Main.kt$import net.corda.explorer.views.*</ID>
    <ID>WildcardImport:Main.kt$import net.corda.nodeapi.internal.network.*</ID>
    <ID>WildcardImport:MainView.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:MainView.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:MainView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:Matchers.kt$import com.natpryce.hamkrest.*</ID>
    <ID>WildcardImport:MerkleTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:MerkleTransaction.kt$import net.corda.core.contracts.ComponentGroupEnum.*</ID>
    <ID>WildcardImport:MerkleTransaction.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:MessageState.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:MigrationServicesForResolution.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:MigrationServicesForResolution.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:MockAttachmentStorage.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:MockKeyManagementService.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:MockNodeMessagingService.kt$import net.corda.node.services.messaging.*</ID>
    <ID>WildcardImport:MockServices.kt$import net.corda.core.node.*</ID>
    <ID>WildcardImport:MockServices.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:MockServices.kt$import net.corda.node.services.api.*</ID>
    <ID>WildcardImport:MockServices.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:MultiCurrencyAmountSerializer.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:Network.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:Network.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:Network.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NetworkBootstrapper.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkBootstrapper.kt$import net.corda.nodeapi.internal.*</ID>
    <ID>WildcardImport:NetworkBuilder.kt$import net.corda.networkbuilder.nodes.*</ID>
    <ID>WildcardImport:NetworkIdentityModel.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:NetworkMapServer.kt$import javax.ws.rs.*</ID>
    <ID>WildcardImport:NetworkMapTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkMapTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:NetworkMapTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:NetworkMapUpdater.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkMapUpdater.kt$import net.corda.nodeapi.internal.network.*</ID>
    <ID>WildcardImport:NetworkParametersReader.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkRegistrationHelper.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NewTransaction.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:NewTransaction.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:NewTransaction.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:NewTransaction.kt$import tornadofx.*</ID>
    <ID>WildcardImport:Node.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:Node.kt$import net.corda.node.utilities.*</ID>
    <ID>WildcardImport:Node.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:NodeAttachmentService.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:NodeAttachmentService.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeAttachmentService.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:NodeBasedTest.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:NodeConfig.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:NodeController.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeController.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NodeData.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NodeInfo.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:NodeInfo.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeInfo.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:NodeInfo.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:NodeInfo.kt$import picocli.CommandLine.*</ID>
    <ID>WildcardImport:NodeInfoFilesCopier.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeInfoSchema.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:NodeInfoWatcher.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeInterestRates.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:NodeMonitorModel.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:NodeProcess.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeRegistrationTest.kt$import javax.ws.rs.*</ID>
    <ID>WildcardImport:NodeSchedulerService.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeSchemaService.kt$import net.corda.core.schemas.*</ID>
    <ID>WildcardImport:NodeStartup.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeStartup.kt$import net.corda.node.*</ID>
    <ID>WildcardImport:NodeStartup.kt$import net.corda.node.internal.subcommands.*</ID>
    <ID>WildcardImport:NodeTabView.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeTabView.kt$import net.corda.demobench.model.*</ID>
    <ID>WildcardImport:NodeTabView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NodeTerminalView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NodeTestUtils.kt$import net.corda.testing.dsl.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.nodeapi.internal.persistence.*</ID>
    <ID>WildcardImport:NodeVersioningTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeWebServer.kt$import net.corda.webserver.servlets.*</ID>
    <ID>WildcardImport:NodeWebServer.kt$import org.eclipse.jetty.server.*</ID>
    <ID>WildcardImport:NotaryChangeTransactions.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:NotaryChangeTransactions.kt$import net.corda.core.transactions.NotaryChangeWireTransaction.Component.*</ID>
    <ID>WildcardImport:NotaryFlow.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NotaryFlow.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:NotaryServiceFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:NotaryUtils.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:OGSwapPricingExample.kt$import com.opengamma.strata.product.swap.*</ID>
    <ID>WildcardImport:OGTrade.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ObjectBuilder.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:ObjectSerializer.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:ObligationUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:OnLedgerAsset.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:P2PFlowsDrainingModeTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:P2PMessagingClient.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:P2PMessagingClient.kt$import net.corda.nodeapi.internal.ArtemisMessagingComponent.*</ID>
    <ID>WildcardImport:P2PMessagingClient.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:PartyAndCertificate.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:PathUtils.kt$import java.io.*</ID>
    <ID>WildcardImport:PathUtils.kt$import java.nio.file.*</ID>
    <ID>WildcardImport:PersistentIdentityService.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:PersistentIdentityService.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:PersistentIdentityService.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:PersistentNetworkMapCacheTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:PersistentUniquenessProvider.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:PersistentUniquenessProvider.kt$import net.corda.core.internal.notary.*</ID>
    <ID>WildcardImport:Portfolio.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:PortfolioApi.kt$import javax.ws.rs.*</ID>
    <ID>WildcardImport:PortfolioState.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:PortfolioSwap.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:PrivateKeySerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:ProfileController.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:ProfileController.kt$import net.corda.demobench.model.*</ID>
    <ID>WildcardImport:ProfileController.kt$import tornadofx.*</ID>
    <ID>WildcardImport:Properties.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:PropertyDescriptor.kt$import net.corda.serialization.internal.amqp.MethodClassifier.*</ID>
    <ID>WildcardImport:ProtonWrapperTests.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:PublicKeyHashToExternalId.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:PublicKeySerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.CollectionOperator.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.ColumnPredicate.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.EqualityComparisonOperator.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.LikenessOperator.*</ID>
    <ID>WildcardImport:RPCClientProxyHandler.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:RPCClientProxyHandler.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:RPCSecurityManagerImpl.kt$import org.apache.shiro.authc.*</ID>
    <ID>WildcardImport:RPCServer.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:RPCServer.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:RPCStabilityTests.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:RPCStabilityTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:RPCStabilityTests.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:RaftUniquenessProvider.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:ReceiveTransactionFlow.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ReconnectingCordaRPCOps.kt$import net.corda.client.rpc.*</ID>
    <ID>WildcardImport:ReconnectingCordaRPCOps.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:RemoteSerializerFactory.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:RemoteTypeCarpenter.kt$import net.corda.serialization.internal.carpenter.*</ID>
    <ID>WildcardImport:RpcClientObservableDeSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:RpcExceptionHandlingTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:RpcExceptionHandlingTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:RpcExceptionHandlingTest.kt$import net.corda.testing.driver.*</ID>
    <ID>WildcardImport:RpcReconnectTests.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:RpcServerObservableSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:SSLHelper.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:SSLHelper.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:ScheduledFlowIntegrationTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ScheduledState.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ScheduledState.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:Schema.kt$import org.apache.qpid.proton.amqp.*</ID>
    <ID>WildcardImport:Schema.kt$import org.objectweb.asm.Opcodes.*</ID>
    <ID>WildcardImport:SchemaFields.kt$import org.objectweb.asm.Opcodes.*</ID>
    <ID>WildcardImport:SearchField.kt$import tornadofx.*</ID>
    <ID>WildcardImport:SendTransactionFlow.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:SerializationEnvironmentRule.kt$import net.corda.testing.internal.*</ID>
    <ID>WildcardImport:SerializationHelper.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:SerializationHelper.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SerializationScheme.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SerializeAsTokenContextImpl.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SerializerFactoryBuilder.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:ServiceHub.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ServiceHub.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:ServiceHub.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:ServiceHubInternal.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:ServicesForResolutionImpl.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:SettingsModel.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:SettingsModel.kt$import tornadofx.*</ID>
    <ID>WildcardImport:SharedContexts.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SignatureConstraintVersioningTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:SignedTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:SignedTransaction.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:SimpleMQClient.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:SingleThreadedStateMachineManager.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:SingleThreadedStateMachineManager.kt$import net.corda.node.services.statemachine.interceptors.*</ID>
    <ID>WildcardImport:StandaloneCordaRPClientTest.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:StandaloneCordaRPClientTest.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:StandaloneCordaRPClientTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:StartedFlowTransition.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:StubOutForDJVM.kt$import kotlin.annotation.AnnotationTarget.*</ID>
    <ID>WildcardImport:SubFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:SwapIdentitiesFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TenorDateParameterMetadataSerializer.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:TenorSerializer.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:TestCommsFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TestCordappImpl.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:TestDSL.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TestUtils.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:ThrowableSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:TopLevelTransition.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:TraderDemoTest.kt$import net.corda.testing.driver.*</ID>
    <ID>WildcardImport:TransactionBuilder.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionBuilder.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:TransactionDSLInterpreter.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionDataModel.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionUtils.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:TransactionUtils.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:TransactionVerifierServiceInternal.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionViewer.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:TransactionViewer.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:TransactionViewer.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionViewer.kt$import tornadofx.*</ID>
    <ID>WildcardImport:TransitionBuilder.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:TutorialContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TwoPartyDealFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlow.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TypeIdentifier.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:TypeLoader.kt$import net.corda.serialization.internal.carpenter.*</ID>
    <ID>WildcardImport:TypeModellingFingerPrinter.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:TypeModellingFingerPrinter.kt$import net.corda.serialization.internal.model.TypeIdentifier.*</ID>
    <ID>WildcardImport:TypeParameterUtils.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:UniqueDummyFungibleContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:UniversalContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:UpdateBusinessDayFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:Utils.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:V1NodeConfigurationSpec.kt$import net.corda.common.configuration.parsing.internal.*</ID>
    <ID>WildcardImport:V1NodeConfigurationSpec.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:V1NodeConfigurationSpec.kt$import net.corda.node.services.config.schema.parsers.*</ID>
    <ID>WildcardImport:VaultFiller.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultSchema.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:VaultSchema.kt$import net.corda.core.schemas.*</ID>
    <ID>WildcardImport:VaultService.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultService.kt$import net.corda.core.node.services.Vault.RelevancyStatus.*</ID>
    <ID>WildcardImport:VaultService.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:VaultStateMigration.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultStateMigration.kt$import net.corda.core.serialization.internal.*</ID>
    <ID>WildcardImport:WebServerController.kt$import tornadofx.*</ID>
    <ID>WildcardImport:WhitelistBasedTypeModelConfiguration.kt$import org.apache.qpid.proton.amqp.*</ID>
    <ID>WildcardImport:WhitelistGenerator.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:WireTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:WireTransaction.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:WireTransaction.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:WorkflowTransactionBuildTutorial.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:WorkflowTransactionBuildTutorial.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:X509CRLSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:X509CertificateSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:X509EdDSAEngine.kt$import java.security.*</ID>
    <ID>WildcardImport:X509Utilities.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:X509Utilities.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:X509Utilities.kt$import org.bouncycastle.asn1.*</ID>
    <ID>WildcardImport:X509Utilities.kt$import org.bouncycastle.asn1.x509.*</ID>
  </Whitelist>
</SmellBaseline>
